diff -urN somfree\a.cmd newsomfree3\a.cmd
--- somfree\a.cmd	Thu Jan 01 07:00:00 1970
+++ newsomfree3\a.cmd	Sat Mar 16 14:09:22 2024
@@ -0,0 +1,4 @@
+call "c:\Program Files\Microsoft Visual Studio\2022\Community\VC\Auxiliary\Build\vcvars32.bat"
+set PLATFORM=
+call make %1
+
diff -urN somfree\emitdef\defemit.idl newsomfree3\emitdef\defemit.idl
--- somfree\emitdef\defemit.idl	Thu Jan 01 07:00:00 1970
+++ newsomfree3\emitdef\defemit.idl	Sat Mar 16 14:09:22 2024
@@ -0,0 +1,19 @@
+#ifndef DEFEmitter_idl
+#define DEFEmitter_idl
+
+#include <scemit.idl>
+
+interface DEFEmitter : SOMTEmitC
+{
+#ifdef __SOMIDL__
+  implementation {
+    //# Class Modifiers
+    callstyle = oidl;
+
+    //# Method Modifiers
+    somtGenerateSections: override;
+  };
+#endif /* __SOMIDL__ */
+};
+
+#endif  /* DEFEmitter_idl */
diff -urN somfree\emitdef\include\def.efw newsomfree3\emitdef\include\def.efw
--- somfree\emitdef\include\def.efw	Thu Jan 01 07:00:00 1970
+++ newsomfree3\emitdef\include\def.efw	Sat Mar 16 14:09:22 2024
@@ -0,0 +1,13 @@
+:prologS
+;
+;  SOM Compiler Definition File Emitter (C) Yuri Prokushev
+;                                       (C) Andrey Vasilkin
+;
+LIBRARY <lnkDLLName> INITINSTANCE
+DESCRIPTION '<className> Definition File'
+PROTMODE
+DATA MULTIPLE NONSHARED LOADONCALL
+EXPORTS
+   <className>ClassData
+   <className>CClassData
+   <className>NewClass
diff -urN somfree\emitdef\makedefs.cf newsomfree3\emitdef\makedefs.cf
--- somfree\emitdef\makedefs.cf	Thu Jan 01 07:00:00 1970
+++ newsomfree3\emitdef\makedefs.cf	Sat Mar 16 14:09:22 2024
@@ -0,0 +1,3 @@
+NAME emitdef
+DEPENDS some somc
+PROVIDES emitdef
diff -urN somfree\emitdef\src\defemit.cpp newsomfree3\emitdef\src\defemit.cpp
--- somfree\emitdef\src\defemit.cpp	Thu Jan 01 07:00:00 1970
+++ newsomfree3\emitdef\src\defemit.cpp	Sat Mar 16 14:09:22 2024
@@ -0,0 +1,94 @@
+/*
+ *  This file was generated by the SOM Compiler and Emitter Framework.
+ *  Generated using template emitter:
+ *      SOM Emitter emitctm: 2.23.1.9
+ */
+
+#ifndef SOM_Module_def_Source
+#define SOM_Module_def_Source
+#endif
+#define DEFEmitter_Class_Source
+
+#include "defemit.xih"
+#include <scmodule.xh>
+#include <scclass.xh>
+#include <sctmplt.xh>
+#include <string.h>
+#include <stdio.h>
+
+boolean flag=FALSE; // Используется, чтоб секция Prolog отрабатывалась один раз.
+
+/*
+ * Управление последовательностью секций
+ */
+
+SOM_Scope boolean  SOMLINK somtGenerateSections(DEFEmitter *somSelf)
+{
+  char *DllName;
+  char *obj;
+  char buf[1024];
+  SOMTTemplateOutputC   *templ = somSelf->_get_somtTemplate();
+  SOMTClassEntryC       *cls = somSelf->_get_somtTargetClass();
+//  DEFEmitterData     *EmitterData = DEFEmitterGetData(somSelf);
+
+  DEFEmitterMethodDebug("DEFEmitter","somtGenerateSections");
+
+ if ( cls )
+ {
+   DllName=somSelf->somtGetGlobalModifierValue("dllname");
+   if (!DllName) DllName= cls->somtGetModifierValue("dllname");
+   if (!DllName) DllName= cls->somtGetModifierValue("filestem");
+   strcpy(buf, DllName);
+   templ->somtSetSymbolCopyBoth("lnkDLLName", buf );
+ };
+
+ if ( cls )
+ {
+   obj = somSelf->somtGetGlobalModifierValue("file");
+   templ->somtSetSymbolCopyBoth("lnkObjects", obj);
+
+   obj = somSelf->somtGetGlobalModifierValue("include");
+
+   if (obj)
+   {
+    FILE *fp;
+    char *content;
+
+     fp = fopen(obj, "r" );
+     if( fp != NULL )
+     {
+       long length = 0;
+       fseek(fp, 0, SEEK_END);
+       length = ftell(fp);
+       fseek(fp, 0, SEEK_SET);
+
+       content=(char *)malloc(length);
+       fread(content, length, 1, fp);
+       fclose(fp);
+       templ->somtSetSymbolCopyBoth("lnkInclude", content);
+       free(content);
+     }
+   }
+
+   obj = somSelf->somtGetGlobalModifierValue("lib");
+   templ->somtSetSymbolCopyBoth("lnkLibs", obj);
+ };
+
+  somSelf->somtFileSymbols();
+
+  if (!flag)
+  {
+    somSelf->somtEmitProlog();
+    flag=TRUE;
+  }
+
+
+  if ( cls )
+  {
+    somSelf->somtEmitClass();
+  }
+
+  return TRUE;
+}
+
+
diff -urN somfree\emitdef\src\emitdef.cpp newsomfree3\emitdef\src\emitdef.cpp
--- somfree\emitdef\src\emitdef.cpp	Thu Jan 01 07:00:00 1970
+++ newsomfree3\emitdef\src\emitdef.cpp	Sat Mar 16 14:09:22 2024
@@ -0,0 +1,81 @@
+#include <scentry.xh>
+#include <scmodule.xh>
+#include <emitlib.h>
+#include <sctypes.h>
+#include "defemit.xh"
+
+#define SYMBOLS_FILE   "def.efw"
+
+SOMEXTERN FILE * SOMLINK emitSL(char *file, Entry * cls, Stab * stab)
+{
+
+    FILE *fp;
+    FILE *deffile;
+    SOMTClassEntryC *oCls;
+    SOMTModuleEntryC *mod;
+    DEFEmitter *emitter;
+    SOMTTemplateOutputC *t;
+
+    /* if this is a class, rather than a module: */
+    if (cls->type == SOMTClassE) {
+        file=strcat(file, ""); //  Модификатор файла. Если такую штуку не делать, то может быть трап.
+        fp = somtopenEmitFileSL(file, "def");
+        oCls = (SOMTClassEntryC *)somtGetObjectWrapper(cls);
+        emitter = new DEFEmitter();
+        emitter->_set_somtTargetFile(fp);
+        emitter->_set_somtTargetClass(oCls);
+        emitter->_set_somtEmitterName("def");
+        t = emitter->_get_somtTemplate();
+        t->_set_somtCommentStyle(somtCPPE);
+        if (deffile = emitter->somtOpenSymbolsFile(SYMBOLS_FILE, "r")) {
+            t->somtReadSectionDefinitions(deffile);
+            somtfcloseSL(deffile);
+        }
+        else {
+//            debug("Не могу открыть файл символов \" %s \".\n",
+//                             SYMBOLS_FILE);
+            exit(-1);
+        }
+        emitter->somtGenerateSections();
+        delete emitter;
+        delete oCls;
+
+        return (fp);
+    }
+    else if (cls->type == SOMTModuleE) {
+
+        fp = somtopenEmitFileSL(file, "def");
+        mod = (SOMTModuleEntryC *) somtGetObjectWrapper(cls);
+        emitter = new DEFEmitter();
+        emitter->_set_somtTargetFile(fp);
+        emitter->_set_somtTargetModule(mod);
+        t = emitter->_get_somtTemplate();
+        t->_set_somtCommentStyle(somtCPPE);
+        if (deffile = emitter->somtOpenSymbolsFile(SYMBOLS_FILE, "r")) {
+            t->somtReadSectionDefinitions(deffile);
+            somtfcloseSL(deffile);
+        }
+        else {
+//            debug("Cannot open Symbols file \" %s \".\n",
+//                             SYMBOLS_FILE);
+            exit(-1);
+        }
+        emitter->somtGenerateSections();
+        delete emitter;
+        delete mod;
+
+        return (fp);
+    }
+    else {
+//      debug("Неизвестно, что делать. Выходим.\n");
+      return ((FILE *) NULL);
+    }
+}
+
+// SOM 2.1 compatible emitter wrapper
+SOMEXTERN FILE * OPTLINK_DECL emit(char *file, Entry * cls, Stab * stab)
+{
+  OPTLINK_3ARGS(file, cls, stab);
+
+  return emitSL(file, cls, stab);
+}
diff -urN somfree\emitdef\win32\emitdef.def newsomfree3\emitdef\win32\emitdef.def
--- somfree\emitdef\win32\emitdef.def	Thu Jan 01 07:00:00 1970
+++ newsomfree3\emitdef\win32\emitdef.def	Sat Mar 16 14:09:22 2024
@@ -0,0 +1,5 @@
+LIBRARY EMITDEF
+VERSION		1.0
+EXPORTS
+   emitSL
+   emit
diff -urN somfree\emitdef\win32\emitdef.mak newsomfree3\emitdef\win32\emitdef.mak
--- somfree\emitdef\win32\emitdef.mak	Thu Jan 01 07:00:00 1970
+++ newsomfree3\emitdef\win32\emitdef.mak	Sat Mar 16 14:09:22 2024
@@ -0,0 +1,115 @@
+#
+#  Copyright 2022, Yuri Prokushev
+#
+#  This file is part of osFree project
+#
+#  This program is free software: you can redistribute it and/or modify it
+#  under the terms of the GNU Lesser General Public License as published by the
+#  Free Software Foundation, either version 3 of the License, or (at your
+#  option) any later version.
+# 
+#  This program is distributed in the hope that it will be useful, but WITHOUT
+#  ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+#  FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for
+#  more details.
+#
+#  You should have received a copy of the GNU Lesser General Public License
+#  along with this program.  If not, see <http://www.gnu.org/licenses/>
+#
+
+!include $(MAKEDEFS)
+
+OUTDIR=$(OUTDIR_BIN)
+INTDIR=$(BUILDTYPE)
+
+DLLNAME=emitdef
+
+IDLTOOL=$(RHBTOOLS_BIN)\idltool.exe
+SC=$(SOMTOOLS_BIN)\sc.exe
+PDL=$(SOMTOOLS_BIN)\pdl.exe
+SOMIDL_IDL=..\..\somidl
+SOMIDL_HEADERS=$(SOMIDL_IDL)\$(PLATFORM)
+
+EMIT_DIR=..\..\emitdef
+SOME_DIR=..\..\some
+SOMC_DIR=..\..\somc
+EMIT_INTDIR=$(INTDIR)
+
+TARGET_DLL=$(OUTDIR)\$(DLLNAME).dll
+TARGET_PDB=$(OUTDIR)\$(DLLNAME).pdb
+TARGET_MAP=$(INTDIR)\$(DLLNAME).map
+TARGET_DEF=..\$(PLATFORM_DEF)\$(DLLNAME).def
+
+PARTOPTS=	$(STDOPT)								\
+			/DWIN32_LEAN_AND_MEAN 					\
+			/DHAVE_CONFIG_HPP							\
+			/I$(INTDIR)								\
+			/I..\win32								\
+			/I..\include							\
+			/I..\src								\
+			/I..\..\include\$(PLATFORM)				\
+			/I..\..\include\$(PLATFORM_DEF)			\
+			/I..\..\include							\
+			/I..\..\somidl\$(PLATFORM)				\
+			/I..\..\somkpub\include					\
+			/I..\..\somc\include					\
+			$(CC_OUT_PDB)$(TARGET_PDB)	
+
+OBJS=	$(INTDIR)\emitdef.obj	\
+	$(INTDIR)\defemit.obj	\
+	$(INTDIR)\link386.obj
+
+PUBLIC_IDLS=$(SOMIDL_IDL)\defemit.idl
+
+EMIT_IH=	$(EMIT_INTDIR)\defemit.h	\
+		$(EMIT_INTDIR)\defemit.ih	\
+		$(EMIT_INTDIR)\defemit.xh	\
+		$(EMIT_INTDIR)\defemit.xih
+
+all: $(INTDIR) $(PUBLIC_IDLS) $(EMIT_IH) $(TARGET_DLL)
+
+clean:
+	$(CLEAN) $(PUBLIC_IDLS) $(EMIT_IH) $(TARGET_DLL) $(TARGET_PDB) $(TARGET_MAP) $(OBJS) $(INTDIR)\$(DLLNAME).res $(OUTDIR)\$(DLLNAME).exp $(OUTDIR)\$(DLLNAME).lib
+	
+$(TARGET_DLL): $(OBJS) $(OUTDIR) $(TARGET_DEF) $(INTDIR)\$(DLLNAME).res
+	$(CC) $(CC_OUT_DLL)$@ $(OBJS)		\
+			$(INTDIR)\$(DLLNAME).res	\
+			$(CC_OUT_PDB)$(TARGET_PDB)	\
+			$(CC_LINK)					\
+			$(LDFLAGS)					\
+			$(LD_DEF)$(TARGET_DEF)
+	$(POSTLINK_DLL) $@
+
+
+$(INTDIR)\emitdef.obj: ..\src\emitdef.cpp $(INTDIR)
+	$(CXX) /c $(PARTOPTS) $(CC_OUT_OBJ)$@ ..\src\emitdef.cpp
+
+$(INTDIR)\defemit.obj: ..\src\defemit.cpp $(INTDIR)
+	$(CXX) /c $(PARTOPTS) $(CC_OUT_OBJ)$@ ..\src\defemit.cpp
+
+$(INTDIR)\link386.obj: ..\win32\link386.c $(INTDIR)
+	$(CC) /c $(PARTOPTS) $(CC_OUT_OBJ)$@ ..\win32\link386.c
+
+$(INTDIR):
+	mkdir $@
+
+$(INTDIR)\$(DLLNAME).res: ..\win32\$(DLLNAME).rc
+	rc /nologo /r /I.. /I..\..\include\$(PLATFORM) /fo$@ ..\win32\$(DLLNAME).rc
+
+$(PUBLIC_IDLS):
+	"$(IDLTOOL)" "$(PDL)"		\
+		$(EMIT_DIR)			\
+		-o $@
+
+$(EMIT_IH): 
+	"$(IDLTOOL)" "$(SC)" $(EMIT_DIR)	\
+					-o $@ -p -I$(EMIT_DIR) -I$(SOMIDL_IDL) -I$(SOMC_DIR)\include
+
+
+dist:
+
+
+
+
+test:
+
diff -urN somfree\emitdef\win32\emitdef.rc newsomfree3\emitdef\win32\emitdef.rc
--- somfree\emitdef\win32\emitdef.rc	Thu Jan 01 07:00:00 1970
+++ newsomfree3\emitdef\win32\emitdef.rc	Sat Mar 16 14:09:22 2024
@@ -0,0 +1,50 @@
+/**************************************************************************
+ *
+ *  Copyright 2022, Yuri Prokushev
+ *
+ *  This file is part of osFree project
+ *
+ *  This program is free software: you can redistribute it and/or modify it
+ *  under the terms of the GNU Lesser General Public License as published by the
+ *  Free Software Foundation, either version 3 of the License, or (at your
+ *  option) any later version.
+ * 
+ *  This program is distributed in the hope that it will be useful, but WITHOUT
+ *  ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ *  FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for
+ *  more details.
+ *
+ *  You should have received a copy of the GNU Lesser General Public License
+ *  along with this program.  If not, see <http://www.gnu.org/licenses/>
+ *
+ */
+
+#include <windows.h>
+#include <depvers.h>
+
+1 VERSIONINFO
+	PRODUCTVERSION DEPVERS_somtkpkg_INT4
+	FILEOS VOS__WINDOWS32
+	FILEVERSION DEPVERS_som_INT4
+	FILETYPE VFT_DLL
+BEGIN
+	BLOCK "StringFileInfo"
+	BEGIN
+		BLOCK "140904E4"
+		BEGIN
+			VALUE "CompanyName","Yuri Prokushev\000\000"
+			VALUE "LegalCopyright","Copyright й Yuri Prokushev 2022\000\000"
+			VALUE "ProductName",DEPVERS_somtkpkg_PRODUCTNAME
+			VALUE "ProductVersion",DEPVERS_somtkpkg_STR4
+			VALUE "Comments","Uncontrolled Release\000\000"
+			VALUE "FileDescription","SOM kernel\000\000"
+			VALUE "FileVersion",DEPVERS_som_STR4
+			VALUE "InternalName","emitdef\000\000"
+			VALUE "OriginalFilename","EMITDEF.DLL\000\000"
+		END
+	END
+    BLOCK "VarFileInfo"
+    BEGIN
+        VALUE "Translation", 0x1409, 1252
+    END
+END
diff -urN somfree\emitdef\win32\link386.c newsomfree3\emitdef\win32\link386.c
--- somfree\emitdef\win32\link386.c	Thu Jan 01 07:00:00 1970
+++ newsomfree3\emitdef\win32\link386.c	Sat Mar 16 14:09:22 2024
@@ -0,0 +1,29 @@
+/**************************************************************************
+ *
+ *  Copyright 2008, Roger Brown
+ *
+ *  This file is part of Roger Brown's Toolkit.
+ *
+ *  This program is free software: you can redistribute it and/or modify it
+ *  under the terms of the GNU Lesser General Public License as published by the
+ *  Free Software Foundation, either version 3 of the License, or (at your
+ *  option) any later version.
+ * 
+ *  This program is distributed in the hope that it will be useful, but WITHOUT
+ *  ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ *  FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for
+ *  more details.
+ *
+ *  You should have received a copy of the GNU Lesser General Public License
+ *  along with this program.  If not, see <http://www.gnu.org/licenses/>
+ *
+ */
+
+/* $Id: link386.c 36 2020-06-07 02:18:04Z somtoolkit $ */
+
+
+#define LINK386_SOM
+#define LINK386_SOMC
+#define LINK386_SOME
+
+#include <link386.h>
diff -urN somfree\emitdump\makedefs.cf newsomfree3\emitdump\makedefs.cf
--- somfree\emitdump\makedefs.cf	Thu Jan 01 07:00:00 1970
+++ newsomfree3\emitdump\makedefs.cf	Sat Mar 16 14:09:22 2024
@@ -0,0 +1,3 @@
+NAME emitdump
+DEPENDS some somc
+PROVIDES emitdump
diff -urN somfree\emitdump\src\emitdump.cpp newsomfree3\emitdump\src\emitdump.cpp
--- somfree\emitdump\src\emitdump.cpp	Thu Jan 01 07:00:00 1970
+++ newsomfree3\emitdump\src\emitdump.cpp	Sat Mar 16 14:09:22 2024
@@ -0,0 +1,584 @@
+// This is experimental emitter to dump and test internal structures, passed to emitter.
+// Was used to reasearch how undocumented functions works.
+
+#include <emitlib.h>
+#include <sctypes.h>
+
+// Experimental replacement of somttype
+char * mysomttype(SOMTTypes ttype)
+{
+  char * result=NULL;
+  switch ( ttype )
+  {
+    case SOMTAnyBE:
+      result="SOMTAnyBE";
+      break;
+    case     SOMTArgumentE:
+      result="SOMTArgumentE";
+      break;
+    case     SOMTAttE:
+      result="SOMTAttE";
+      break;
+    case     SOMTBadEntryE:
+      result="SOMTBadEntryE";
+      break;
+    case     SOMTBaseE:
+      result="SOMTBaseE";
+      break;
+    case     SOMTBooleanBE:
+      result="SOMTBooleanBE";
+      break;
+    case     SOMTCaseEntryE:
+      result="SOMTCaseEntryE";
+      break;
+    case     SOMTCaseListE:
+      result="SOMTCaseListE";
+      break;
+    case     SOMTCaseSTME:
+      result="SOMTCaseSTME";
+      break;
+    case     SOMTCharBE:
+      result="SOMTCharBE";
+      break;
+    case     SOMTClassE:
+      result="SOMTClassE";
+      break;
+    case     SOMTConstE:
+      result="SOMTConstE";
+      break;
+    case     SOMTCopyrightE:
+      result="SOMTCopyrightE";
+      break;
+    case     SOMTDataE:
+      result="SOMTDataE";
+      break;
+    case     SOMTDclListE:
+      result="SOMTDclListE";
+      break;
+    case     SOMTDefaultE:
+      result="SOMTDefaultE";
+      break;
+    case     SOMTDoubleBE:
+      result="SOMTDoubleBE";
+      break;
+    case     SOMTEBaseE:
+      result="SOMTEBaseE";
+      break;
+    case     SOMTEEnumE:
+      result="SOMTEEnumE";
+      break;
+    case     SOMTEnumBE:
+      result="SOMTEnumBE";
+      break;
+    case     SOMTEnumE:
+      result="SOMTEnumE";
+      break;
+    case     SOMTEnumPE:
+      result="SOMTEnumPE";
+      break;
+    case     SOMTFloatBE:
+      result="SOMTFloatBE";
+      break;
+    case     SOMTGroupE:
+      result="SOMTGroupE";
+      break;
+    case     SOMTLongBE:
+      result="SOMTLongBE";
+      break;
+    case     SOMTMetaE:
+      result="SOMTMetaE";
+      break;
+    case     SOMTModuleE:
+      result="SOMTModuleE";
+      break;
+    case     SOMTNegativeBE:
+      result="SOMTNegativeBE";
+      break;
+    case     SOMTNewMethodE:
+      result="SOMTNewMethodE";
+      break;
+    case     SOMTOctetBE:
+      result="SOMTOctetBE";
+      break;
+    case     SOMTOverriddenMethodE:
+      result="SOMTOverriddenMethodE";
+      break;
+    case     SOMTOverrideMethodE:
+      result="SOMTOverrideMethodE";
+      break;
+    case     SOMTPassthruE:
+      result="SOMTPassthruE";
+      break;
+    case     SOMTSequenceE:
+      result="SOMTSequenceE";
+      break;
+    case     SOMTSequenceTDE:
+      result="SOMTSequenceTDE";
+      break;
+    case     SOMTShortBE:
+      result="SOMTShortBE";
+      break;
+    case     SOMTStringBE:
+      result="SOMTStringBE";
+      break;
+    case     SOMTStringE:
+      result="SOMTStringE";
+      break;
+    case     SOMTStructE:
+      result="SOMTStructE";
+      break;
+    case     SOMTStructPE:
+      result="SOMTStructPE";
+      break;
+    case     SOMTStructSE:
+      result="SOMTStructSE";
+      break;
+    case     SOMTTyDclE:
+      result="SOMTTyDclE";
+      break;
+    case     SOMTTypeCodeBE:
+      result="SOMTTypeCodeBE";
+      break;
+    case     SOMTTypedefBE:
+      result="SOMTTypedefBE";
+      break;
+    case     SOMTTypedefE:
+      result="SOMTTypedefE";
+      break;
+    case     SOMTUnionE:
+      result="SOMTUnionE";
+      break;
+    case     SOMTUnionPE:
+      result="SOMTUnionPE";
+      break;
+    case     SOMTUnionSE:
+      result="SOMTUnionSE";
+      break;
+    case     SOMTUnsignedLongBE:
+      result="SOMTUnsignedLongBE";
+      break;
+    case     SOMTUnsignedShortBE:
+      result="SOMTUnsignedShortBE";
+      break;
+    case     SOMTVoidBE:
+      result="SOMTVoidBE";
+      break;
+    case     SOMTVoidPtrBE:
+      result="SOMTVoidPtrBE";
+      break;
+// This is special case SOMTTypes used on call of emitter start and emitter end
+/*    case     SOMTEmitterBeginE:
+      result="SOMTEmitterBeginE";
+      break;
+    case     SOMTEmitterEndE:
+      result="SOMTEmitterEndE";
+      break; */
+    default:
+      somterrorSL(__FILE__, __LINE__, "Unknown entry type: %d.\n", ttype);
+  }
+  return result;
+}
+
+void dumpAttrs(char * name, AttList *ap)
+{
+  struct AttList *cur = ap;
+
+  for(cur = ap; cur; cur = cur->next) 
+  {
+    printf("\t%s %s=%s\n", name, cur->name, cur->value);
+  }
+}
+
+
+void dumpReleaseOrder(char * name, AttList *ap)
+{
+  AttList *cur=ap;
+
+  for(; cur; cur = cur->next) 
+  {
+    printf("\t%s %s\n", name, cur->name);
+//    dumpAttrs("static", cur->staticlist);
+//    dumpAttrs("protectted", cur->protectedlist);
+//    dumpAttrs("public", cur->publiclist);
+//    dumpAttrs("private", cur->privatelist);
+  }
+}
+
+void dumpMethodOrData(Entry * ep)
+{
+  somPrintf("\teptype = %08p\n", ep->u.m.eptype);
+  somPrintf("\tptrs = %08p\n", ep->u.m.ptrs);
+  somPrintf("\tarray = %08p\n", ep->u.m.array);
+  somPrintf("\tarrays = %s\n", ep->u.m.arrays);
+  somPrintf("\tdefn = %s\n", ep->u.m.defn);
+  somPrintf("\ttype = %s\n", ep->u.m.type);
+  somPrintf("\tvarargs = %s\n", ep->u.m.varargs ? "true" : "false");
+  somPrintf("\tprivate = %s\n", ep->u.m.isprivate ? "true" : "false");
+  somPrintf("\tinout = %d\n", ep->u.m.inoutmode);
+  somPrintf("\tselfref = %s\n", ep->u.m.isselfref ? "true" : "false");
+  somPrintf("\toneway = %s\n", ep->u.m.isoneway ? "true" : "false");
+  somPrintf("\targcnt = %d\n", ep->u.m.argcnt);
+  somPrintf("\targs = %08p\n", ep->u.m.args);
+  somPrintf("\tomethod = %08p\n", ep->u.m.omethod);
+  somPrintf("\toparent = %08p\n", ep->u.m.oparent);
+  somPrintf("\tgroup = %08p\n", ep->u.m.group);
+  somPrintf("\tnext = %08p\n", ep->u.m.next);
+  somPrintf("\tctxsa = %08p\n", ep->u.m.ctxsa);
+  somPrintf("\traiseslist = %08p\n", ep->u.m.raiseslist);
+}
+
+void mysomtShowEntry(Entry * ep)
+{
+  if (ep)
+  {
+    somPrintf("      somtShowEntry: Entry at %08p, name = %s, type = %d\n", ep, ep->name, ep->type);
+    somPrintf("\tlineno = %d\n", ep->lineno);
+    switch ( ep->type )
+    {
+      case SOMTAnyBE:
+        somPrintf("\t SOMTAnyBE\n");
+        break;
+      case     SOMTArgumentE:
+        somPrintf("\t SOMTArgumentE\n");
+        dumpMethodOrData(ep);
+        break;
+      case     SOMTAttE:
+        somPrintf("\t SOMTAttE\n");
+        break;
+      case     SOMTBadEntryE:
+        somPrintf("\t SOMTBadEntryE\n");
+        break;
+      case     SOMTBaseE:
+        somPrintf("\t SOMTBaseE\n");
+        somPrintf("\tparentdef = %08p\n", ep->u.p.parentdef);
+        break;
+      case     SOMTBooleanBE:
+        somPrintf("\t SOMTBooleanBE\n");
+        break;
+      case     SOMTCaseEntryE:
+        somPrintf("\t SOMTCaseEntryE\n");
+        break;
+      case     SOMTCaseListE:
+        somPrintf("\t SOMTCaseListE\n");
+        break;
+      case     SOMTCaseSTME:
+        somPrintf("\t SOMTCaseSTME\n");
+        break;
+      case     SOMTCharBE:
+        somPrintf("\t SOMTCharBE\n");
+        break;
+      case     SOMTClassE:
+        somPrintf("\tClass Definition Entry:\n");
+        somPrintf("\tfile = %s\n", ep->u.c.file);
+        somPrintf("\tmeta = %08p\n", ep->u.c.meta);
+        somPrintf("\tparent = %08p\n", ep->u.c.parent);
+        somPrintf("\tparents = %08p\n", ep->u.c.parents);
+        somPrintf("\trelease = %08p\n", ep->u.c.release);
+        dumpReleaseOrder("\t", ep->u.c.release);
+        somPrintf("\tpassthru = %08p\n", ep->u.c.passthrus);
+        somPrintf("\tdata = %08p\n", ep->u.c.data);
+        somPrintf("\ttc = %08p\n", ep->tc);
+        somPrintf("\tmethodcnt = %08d\n", ep->u.c.methodcnt);
+        somPrintf("\tmethods = %08p\n", ep->u.c.methods);
+        somPrintf("\tinherited = %08p\n", ep->u.c.inherited);
+        somPrintf("\tpubdefs = %08p\n", ep->u.c.pubdefs);
+        somPrintf("\tmod = %08p\n", ep->u.c.mod);
+        somPrintf("\tcls = %08p\n", ep->u.c.cls);
+        somPrintf("\tforward = %s\n", ep->u.c.isforward ? "true" : "false");
+        break;
+      case     SOMTConstE:
+        somPrintf("\t SOMTConstE\n");
+        break;
+      case     SOMTCopyrightE:
+        somPrintf("\t SOMTCopyrightE\n");
+        break;
+      case     SOMTDataE:
+        somPrintf("\t SOMTDataE\n");
+        dumpMethodOrData(ep);
+        break;
+      case     SOMTDclListE:
+        somPrintf("\t SOMTDclListE\n");
+        break;
+      case     SOMTDefaultE:
+        somPrintf("\t SOMTDefaultE\n");
+        break;
+      case     SOMTDoubleBE:
+        somPrintf("\t SOMTDoubleBE\n");
+        break;
+      case     SOMTEBaseE:
+        somPrintf("\t SOMTEBaseE\n");
+        break;
+      case     SOMTEEnumE:
+        somPrintf("\t SOMTEEnumE\n");
+        break;
+      case     SOMTEnumBE:
+        somPrintf("\t SOMTEnumBE\n");
+        break;
+      case     SOMTEnumE:
+        somPrintf("\t SOMTEnumE\n");
+        break;
+      case     SOMTEnumPE:
+        somPrintf("\t SOMTEnumPE\n");
+        break;
+      case     SOMTFloatBE:
+        somPrintf("\t SOMTFloatBE\n");
+        break;
+      case     SOMTGroupE:
+        somPrintf("\t SOMTGroupE\n");
+        break;
+      case     SOMTLongBE:
+        somPrintf("\t SOMTLongBE\n");
+        break;
+      case     SOMTMetaE:
+        somPrintf("\t SOMTMetaE\n");
+        break;
+      case     SOMTModuleE:
+        somPrintf("\t SOMTModuleE\n");
+        break;
+      case     SOMTNegativeBE:
+        somPrintf("\t SOMTNegativeBE\n");
+        break;
+      case     SOMTNewMethodE:
+        somPrintf("\t SOMTNewMethodE\n");
+        dumpMethodOrData(ep);
+        break;
+      case     SOMTOctetBE:
+        somPrintf("\t SOMTOctetBE\n");
+        break;
+      case     SOMTOverriddenMethodE:
+        somPrintf("\t SOMTOverriddenMethodE\n");
+        dumpMethodOrData(ep);
+        break;
+      case     SOMTOverrideMethodE:
+        somPrintf("\t SOMTOverrideMethodE\n");
+        dumpMethodOrData(ep);
+        break;
+      case     SOMTPassthruE:
+        somPrintf("\t SOMTPassthruE\n");
+        break;
+      case     SOMTSequenceE:
+        somPrintf("\t SOMTSequenceE\n");
+        break;
+      case     SOMTSequenceTDE:
+        somPrintf("\t SOMTSequenceTDE\n");
+        break;
+      case     SOMTShortBE:
+        somPrintf("\t SOMTShortBE\n");
+        break;
+      case     SOMTStringBE:
+        somPrintf("\t SOMTStringBE\n");
+        break;
+      case     SOMTStringE:
+        somPrintf("\t SOMTStringE\n");
+        break;
+      case     SOMTStructE:
+        somPrintf("\t SOMTStructE\n");
+        break;
+      case     SOMTStructPE:
+        somPrintf("\t SOMTStructPE\n");
+        break;
+      case     SOMTStructSE:
+        somPrintf("\t SOMTStructSE\n");
+        somPrintf("\tdcllist = %08p\n", ep->u.struc.dcllist);
+        somPrintf("\tcls = %08p\n", ep->u.struc.cls);
+        somPrintf("\texception = %s\n", ep->u.struc.isexcept ? "true" : "false");
+        somPrintf("\tmutref = %s\n", ep->u.struc.ismutref ? "true" : "false");
+        break;
+      case     SOMTTyDclE:
+        somPrintf("\t SOMTTyDclE\n");
+        break;
+      case     SOMTTypeCodeBE:
+        somPrintf("\t SOMTTypeCodeBE\n");
+        break;
+      case     SOMTTypedefBE:
+        somPrintf("\t SOMTTypedefBE\n");
+        dumpMethodOrData(ep);
+        break;
+      case     SOMTTypedefE:
+        somPrintf("\t SOMTTypedefE\n");
+        break;
+      case     SOMTUnionE:
+        somPrintf("\t SOMTUnionE\n");
+        break;
+      case     SOMTUnionPE:
+        somPrintf("\t SOMTUnionPE\n");
+        break;
+      case     SOMTUnionSE:
+        somPrintf("\t SOMTUnionSE\n");
+        break;
+      case     SOMTUnsignedLongBE:
+        somPrintf("\t SOMTUnsignedLongBE\n");
+        break;
+      case     SOMTUnsignedShortBE:
+        somPrintf("\t SOMTUnsignedShortBE\n");
+        break;
+      case     SOMTVoidBE:
+        somPrintf("\t SOMTVoidBE\n");
+        break;
+      case     SOMTVoidPtrBE:
+        somPrintf("\t SOMTVoidPtrBE\n");
+        dumpMethodOrData(ep);
+        break;
+  // This is special case SOMTTypes used on call of emitter start and emitter end
+  /*    case     SOMTEmitterBeginE:
+        result="SOMTEmitterBeginE";
+        break;
+      case     SOMTEmitterEndE:
+        result="SOMTEmitterEndE";
+        break; */
+      default:
+        somPrintf("Error: somtShowEntry, bad entry type of %d", ep->type);
+//        SOM_Error(SOM_Fatal, __FILE__, __LINE__);
+        SOMError(9, __FILE__, __LINE__);
+    }
+  }
+  else 
+  {
+    somPrintf("somtShowEntry: NULL entry\n");
+  }
+}
+
+void dumpEntry(Entry * ep)
+{
+  printf("Entry at address %p\n", ep);
+  printf("--------------------------\n");
+  printf("Entry type: %s (%d)\n", mysomttype(ep->type), ep->type);
+  printf("Entry type: %s (%d)\n", somtEntryTypeName(ep->type), ep->type);
+  if (ep->sname) printf("Scoped name: %s\n", *ep->sname);
+  if (ep->comment) printf("Comment associated with entry: %s\n", ep->comment);
+  printf("Modifiers: %p\n", ep->atts);
+  if (ep->atts) dumpAttrs("Modifier", ep->atts);
+  printf("TypeCode: %p\n", ep->tc);
+  printf("Points to the object: %p\n", ep->objref);
+  printf("Reference to real type: %s\n", ep->isref ? "true" : "false");
+  printf("Entry union: %p\n", &ep->u);
+#ifdef __PRIVATE__
+//    RHBelement *data;
+//    char *filestem;
+#endif    
+  mysomtShowEntry(ep);
+//  somtShowEntry(ep);
+};
+
+void dumpSep(Sep * sep)
+{
+    printf("Linked list item at address %p\n", sep);
+    printf("---------------------------------------\n");
+    printf("Position number: %d\n", sep->posn);
+    printf("Address of Entry: %p\n", sep->ep);
+    printf("Next linked list item address: %p\n", sep->next);
+    if (sep->ep) 
+    {
+      dumpEntry((Entry *)sep->ep);
+      dumpSep(sep->next);
+    }
+}
+
+void dumpStab(Stab * stab)
+{
+  printf("Basic Symbol Table/Hash table (STab) structure\n");
+  printf("----------------------------------------------\n");
+  printf("Size of buscet: %d\n", stab->size);
+  printf("Size of entry structure: %d\n", stab->entrysize);
+  printf("Number of elements: %d\n", stab->nelms);
+  printf("Address of base slot: %p\n", stab->base);
+  printf("Max address of slot: %p\n", stab->limit);
+  printf("Start address of slot buffer: %p\n", stab->buf);
+  printf("Address of MemBuf: %p\n", stab->membuf);
+  printf("Ignore case flag: %s\n", stab->ignorecase ? "true" : "false");
+  for(unsigned int i=0; i<stab->size;i++)
+  {
+    printf("Linked list at slot %d at offset %08x at address %p\n", i, sizeof(Sep)*i, stab->buf+i);
+    printf("----------------------\n");
+    dumpSep(stab->buf+i);
+  }
+};
+
+static int SOMLINK my_output(char c)
+{
+	if (c) printf("%c",c);
+	return 1;
+}
+
+void dumpFlags(void)
+{
+  printf("Global flags information\n");
+  printf("========================\n");
+  printf("verbose: %s\n", somtg_f.verbose?"true":"false");
+  printf("quiet: %s\n", somtg_f.quiet?"true":"false");
+  printf("warn: %s\n", somtg_f.warn?"true":"false");
+  printf("extra: %s\n", somtg_f.extra?"true":"false");
+  printf("comments: %s\n", somtg_f.comments?"true":"false");
+  printf("atts: \n");
+  dumpAttrs("Modifier", somtg_f.atts);
+  printf("lex: %s\n", somtg_f.lex?"true":"false");
+  printf("yacc: %s\n", somtg_f.yacc?"true":"false");
+  printf("release: %s\n", somtg_f.release?"true":"false");
+  printf("stab: %s\n", somtg_f.stab?"true":"false");
+  printf("qualify: %s\n", somtg_f.qualify?"true":"false");
+  printf("idl: %s\n", somtg_f.idl?"true":"false");
+//#ifdef __RESTRICT_MEMORY__
+//#define MAX_NO_EMITTERS 4
+//#else
+//#define MAX_NO_EMITTERS 32
+//#endif
+//    char *emitters[MAX_NO_EMITTERS];
+  printf("progname: %s\n", somtg_f.progname);
+//    int _ERROR;
+//    int WARN;
+//    int FATAL;
+//    int INTERNAL;
+  printf("append: %s\n", somtg_f.append?"true":"false");
+  printf("level2: %s\n", somtg_f.level2?"true":"false");
+  printf("noint: %s\n", somtg_f.noint?"true":"false");
+  printf("noint: %d\n", somtg_f.commentsize);
+  printf("useshort: %s\n", somtg_f.useshort?"true":"false");
+  printf("pragmas: \n");
+  dumpAttrs("Pragma", somtg_f.pragmas);
+//    Mlist *glbemits;            /* list of types to globally emit */
+  printf("fullyqualified: %s\n", somtg_f.fullyqualified?"true":"false");
+  printf("tcdone: %s\n", somtg_f.tcdone?"true":"false");
+  printf("relchk: %s\n", somtg_f.relchk?"true":"false");
+  printf("binary: %s\n", somtg_f.binary?"true":"false");
+}
+
+
+SOMEXTERN FILE * SOMLINK emitSL(char *file, Entry * cls, Stab * stab)
+{
+  somSetOutChar(my_output);
+
+  if (cls->type==SOMTEmitterBeginE) 
+  {
+    printf("Emitter begin\n");
+  } else if (cls->type==SOMTClassE) 
+  {
+    printf("Size of size: %d\n", sizeof(stab->size));
+    printf("Size of entrysize: %d\n", sizeof(stab->entrysize));
+    printf("Size of nelms: %d\n", sizeof(stab->nelms));
+    printf("Size of Sep: %d\n", sizeof(Sep));
+    dumpFlags();
+    printf("Symbol Table\n");
+    printf("============\n");
+    dumpStab(stab);
+
+    printf("Abstract syntax graph\n");
+    printf("=====================\n");
+    dumpEntry(cls);
+  } else if (cls->type==SOMTModuleE)
+  {
+    printf("Emit module\n");
+  } else if (cls->type==SOMTEmitterEndE)
+  {
+    printf("Emitter end\n");
+  }
+
+    return NULL;
+}
+
+// SOM 2.1 compatible emitter wrapper
+SOMEXTERN FILE * OPTLINK_DECL emit(char *file, Entry * cls, Stab * stab)
+{
+  OPTLINK_3ARGS(file, cls, stab);
+
+  return emitSL(file, cls, stab);
+}
diff -urN somfree\emitdump\win32\emitdump.def newsomfree3\emitdump\win32\emitdump.def
--- somfree\emitdump\win32\emitdump.def	Thu Jan 01 07:00:00 1970
+++ newsomfree3\emitdump\win32\emitdump.def	Sat Mar 16 14:09:22 2024
@@ -0,0 +1,5 @@
+LIBRARY EMITDUMP
+VERSION		1.0
+EXPORTS
+   emitSL
+   emit
diff -urN somfree\emitdump\win32\emitdump.mak newsomfree3\emitdump\win32\emitdump.mak
--- somfree\emitdump\win32\emitdump.mak	Thu Jan 01 07:00:00 1970
+++ newsomfree3\emitdump\win32\emitdump.mak	Sat Mar 16 14:09:22 2024
@@ -0,0 +1,84 @@
+#
+#  Copyright 2022, Yuri Prokushev
+#
+#  This file is part of osFree project
+#
+#  This program is free software: you can redistribute it and/or modify it
+#  under the terms of the GNU Lesser General Public License as published by the
+#  Free Software Foundation, either version 3 of the License, or (at your
+#  option) any later version.
+# 
+#  This program is distributed in the hope that it will be useful, but WITHOUT
+#  ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+#  FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for
+#  more details.
+#
+#  You should have received a copy of the GNU Lesser General Public License
+#  along with this program.  If not, see <http://www.gnu.org/licenses/>
+#
+
+!include $(MAKEDEFS)
+
+OUTDIR=$(OUTDIR_BIN)
+INTDIR=$(BUILDTYPE)
+
+DLLNAME=emitdump
+
+TARGET_DLL=$(OUTDIR)\$(DLLNAME).dll
+TARGET_PDB=$(OUTDIR)\$(DLLNAME).pdb
+TARGET_MAP=$(INTDIR)\$(DLLNAME).map
+TARGET_DEF=..\$(PLATFORM_DEF)\$(DLLNAME).def
+
+PARTOPTS=	$(STDOPT)								\
+			/DWIN32_LEAN_AND_MEAN 					\
+			/DHAVE_CONFIG_HPP							\
+			/I$(INTDIR)								\
+			/I..\win32								\
+			/I..\include							\
+			/I..\src								\
+			/I..\..\include\$(PLATFORM)				\
+			/I..\..\include\$(PLATFORM_DEF)			\
+			/I..\..\include							\
+			/I..\..\somidl\$(PLATFORM)				\
+			/I..\..\somkpub\include					\
+			/I..\..\somc\include					\
+			$(CC_OUT_PDB)$(TARGET_PDB)	
+
+OBJS=	$(INTDIR)\emitdump.obj	\
+	$(INTDIR)\link386.obj
+
+all: $(TARGET_DLL)
+
+clean:
+	$(CLEAN) $(TARGET_DLL) $(TARGET_PDB) $(TARGET_MAP) $(OBJS) $(INTDIR)\$(DLLNAME).res $(OUTDIR)\$(DLLNAME).exp $(OUTDIR)\$(DLLNAME).lib
+	
+$(TARGET_DLL): $(OBJS) $(OUTDIR) $(TARGET_DEF) $(INTDIR)\$(DLLNAME).res
+	$(CC) $(CC_OUT_DLL)$@ $(OBJS)		\
+			$(INTDIR)\$(DLLNAME).res	\
+			$(CC_OUT_PDB)$(TARGET_PDB)	\
+			$(CC_LINK)					\
+			$(LDFLAGS)					\
+			$(LD_DEF)$(TARGET_DEF)
+	$(POSTLINK_DLL) $@
+
+
+$(INTDIR)\emitdump.obj: ..\src\emitdump.cpp $(INTDIR)
+	$(CXX) /c $(PARTOPTS) $(CC_OUT_OBJ)$@ ..\src\emitdump.cpp
+
+$(INTDIR)\link386.obj: ..\win32\link386.c $(INTDIR)
+	$(CC) /c $(PARTOPTS) $(CC_OUT_OBJ)$@ ..\win32\link386.c
+
+$(INTDIR):
+	mkdir $@
+
+$(INTDIR)\$(DLLNAME).res: ..\win32\$(DLLNAME).rc
+	rc /nologo /r /I.. /I..\..\include\$(PLATFORM) /fo$@ ..\win32\$(DLLNAME).rc
+
+
+dist:
+
+
+
+
+test:
+
diff -urN somfree\emitdump\win32\emitdump.rc newsomfree3\emitdump\win32\emitdump.rc
--- somfree\emitdump\win32\emitdump.rc	Thu Jan 01 07:00:00 1970
+++ newsomfree3\emitdump\win32\emitdump.rc	Sat Mar 16 14:09:22 2024
@@ -0,0 +1,50 @@
+/**************************************************************************
+ *
+ *  Copyright 2022, Yuri Prokushev
+ *
+ *  This file is part of osFree project
+ *
+ *  This program is free software: you can redistribute it and/or modify it
+ *  under the terms of the GNU Lesser General Public License as published by the
+ *  Free Software Foundation, either version 3 of the License, or (at your
+ *  option) any later version.
+ * 
+ *  This program is distributed in the hope that it will be useful, but WITHOUT
+ *  ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ *  FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for
+ *  more details.
+ *
+ *  You should have received a copy of the GNU Lesser General Public License
+ *  along with this program.  If not, see <http://www.gnu.org/licenses/>
+ *
+ */
+
+#include <windows.h>
+#include <depvers.h>
+
+1 VERSIONINFO
+	PRODUCTVERSION DEPVERS_somtkpkg_INT4
+	FILEOS VOS__WINDOWS32
+	FILEVERSION DEPVERS_som_INT4
+	FILETYPE VFT_DLL
+BEGIN
+	BLOCK "StringFileInfo"
+	BEGIN
+		BLOCK "140904E4"
+		BEGIN
+			VALUE "CompanyName","Yuri Prokushev\000\000"
+			VALUE "LegalCopyright","Copyright й Yuri Prokushev 2022\000\000"
+			VALUE "ProductName",DEPVERS_somtkpkg_PRODUCTNAME
+			VALUE "ProductVersion",DEPVERS_somtkpkg_STR4
+			VALUE "Comments","Uncontrolled Release\000\000"
+			VALUE "FileDescription","SOM kernel\000\000"
+			VALUE "FileVersion",DEPVERS_som_STR4
+			VALUE "InternalName","emitdump\000\000"
+			VALUE "OriginalFilename","EMITDUMP.DLL\000\000"
+		END
+	END
+    BLOCK "VarFileInfo"
+    BEGIN
+        VALUE "Translation", 0x1409, 1252
+    END
+END
diff -urN somfree\emitdump\win32\link386.c newsomfree3\emitdump\win32\link386.c
--- somfree\emitdump\win32\link386.c	Thu Jan 01 07:00:00 1970
+++ newsomfree3\emitdump\win32\link386.c	Sat Mar 16 14:09:22 2024
@@ -0,0 +1,29 @@
+/**************************************************************************
+ *
+ *  Copyright 2008, Roger Brown
+ *
+ *  This file is part of Roger Brown's Toolkit.
+ *
+ *  This program is free software: you can redistribute it and/or modify it
+ *  under the terms of the GNU Lesser General Public License as published by the
+ *  Free Software Foundation, either version 3 of the License, or (at your
+ *  option) any later version.
+ * 
+ *  This program is distributed in the hope that it will be useful, but WITHOUT
+ *  ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ *  FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for
+ *  more details.
+ *
+ *  You should have received a copy of the GNU Lesser General Public License
+ *  along with this program.  If not, see <http://www.gnu.org/licenses/>
+ *
+ */
+
+/* $Id: link386.c 36 2020-06-07 02:18:04Z somtoolkit $ */
+
+
+#define LINK386_SOM
+#define LINK386_SOMC
+#define LINK386_SOME
+
+#include <link386.h>
diff -urN somfree\emitgen\genemit.idl newsomfree3\emitgen\genemit.idl
--- somfree\emitgen\genemit.idl	Thu Jan 01 07:00:00 1970
+++ newsomfree3\emitgen\genemit.idl	Sat Mar 16 14:09:22 2024
@@ -0,0 +1,19 @@
+#ifndef GENEmitter_idl
+#define GENEmitter_idl
+
+#include <scemit.idl>
+
+interface GENEmitter : SOMTEmitC
+{
+#ifdef __SOMIDL__
+  implementation {
+    //# Class Modifiers
+    callstyle = oidl;
+
+    //# Method Modifiers
+    somtGenerateSections: override;
+  };
+#endif /* __SOMIDL__ */
+};
+
+#endif  /* GENEmitter_idl */
diff -urN somfree\emitgen\include\genemit.efw newsomfree3\emitgen\include\genemit.efw
--- somfree\emitgen\include\genemit.efw	Thu Jan 01 07:00:00 1970
+++ newsomfree3\emitgen\include\genemit.efw	Sat Mar 16 14:09:22 2024
@@ -0,0 +1,13 @@
+:prologS
+;
+;  SOM Compiler Definition File Emitter (C) Yuri Prokushev
+;                                       (C) Andrey Vasilkin
+;
+LIBRARY <lnkDLLName> INITINSTANCE
+DESCRIPTION '<className> Definition File'
+PROTMODE
+DATA MULTIPLE NONSHARED LOADONCALL
+EXPORTS
+   <className>ClassData
+   <className>CClassData
+   <className>NewClass
diff -urN somfree\emitgen\makedefs.cf newsomfree3\emitgen\makedefs.cf
--- somfree\emitgen\makedefs.cf	Thu Jan 01 07:00:00 1970
+++ newsomfree3\emitgen\makedefs.cf	Sat Mar 16 14:09:22 2024
@@ -0,0 +1,3 @@
+NAME emitgen
+DEPENDS some somc
+PROVIDES emitgen
diff -urN somfree\emitgen\src\emitgen.cpp newsomfree3\emitgen\src\emitgen.cpp
--- somfree\emitgen\src\emitgen.cpp	Thu Jan 01 07:00:00 1970
+++ newsomfree3\emitgen\src\emitgen.cpp	Sat Mar 16 14:09:22 2024
@@ -0,0 +1,84 @@
+#include <scentry.xh>
+#include <scmodule.xh>
+#include <emitlib.h>
+#include <sctypes.h>
+#include "genemit.xh"
+
+char *get_filename_ext(char *filename) {
+    char *dot = strrchr(filename, '.');
+    if(!dot || dot == filename) return "";
+    return dot + 1;
+}
+
+SOMEXTERN FILE * SOMLINK emitSL(char *file, Entry * cls, Stab * stab)
+{
+
+    FILE *fp;
+    FILE *genfile;
+    SOMTClassEntryC *oCls;
+    SOMTModuleEntryC *mod;
+    GENEmitter *emitter;
+    SOMTTemplateOutputC *t;
+    char * emitfile;
+    char * deffile;
+
+
+    /* if this is a class, rather than a module: */
+    if (cls->type == SOMTClassE) {
+        oCls = (SOMTClassEntryC *)somtGetObjectWrapper(cls);
+        emitter = new GENEmitter();
+ 	emitfile=emitter->somtGetGlobalModifierValue("emitfile");
+        deffile=emitter->somtGetGlobalModifierValue("deffile");
+        fp = somtopenEmitFileSL(emitfile, get_filename_ext(emitfile));
+        emitter->_set_somtTargetFile(fp);
+        emitter->_set_somtTargetClass(oCls);
+        emitter->_set_somtEmitterName("gen");
+        t = emitter->_get_somtTemplate();
+        t->_set_somtCommentStyle(somtCPPE);
+        if (genfile = emitter->somtOpenSymbolsFile(deffile, "r")) {
+            t->somtReadSectionDefinitions(genfile);
+            somtfcloseSL(genfile);
+        }
+        else {
+            exit(-1);
+        }
+        emitter->somtGenerateSections();
+        delete emitter;
+        delete oCls;
+
+        return (fp);
+    }
+    else if (cls->type == SOMTModuleE) {
+
+        fp = somtopenEmitFileSL(file, "gen");
+        mod = (SOMTModuleEntryC *) somtGetObjectWrapper(cls);
+        emitter = new GENEmitter();
+        emitter->_set_somtTargetFile(fp);
+        emitter->_set_somtTargetModule(mod);
+        t = emitter->_get_somtTemplate();
+        t->_set_somtCommentStyle(somtCPPE);
+	if (genfile = emitter->somtOpenSymbolsFile(emitter->somtGetGlobalModifierValue("deffile"), "r")) {
+            t->somtReadSectionDefinitions(genfile);
+            somtfcloseSL(genfile);
+        }
+        else {
+            exit(-1);
+        }
+        emitter->somtGenerateSections();
+        delete emitter;
+        delete mod;
+
+        return (fp);
+    }
+    else {
+      return ((FILE *) NULL);
+    }
+}
+
+// SOM 2.1 compatible emitter wrapper
+SOMEXTERN FILE * OPTLINK_DECL emit(char *file, Entry * cls, Stab * stab)
+{
+  OPTLINK_3ARGS(file, cls, stab);
+
+  return emitSL(file, cls, stab);
+}
diff -urN somfree\emitgen\src\genemit.cpp newsomfree3\emitgen\src\genemit.cpp
--- somfree\emitgen\src\genemit.cpp	Thu Jan 01 07:00:00 1970
+++ newsomfree3\emitgen\src\genemit.cpp	Sat Mar 16 14:09:22 2024
@@ -0,0 +1,41 @@
+/*
+ *  This file was generated by the SOM Compiler and Emitter Framework.
+ *  Generated using template emitter:
+ *      SOM Emitter emitctm: 2.23.1.9
+ */
+
+#ifndef SOM_Module_gen_Source
+#define SOM_Module_gen_Source
+#endif
+#define GENEmitter_Class_Source
+
+#include "genemit.xih"
+#include <scmodule.xh>
+#include <scclass.xh>
+#include <string.h>
+#include <stdio.h>
+
+
+/*
+ * Управление последовательностью секций
+ */
+
+SOM_Scope boolean  SOMLINK somtGenerateSections(GENEmitter *somSelf)
+{
+  SOMTTemplateOutputC   *templ = somSelf->_get_somtTemplate();
+  SOMTClassEntryC       *cls = somSelf->_get_somtTargetClass();
+//  GENEmitterData     *EmitterData = GENEmitterGetData(somSelf);
+
+  GENEmitterMethodDebug("GENEmitter","somtGenerateSections");
+
+  if ( cls )
+  {
+    somSelf->somtFileSymbols();
+    templ->somtSetSymbolCopyBoth("cppext", "cpp");
+    templ->somtOutputSection("template");
+  }
+
+  return TRUE;
+}
+
+
diff -urN somfree\emitgen\win32\emitgen.def newsomfree3\emitgen\win32\emitgen.def
--- somfree\emitgen\win32\emitgen.def	Thu Jan 01 07:00:00 1970
+++ newsomfree3\emitgen\win32\emitgen.def	Sat Mar 16 14:09:22 2024
@@ -0,0 +1,5 @@
+LIBRARY EMITGEN
+VERSION		1.0
+EXPORTS
+   emitSL
+   emit
diff -urN somfree\emitgen\win32\emitgen.mak newsomfree3\emitgen\win32\emitgen.mak
--- somfree\emitgen\win32\emitgen.mak	Thu Jan 01 07:00:00 1970
+++ newsomfree3\emitgen\win32\emitgen.mak	Sat Mar 16 14:09:22 2024
@@ -0,0 +1,115 @@
+#
+#  Copyright 2022, Yuri Prokushev
+#
+#  This file is part of osFree project
+#
+#  This program is free software: you can redistribute it and/or modify it
+#  under the terms of the GNU Lesser General Public License as published by the
+#  Free Software Foundation, either version 3 of the License, or (at your
+#  option) any later version.
+# 
+#  This program is distributed in the hope that it will be useful, but WITHOUT
+#  ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+#  FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for
+#  more details.
+#
+#  You should have received a copy of the GNU Lesser General Public License
+#  along with this program.  If not, see <http://www.gnu.org/licenses/>
+#
+
+!include $(MAKEDEFS)
+
+OUTDIR=$(OUTDIR_BIN)
+INTDIR=$(BUILDTYPE)
+
+DLLNAME=emitgen
+
+IDLTOOL=$(RHBTOOLS_BIN)\idltool.exe
+SC=$(SOMTOOLS_BIN)\sc.exe
+PDL=$(SOMTOOLS_BIN)\pdl.exe
+SOMIDL_IDL=..\..\somidl
+SOMIDL_HEADERS=$(SOMIDL_IDL)\$(PLATFORM)
+
+EMIT_DIR=..\..\emitgen
+SOME_DIR=..\..\some
+SOMC_DIR=..\..\somc
+EMIT_INTDIR=$(INTDIR)
+
+TARGET_DLL=$(OUTDIR)\$(DLLNAME).dll
+TARGET_PDB=$(OUTDIR)\$(DLLNAME).pdb
+TARGET_MAP=$(INTDIR)\$(DLLNAME).map
+TARGET_DEF=..\$(PLATFORM_DEF)\$(DLLNAME).def
+
+PARTOPTS=	$(STDOPT)								\
+			/DWIN32_LEAN_AND_MEAN 					\
+			/DHAVE_CONFIG_HPP							\
+			/I$(INTDIR)								\
+			/I..\win32								\
+			/I..\include							\
+			/I..\src								\
+			/I..\..\include\$(PLATFORM)				\
+			/I..\..\include\$(PLATFORM_DEF)			\
+			/I..\..\include							\
+			/I..\..\somidl\$(PLATFORM)				\
+			/I..\..\somkpub\include					\
+			/I..\..\somc\include					\
+			$(CC_OUT_PDB)$(TARGET_PDB)	
+
+OBJS=	$(INTDIR)\emitgen.obj	\
+	$(INTDIR)\genemit.obj	\
+	$(INTDIR)\link386.obj
+
+PUBLIC_IDLS=$(SOMIDL_IDL)\genemit.idl
+
+EMIT_IH=	$(EMIT_INTDIR)\genemit.h	\
+		$(EMIT_INTDIR)\genemit.ih	\
+		$(EMIT_INTDIR)\genemit.xh	\
+		$(EMIT_INTDIR)\genemit.xih
+
+all: $(INTDIR) $(PUBLIC_IDLS) $(EMIT_IH) $(TARGET_DLL)
+
+clean:
+	$(CLEAN) $(PUBLIC_IDLS) $(EMIT_IH) $(TARGET_DLL) $(TARGET_PDB) $(TARGET_MAP) $(OBJS) $(INTDIR)\$(DLLNAME).res $(OUTDIR)\$(DLLNAME).exp $(OUTDIR)\$(DLLNAME).lib
+	
+$(TARGET_DLL): $(OBJS) $(OUTDIR) $(TARGET_DEF) $(INTDIR)\$(DLLNAME).res
+	$(CC) $(CC_OUT_DLL)$@ $(OBJS)		\
+			$(INTDIR)\$(DLLNAME).res	\
+			$(CC_OUT_PDB)$(TARGET_PDB)	\
+			$(CC_LINK)					\
+			$(LDFLAGS)					\
+			$(LD_DEF)$(TARGET_DEF)
+	$(POSTLINK_DLL) $@
+
+
+$(INTDIR)\emitgen.obj: ..\src\emitgen.cpp $(INTDIR)
+	$(CXX) /c $(PARTOPTS) $(CC_OUT_OBJ)$@ ..\src\emitgen.cpp
+
+$(INTDIR)\genemit.obj: ..\src\genemit.cpp $(INTDIR)
+	$(CXX) /c $(PARTOPTS) $(CC_OUT_OBJ)$@ ..\src\genemit.cpp
+
+$(INTDIR)\link386.obj: ..\win32\link386.c $(INTDIR)
+	$(CC) /c $(PARTOPTS) $(CC_OUT_OBJ)$@ ..\win32\link386.c
+
+$(INTDIR):
+	mkdir $@
+
+$(INTDIR)\$(DLLNAME).res: ..\win32\$(DLLNAME).rc
+	rc /nologo /r /I.. /I..\..\include\$(PLATFORM) /fo$@ ..\win32\$(DLLNAME).rc
+
+$(PUBLIC_IDLS):
+	"$(IDLTOOL)" "$(PDL)"		\
+		$(EMIT_DIR)			\
+		-o $@
+
+$(EMIT_IH): 
+	"$(IDLTOOL)" "$(SC)" $(EMIT_DIR)	\
+					-o $@ -p -I$(EMIT_DIR) -I$(SOMIDL_IDL) -I$(SOMC_DIR)\include
+
+
+dist:
+
+
+
+
+test:
+
diff -urN somfree\emitgen\win32\emitgen.rc newsomfree3\emitgen\win32\emitgen.rc
--- somfree\emitgen\win32\emitgen.rc	Thu Jan 01 07:00:00 1970
+++ newsomfree3\emitgen\win32\emitgen.rc	Sat Mar 16 14:09:22 2024
@@ -0,0 +1,50 @@
+/**************************************************************************
+ *
+ *  Copyright 2022, Yuri Prokushev
+ *
+ *  This file is part of osFree project
+ *
+ *  This program is free software: you can redistribute it and/or modify it
+ *  under the terms of the GNU Lesser General Public License as published by the
+ *  Free Software Foundation, either version 3 of the License, or (at your
+ *  option) any later version.
+ * 
+ *  This program is distributed in the hope that it will be useful, but WITHOUT
+ *  ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ *  FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for
+ *  more details.
+ *
+ *  You should have received a copy of the GNU Lesser General Public License
+ *  along with this program.  If not, see <http://www.gnu.org/licenses/>
+ *
+ */
+
+#include <windows.h>
+#include <depvers.h>
+
+1 VERSIONINFO
+	PRODUCTVERSION DEPVERS_somtkpkg_INT4
+	FILEOS VOS__WINDOWS32
+	FILEVERSION DEPVERS_som_INT4
+	FILETYPE VFT_DLL
+BEGIN
+	BLOCK "StringFileInfo"
+	BEGIN
+		BLOCK "140904E4"
+		BEGIN
+			VALUE "CompanyName","Yuri Prokushev\000\000"
+			VALUE "LegalCopyright","Copyright й Yuri Prokushev 2022\000\000"
+			VALUE "ProductName",DEPVERS_somtkpkg_PRODUCTNAME
+			VALUE "ProductVersion",DEPVERS_somtkpkg_STR4
+			VALUE "Comments","Uncontrolled Release\000\000"
+			VALUE "FileDescription","SOM kernel\000\000"
+			VALUE "FileVersion",DEPVERS_som_STR4
+			VALUE "InternalName","emitgen\000\000"
+			VALUE "OriginalFilename","EMITGEN.DLL\000\000"
+		END
+	END
+    BLOCK "VarFileInfo"
+    BEGIN
+        VALUE "Translation", 0x1409, 1252
+    END
+END
diff -urN somfree\emitgen\win32\link386.c newsomfree3\emitgen\win32\link386.c
--- somfree\emitgen\win32\link386.c	Thu Jan 01 07:00:00 1970
+++ newsomfree3\emitgen\win32\link386.c	Sat Mar 16 14:09:22 2024
@@ -0,0 +1,29 @@
+/**************************************************************************
+ *
+ *  Copyright 2008, Roger Brown
+ *
+ *  This file is part of Roger Brown's Toolkit.
+ *
+ *  This program is free software: you can redistribute it and/or modify it
+ *  under the terms of the GNU Lesser General Public License as published by the
+ *  Free Software Foundation, either version 3 of the License, or (at your
+ *  option) any later version.
+ * 
+ *  This program is distributed in the hope that it will be useful, but WITHOUT
+ *  ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ *  FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for
+ *  more details.
+ *
+ *  You should have received a copy of the GNU Lesser General Public License
+ *  along with this program.  If not, see <http://www.gnu.org/licenses/>
+ *
+ */
+
+/* $Id: link386.c 36 2020-06-07 02:18:04Z somtoolkit $ */
+
+
+#define LINK386_SOM
+#define LINK386_SOMC
+#define LINK386_SOME
+
+#include <link386.h>
diff -urN somfree\emitlnk\include\lnk.efw newsomfree3\emitlnk\include\lnk.efw
--- somfree\emitlnk\include\lnk.efw	Thu Jan 01 07:00:00 1970
+++ newsomfree3\emitlnk\include\lnk.efw	Sat Mar 16 14:09:22 2024
@@ -0,0 +1,20 @@
+:prologS
+;
+;  SOM Compiler Watcom Linker Emitter (C) Yuri Prokushev
+;                                     (C) Andrey Vasilkin
+;
+name      <lnkDLLName>
+format    os2 lx dll INITINSTANCE TERMINSTANCE
+option    manyautodata
+option    caseexact
+lib       somtk.lib
+?lib      <lnkLibs>
+option    map=<classSourceFileStem>.wmp
+option    eliminate
+option    showdead
+?<lnkInclude>
+?file      <lnkObjects>
+:classS
+export    <className>ClassData
+export    <className>CClassData
+export    <className>NewClass
diff -urN somfree\emitlnk\lnkemit.idl newsomfree3\emitlnk\lnkemit.idl
--- somfree\emitlnk\lnkemit.idl	Thu Jan 01 07:00:00 1970
+++ newsomfree3\emitlnk\lnkemit.idl	Sat Mar 16 14:09:22 2024
@@ -0,0 +1,20 @@
+#ifndef LnkEmitter_idl
+#define LnkEmitter_idl
+
+#include <scemit.idl>
+
+interface LnkEmitter : SOMTEmitC
+{
+#ifdef __SOMIDL__
+  implementation {
+
+    //# Class Modifiers
+    callstyle = oidl;
+
+    //# Method Modifiers
+    somtGenerateSections: override;
+  };
+#endif /* __SOMIDL__ */
+};
+
+#endif  /* LnkEmitter_idl */
diff -urN somfree\emitlnk\makedefs.cf newsomfree3\emitlnk\makedefs.cf
--- somfree\emitlnk\makedefs.cf	Thu Jan 01 07:00:00 1970
+++ newsomfree3\emitlnk\makedefs.cf	Sat Mar 16 14:09:22 2024
@@ -0,0 +1,3 @@
+NAME emitlnk
+DEPENDS some somc
+PROVIDES emitlnk
diff -urN somfree\emitlnk\src\emitlnk.cpp newsomfree3\emitlnk\src\emitlnk.cpp
--- somfree\emitlnk\src\emitlnk.cpp	Thu Jan 01 07:00:00 1970
+++ newsomfree3\emitlnk\src\emitlnk.cpp	Sat Mar 16 14:09:22 2024
@@ -0,0 +1,75 @@
+#include <scentry.xh>
+#include <scmodule.xh>
+#include <emitlib.h>
+#include <sctypes.h>
+#include "lnkemit.xh"
+
+
+#define SYMBOLS_FILE   "lnk.efw"
+
+SOMEXTERN FILE * SOMLINK emitSL(char *file, Entry * cls, Stab * stab)
+{
+
+    FILE *fp;
+    FILE *deffile;
+    SOMTClassEntryC *oCls;
+    SOMTModuleEntryC *mod;
+    LnkEmitter *emitter;
+    SOMTTemplateOutputC *t;
+
+    /* if this is a class, rather than a module: */
+    if (cls->type == SOMTClassE) {
+        fp = somtopenEmitFileSL(file, "lnk");
+        oCls = (SOMTClassEntryC *)somtGetObjectWrapper(cls);
+        emitter = new LnkEmitter();
+        emitter->_set_somtTargetFile(fp);
+        emitter->_set_somtTargetClass(oCls);
+        emitter->_set_somtEmitterName("lnk");
+        t = emitter->_get_somtTemplate();
+        t->_set_somtCommentStyle(somtCPPE);
+        if (deffile = emitter->somtOpenSymbolsFile(SYMBOLS_FILE, "r")) {
+            t->somtReadSectionDefinitions(deffile);
+            somtfcloseSL(deffile);
+        }
+        else {
+            exit(-1);
+        }
+        emitter->somtGenerateSections();
+        delete emitter;
+        delete oCls;
+
+        return (fp);
+    }
+    else if (cls->type == SOMTModuleE) {
+        fp = somtopenEmitFileSL(file, "lnk");
+        mod = (SOMTModuleEntryC *) somtGetObjectWrapper(cls);
+        emitter = new LnkEmitter();
+        emitter->_set_somtTargetFile(fp);
+        emitter->_set_somtTargetModule(mod);
+        t = emitter->_get_somtTemplate();
+        t->_set_somtCommentStyle(somtCPPE);
+        if (deffile = emitter->somtOpenSymbolsFile(SYMBOLS_FILE, "r")) {
+            t->somtReadSectionDefinitions(deffile);
+            somtfcloseSL(deffile);
+        }
+        else {
+            exit(-1);
+        }
+        emitter->somtGenerateSections();
+        delete emitter;
+        delete mod;
+
+        return (fp);
+    }
+    else {
+      return ((FILE *) NULL);
+    }
+}
+
+// SOM 2.1 compatible emitter wrapper
+SOMEXTERN FILE * OPTLINK_DECL emit(char *file, Entry * cls, Stab * stab)
+{
+  OPTLINK_3ARGS(file, cls, stab);
+
+  return emitSL(file, cls, stab);
+}
diff -urN somfree\emitlnk\src\lnkemit.cpp newsomfree3\emitlnk\src\lnkemit.cpp
--- somfree\emitlnk\src\lnkemit.cpp	Thu Jan 01 07:00:00 1970
+++ newsomfree3\emitlnk\src\lnkemit.cpp	Sat Mar 16 14:09:22 2024
@@ -0,0 +1,87 @@
+#ifndef SOM_Module_lnk_Source
+#define SOM_Module_lnk_Source
+#endif
+#define LnkEmitter_Class_Source
+
+#include "lnkemit.xih"
+#include <scmodule.xh>
+#include <scclass.xh>
+#include <sctmplt.xh>
+#include <string.h>
+#include <stdio.h>
+
+
+boolean flag=FALSE; // Используется, чтоб секция Prolog отрабатывалась один раз.
+
+/*
+ * Управление последовательностью секций
+ */
+
+SOM_Scope boolean  SOMLINK somtGenerateSections(LnkEmitter SOMSTAR somSelf)
+{
+  char *DllName;
+  char *obj;
+  char buf[1024];
+  SOMTTemplateOutputC   *templ = somSelf->_get_somtTemplate();
+  SOMTClassEntryC       *cls = somSelf->_get_somtTargetClass();
+//  LnkEmitterData     *EmitterData = LnkEmitterGetData(somSelf);
+
+  LnkEmitterMethodDebug("LnkEmitter","somtGenerateSections");
+
+ if ( cls )
+ {
+   DllName=somSelf->somtGetGlobalModifierValue("dllname");
+   if (!DllName) DllName= cls->somtGetModifierValue("dllname");
+   if (!DllName) DllName= cls->somtGetModifierValue("filestem");
+   strcpy(buf, DllName);
+   templ->somtSetSymbolCopyBoth("lnkDLLName", buf );
+ };
+
+ if ( cls )
+ {
+   obj = somSelf->somtGetGlobalModifierValue("file");
+   templ->somtSetSymbolCopyBoth("lnkObjects", obj);
+
+   obj = somSelf->somtGetGlobalModifierValue("include");
+
+   if (obj)
+   {
+    FILE *fp;
+    char *content;
+
+     fp = fopen(obj, "r" );
+     if( fp != NULL )
+     {
+       long length = 0;
+       fseek(fp, 0, SEEK_END);
+       length = ftell(fp);
+       fseek(fp, 0, SEEK_SET);
+
+       content=(char *)malloc(length);
+       fread(content, length, 1, fp);
+       fclose(fp);
+       templ->somtSetSymbolCopyBoth("lnkInclude", content);
+       free(content);
+     }
+   }
+
+   obj = somSelf->somtGetGlobalModifierValue("lib");
+   templ->somtSetSymbolCopyBoth("lnkLibs", obj);
+ };
+
+  somSelf->somtFileSymbols();
+
+  if (!flag)
+  {
+    somSelf->somtEmitProlog();
+    flag=TRUE;
+  }
+
+
+  if ( cls )
+  {
+    somSelf->somtEmitClass();
+  }
+
+  return TRUE;
+}
diff -urN somfree\emitlnk\win32\emitlnk.def newsomfree3\emitlnk\win32\emitlnk.def
--- somfree\emitlnk\win32\emitlnk.def	Thu Jan 01 07:00:00 1970
+++ newsomfree3\emitlnk\win32\emitlnk.def	Sat Mar 16 14:09:22 2024
@@ -0,0 +1,5 @@
+LIBRARY EMITLNK
+VERSION		1.0
+EXPORTS
+   emitSL
+   emit
diff -urN somfree\emitlnk\win32\emitlnk.mak newsomfree3\emitlnk\win32\emitlnk.mak
--- somfree\emitlnk\win32\emitlnk.mak	Thu Jan 01 07:00:00 1970
+++ newsomfree3\emitlnk\win32\emitlnk.mak	Sat Mar 16 14:09:22 2024
@@ -0,0 +1,115 @@
+#
+#  Copyright 2022, Yuri Prokushev
+#
+#  This file is part of osFree project
+#
+#  This program is free software: you can redistribute it and/or modify it
+#  under the terms of the GNU Lesser General Public License as published by the
+#  Free Software Foundation, either version 3 of the License, or (at your
+#  option) any later version.
+# 
+#  This program is distributed in the hope that it will be useful, but WITHOUT
+#  ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+#  FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for
+#  more details.
+#
+#  You should have received a copy of the GNU Lesser General Public License
+#  along with this program.  If not, see <http://www.gnu.org/licenses/>
+#
+
+!include $(MAKEDEFS)
+
+OUTDIR=$(OUTDIR_BIN)
+INTDIR=$(BUILDTYPE)
+
+DLLNAME=emitlnk
+
+IDLTOOL=$(RHBTOOLS_BIN)\idltool.exe
+SC=$(SOMTOOLS_BIN)\sc.exe
+PDL=$(SOMTOOLS_BIN)\pdl.exe
+SOMIDL_IDL=..\..\somidl
+SOMIDL_HEADERS=$(SOMIDL_IDL)\$(PLATFORM)
+
+EMIT_DIR=..\..\emitlnk
+SOME_DIR=..\..\some
+SOMC_DIR=..\..\somc
+EMIT_INTDIR=$(INTDIR)
+
+TARGET_DLL=$(OUTDIR)\$(DLLNAME).dll
+TARGET_PDB=$(OUTDIR)\$(DLLNAME).pdb
+TARGET_MAP=$(INTDIR)\$(DLLNAME).map
+TARGET_DEF=..\$(PLATFORM_DEF)\$(DLLNAME).def
+
+PARTOPTS=	$(STDOPT)								\
+			/DWIN32_LEAN_AND_MEAN 					\
+			/DHAVE_CONFIG_HPP							\
+			/I$(INTDIR)								\
+			/I..\win32								\
+			/I..\include							\
+			/I..\src								\
+			/I..\..\include\$(PLATFORM)				\
+			/I..\..\include\$(PLATFORM_DEF)			\
+			/I..\..\include							\
+			/I..\..\somidl\$(PLATFORM)				\
+			/I..\..\somkpub\include					\
+			/I..\..\somc\include					\
+			$(CC_OUT_PDB)$(TARGET_PDB)	
+
+OBJS=	$(INTDIR)\emitlnk.obj	\
+	$(INTDIR)\lnkemit.obj	\
+	$(INTDIR)\link386.obj
+
+PUBLIC_IDLS=$(SOMIDL_IDL)\lnkemit.idl
+
+EMIT_IH=	$(EMIT_INTDIR)\lnkemit.h	\
+		$(EMIT_INTDIR)\lnkemit.ih	\
+		$(EMIT_INTDIR)\lnkemit.xh	\
+		$(EMIT_INTDIR)\lnkemit.xih
+
+all: $(INTDIR) $(PUBLIC_IDLS) $(EMIT_IH) $(TARGET_DLL)
+
+clean:
+	$(CLEAN) $(PUBLIC_IDLS) $(EMIT_IH) $(TARGET_DLL) $(TARGET_PDB) $(TARGET_MAP) $(OBJS) $(INTDIR)\$(DLLNAME).res $(OUTDIR)\$(DLLNAME).exp $(OUTDIR)\$(DLLNAME).lib
+	
+$(TARGET_DLL): $(OBJS) $(OUTDIR) $(TARGET_DEF) $(INTDIR)\$(DLLNAME).res
+	$(CC) $(CC_OUT_DLL)$@ $(OBJS)		\
+			$(INTDIR)\$(DLLNAME).res	\
+			$(CC_OUT_PDB)$(TARGET_PDB)	\
+			$(CC_LINK)					\
+			$(LDFLAGS)					\
+			$(LD_DEF)$(TARGET_DEF)
+	$(POSTLINK_DLL) $@
+
+
+$(INTDIR)\emitlnk.obj: ..\src\emitlnk.cpp $(INTDIR)
+	$(CXX) /c $(PARTOPTS) $(CC_OUT_OBJ)$@ ..\src\emitlnk.cpp
+
+$(INTDIR)\lnkemit.obj: ..\src\lnkemit.cpp $(INTDIR)
+	$(CXX) /c $(PARTOPTS) $(CC_OUT_OBJ)$@ ..\src\lnkemit.cpp
+
+$(INTDIR)\link386.obj: ..\win32\link386.c $(INTDIR)
+	$(CC) /c $(PARTOPTS) $(CC_OUT_OBJ)$@ ..\win32\link386.c
+
+$(INTDIR):
+	mkdir $@
+
+$(INTDIR)\$(DLLNAME).res: ..\win32\$(DLLNAME).rc
+	rc /nologo /r /I.. /I..\..\include\$(PLATFORM) /fo$@ ..\win32\$(DLLNAME).rc
+
+$(PUBLIC_IDLS):
+	"$(IDLTOOL)" "$(PDL)"		\
+		$(EMIT_DIR)			\
+		-o $@
+
+$(EMIT_IH): 
+	"$(IDLTOOL)" "$(SC)" $(EMIT_DIR)	\
+					-o $@ -p -I$(EMIT_DIR) -I$(SOMIDL_IDL) -I$(SOMC_DIR)\include
+
+
+dist:
+
+
+
+
+test:
+
diff -urN somfree\emitlnk\win32\emitlnk.rc newsomfree3\emitlnk\win32\emitlnk.rc
--- somfree\emitlnk\win32\emitlnk.rc	Thu Jan 01 07:00:00 1970
+++ newsomfree3\emitlnk\win32\emitlnk.rc	Sat Mar 16 14:09:22 2024
@@ -0,0 +1,50 @@
+/**************************************************************************
+ *
+ *  Copyright 2022, Yuri Prokushev
+ *
+ *  This file is part of osFree project
+ *
+ *  This program is free software: you can redistribute it and/or modify it
+ *  under the terms of the GNU Lesser General Public License as published by the
+ *  Free Software Foundation, either version 3 of the License, or (at your
+ *  option) any later version.
+ * 
+ *  This program is distributed in the hope that it will be useful, but WITHOUT
+ *  ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ *  FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for
+ *  more details.
+ *
+ *  You should have received a copy of the GNU Lesser General Public License
+ *  along with this program.  If not, see <http://www.gnu.org/licenses/>
+ *
+ */
+
+#include <windows.h>
+#include <depvers.h>
+
+1 VERSIONINFO
+	PRODUCTVERSION DEPVERS_somtkpkg_INT4
+	FILEOS VOS__WINDOWS32
+	FILEVERSION DEPVERS_som_INT4
+	FILETYPE VFT_DLL
+BEGIN
+	BLOCK "StringFileInfo"
+	BEGIN
+		BLOCK "140904E4"
+		BEGIN
+			VALUE "CompanyName","Yuri Prokushev\000\000"
+			VALUE "LegalCopyright","Copyright й Yuri Prokushev 2022\000\000"
+			VALUE "ProductName",DEPVERS_somtkpkg_PRODUCTNAME
+			VALUE "ProductVersion",DEPVERS_somtkpkg_STR4
+			VALUE "Comments","Uncontrolled Release\000\000"
+			VALUE "FileDescription","SOM kernel\000\000"
+			VALUE "FileVersion",DEPVERS_som_STR4
+			VALUE "InternalName","emitlnk\000\000"
+			VALUE "OriginalFilename","EMITLNK.DLL\000\000"
+		END
+	END
+    BLOCK "VarFileInfo"
+    BEGIN
+        VALUE "Translation", 0x1409, 1252
+    END
+END
diff -urN somfree\emitlnk\win32\link386.c newsomfree3\emitlnk\win32\link386.c
--- somfree\emitlnk\win32\link386.c	Thu Jan 01 07:00:00 1970
+++ newsomfree3\emitlnk\win32\link386.c	Sat Mar 16 14:09:22 2024
@@ -0,0 +1,29 @@
+/**************************************************************************
+ *
+ *  Copyright 2008, Roger Brown
+ *
+ *  This file is part of Roger Brown's Toolkit.
+ *
+ *  This program is free software: you can redistribute it and/or modify it
+ *  under the terms of the GNU Lesser General Public License as published by the
+ *  Free Software Foundation, either version 3 of the License, or (at your
+ *  option) any later version.
+ * 
+ *  This program is distributed in the hope that it will be useful, but WITHOUT
+ *  ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ *  FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for
+ *  more details.
+ *
+ *  You should have received a copy of the GNU Lesser General Public License
+ *  along with this program.  If not, see <http://www.gnu.org/licenses/>
+ *
+ */
+
+/* $Id: link386.c 36 2020-06-07 02:18:04Z somtoolkit $ */
+
+
+#define LINK386_SOM
+#define LINK386_SOMC
+#define LINK386_SOME
+
+#include <link386.h>
diff -urN somfree\emitmods\include\mods.efw newsomfree3\emitmods\include\mods.efw
--- somfree\emitmods\include\mods.efw	Thu Jan 01 07:00:00 1970
+++ newsomfree3\emitmods\include\mods.efw	Sat Mar 16 14:09:22 2024
@@ -0,0 +1,9 @@
+:copyrightS
+;
+;  SOM Compiler MODS Emitter (C) Yuri Prokushev
+;
+:prologS
+[<classSourceFile>]
+	__modsClass=<className>
+:modifierS
+	<modifierName>=<modifierValue>
diff -urN somfree\emitmods\makedefs.cf newsomfree3\emitmods\makedefs.cf
--- somfree\emitmods\makedefs.cf	Thu Jan 01 07:00:00 1970
+++ newsomfree3\emitmods\makedefs.cf	Sat Mar 16 14:09:23 2024
@@ -0,0 +1,3 @@
+NAME emitmods
+DEPENDS some somc
+PROVIDES emitmods
diff -urN somfree\emitmods\modsemit.idl newsomfree3\emitmods\modsemit.idl
--- somfree\emitmods\modsemit.idl	Thu Jan 01 07:00:00 1970
+++ newsomfree3\emitmods\modsemit.idl	Sat Mar 16 14:09:23 2024
@@ -0,0 +1,23 @@
+#ifndef MODSEmitter_idl
+#define MODSEmitter_idl
+
+#include <scemit.idl>
+
+interface MODSEmitter : SOMTEmitC
+{
+  void somtEmitModifier();
+
+  boolean somtScanModifiers(in string each);
+
+#ifdef __SOMIDL__
+  implementation {
+    //# Class Modifiers
+    callstyle = oidl;
+
+    //# Method Modifiers
+    somtGenerateSections: override;
+  };
+#endif /* __SOMIDL__ */
+};
+
+#endif  /* MODSEmitter_idl */
diff -urN somfree\emitmods\src\emitmods.cpp newsomfree3\emitmods\src\emitmods.cpp
--- somfree\emitmods\src\emitmods.cpp	Thu Jan 01 07:00:00 1970
+++ newsomfree3\emitmods\src\emitmods.cpp	Sat Mar 16 14:09:23 2024
@@ -0,0 +1,57 @@
+#include <scentry.xh>
+#include <emitlib.h>
+#include <sctypes.h>
+#include "modsemit.xh"
+
+#define SYMBOLS_FILE   "mods.efw"
+
+SOMEXTERN FILE * SOMLINK emitSL(char *file, Entry * cls, Stab * stab)
+{
+
+    FILE *fp;
+    FILE *deffile;
+    SOMTClassEntryC *oCls;
+    MODSEmitter *emitter;
+    SOMTTemplateOutputC *t;
+
+    /* if this is a class, rather than a module: */
+    if (cls->type == SOMTClassE) 
+    {
+        somtg_f.append=1;
+        fp = somtopenEmitFileSL("__mods__", "ini");
+        oCls = (SOMTClassEntryC *)somtGetObjectWrapper(cls);
+        emitter = new MODSEmitter();
+        emitter->_set_somtTargetFile(fp);
+        emitter->_set_somtTargetClass(oCls);
+        emitter->_set_somtEmitterName("mods");
+        t = emitter->_get_somtTemplate();
+        t->_set_somtCommentStyle(somtCPPE);
+        if (deffile = emitter->somtOpenSymbolsFile(SYMBOLS_FILE, "r")) 
+        {
+            t->somtReadSectionDefinitions(deffile);
+            somtfcloseSL(deffile);
+        }
+        else 
+        {
+            exit(-1);
+        }
+        emitter->somtGenerateSections();
+
+        delete emitter;
+        delete oCls;
+
+        return (fp);
+    }
+    else 
+    {
+      return ((FILE *) NULL);
+    }
+}
+
+// SOM 2.1 compatible emitter wrapper
+SOMEXTERN FILE * OPTLINK_DECL emit(char *file, Entry * cls, Stab * stab)
+{
+  OPTLINK_3ARGS(file, cls, stab);
+
+  return emitSL(file, cls, stab);
+}
diff -urN somfree\emitmods\src\modsemit.cpp newsomfree3\emitmods\src\modsemit.cpp
--- somfree\emitmods\src\modsemit.cpp	Thu Jan 01 07:00:00 1970
+++ newsomfree3\emitmods\src\modsemit.cpp	Sat Mar 16 14:09:23 2024
@@ -0,0 +1,69 @@
+/*
+ *  This file was generated by the SOM Compiler and Emitter Framework.
+ *  Generated using template emitter:
+ *      SOM Emitter emitctm: 2.23.1.9
+ */
+
+#ifndef SOM_Module_mods_Source
+#define SOM_Module_mods_Source
+#endif
+#define MODSEmitter_Class_Source
+
+#include "modsemit.xih"
+#include <scmodule.xh>
+#include <scclass.xh>
+#include <string.h>
+#include <stdio.h>
+
+/*
+ * Управление последовательностью секций
+ */
+
+SOM_Scope boolean  SOMLINK somtGenerateSections(MODSEmitter SOMSTAR somSelf)
+{
+//  SOMTTemplateOutputC   *templ = somSelf->_get_somtTemplate();
+  SOMTClassEntryC       *cls = somSelf->_get_somtTargetClass();
+//  MODSEmitterData     *EmitterData = MODSEmitterGetData(somSelf);
+
+  MODSEmitterMethodDebug("MODSEmitter","somtGenerateSections");
+
+  somSelf->somtFileSymbols();
+
+  somSelf->somtEmitProlog();
+
+  somSelf->somtScanModifiers("somtEmitModifier");
+
+  return TRUE;
+}
+
+
+typedef void (SOMLINK * somtEmitProc)(SOMTEmitC SOMSTAR somSelf);
+
+SOM_Scope boolean SOMLINK somtScanModifiers(MODSEmitter SOMSTAR somSelf, /* in */ string each)
+{
+  string name, value;
+  boolean done;
+  somtEmitProc Proc;
+  MODSEmitterData *somThis = MODSEmitterGetData(somSelf);
+  MODSEmitterMethodDebug("MODSEmitter","somtScanModifiers");
+  SOMTClassEntryC *cls = somSelf->_get_somtTargetClass();
+
+  for (done = cls->somtGetFirstModifier(&name, &value); done;
+       done = cls->somtGetNextModifier(&name, &value))
+  {       
+    Proc = (somtEmitProc) somResolveByName(somSelf, each);
+    somSelf->_get_somtTemplate()->somtSetSymbolCopyBoth("modifierName", name);
+    somSelf->_get_somtTemplate()->somtSetSymbolCopyBoth("modifierValue", value);
+    Proc(somSelf);
+  }
+
+  return FALSE;
+}
+
+SOM_Scope void SOMLINK somtEmitModifier(MODSEmitter SOMSTAR somSelf)
+{
+  MODSEmitterData *somThis = MODSEmitterGetData(somSelf);
+  MODSEmitterMethodDebug("MODSEmitter","somtEmitModifier");
+
+  somSelf->_get_somtTemplate()->somtOutputSection("modifierS");
+}                                               
diff -urN somfree\emitmods\win32\emitmods.def newsomfree3\emitmods\win32\emitmods.def
--- somfree\emitmods\win32\emitmods.def	Thu Jan 01 07:00:00 1970
+++ newsomfree3\emitmods\win32\emitmods.def	Sat Mar 16 14:09:23 2024
@@ -0,0 +1,5 @@
+LIBRARY EMITMODS
+VERSION		1.0
+EXPORTS
+   emitSL
+   emit
diff -urN somfree\emitmods\win32\emitmods.mak newsomfree3\emitmods\win32\emitmods.mak
--- somfree\emitmods\win32\emitmods.mak	Thu Jan 01 07:00:00 1970
+++ newsomfree3\emitmods\win32\emitmods.mak	Sat Mar 16 14:09:23 2024
@@ -0,0 +1,115 @@
+#
+#  Copyright 2022, Yuri Prokushev
+#
+#  This file is part of osFree project
+#
+#  This program is free software: you can redistribute it and/or modify it
+#  under the terms of the GNU Lesser General Public License as published by the
+#  Free Software Foundation, either version 3 of the License, or (at your
+#  option) any later version.
+# 
+#  This program is distributed in the hope that it will be useful, but WITHOUT
+#  ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+#  FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for
+#  more details.
+#
+#  You should have received a copy of the GNU Lesser General Public License
+#  along with this program.  If not, see <http://www.gnu.org/licenses/>
+#
+
+!include $(MAKEDEFS)
+
+OUTDIR=$(OUTDIR_BIN)
+INTDIR=$(BUILDTYPE)
+
+DLLNAME=emitmods
+
+IDLTOOL=$(RHBTOOLS_BIN)\idltool.exe
+SC=$(SOMTOOLS_BIN)\sc.exe
+PDL=$(SOMTOOLS_BIN)\pdl.exe
+SOMIDL_IDL=..\..\somidl
+SOMIDL_HEADERS=$(SOMIDL_IDL)\$(PLATFORM)
+
+EMIT_DIR=..\..\emitmods
+SOME_DIR=..\..\some
+SOMC_DIR=..\..\somc
+EMIT_INTDIR=$(INTDIR)
+
+TARGET_DLL=$(OUTDIR)\$(DLLNAME).dll
+TARGET_PDB=$(OUTDIR)\$(DLLNAME).pdb
+TARGET_MAP=$(INTDIR)\$(DLLNAME).map
+TARGET_DEF=..\$(PLATFORM_DEF)\$(DLLNAME).def
+
+PARTOPTS=	$(STDOPT)								\
+			/DWIN32_LEAN_AND_MEAN 					\
+			/DHAVE_CONFIG_HPP							\
+			/I$(INTDIR)								\
+			/I..\win32								\
+			/I..\include							\
+			/I..\src								\
+			/I..\..\include\$(PLATFORM)				\
+			/I..\..\include\$(PLATFORM_DEF)			\
+			/I..\..\include							\
+			/I..\..\somidl\$(PLATFORM)				\
+			/I..\..\somkpub\include					\
+			/I..\..\somc\include					\
+			$(CC_OUT_PDB)$(TARGET_PDB)	
+
+OBJS=	$(INTDIR)\emitmods.obj	\
+	$(INTDIR)\modsemit.obj	\
+	$(INTDIR)\link386.obj
+
+PUBLIC_IDLS=$(SOMIDL_IDL)\modsemit.idl
+
+EMIT_IH=	$(EMIT_INTDIR)\modsemit.h	\
+		$(EMIT_INTDIR)\modsemit.ih	\
+		$(EMIT_INTDIR)\modsemit.xh	\
+		$(EMIT_INTDIR)\modsemit.xih
+
+all: $(INTDIR) $(PUBLIC_IDLS) $(EMIT_IH) $(TARGET_DLL)
+
+clean:
+	$(CLEAN) $(PUBLIC_IDLS) $(EMIT_IH) $(TARGET_DLL) $(TARGET_PDB) $(TARGET_MAP) $(OBJS) $(INTDIR)\$(DLLNAME).res $(OUTDIR)\$(DLLNAME).exp $(OUTDIR)\$(DLLNAME).lib
+	
+$(TARGET_DLL): $(OBJS) $(OUTDIR) $(TARGET_DEF) $(INTDIR)\$(DLLNAME).res
+	$(CC) $(CC_OUT_DLL)$@ $(OBJS)		\
+			$(INTDIR)\$(DLLNAME).res	\
+			$(CC_OUT_PDB)$(TARGET_PDB)	\
+			$(CC_LINK)					\
+			$(LDFLAGS)					\
+			$(LD_DEF)$(TARGET_DEF)
+	$(POSTLINK_DLL) $@
+
+
+$(INTDIR)\emitmods.obj: ..\src\emitmods.cpp $(INTDIR)
+	$(CXX) /c $(PARTOPTS) $(CC_OUT_OBJ)$@ ..\src\emitmods.cpp
+
+$(INTDIR)\modsemit.obj: ..\src\modsemit.cpp $(INTDIR)
+	$(CXX) /c $(PARTOPTS) $(CC_OUT_OBJ)$@ ..\src\modsemit.cpp
+
+$(INTDIR)\link386.obj: ..\win32\link386.c $(INTDIR)
+	$(CC) /c $(PARTOPTS) $(CC_OUT_OBJ)$@ ..\win32\link386.c
+
+$(INTDIR):
+	mkdir $@
+
+$(INTDIR)\$(DLLNAME).res: ..\win32\$(DLLNAME).rc
+	rc /nologo /r /I.. /I..\..\include\$(PLATFORM) /fo$@ ..\win32\$(DLLNAME).rc
+
+$(PUBLIC_IDLS):
+	"$(IDLTOOL)" "$(PDL)"		\
+		$(EMIT_DIR)			\
+		-o $@
+
+$(EMIT_IH): 
+	"$(IDLTOOL)" "$(SC)" $(EMIT_DIR)	\
+					-o $@ -p -I$(EMIT_DIR) -I$(SOMIDL_IDL) -I$(SOMC_DIR)\include
+
+
+dist:
+
+
+
+
+test:
+
diff -urN somfree\emitmods\win32\emitmods.rc newsomfree3\emitmods\win32\emitmods.rc
--- somfree\emitmods\win32\emitmods.rc	Thu Jan 01 07:00:00 1970
+++ newsomfree3\emitmods\win32\emitmods.rc	Sat Mar 16 14:09:23 2024
@@ -0,0 +1,50 @@
+/**************************************************************************
+ *
+ *  Copyright 2022, Yuri Prokushev
+ *
+ *  This file is part of osFree project
+ *
+ *  This program is free software: you can redistribute it and/or modify it
+ *  under the terms of the GNU Lesser General Public License as published by the
+ *  Free Software Foundation, either version 3 of the License, or (at your
+ *  option) any later version.
+ * 
+ *  This program is distributed in the hope that it will be useful, but WITHOUT
+ *  ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ *  FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for
+ *  more details.
+ *
+ *  You should have received a copy of the GNU Lesser General Public License
+ *  along with this program.  If not, see <http://www.gnu.org/licenses/>
+ *
+ */
+
+#include <windows.h>
+#include <depvers.h>
+
+1 VERSIONINFO
+	PRODUCTVERSION DEPVERS_somtkpkg_INT4
+	FILEOS VOS__WINDOWS32
+	FILEVERSION DEPVERS_som_INT4
+	FILETYPE VFT_DLL
+BEGIN
+	BLOCK "StringFileInfo"
+	BEGIN
+		BLOCK "140904E4"
+		BEGIN
+			VALUE "CompanyName","Yuri Prokushev\000\000"
+			VALUE "LegalCopyright","Copyright й Yuri Prokushev 2022\000\000"
+			VALUE "ProductName",DEPVERS_somtkpkg_PRODUCTNAME
+			VALUE "ProductVersion",DEPVERS_somtkpkg_STR4
+			VALUE "Comments","Uncontrolled Release\000\000"
+			VALUE "FileDescription","SOM kernel\000\000"
+			VALUE "FileVersion",DEPVERS_som_STR4
+			VALUE "InternalName","emitmods\000\000"
+			VALUE "OriginalFilename","EMITMODS.DLL\000\000"
+		END
+	END
+    BLOCK "VarFileInfo"
+    BEGIN
+        VALUE "Translation", 0x1409, 1252
+    END
+END
diff -urN somfree\emitmods\win32\link386.c newsomfree3\emitmods\win32\link386.c
--- somfree\emitmods\win32\link386.c	Thu Jan 01 07:00:00 1970
+++ newsomfree3\emitmods\win32\link386.c	Sat Mar 16 14:09:23 2024
@@ -0,0 +1,29 @@
+/**************************************************************************
+ *
+ *  Copyright 2008, Roger Brown
+ *
+ *  This file is part of Roger Brown's Toolkit.
+ *
+ *  This program is free software: you can redistribute it and/or modify it
+ *  under the terms of the GNU Lesser General Public License as published by the
+ *  Free Software Foundation, either version 3 of the License, or (at your
+ *  option) any later version.
+ * 
+ *  This program is distributed in the hope that it will be useful, but WITHOUT
+ *  ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ *  FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for
+ *  more details.
+ *
+ *  You should have received a copy of the GNU Lesser General Public License
+ *  along with this program.  If not, see <http://www.gnu.org/licenses/>
+ *
+ */
+
+/* $Id: link386.c 36 2020-06-07 02:18:04Z somtoolkit $ */
+
+
+#define LINK386_SOM
+#define LINK386_SOMC
+#define LINK386_SOME
+
+#include <link386.h>
diff -urN somfree\emitsc\include\sc.efw newsomfree3\emitsc\include\sc.efw
--- somfree\emitsc\include\sc.efw	Thu Jan 01 07:00:00 1970
+++ newsomfree3\emitsc\include\sc.efw	Sat Mar 16 14:09:23 2024
@@ -0,0 +1,293 @@
+:copyrightS
+/*
+ */
+
+:prologS
+/*
+ * This file was generated by the SOM Compiler.
+ * FileName: <classSourceFileStem>.sc.
+ */
+
+:baseIncludesPrologS
+:baseIncludesS
+#include "<baseInclude>"
+:baseIncludesEpilogS
+:metaIncludeS
+Section: metaIncludesS
+
+  metaName = "<metaName>"
+  metaIDLScopedName = "<metaIDLScopedName>"
+  metaCScopedName = "<metaCScopedName>"
+  metaComment = "<-- metaComment>"
+  metaInclude = "<metaInclude>"
+  metaLineNumber = "<metaLineNumber>"
+  metaMajorVersion = "<metaMajorVersion>"
+  metaMinorVersion = "<metaMinorVersion>"
+  metaMods = "<metaMods, ...>"
+  metaReleaseOrder = "<metaReleaseOrder, ...>"
+  metaSourceFile = "<metaSourceFile>"
+  metaSourceFileStem = "<metaSourceFileStem>"
+
+:classS
+
+class: <className>, 
+    majorversion = <classMajorVersion>, minorversion = <classMinorVersion>, 
+    filestem = <classSourceFileStem>, somUninit = override;
+
+?    <-- classComment>
+:basePrologS
+:baseS
+
+parent class: <baseName>;
+:baseEpilogS
+:metaS
+Section: metaS
+
+  metaName = "<metaName>"
+  metaIDLScopedName = "<metaIDLScopedName>"
+  metaCScopedName = "<metaCScopedName>"
+  metaComment = "<-- metaComment>"
+  metaInclude = "<metaInclude>"
+  metaLineNumber = "<metaLineNumber>"
+  metaMajorVersion = "<metaMajorVersion>"
+  metaMinorVersion = "<metaMinorVersion>"
+  metaMods = "<metaMods, ...>"
+  metaReleaseOrder = "<metaReleaseOrder, ...>"
+  metaSourceFile = "<metaSourceFile>"
+  metaSourceFileStem = "<metaSourceFileStem>"
+
+:constantPrologS
+Section: constantPrologS
+
+:constantS
+Section: constantS
+
+  constantName = "<constantName>"
+  constantIDLScopedName = "<constantIDLScopedName>"
+  constantCScopedName = "<constantCScopedName>"
+  constantComment = "<-- constantComment>"
+  constantLineNumber = "<constantLineNumber>"
+  constantMods = "<constantMods, ...>"
+  constType = "<constantType>"
+  constantValueUnevaluated = "<constantValueUnevaluated>"
+  constantValueEvaluated = "<constantValueEvaluated>"
+
+:constantEpilogS
+Section: constantEpilogS
+
+:typedefPrologS
+Section: typedefPrologS
+
+:typedefS
+Section: typedefS
+
+  typedefDeclarators = "<typedefDeclarators, ...>"
+  typedefBaseType = "<typedefBaseType>"
+  typedefComment = "<-- typedefComment>"
+  typedefLineNumber = "<typedefLineNumber>"
+  typedefMods = "<typedefMods, ...>"
+
+:typedefEpilogS
+Section: typedefEpilogS
+
+:structPrologS
+Section: structPrologS
+
+:structS
+Section: structS
+
+  structName = "<structName>"
+  structIDLScopedName = "<structIDLScopedName>"
+  structCScopedName = "<structCScopedName>"
+  structComment = "<-- structComment>"
+  structLineNumber = "<structLineNumber>"
+  structMods = "<structMods, ...>"
+
+:structEpilogS
+Section: structEpilogS
+
+:unionPrologS
+Section: unionPrologS
+
+:unionS
+Section: unionS
+
+  unionName = "<unionName>"
+  unionIDLScopedName = "<unionIDLScopedName>"
+  unionCScopedName = "<unionCScopedName>"
+  unionComment = "<-- unionComment>"
+  unionLineNumber = "<unionLineNumber>"
+  unionMods = "<unionMods, ...>"
+
+:unionEpilogS
+Section: unionEpilogS
+
+:enumPrologS
+Section: enumPrologS
+
+:enumS
+Section: enumS
+
+  enumName = "<enumName>"
+  enumIDLScopedName = "<enumIDLScopedName>"
+  enumCScopedName = "<enumCScopedName>"
+  enumComment = "<-- enumComment>"
+  enumLineNumber = "<enumLineNumber>"
+  enumMods = "<enumMods, ...>"
+  enumNames = "<enumNames, ...>"
+
+:enumEpilogS
+Section: enumEpilogS
+
+:attributePrologS
+Section: attributePrologS
+
+:attributeS
+Section: attributeS
+
+  attributeDeclarators = "<attributeDeclarators, ...>"
+  attributeBaseType = "<attributeBaseType>"
+  attributeComment = "<-- attributeComment>"
+  attributeLineNumber = "<attributeLineNumber>"
+  attributeMods = "<attributeMods, ...>"
+
+:attributeEpilogS
+Section: attributeEpilogS
+
+:methodsPrologS
+Section: methodsPrologS
+
+:methodsS
+Section: methodsS
+
+  methodName = "<methodName>"
+  methodIDLScopedName = "<methodIDLScopedName>"
+  methodCScopedName = "<methodCScopedName>"
+  methodComment = "<-- methodComment>"
+  methodLineNumber = "<methodLineNumber>"
+  methodMods = "<methodMods, ...>"
+  methodType = "<methodType>"
+  methodCReturnType = "<methodCReturnType>"
+  methodContext = "<methodContext, ...>"
+  methodRaises = "<methodRaises, ...>"
+  methodClassName = "<methodClassName>"
+  methodCParamList = "(<methodCParamList, ...>)"
+  methodCParamListVA = "(<methodCParamListVA, ...>)"
+  methodIDLParamList = "(<methodIDLParamList, ...>)"
+  methodShortParamNameList = "(<methodShortParamNameList, ...>)"
+  methodFullParamNameList = "(<methodFullParamNameList, ...>)"
+
+:overrideMethodsS
+Section: overrideMethodsS
+
+  methodName = "<methodName>"
+  methodIDLScopedName = "<methodIDLScopedName>"
+  methodCScopedName = "<methodCScopedName>"
+  methodComment = "<-- methodComment>"
+  methodLineNumber = "<methodLineNumber>"
+  methodMods = "<methodMods, ...>"
+  methodType = "<methodType>"
+  methodCReturnType = "<methodCReturnType>"
+  methodContext = "<methodContext, ...>"
+  methodRaises = "<methodRaises, ...>"
+  methodClassName = "<methodClassName>"
+  methodCParamList = "(<methodCParamList, ...>)"
+  methodCParamListVA = "(<methodCParamListVA, ...>)"
+  methodIDLParamList = "(<methodIDLParamList, ...>)"
+  methodShortParamNameList = "(<methodShortParamNameList, ...>)"
+  methodFullParamNameList = "(<methodFullParamNameList, ...>)"
+
+:inheritedMethodsS
+Section: inheritedMethodsS
+
+  methodName = "<methodName>"
+  methodIDLScopedName = "<methodIDLScopedName>"
+  methodCScopedName = "<methodCScopedName>"
+  methodComment = "<-- methodComment>"
+  methodLineNumber = "<methodLineNumber>"
+  methodMods = "<methodMods, ...>"
+  methodType = "<methodType>"
+  methodCReturnType = "<methodCReturnType>"
+  methodContext = "<methodContext, ...>"
+  methodRaises = "<methodRaises, ...>"
+  methodClassName = "<methodClassName>"
+  methodCParamList = "(<methodCParamList, ...>)"
+  methodCParamListVA = "(<methodCParamListVA, ...>)"
+  methodIDLParamList = "(<methodIDLParamList, ...>)"
+  methodShortParamNameList = "(<methodShortParamNameList, ...>)"
+  methodFullParamNameList = "(<methodFullParamNameList, ...>)"
+
+:methodsEpilogS
+Section: methodsEpilogS
+
+:releaseS
+
+releaseorder:
+     <classReleaseOrder, ...>;
+
+:passthruPrologS
+:passthruS
+
+passthru: <passthruName>, <passthruMods, ...>;
+<passthruBody>
+endpassthru;
+:passthruEpilogS
+:dataPrologS
+Section: dataPrologS
+
+:dataS
+Section: dataS
+
+  dataName = "<dataName>"
+  dataIDLScopedName = "<dataIDLScopedName>"
+  dataCScopedName = "<dataCScopedName>"
+  dataComment = "<-- dataComment>"
+  dataLineNumber = "<dataLineNumber>"
+  dataMods = "<dataMods, ...>"
+  dataType = "<dataType>"
+  dataArrayDimensions = "<dataArrayDimensions>"
+  dataPointers = "<dataPointers>"
+
+:dataEpilogS
+Section: dataEpilogS
+
+:interfacePrologS
+Section: interfacePrologS
+
+:interfaceS
+Section: interfaceS
+
+  className = "<className>"
+  classIDLScopedName = "<classIDLScopedName>"
+  classCScopedName = "<classCScopedName>"
+  classComment = "<-- classComment>"
+  classInclude = "<classInclude>"
+  classLineNumber = "<classLineNumber>"
+  classMods = "<classMods, ...>"
+  classMajorVersion = "<classMajorVersion>"
+  classMinorVersion = "<classMinorVersion>"
+  classReleaseOrder = "<classReleaseOrder, ...>"
+  classSourceFile = "<classSourceFile>"
+  classSourceFileStem = "<classSourceFileStem>"
+
+:interfaceEpilogS
+Section: interfaceEpilogS
+
+:modulePrologS
+Section: modulePrologS
+
+:moduleS
+Section: moduleS
+
+  moduleName = "<moduleName>"
+  moduleIDLScopedName = "<moduleIDLScopedName>"
+  moduleCScopedName = "<moduleCScopedName>"
+  moduleComment = "<-- moduleComment>"
+  moduleLineNumber = "<moduleLineNumber>"
+  moduleMods = "<moduleMods, ...>"
+
+:moduleEpilogS
+Section: moduleEpilogS
+
+:epilogS
+Section: epilogS
diff -urN somfree\emitsc\makedefs.cf newsomfree3\emitsc\makedefs.cf
--- somfree\emitsc\makedefs.cf	Thu Jan 01 07:00:00 1970
+++ newsomfree3\emitsc\makedefs.cf	Sat Mar 16 14:09:23 2024
@@ -0,0 +1,3 @@
+NAME emitsc
+DEPENDS some somc
+PROVIDES emitsc
diff -urN somfree\emitsc\sc.idl newsomfree3\emitsc\sc.idl
--- somfree\emitsc\sc.idl	Thu Jan 01 07:00:00 1970
+++ newsomfree3\emitsc\sc.idl	Sat Mar 16 14:09:23 2024
@@ -0,0 +1,50 @@
+
+// This file was generated by the SOM Compiler.
+// FileName: _sc.idl.
+// Generated using:
+//     SOM Precompiler somipc: 2.29.1.19
+//     SOM Emitter emitgen.dll: 2.49
+/* @(#) somc/gen_idl.efw 2.5 9/1/94 19:27:23 [12/22/96 21:11:23] */
+
+/*
+ *   COMPONENT_NAME: some
+ *
+ *   ORIGINS: 27
+ *
+ *
+ *   10H9767, 10H9769  (C) COPYRIGHT International Business Machines Corp. 1992,1994
+ *   All Rights Reserved
+ *   Licensed Materials - Property of IBM
+ *   US Government Users Restricted Rights - Use, duplication or
+ *   disclosure restricted by GSA ADP Schedule Contract with IBM Corp.
+ */
+
+
+/*
+ *         File:    SCEmitter.idl
+ *       Author:    SOMObjects Emitter Framework
+ *     Contents:    Generic framework logic class for SCEmitter.
+ *         Date:    Fri Aug  5 21:43:01 2022.
+ */
+
+#ifndef SCEmitter_idl
+#define SCEmitter_idl
+
+#include <scemit.idl>
+#include <scmethod.idl>
+interface SCEmitter : SOMTEmitC
+{
+#ifdef __SOMIDL__
+  implementation {
+    //# Class Modifiers
+    callstyle = oidl;
+  
+    //# Method Modifiers
+    somtGenerateSections: override;
+    somtScanMethods: override;
+    somtEmitMethod: override;
+  };
+#endif /* __SOMIDL__ */
+};
+
+#endif  /* SCEmitter_idl */
diff -urN somfree\emitsc\scmthd.idl newsomfree3\emitsc\scmthd.idl
--- somfree\emitsc\scmthd.idl	Thu Jan 01 07:00:00 1970
+++ newsomfree3\emitsc\scmthd.idl	Sat Mar 16 14:09:23 2024
@@ -0,0 +1,54 @@
+#ifndef SCMethodEntry_idl
+#define SCMethodEntry_idl
+
+#include <scmethod.idl>
+
+interface SCMethodEntry : SOMTMethodEntryC
+{
+#ifdef __SOMIDL__
+  implementation {
+    //# Class Modifiers
+    callstyle = oidl;
+  
+    //# Method Modifiers
+    _get_somtIsVarargs: override;
+    _get_somtOriginalMethod: override;
+    _get_somtOriginalClass: override;
+    _get_somtMethodGroup: override;
+    somtGetFirstParameter: override;
+    somtGetNextParameter: override;
+    somtGetArgList: override;
+    somtGetParmList: override;
+    _get_somtIsPrivateMethod: override;
+    _get_somtIsOneway: override;
+    _get_somtArgCount: override;
+    somtGetFirstException: override;
+    somtGetNextException: override;
+    _get_somtContextArray: override;
+    somtGetShortCPrototype: override;
+    somtGetFullCPrototype: override;
+    somtGetShortParmList: override;
+    somtGetFullParmList: override;
+    somtGetNthParameter: override;
+    _get_somtCReturnType: override;
+    somtGetIDLParamList: override;
+    somtGetShortCParamList: override;
+    somtGetFullCParamList: override;
+    somtGetShortParamNameList: override;
+    somtGetFullParamNameList: override;
+
+    //# Class Modifiers
+    majorversion = 2;
+    minorversion = 1;
+    filestem = scmethod;
+
+    //# Method Modifiers
+    somtSetSymbolsOnEntry: override;
+    somDumpSelfInt: override;
+  
+  };
+#endif /* __SOMIDL__ */
+};
+
+
+#endif  /* SCMethodEntry_idl */
diff -urN somfree\emitsc\sctmpl.idl newsomfree3\emitsc\sctmpl.idl
--- somfree\emitsc\sctmpl.idl	Thu Jan 01 07:00:00 1970
+++ newsomfree3\emitsc\sctmpl.idl	Sat Mar 16 14:09:23 2024
@@ -0,0 +1,71 @@
+#ifndef SCTemplate_idl
+#define SCTemplate_idl
+
+#include <sctmplt.idl>
+
+interface SCTemplate : SOMTTemplateOutputC
+{
+  const long MAX_INPUT_LINE_LENGTH = 1024;
+  const long MAX_OUTPUT_LINE_LENGTH = 4096;
+#ifdef __SOMIDL__
+  implementation {
+    //# Class Modifiers
+    callstyle = oidl;
+  
+    //# Method Modifiers
+    _get_somtCommentStyle: override;
+    _set_somtCommentStyle: override;
+    _get_somtLineLength: override;
+    _set_somtLineLength: override;
+    _set_somtCommentNewline: override;
+    _get_somtCommentNewline: override;
+    somtGetSymbol: override;
+    somtSetSymbol: override;
+    somtSetSymbolCopyName: override;
+    somtSetSymbolCopyValue: override;
+    somtSetSymbolCopyBoth: override;
+    somtCheckSymbol: override;
+    somtSetOutputFil: override;
+    somto: override;
+    somtOutputComment: override;
+    somtOutputSection: override;
+    somtAddSectionDefinitions: override;
+    somtReadSectionDefinitions: override;
+    somtExpandSymbol: override;
+
+    //# Class Modifiers
+    majorversion = 2;
+    minorversion = 2;
+    filestem = sctmpl;
+    dllname = "emitsc.dll";
+  
+//    passthru C_h =        "#include <stdio.h>"
+//"typedef enum somtCommentStyleT { somtDashesE, somtCPPE, somtCSimpleE, somtCBlockE, somtPSimpleE, somtPBlockE } somtCommentStyleT;";
+//    passthru C_xh =        "#include <stdio.h>"
+//"typedef enum somtCommentStyleT { somtDashesE, somtCPPE, somtCSimpleE, somtCBlockE, somtPSimpleE, somtPBlockE } somtCommentStyleT;";
+  
+    //# Internal Instance Variables
+    SOMStringTableC stab;           
+    FILE *fp;                       
+    long currentColumn;             
+    boolean conditionalLine;            
+    boolean anyExpansions;              
+    char oBuf[MAX_OUTPUT_LINE_LENGTH];     
+    long oBufPos;                   
+
+    somtCommentStyleT somtCommentStyle;
+    long somtLineLength;
+    boolean somtCommentNewline;
+  
+    //# Method Modifiers
+    somDefaultInit: override;
+    somDestruct: override;
+    //somPrintSelf: override;
+    //somDumpSelfInt: override;
+    //somtSetOutputFile: mplan=none;
+    //somtReadSectionDefinitions: mplan=none;
+  };
+#endif /* __SOMIDL__ */
+};
+
+#endif  /* SCTemplate_idl */
diff -urN somfree\emitsc\src\emitsc.cpp newsomfree3\emitsc\src\emitsc.cpp
--- somfree\emitsc\src\emitsc.cpp	Thu Jan 01 07:00:00 1970
+++ newsomfree3\emitsc\src\emitsc.cpp	Sat Mar 16 14:09:23 2024
@@ -0,0 +1,130 @@
+/* # @(#) /44 1.9 6/7/96 16:14:31 [12/22/96 21:24:38] */
+
+/*
+ *   COMPONENT_NAME: some
+ *
+ *   ORIGINS: 27
+ *
+ *
+ *   10H9767, 25H7912  (C) COPYRIGHT International Business Machines Corp. 1992,1996 
+ *   All Rights Reserved
+ *   Licensed Materials - Property of IBM
+ *   US Government Users Restricted Rights - Use, duplication or
+ *   disclosure restricted by GSA ADP Schedule Contract with IBM Corp.
+ */
+
+/*
+ *         File:    emitsc.cpp
+ *       Author:    SOMObjects Emitter Framework
+ *     Contents:    Generic framework emitter for SCEmitter.
+ *         Date:    Fri Aug  5 21:46:00 2022.
+ */
+
+#include <scentry.xh>
+#include <scmodule.xh>
+#include <scmethod.xh> // original
+#include <scmthd.xh> // replacement
+#include <sctmplt.xh> // original
+#include <sctmpl.xh>  // replacement
+#include <emitlib.h>
+#include "sc.xh"
+
+#define SYMBOLS_FILE   "sc.efw"
+
+static int SOMLINK my_output(char c)
+{
+	if (c) printf("%c",c);
+	return 1;
+}
+
+
+SOMEXTERN FILE * SOMLINK emitSL(char *file, Entry * cls, Stab * stab)
+{
+    FILE *fp;
+    FILE *deffile;
+    SOMTClassEntryC *oCls;
+    SOMTModuleEntryC *mod;
+    SCEmitter *emitter;
+    SOMTTemplateOutputC *t;
+
+    somSetOutChar(my_output);
+    SOM_TraceLevel=2;
+
+    SOM_SubstituteClass(SOMTMethodEntryC, SCMethodEntry);
+    SOM_SubstituteClass(SOMTTemplateOutputC, SCTemplate);
+
+    printf("1\n");
+    /* if this is a class, rather than a module: */
+    if (cls->type == SOMTClassE) {
+        printf("2\n");
+        file=strcat(file, ""); //  ╠юфшЇшърЄюЁ Їрщыр. ┼ёыш Єръє■ °Єєъє эх фхырЄ№, Єю ьюцхЄ с√Є№ ЄЁря.
+        printf("3\n");
+        fp = somtopenEmitFileSL(file, "sc");
+        printf("4\n");
+        oCls = (SOMTClassEntryC *) somtGetObjectWrapper(cls);
+        printf("5\n");
+        emitter = new SCEmitter();
+        printf("6\n");
+        emitter->_set_somtTargetFile(fp);
+        printf("7\n");
+        emitter->_set_somtTargetClass(oCls);
+        printf("8\n");
+	emitter->_set_somtEmitterName("sc");
+        printf("9\n");
+        t = emitter->_get_somtTemplate();
+        printf("10\n");
+//        t->_set_somtCommentStyle(somtCPPE);
+        printf("11\n");
+        if (deffile = emitter->somtOpenSymbolsFile(SYMBOLS_FILE, "r")) {
+        printf("12\n");
+            t->somtReadSectionDefinitions(deffile);
+        printf("13\n");
+            somtfcloseSL(deffile);
+        printf("14\n");
+        }         
+        else {
+            fprintf(stderr, "Cannot open Symbols file \" %s \".\n", 
+			     SYMBOLS_FILE);
+            exit(-1);
+        }
+        printf("15\n");
+        emitter->somtGenerateSections();
+        printf("16\n");
+	delete emitter;
+        printf("17\n");
+	delete oCls;
+        printf("18\n");
+
+        somtfcloseSL(fp);
+        printf("19\n");
+        return ((FILE *) NULL);
+    }
+    else if (cls->type == SOMTModuleE) {
+        file=strcat(file, ""); //  ╠юфшЇшърЄюЁ Їрщыр. ┼ёыш Єръє■ °Єєъє эх фхырЄ№, Єю ьюцхЄ с√Є№ ЄЁря.
+        fp = somtopenEmitFileSL(file, "sc");
+	mod = (SOMTModuleEntryC *) somtGetObjectWrapper(cls);
+        emitter = new SCEmitter();
+        emitter->_set_somtTargetFile(fp);
+        emitter->_set_somtTargetModule(mod);
+        t = emitter->_get_somtTemplate();
+        t->_set_somtCommentStyle(somtCPPE);
+        if (deffile = emitter->somtOpenSymbolsFile(SYMBOLS_FILE, "r")) {
+            t->somtReadSectionDefinitions(deffile);
+            somtfcloseSL(deffile);
+        }
+        else {
+            fprintf(stderr, "Cannot open Symbols file \" %s \".\n", 
+			     SYMBOLS_FILE);
+            exit(-1);
+        }
+        emitter->somtGenerateSections();
+        delete emitter;
+	delete mod;
+
+        somtfcloseSL(fp);
+        return ((FILE *) NULL);
+    }
+
+    else return ((FILE *) NULL);
+}
+
diff -urN somfree\emitsc\src\sc.cpp newsomfree3\emitsc\src\sc.cpp
--- somfree\emitsc\src\sc.cpp	Thu Jan 01 07:00:00 1970
+++ newsomfree3\emitsc\src\sc.cpp	Sat Mar 16 14:09:23 2024
@@ -0,0 +1,189 @@
+/* # @(#) /47 1.5 12/19/95 14:49:37 [12/22/96 21:24:40] */
+
+/*
+ *   COMPONENT_NAME: some
+ *
+ *   ORIGINS: 27
+ *
+ *
+ *   10H9767, 25H7912  (C) COPYRIGHT International Business Machines Corp. 1992,1996 
+ *   All Rights Reserved
+ *   Licensed Materials - Property of IBM
+ *   US Government Users Restricted Rights - Use, duplication or
+ *   disclosure restricted by GSA ADP Schedule Contract with IBM Corp.
+ */
+
+/*
+ *         File:    sc.cpp
+ *       Author:    SOMObjects Emitter Framework.
+ *     Contents:    Generic framework implementation for SCEmitter.
+ *         Date:    Fri Aug  5 21:46:00 2022.
+ */
+
+#define SCEmitter_Class_Source
+
+#define debug(...) somPrintf(__VA_ARGS__)
+#define SCEmitterMethodDebug(x,y) debug("%s->%s\n", x, y);
+           
+#include "scentry.xh"
+#include "scmethod.xh"
+#include "sc.xih"
+
+SOM_Scope boolean  SOMLINK somtGenerateSections(SCEmitter *somSelf)
+{
+    /* SCEmitterData *somThis = SCEmitterGetData(somSelf); */
+    SOMTClassEntryC *cls = somSelf->_get_somtTargetClass();
+    SOMTTemplateOutputC *templte = somSelf->_get_somtTemplate();
+    SCEmitterMethodDebug("SCEmitter","somtGenerateSections");
+    printf("15.1\n");
+//    templte->_set_somtCommentStyle(somtDashesE);
+
+    printf("15.2\n");
+    /*
+     * Setup symbols that are common to the whole file 
+     */
+    somSelf->somtFileSymbols();
+
+    printf("15.3\n");
+    somSelf->somtEmitProlog();
+
+    if (cls != (SOMTClassEntryC *) NULL) {
+    printf("15.4\n");
+        somSelf->somtScanBases(
+                       "somtEmitBaseIncludesProlog",
+                       "somtEmitBaseIncludes",
+                       "somtEmitBaseIncludesEpilog");
+
+    printf("15.5\n");
+        somSelf->somtEmitMetaInclude();
+
+    printf("15.6\n");
+        somSelf->somtEmitClass();
+
+    printf("15.7\n");
+        somSelf->somtEmitRelease();
+
+    printf("15.8\n");
+        somSelf->somtEmitMeta();
+
+    printf("15.9\n");
+        somSelf->somtScanBases(
+                       "somtEmitBaseProlog",
+                       "somtEmitBase",
+                       "somtEmitBaseEpilog");
+
+    printf("15.11\n");
+        somSelf->somtScanPassthru(TRUE,
+                          "somtEmitPassthruProlog",
+                          "somtEmitPassthru",
+                          "somtEmitPassthruEpilog");
+
+    printf("15.12\n");
+        somSelf->somtScanPassthru(FALSE,
+                          "somtEmitPassthruProlog",
+                          "somtEmitPassthru",
+                          "somtEmitPassthruEpilog");
+
+    printf("15.13\n");
+        somSelf->somtScanData(
+                      "somtEmitDataProlog",
+                      "somtEmitData",
+                      "somtEmitDataEpilog");
+
+//        somSelf->somtScanAttributes("somtEmitAttributeProlog",
+//                            "somtEmitAttribute", "somtEmitAttributeEpilog");
+
+    printf("15.14\n");
+        somSelf->somtScanMethods(
+                         "somtImplemented",
+                         "somtEmitMethodsProlog",
+                         "somtEmitMethod",
+                         "somtEmitMethodsEpilog",
+                         FALSE);
+
+    }
+
+//    somSelf->somtScanConstants("somtEmitConstantProlog",
+//                      "somtEmitConstant", "somtEmitConstantEpilog");
+
+//    somSelf->somtScanTypedefs("somtEmitTypedefProlog",
+//                      "somtEmitTypedef", "somtEmitTypedefEpilog");
+
+//    somSelf->somtScanStructs("somtEmitStructProlog",
+//                     "somtEmitStruct", "somtEmitStructEpilog");
+
+//    somSelf->somtScanUnions("somtEmitUnionProlog",
+//                    "somtEmitUnion", "somtEmitUnionEpilog");
+
+//    somSelf->somtScanEnums("somtEmitEnumProlog",
+//                   "somtEmitEnum", "somtEmitEnumEpilog");
+
+//    if (somSelf->_get_somtTargetModule() != (SOMTModuleEntryC *) NULL) {
+
+//        somSelf->somtScanInterfaces("somtEmitInterfaceProlog",
+//                            "somtEmitInterface", "somtEmitInterfaceEpilog");
+
+//        somSelf->somtScanModules("somtEmitModuleProlog",
+//                         "somtEmitModule", "somtEmitModuleEpilog");
+//    }
+
+    printf("15.15\n");
+    somSelf->somtEmitEpilog();
+    printf("15.16\n");
+
+    return (TRUE);
+}
+
+SOM_Scope boolean SOMLINK somtScanMethods(SCEmitter SOMSTAR somSelf,
+                                                 /* in */ string filter,
+                                                 /* in */ string prolog,
+                                                 /* in */ string each,
+                                                 /* in */ string epilog,
+                                                 /* in */ boolean forceProlog)
+{
+/*
+  somTD_SOMTEmitC_somtEmitMethodsProlog ProcProlog;
+  somTD_SOMTEmitC_somtEmitMethodsEpilog ProcEpilog;
+  somTD_SOMTEmitC_somtEmitMethod ProcEach;
+*/
+  SCEmitterData *somThis = SCEmitterGetData(somSelf);
+  SCEmitterMethodDebug("SCEmitter","somtScanMethods");
+/*  SOMTClassEntryC *cls = somSelf->_get_somtTargetClass();
+  SOMTMethodEntryC *method;
+
+  printf("15.14.1\n");
+  ProcProlog = (somTD_SOMTEmitC_somtEmitMethodsProlog) somResolveByName(somSelf, prolog);
+  printf("15.14.2\n");
+  ProcProlog(somSelf);
+  printf("15.14.3\n");
+
+  boolean done;
+  for (done = ((method=cls->somtGetFirstMethod())!=NULL); done;
+       done = ((method=cls->somtGetNextMethod())!=NULL))
+  {       
+  printf("15.14.4 each=%s\n", each);
+    ProcEach = (somTD_SOMTEmitC_somtEmitMethod) somResolveByName(somSelf, each);
+  printf("15.14.5 ProcEach=%08p\n", ProcEach);
+    ProcEach(somSelf, method);
+  printf("15.14.6\n");
+  }
+
+  printf("15.14.7\n");
+  ProcEpilog = (somTD_SOMTEmitC_somtEmitMethodsEpilog) somResolveByName(somSelf, epilog);
+  printf("15.14.8\n");
+  ProcEpilog(somSelf);
+  printf("15.14.9\n");
+
+  return FALSE;
+*/
+  return parent_somtScanMethods(somSelf, filter, prolog, each, epilog, forceProlog);
+}
+
+SOM_Scope void SOMLINK somtEmitMethod(SCEmitter SOMSTAR somSelf,
+	                                           /* in */ SOMTMethodEntryC SOMSTAR entry)
+{
+  SCEmitterData *somThis = SCEmitterGetData(somSelf);
+  SCEmitterMethodDebug("SCEmitter","somtEmitMethod");
+
+  parent_somtEmitMethod(somSelf, entry);
+}
diff -urN somfree\emitsc\src\scmthd.cpp newsomfree3\emitsc\src\scmthd.cpp
--- somfree\emitsc\src\scmthd.cpp	Thu Jan 01 07:00:00 1970
+++ newsomfree3\emitsc\src\scmthd.cpp	Sat Mar 16 14:09:23 2024
@@ -0,0 +1,227 @@
+/**************************************************************************
+ *
+ *  Copyright 2015, 2017 Yuri Prokushev
+ *
+ *  This file is part of osFree project
+ *
+ *  This program is free software: you can redistribute it and/or modify it
+ *  under the terms of the GNU Lesser General Public License as published by the
+ *  Free Software Foundation, either version 3 of the License, or (at your
+ *  option) any later version.
+ * 
+ *  This program is distributed in the hope that it will be useful, but WITHOUT
+ *  ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ *  FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for
+ *  more details.
+ *
+ *  You should have received a copy of the GNU Lesser General Public License
+ *  along with this program.  If not, see <http://www.gnu.org/licenses/>
+ *
+ */
+
+#ifndef SOM_Module_scmthd_Source
+#define SOM_Module_scmthd_Source
+#endif
+
+#define SCMethodEntry_Class_Source
+
+#define debug(...) somPrintf(__VA_ARGS__)
+#define SCMethodEntryMethodDebug(x,y) debug("%s->%s\n", x, y);
+
+#include "scmethod.xh"
+#include "scmthd.xih"
+
+SOM_Scope SOMTMethodEntryC * SOMLINK _get_somtOriginalMethod(SCMethodEntry * somSelf)
+{
+  SCMethodEntryData *somThis = SCMethodEntryGetData(somSelf);
+  SCMethodEntryMethodDebug("SCMethodEntry","_get_somtOriginalMethod");
+
+  return parent__get_somtOriginalMethod(somSelf);
+}
+
+SOM_Scope boolean SOMLINK _get_somtIsVarargs(SCMethodEntry * somSelf)
+{
+  SCMethodEntryData *somThis = SCMethodEntryGetData(somSelf);
+  SCMethodEntryMethodDebug("SCMethodEntry","_get_somtIsVarargs");
+
+  return parent__get_somtIsVarargs(somSelf);
+}
+
+SOM_Scope SOMTParameterEntryC * SOMLINK somtGetNextParameter(SCMethodEntry * somSelf)
+{
+  SCMethodEntryData *somThis = SCMethodEntryGetData(somSelf);
+  SCMethodEntryMethodDebug("SCMethodEntry","somtGetNextParameter");
+
+  return parent_somtGetNextParameter(somSelf);
+}
+
+SOM_Scope SOMTEntryC * SOMLINK _get_somtMethodGroup(SCMethodEntry * somSelf)
+{
+  SCMethodEntryData *somThis = SCMethodEntryGetData(somSelf);
+  SCMethodEntryMethodDebug("SCMethodEntry","_get_somtMethodGroup");
+
+  return parent__get_somtMethodGroup(somSelf);
+}
+
+SOM_Scope boolean SOMLINK _get_somtIsOneway(SCMethodEntry * somSelf)
+{
+  SCMethodEntryData *somThis = SCMethodEntryGetData(somSelf);
+  SCMethodEntryMethodDebug("SCMethodEntry","_get_somtIsOneway");
+
+  return parent__get_somtIsOneway(somSelf);
+}
+
+SOM_Scope SOMTParameterEntryC * SOMLINK somtGetNthParameter(SCMethodEntry * somSelf,
+                                                            /* in */ short n)
+{
+  SCMethodEntryData *somThis = SCMethodEntryGetData(somSelf);
+  SCMethodEntryMethodDebug("SCMethodEntry","somtGetNthParameter");
+
+  return parent_somtGetNthParameter(somSelf, n);
+}
+
+SOM_Scope string SOMLINK somtGetShortParamNameList(SCMethodEntry * somSelf,
+                                                   /* in */ string buffer,
+                                                   /* in */ string selfParm,
+                                                   /* in */ string varargsParm)
+{
+  SCMethodEntryData *somThis = SCMethodEntryGetData(somSelf);
+  SCMethodEntryMethodDebug("SCMethodEntry","somtGetShortParamNameList");
+
+  return parent_somtGetShortParamNameList(somSelf, buffer, selfParm, varargsParm);
+}
+
+SOM_Scope string SOMLINK somtGetIDLParamList(SCMethodEntry * somSelf,
+                                             /* in */ string buffer)
+{
+  SCMethodEntryData *somThis = SCMethodEntryGetData(somSelf);
+  SCMethodEntryMethodDebug("SCMethodEntry","somtGetIDLParamList");
+
+  return parent_somtGetIDLParamList(somSelf, buffer);
+}
+
+SOM_Scope string *SOMLINK _get_somtContextArray(SCMethodEntry * somSelf)
+{
+  string * res;
+  SCMethodEntryData *somThis = SCMethodEntryGetData(somSelf);
+  SCMethodEntryMethodDebug("SCMethodEntry","_get_somtContextArray");
+
+  res=parent__get_somtContextArray(somSelf);
+
+  debug("_get_somtContextArray return=%08p\n", res);
+  return res;
+}
+
+SOM_Scope SOMTParameterEntryC * SOMLINK somtGetFirstParameter(SCMethodEntry * somSelf)
+{
+  SCMethodEntryData *somThis = SCMethodEntryGetData(somSelf);
+  SCMethodEntryMethodDebug("SCMethodEntry","somtGetFirstParameter");
+
+  return parent_somtGetFirstParameter(somSelf);
+}
+
+SOM_Scope long SOMLINK somtSetSymbolsOnEntry(SCMethodEntry * somSelf,
+                                             /* in */ SOMTEmitC * emitter,
+                                             /* in */ string prefix)
+{
+  SCMethodEntryData *somThis = SCMethodEntryGetData(somSelf);
+  SCMethodEntryMethodDebug("SCMethodEntry","somtSetSymbolsOnEntry");
+
+  return parent_somtSetSymbolsOnEntry(somSelf, emitter, prefix);
+}
+
+SOM_Scope string SOMLINK somtGetFullCParamList(SCMethodEntry * somSelf,
+                                               /* in */ string buffer,
+                                               /* in */ string varargsParm)
+{
+  SCMethodEntryData *somThis = SCMethodEntryGetData(somSelf);
+  SCMethodEntryMethodDebug("SCMethodEntry","somtGetFullCParamList");
+
+  return parent_somtGetFullCParamList(somSelf, buffer, varargsParm);
+}
+
+SOM_Scope void SOMLINK somDumpSelfInt(SCMethodEntry * somSelf,
+                                      /* in */ long level)
+{
+  SCMethodEntryData *somThis = SCMethodEntryGetData(somSelf);
+  SCMethodEntryMethodDebug("SCMethodEntry","somDumpSelfInt");
+
+  parent_somDumpSelfInt(somSelf, level);
+}
+
+SOM_Scope string SOMLINK somtGetShortCParamList(SCMethodEntry * somSelf,
+                                                /* in */ string buffer,
+                                                /* in */ string selfParm,
+                                                /* in */ string varargsParm)
+{
+  SCMethodEntryData *somThis = SCMethodEntryGetData(somSelf);
+  SCMethodEntryMethodDebug("SCMethodEntry","somtGetShortCParamList");
+
+  return parent_somtGetShortCParamList(somSelf, buffer, selfParm, varargsParm);
+}
+
+SOM_Scope boolean SOMLINK _get_somtIsPrivateMethod(SCMethodEntry * somSelf)
+{
+  SCMethodEntryData *somThis = SCMethodEntryGetData(somSelf);
+  SCMethodEntryMethodDebug("SCMethodEntry","_get_somtIsPrivateMethod");
+
+  return parent__get_somtIsPrivateMethod(somSelf);
+}
+
+SOM_Scope SOMTStructEntryC * SOMLINK somtGetNextException(SCMethodEntry * somSelf)
+{
+  SOMTStructEntryC * res;
+  SCMethodEntryData *somThis = SCMethodEntryGetData(somSelf);
+  SCMethodEntryMethodDebug("SCMethodEntry","somtGetNextException");
+
+  res=parent_somtGetNextException(somSelf);
+  debug("somtGetNextException return=%08p\n", res);
+  return res;
+}
+
+SOM_Scope short SOMLINK _get_somtArgCount(SCMethodEntry * somSelf)
+{
+  SCMethodEntryData *somThis = SCMethodEntryGetData(somSelf);
+  SCMethodEntryMethodDebug("SCMethodEntry","_get_somtArgCount");
+
+  return parent__get_somtArgCount(somSelf);
+}
+
+SOM_Scope string SOMLINK _get_somtCReturnType(SCMethodEntry * somSelf)
+{
+  SCMethodEntryData *somThis = SCMethodEntryGetData(somSelf);
+  SCMethodEntryMethodDebug("SCMethodEntry","_get_somtCReturnType");
+
+  return parent__get_somtCReturnType(somSelf);
+}
+
+SOM_Scope SOMTStructEntryC * SOMLINK somtGetFirstException(SCMethodEntry * somSelf)
+{
+  SOMTStructEntryC * res;
+  SCMethodEntryData *somThis = SCMethodEntryGetData(somSelf);
+  SCMethodEntryMethodDebug("SCMethodEntry","somtGetFirstException");
+  res=parent_somtGetFirstException(somSelf);
+  debug("somtGetFirstException return=%08p\n", res);
+  return res;
+}
+
+SOM_Scope SOMTClassEntryC * SOMLINK _get_somtOriginalClass(SCMethodEntry * somSelf)
+{
+  SOMTClassEntryC * res;
+  SCMethodEntryData *somThis = SCMethodEntryGetData(somSelf);
+  SCMethodEntryMethodDebug("SCMethodEntry","_get_somtOriginalClass");
+  res=parent__get_somtOriginalClass(somSelf);
+  debug("_get_somtOriginalClass return=%08p\n", res);
+  return res;
+}
+
+SOM_Scope string SOMLINK somtGetFullParamNameList(SCMethodEntry * somSelf,
+                                                  /* in */ string buffer,
+                                                  /* in */ string varargsParm)
+{
+  SCMethodEntryData *somThis = SCMethodEntryGetData(somSelf);
+  SCMethodEntryMethodDebug("SCMethodEntry","somtGetFullParamNameList");
+
+  return parent_somtGetFullParamNameList(somSelf, buffer, varargsParm);
+}
+
diff -urN somfree\emitsc\src\sctmpl.cpp newsomfree3\emitsc\src\sctmpl.cpp
--- somfree\emitsc\src\sctmpl.cpp	Thu Jan 01 07:00:00 1970
+++ newsomfree3\emitsc\src\sctmpl.cpp	Sat Mar 16 14:09:23 2024
@@ -0,0 +1,249 @@
+/**************************************************************************
+ *
+ *  Copyright 2015, 2017, Yuri Prokushev
+ *
+ *  This file is part of osFree project
+ *
+ *  This program is free software: you can redistribute it and/or modify it
+ *  under the terms of the GNU Lesser General Public License as published by the
+ *  Free Software Foundation, either version 3 of the License, or (at your
+ *  option) any later version.
+ * 
+ *  This program is distributed in the hope that it will be useful, but WITHOUT
+ *  ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ *  FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for
+ *  more details.
+ *
+ *  You should have received a copy of the GNU Lesser General Public License
+ *  along with this program.  If not, see <http://www.gnu.org/licenses/>
+ *
+ */
+
+#ifndef SOM_Module_sctmpl_Source
+#define SOM_Module_sctmpl_Source
+#endif
+
+#define SCTemplate_Class_Source
+
+#define debug(...) somPrintf(__VA_ARGS__)
+#define SCTemplateMethodDebug(x,y) debug("%s->%s\n", x, y);
+
+#include "sctmpl.xih"
+
+#include <somstrt.xh>
+
+
+SOM_Scope string SOMLINK somtExpandSymbol(SCTemplate SOMSTAR somSelf,
+	                                        /* in */ string s,
+	                                        /* in */ string buf)
+{
+  SCTemplateData *somThis = SCTemplateGetData(somSelf);
+  SCTemplateMethodDebug("SCTemplate","somtExpandSymbol");
+  
+  return parent_somtExpandSymbol(somSelf, s, buf);
+}                                          
+
+SOM_Scope void SOMLINK somtSetOutputFile(SCTemplate SOMSTAR somSelf,
+	                                       /* inout */ FILE *fp)
+{
+  SCTemplateData *somThis = SCTemplateGetData(somSelf);
+  SCTemplateMethodDebug("SCTemplate","somtSetOutputFile");
+  
+  parent_somtSetOutputFile(somSelf, fp);
+}                                          
+
+/****************************************************
+ *
+ * ─юсрты хЄ юяЁхфхыхэш  ёхъЎшщ шч сєЇхЁр defString
+ * 
+ */
+SOM_Scope void SOMLINK somtAddSectionDefinitions(SCTemplate SOMSTAR somSelf,
+	                                               /* in */ string defString)
+{
+  SCTemplateData *somThis = SCTemplateGetData(somSelf);
+  SCTemplateMethodDebug("SCTemplate","somtAddSectionDefinitions");
+
+  parent_somtAddSectionDefinitions(somSelf, defString);
+}
+
+SOM_Scope void SOMLINK somtSetSymbolCopyBoth(SCTemplate SOMSTAR somSelf,
+	                                           /* in */ string name,
+	                                           /* in */ string value)
+{
+  SCTemplateData *somThis = SCTemplateGetData(somSelf);
+  SCTemplateMethodDebug("SCTemplate","somtSetSymbolCopyBoth");
+  debug("(name=%s, value=%s)\n", name, value);
+
+  parent_somtSetSymbolCopyBoth(somSelf, name, value);
+  debug("return\n");
+}
+                                             
+SOM_Scope void SOMLINK somtOutputSection(SCTemplate SOMSTAR somSelf,
+	                                       /* in */ string sectionName)
+{
+  SCTemplateData *somThis = SCTemplateGetData(somSelf);
+  SCTemplateMethodDebug("SCTemplate","somtOutputSection");
+
+  parent_somtOutputSection(somSelf, sectionName);
+}
+
+SOM_Scope string SOMLINK somtGetSymbol(SCTemplate SOMSTAR somSelf,
+	                                     /* in */ string name)
+{
+  SCTemplateData *somThis = SCTemplateGetData(somSelf);
+  SCTemplateMethodDebug("SCTemplate","somtGetSymbol");
+
+  return parent_somtGetSymbol(somSelf, name);
+}
+
+SOM_Scope boolean SOMLINK somtCheckSymbol(SCTemplate SOMSTAR somSelf,
+	                                        /* in */ string name)
+{
+  string value=NULL;
+  SCTemplateData *somThis = SCTemplateGetData(somSelf);
+  SCTemplateMethodDebug("SCTemplate","somtCheckSymbol");
+  
+  return parent_somtCheckSymbol(somSelf, name);
+}
+
+SOM_Scope void SOMLINK somtSetSymbol(SCTemplate SOMSTAR somSelf,
+	                                   /* in */ string name,
+	                                   /* in */ string value)
+{
+  SCTemplateData *somThis = SCTemplateGetData(somSelf);
+  SCTemplateMethodDebug("SCTemplate","somtSetSymbol");
+  
+  parent_somtSetSymbol(somSelf, name, value);
+}
+
+/*********************************************************
+ *
+ * ╤ўшЄ√трхЄ юяЁхфхыхэш  ёхъЎшщ шч Їрщыр ш фюсры хЄ шї т ьрёёшт юяЁхфхыхэш  ёхъЎшщ
+ *
+ */
+
+SOM_Scope void SOMLINK somtReadSectionDefinitions(SCTemplate SOMSTAR somSelf,
+	                                                /* inout */ FILE *fp)
+{
+  SCTemplateData *somThis = SCTemplateGetData(somSelf);
+  SCTemplateMethodDebug("SCTemplate","somtReadSectionDefinitions");
+
+  parent_somtReadSectionDefinitions(somSelf, fp);
+}
+
+SOM_Scope void SOMLINK somto(SCTemplate SOMSTAR somSelf,
+	                           /* in */ string tmplt)
+{
+  
+  SCTemplateData *somThis = SCTemplateGetData(somSelf);
+  SCTemplateMethodDebug("SCTemplate","somto");
+
+  parent_somto(somSelf, tmplt);
+  
+}
+
+SOM_Scope void SOMLINK somtSetSymbolCopyValue(SCTemplate SOMSTAR somSelf,
+	                                            /* in */ string name,
+	                                            /* in */ string value)
+{
+  SCTemplateData *somThis = SCTemplateGetData(somSelf);
+  SCTemplateMethodDebug("SCTemplate","somtSetSymbolCopyValue");
+  debug("(name=%s, value=%s)\n", name, value);
+  parent_somtSetSymbolCopyValue(somSelf, name, value);
+  debug("return\n");
+}
+
+SOM_Scope void SOMLINK somtOutputComment(SCTemplate SOMSTAR somSelf,
+	                                       /* in */ string comment)
+{
+  SCTemplateData *somThis = SCTemplateGetData(somSelf);
+  SCTemplateMethodDebug("SCTemplate","somtOutputComment");
+
+  parent_somtOutputComment(somSelf, comment);
+}
+
+SOM_Scope void SOMLINK somtSetSymbolCopyName(SCTemplate SOMSTAR somSelf,
+	                                           /* in */ string name,
+	                                           /* in */ string value)
+{
+  SCTemplateData *somThis = SCTemplateGetData(somSelf);
+  SCTemplateMethodDebug("SCTemplate","somtSetSymbolCopyName");
+  
+  debug("(name=%s, value=%s)\n", name, value);
+  parent_somtSetSymbolCopyName(somSelf, name, value);
+  debug("return\n");
+}
+
+
+SOM_Scope void SOMLINK somDefaultInit(SCTemplate SOMSTAR somSelf, somInitCtrl *ctrl)
+{
+  SCTemplateData *somThis; // set by BeginInitializer 
+  somInitCtrl globalCtrl;
+  somBooleanVector myMask;
+  SCTemplateMethodDebug("SCTemplate", "somDefaultInit");
+  
+  SCTemplate_BeginInitializer_somDefaultInit;
+  SCTemplate_Init_SOMTTemplateOutputC_somDefaultInit(somSelf, ctrl);
+}
+
+SOM_Scope void SOMLINK somDestruct(SCTemplate *somSelf, octet doFree, somDestructCtrl* ctrl)
+{
+  SCTemplateData *somThis; /* set by BeginDestructor */
+  somDestructCtrl globalCtrl;
+  somBooleanVector myMask;
+  SCTemplateMethodDebug("SCTemplate","somDestruct");
+  SCTemplate_BeginDestructor;
+  /*
+  * local SCTemplate deinitialization code added by programmer
+  */
+  SCTemplate_EndDestructor;
+}
+
+SOM_Scope void SOMLINK _set_somtLineLength(SCTemplate * somSelf, /* in */ long somtLineLength)
+{
+  SCTemplateData *somThis = SCTemplateGetData(somSelf);
+  SCTemplateMethodDebug("SCTemplate","_set_somtLineLength");
+
+  parent__set_somtLineLength(somSelf, somtLineLength);
+}
+
+SOM_Scope long SOMLINK _get_somtLineLength(SCTemplate * somSelf)
+{
+  SCTemplateData *somThis = SCTemplateGetData(somSelf);
+  SCTemplateMethodDebug("SCTemplate","_get_somtLineLength");
+
+  return parent__get_somtLineLength(somSelf);
+}
+
+
+SOM_Scope void SOMLINK _set_somtCommentNewline(	SCTemplate * somSelf,	/* in */ boolean somtCommentNewline)
+{
+  SCTemplateData *somThis = SCTemplateGetData(somSelf);
+  SCTemplateMethodDebug("SCTemplate","_set_somtCommentNewline");
+
+  _somtCommentNewline=somtCommentNewline;
+}
+
+SOM_Scope boolean SOMLINK _get_somtCommentNewline(SCTemplate * somSelf)
+{
+  SCTemplateData *somThis = SCTemplateGetData(somSelf);
+  SCTemplateMethodDebug("SCTemplate","_get_somtCommentNewline");
+ 
+  return _somtCommentNewline;
+}
+
+SOM_Scope void SOMLINK _set_somtCommentStyle(SCTemplate * somSelf, /* in */ somtCommentStyleT somtCommentStyle)
+{
+  SCTemplateData *somThis = SCTemplateGetData(somSelf);
+  SCTemplateMethodDebug("SCTemplate","_set_somtCommentStyle");
+
+  _somtCommentStyle=somtCommentStyle; 
+}
+
+SOM_Scope somtCommentStyleT SOMLINK _get_somtCommentStyle(SCTemplate * somSelf)
+{
+  SCTemplateData *somThis = SCTemplateGetData(somSelf);
+  SCTemplateMethodDebug("SCTemplate","_get_somtCommentStyle");
+
+  return _somtCommentStyle; 
+}
diff -urN somfree\emitsc\win32\emitsc.def newsomfree3\emitsc\win32\emitsc.def
--- somfree\emitsc\win32\emitsc.def	Thu Jan 01 07:00:00 1970
+++ newsomfree3\emitsc\win32\emitsc.def	Sat Mar 16 14:09:23 2024
@@ -0,0 +1,4 @@
+LIBRARY EMITSC
+VERSION		1.0
+EXPORTS
+   emitSL
diff -urN somfree\emitsc\win32\emitsc.mak newsomfree3\emitsc\win32\emitsc.mak
--- somfree\emitsc\win32\emitsc.mak	Thu Jan 01 07:00:00 1970
+++ newsomfree3\emitsc\win32\emitsc.mak	Sat Mar 16 14:09:23 2024
@@ -0,0 +1,132 @@
+#
+#  Copyright 2022, Yuri Prokushev
+#
+#  This file is part of osFree project
+#
+#  This program is free software: you can redistribute it and/or modify it
+#  under the terms of the GNU Lesser General Public License as published by the
+#  Free Software Foundation, either version 3 of the License, or (at your
+#  option) any later version.
+# 
+#  This program is distributed in the hope that it will be useful, but WITHOUT
+#  ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+#  FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for
+#  more details.
+#
+#  You should have received a copy of the GNU Lesser General Public License
+#  along with this program.  If not, see <http://www.gnu.org/licenses/>
+#
+
+!include $(MAKEDEFS)
+
+OUTDIR=$(OUTDIR_BIN)
+INTDIR=$(BUILDTYPE)
+
+DLLNAME=emitsc
+
+IDLTOOL=$(RHBTOOLS_BIN)\idltool.exe
+SC=$(SOMTOOLS_BIN)\sc.exe
+PDL=$(SOMTOOLS_BIN)\pdl.exe
+SOMIDL_IDL=..\..\somidl
+SOMIDL_HEADERS=$(SOMIDL_IDL)\$(PLATFORM)
+
+EMIT_DIR=..\..\emitsc
+SOME_DIR=..\..\some
+SOMC_DIR=..\..\somc
+EMIT_INTDIR=$(INTDIR)
+
+TARGET_DLL=$(OUTDIR)\$(DLLNAME).dll
+TARGET_PDB=$(OUTDIR)\$(DLLNAME).pdb
+TARGET_MAP=$(INTDIR)\$(DLLNAME).map
+TARGET_DEF=..\$(PLATFORM_DEF)\$(DLLNAME).def
+
+PARTOPTS=	$(STDOPT)								\
+			/DWIN32_LEAN_AND_MEAN 					\
+			/DHAVE_CONFIG_HPP							\
+			/I$(INTDIR)								\
+			/I..\win32								\
+			/I..\include							\
+			/I..\src								\
+			/I..\..\include\$(PLATFORM)				\
+			/I..\..\include\$(PLATFORM_DEF)			\
+			/I..\..\include							\
+			/I..\..\somidl\$(PLATFORM)				\
+			/I..\..\somkpub\include					\
+			/I..\..\somc\include					\
+			$(CC_OUT_PDB)$(TARGET_PDB)	
+
+OBJS=	$(INTDIR)\emitsc.obj	\
+	$(INTDIR)\sc.obj	\
+	$(INTDIR)\sctmpl.obj	\
+	$(INTDIR)\scmthd.obj	\
+	$(INTDIR)\link386.obj
+
+PUBLIC_IDLS=$(SOMIDL_IDL)\sc.idl	\
+		$(SOMIDL_IDL)\sctmpl.idl	\
+		$(SOMIDL_IDL)\scmthd.idl
+
+EMIT_IH=	$(EMIT_INTDIR)\sc.h	\
+		$(EMIT_INTDIR)\sc.ih	\
+		$(EMIT_INTDIR)\sc.xh	\
+		$(EMIT_INTDIR)\sc.xih	\
+		$(EMIT_INTDIR)\sctmpl.h	\
+		$(EMIT_INTDIR)\sctmpl.ih	\
+		$(EMIT_INTDIR)\sctmpl.xh	\
+		$(EMIT_INTDIR)\sctmpl.xih	\
+		$(EMIT_INTDIR)\scmthd.h	\
+		$(EMIT_INTDIR)\scmthd.ih	\
+		$(EMIT_INTDIR)\scmthd.xh	\
+		$(EMIT_INTDIR)\scmthd.xih
+
+all: $(INTDIR) $(PUBLIC_IDLS) $(EMIT_IH) $(TARGET_DLL)
+
+clean:
+	$(CLEAN) $(PUBLIC_IDLS) $(EMIT_IH) $(TARGET_DLL) $(TARGET_PDB) $(TARGET_MAP) $(OBJS) $(INTDIR)\$(DLLNAME).res $(OUTDIR)\$(DLLNAME).exp $(OUTDIR)\$(DLLNAME).lib
+	
+$(TARGET_DLL): $(OBJS) $(OUTDIR) $(TARGET_DEF) $(INTDIR)\$(DLLNAME).res
+	$(CC) $(CC_OUT_DLL)$@ $(OBJS)		\
+			$(INTDIR)\$(DLLNAME).res	\
+			$(CC_OUT_PDB)$(TARGET_PDB)	\
+			$(CC_LINK)					\
+			$(LDFLAGS)					\
+			$(LD_DEF)$(TARGET_DEF)
+	$(POSTLINK_DLL) $@
+
+
+$(INTDIR)\emitsc.obj: ..\src\emitsc.cpp $(INTDIR) $(EMIT_IH)
+	$(CXX) /c $(PARTOPTS) $(CC_OUT_OBJ)$@ ..\src\emitsc.cpp
+
+$(INTDIR)\sc.obj: ..\src\sc.cpp $(INTDIR) $(EMIT_IH)
+	$(CXX) /c $(PARTOPTS) $(CC_OUT_OBJ)$@ ..\src\sc.cpp
+
+$(INTDIR)\sctmpl.obj: ..\src\sctmpl.cpp $(INTDIR) $(EMIT_IH)
+	$(CXX) /c $(PARTOPTS) $(CC_OUT_OBJ)$@ ..\src\sctmpl.cpp
+
+$(INTDIR)\scmthd.obj: ..\src\scmthd.cpp $(INTDIR) $(EMIT_IH)
+	$(CXX) /c $(PARTOPTS) $(CC_OUT_OBJ)$@ ..\src\scmthd.cpp
+
+$(INTDIR)\link386.obj: ..\win32\link386.c $(INTDIR)
+	$(CC) /c $(PARTOPTS) $(CC_OUT_OBJ)$@ ..\win32\link386.c
+	                                                    
+$(INTDIR):
+	mkdir $@
+
+$(INTDIR)\$(DLLNAME).res: ..\win32\$(DLLNAME).rc
+	rc /nologo /r /I.. /I..\..\include\$(PLATFORM) /fo$@ ..\win32\$(DLLNAME).rc
+
+$(PUBLIC_IDLS):
+	"$(IDLTOOL)" "$(PDL)"		\
+		$(EMIT_DIR)			\
+		-o $@
+
+$(EMIT_IH): 
+	"$(IDLTOOL)" "$(SC)" $(EMIT_DIR)	\
+					-o $@ -p -I$(EMIT_DIR) -I$(SOMIDL_IDL) -I$(SOMC_DIR)\include
+
+
+dist:
+
+
+
+test:
+
diff -urN somfree\emitsc\win32\emitsc.rc newsomfree3\emitsc\win32\emitsc.rc
--- somfree\emitsc\win32\emitsc.rc	Thu Jan 01 07:00:00 1970
+++ newsomfree3\emitsc\win32\emitsc.rc	Sat Mar 16 14:09:23 2024
@@ -0,0 +1,50 @@
+/**************************************************************************
+ *
+ *  Copyright 2022, Yuri Prokushev
+ *
+ *  This file is part of osFree project
+ *
+ *  This program is free software: you can redistribute it and/or modify it
+ *  under the terms of the GNU Lesser General Public License as published by the
+ *  Free Software Foundation, either version 3 of the License, or (at your
+ *  option) any later version.
+ * 
+ *  This program is distributed in the hope that it will be useful, but WITHOUT
+ *  ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ *  FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for
+ *  more details.
+ *
+ *  You should have received a copy of the GNU Lesser General Public License
+ *  along with this program.  If not, see <http://www.gnu.org/licenses/>
+ *
+ */
+
+#include <windows.h>
+#include <depvers.h>
+
+1 VERSIONINFO
+	PRODUCTVERSION DEPVERS_somtkpkg_INT4
+	FILEOS VOS__WINDOWS32
+	FILEVERSION DEPVERS_som_INT4
+	FILETYPE VFT_DLL
+BEGIN
+	BLOCK "StringFileInfo"
+	BEGIN
+		BLOCK "140904E4"
+		BEGIN
+			VALUE "CompanyName","Yuri Prokushev\000\000"
+			VALUE "LegalCopyright","Copyright й Yuri Prokushev 2022\000\000"
+			VALUE "ProductName",DEPVERS_somtkpkg_PRODUCTNAME
+			VALUE "ProductVersion",DEPVERS_somtkpkg_STR4
+			VALUE "Comments","Uncontrolled Release\000\000"
+			VALUE "FileDescription","SOM kernel\000\000"
+			VALUE "FileVersion",DEPVERS_som_STR4
+			VALUE "InternalName","emitsc\000\000"
+			VALUE "OriginalFilename","EMITSC.DLL\000\000"
+		END
+	END
+    BLOCK "VarFileInfo"
+    BEGIN
+        VALUE "Translation", 0x1409, 1252
+    END
+END
diff -urN somfree\emitsc\win32\link386.c newsomfree3\emitsc\win32\link386.c
--- somfree\emitsc\win32\link386.c	Thu Jan 01 07:00:00 1970
+++ newsomfree3\emitsc\win32\link386.c	Sat Mar 16 14:09:23 2024
@@ -0,0 +1,29 @@
+/**************************************************************************
+ *
+ *  Copyright 2008, Roger Brown
+ *
+ *  This file is part of Roger Brown's Toolkit.
+ *
+ *  This program is free software: you can redistribute it and/or modify it
+ *  under the terms of the GNU Lesser General Public License as published by the
+ *  Free Software Foundation, either version 3 of the License, or (at your
+ *  option) any later version.
+ * 
+ *  This program is distributed in the hope that it will be useful, but WITHOUT
+ *  ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ *  FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for
+ *  more details.
+ *
+ *  You should have received a copy of the GNU Lesser General Public License
+ *  along with this program.  If not, see <http://www.gnu.org/licenses/>
+ *
+ */
+
+/* $Id: link386.c 36 2020-06-07 02:18:04Z somtoolkit $ */
+
+
+#define LINK386_SOM
+#define LINK386_SOMC
+#define LINK386_SOME
+
+#include <link386.h>
diff -urN somfree\gastm\gascope.idl newsomfree3\gastm\gascope.idl
--- somfree\gastm\gascope.idl	Thu Jan 01 07:00:00 1970
+++ newsomfree3\gastm\gascope.idl	Sat Mar 16 14:09:23 2024
@@ -0,0 +1,9 @@
+#include <gscope.idl>
+
+interface AggregateScope: Scope
+{
+#ifdef __SOMIDL__
+  implementation {
+  };
+#endif /* __SOMIDL__ */
+};
diff -urN somfree\gastm\gatdef.idl newsomfree3\gastm\gatdef.idl
--- somfree\gastm\gatdef.idl	Thu Jan 01 07:00:00 1970
+++ newsomfree3\gastm\gatdef.idl	Sat Mar 16 14:09:23 2024
@@ -0,0 +1,15 @@
+#ifndef gatdef_idl
+#define gatdef_idl
+
+#include <gtdef.idl>
+
+interface AggregateTypeDefinition: TypeDefinition
+{
+  attribute AggregateType aggregateType;
+#ifdef __SOMIDL__
+  implementation {
+  };
+#endif /* __SOMIDL__ */
+};
+
+#endif  /* gatdef_idl */
diff -urN somfree\gastm\gbfdef.idl newsomfree3\gastm\gbfdef.idl
--- somfree\gastm\gbfdef.idl	Thu Jan 01 07:00:00 1970
+++ newsomfree3\gastm\gbfdef.idl	Sat Mar 16 14:09:23 2024
@@ -0,0 +1,15 @@
+#ifndef gbfdef_idl
+#define gbfdef_idl
+
+#include <gddef.idl>
+
+interface BitFieldDefinition: DataDefinition
+{
+  attribute Expression bitFieldSize;
+#ifdef __SOMIDL__
+  implementation {
+  };
+#endif /* __SOMIDL__ */
+};
+
+#endif  /* gbfdef_idl */
diff -urN somfree\gastm\gbscope.idl newsomfree3\gastm\gbscope.idl
--- somfree\gastm\gbscope.idl	Thu Jan 01 07:00:00 1970
+++ newsomfree3\gastm\gbscope.idl	Sat Mar 16 14:09:23 2024
@@ -0,0 +1,9 @@
+#include <gscope.idl>
+
+interface BlockScope: Scope
+{
+#ifdef __SOMIDL__
+  implementation {
+  };
+#endif /* __SOMIDL__ */
+};
diff -urN somfree\gastm\gcompunt.idl newsomfree3\gastm\gcompunt.idl
--- somfree\gastm\gcompunt.idl	Thu Jan 01 07:00:00 1970
+++ newsomfree3\gastm\gcompunt.idl	Sat Mar 16 14:09:23 2024
@@ -0,0 +1,20 @@
+#ifndef gcompunt_idl
+#define gcompunt_idl
+
+#include <gsrcfile.idl>
+#include <gpscope.idl>
+#include <gdefobj.idl>
+
+interface CompilationUnit: SourceFile
+{
+  typedef sequence<DefinitionObject> fragmentsSeq;
+  attribute string language;
+  attribute fragmentsSeq fragments;
+  attribute ProgramScope openScope;
+#ifdef __SOMIDL__
+  implementation {
+  };
+#endif /* __SOMIDL__ */
+};
+
+#endif  /* gcompunt_idl */
diff -urN somfree\gastm\gddef.idl newsomfree3\gastm\gddef.idl
--- somfree\gastm\gddef.idl	Thu Jan 01 07:00:00 1970
+++ newsomfree3\gastm\gddef.idl	Sat Mar 16 14:09:23 2024
@@ -0,0 +1,16 @@
+#ifndef gddef_idl
+#define gddef_idl
+
+#include <gdef.idl>
+
+interface DataDefinition: Definition
+{
+  attribute Expression initialValue;
+  attribute boolean isMutable;
+#ifdef __SOMIDL__
+  implementation {
+  };
+#endif /* __SOMIDL__ */
+};
+
+#endif  /* gddef_idl */
diff -urN somfree\gastm\gdecl.idl newsomfree3\gastm\gdecl.idl
--- somfree\gastm\gdecl.idl	Thu Jan 01 07:00:00 1970
+++ newsomfree3\gastm\gdecl.idl	Sat Mar 16 14:09:23 2024
@@ -0,0 +1,17 @@
+#ifndef gdecl_idl
+#define gdecl_idl
+
+#include <gdord.idl>
+#include <gdef.idl>
+
+interface Declaration: DeclarationOrDefinition
+{
+  attribute Definition defRef;
+  attribute Name identifierName;
+#ifdef __SOMIDL__
+  implementation {
+  };
+#endif /* __SOMIDL__ */
+};
+
+#endif  /* gdecl_idl */
diff -urN somfree\gastm\gdef.idl newsomfree3\gastm\gdef.idl
--- somfree\gastm\gdef.idl	Thu Jan 01 07:00:00 1970
+++ newsomfree3\gastm\gdef.idl	Sat Mar 16 14:09:23 2024
@@ -0,0 +1,16 @@
+#ifndef gdef_idl
+#define gdef_idl
+
+#include <gdord.idl>
+
+interface Definition: DeclarationOrDefinition
+{
+  attribute Name identifierName;
+  attribute TypeReference definitionType;
+#ifdef __SOMIDL__
+  implementation {
+  };
+#endif /* __SOMIDL__ */
+};
+
+#endif  /* gdef_idl */
diff -urN somfree\gastm\gdefobj.idl newsomfree3\gastm\gdefobj.idl
--- somfree\gastm\gdefobj.idl	Thu Jan 01 07:00:00 1970
+++ newsomfree3\gastm\gdefobj.idl	Sat Mar 16 14:09:23 2024
@@ -0,0 +1,14 @@
+#ifndef gdefobj_idl
+#define gdefobj_idl
+
+#include <gsynobj.idl>
+
+interface DefinitionObject: GASTMSyntaxObject
+{
+#ifdef __SOMIDL__
+  implementation {
+  };
+#endif /* __SOMIDL__ */
+};
+
+#endif  /* gdefobj_idl */
diff -urN somfree\gastm\gdord.idl newsomfree3\gastm\gdord.idl
--- somfree\gastm\gdord.idl	Thu Jan 01 07:00:00 1970
+++ newsomfree3\gastm\gdord.idl	Sat Mar 16 14:09:23 2024
@@ -0,0 +1,17 @@
+#ifndef gdord_idl
+#define gdord_idl
+
+#include <gdefobj.idl>
+
+interface DeclarationOrDefinition: DefinitionObject
+{
+  attribute StrorageSpecification storageSpecifiers;
+  attribute AccessKind accessKind;
+  attribute string linkageSpecifier;
+#ifdef __SOMIDL__
+  implementation {
+  };
+#endif /* __SOMIDL__ */
+};
+
+#endif  /* gdord_idl */
diff -urN somfree\gastm\gedef.idl newsomfree3\gastm\gedef.idl
--- somfree\gastm\gedef.idl	Thu Jan 01 07:00:00 1970
+++ newsomfree3\gastm\gedef.idl	Sat Mar 16 14:09:23 2024
@@ -0,0 +1,19 @@
+#ifndef gedef_idl
+#define gedef_idl
+
+#include <gdef.idl>
+#include <gfpdef.idl>
+
+interface EntryDefinition: Definition
+{
+  typedef sequence<FormalParameterDefinition> FormalParameterDefinitionSeq;
+  typedef sequence<Statement> StatementSeq;
+  attribute FormalParameterDefinition formalParameters;
+  attribute StatementSeq body;
+#ifdef __SOMIDL__
+  implementation {
+  };
+#endif /* __SOMIDL__ */
+};
+
+#endif  /* gedef_idl */
diff -urN somfree\gastm\geldef.idl newsomfree3\gastm\geldef.idl
--- somfree\gastm\geldef.idl	Thu Jan 01 07:00:00 1970
+++ newsomfree3\gastm\geldef.idl	Sat Mar 16 14:09:23 2024
@@ -0,0 +1,15 @@
+#ifndef geldef_idl
+#define geldef_idl
+
+#include <gdef.idl>
+
+interface EnumLiteralDefinition: Definition
+{
+  attribute Expression Value;
+#ifdef __SOMIDL__
+  implementation {
+  };
+#endif /* __SOMIDL__ */
+};
+
+#endif  /* geldef_idl */
diff -urN somfree\gastm\getdef.idl newsomfree3\gastm\getdef.idl
--- somfree\gastm\getdef.idl	Thu Jan 01 07:00:00 1970
+++ newsomfree3\gastm\getdef.idl	Sat Mar 16 14:09:23 2024
@@ -0,0 +1,15 @@
+#ifndef getdef_idl
+#define getdef_idl
+
+#include <gtdef.idl>
+
+interface EnumTypeDefinition: TypeDefinition
+{
+  attribute EnumType definitionType;
+#ifdef __SOMIDL__
+  implementation {
+  };
+#endif /* __SOMIDL__ */
+};
+
+#endif  /* getdef_idl */
diff -urN somfree\gastm\gfdecl.idl newsomfree3\gastm\gfdecl.idl
--- somfree\gastm\gfdecl.idl	Thu Jan 01 07:00:00 1970
+++ newsomfree3\gastm\gfdecl.idl	Sat Mar 16 14:09:23 2024
@@ -0,0 +1,18 @@
+#ifndef gfdecl_idl
+#define gfdecl_idl
+
+#include <gdecl.idl>
+#include <gfpdecl.idl>
+
+interface FunctionDeclaration: Declaration
+{
+  typedef sequence<FormalParameterDeclaration> FormalParameterDeclarationSeq
+  attribute FormalParameterDeclarationSeq formalParameters;
+  attribute FunctionMemberAttributes functionMemberAttributes;
+#ifdef __SOMIDL__
+  implementation {
+  };
+#endif /* __SOMIDL__ */
+};
+
+#endif  /* gfdecl_idl */
diff -urN somfree\gastm\gfdef.idl newsomfree3\gastm\gfdef.idl
--- somfree\gastm\gfdef.idl	Thu Jan 01 07:00:00 1970
+++ newsomfree3\gastm\gfdef.idl	Sat Mar 16 14:09:23 2024
@@ -0,0 +1,23 @@
+#ifndef gfdef_idl
+#define gfdef_idl
+
+#include <gdef.idl>
+#include <gfpdef.idl>
+#include <gfscope.idl>
+
+interface FunctionDefinition: Definition
+{
+  typedef sequence<FormalParameterDefinition> FormalParameterDefinitionSeq;
+  typedef sequence<Statement> StatementSeq;
+  attribute FormalParameterDefinition formalParameters;
+  attribute TypeReference returnType;
+  attribute StatementSeq body;
+  attribute FunctionMemberAttributes functionMemberAttributes;
+  attribute FunctionScope opensScope;
+#ifdef __SOMIDL__
+  implementation {
+  };
+#endif /* __SOMIDL__ */
+};
+
+#endif  /* gfdef_idl */
diff -urN somfree\gastm\gfpdecl.idl newsomfree3\gastm\gfpdecl.idl
--- somfree\gastm\gfpdecl.idl	Thu Jan 01 07:00:00 1970
+++ newsomfree3\gastm\gfpdecl.idl	Sat Mar 16 14:09:23 2024
@@ -0,0 +1,14 @@
+#ifndef gfpdecl_idl
+#define gfpdecl_idl
+
+#include <gdecl.idl>
+
+interface FormalParameterDeclaration: Declaration
+{
+#ifdef __SOMIDL__
+  implementation {
+  };
+#endif /* __SOMIDL__ */
+};
+
+#endif  /* gfpdecl_idl */
diff -urN somfree\gastm\gfscope.idl newsomfree3\gastm\gfscope.idl
--- somfree\gastm\gfscope.idl	Thu Jan 01 07:00:00 1970
+++ newsomfree3\gastm\gfscope.idl	Sat Mar 16 14:09:23 2024
@@ -0,0 +1,9 @@
+#include <gscope.idl>
+
+interface FunctionScope: Scope
+{
+#ifdef __SOMIDL__
+  implementation {
+  };
+#endif /* __SOMIDL__ */
+};
diff -urN somfree\gastm\ggscope.idl newsomfree3\gastm\ggscope.idl
--- somfree\gastm\ggscope.idl	Thu Jan 01 07:00:00 1970
+++ newsomfree3\gastm\ggscope.idl	Sat Mar 16 14:09:23 2024
@@ -0,0 +1,9 @@
+#include <gscope.idl>
+
+interface GlobalScope: Scope
+{
+#ifdef __SOMIDL__
+  implementation {
+  };
+#endif /* __SOMIDL__ */
+};
diff -urN somfree\gastm\gntdef.idl newsomfree3\gastm\gntdef.idl
--- somfree\gastm\gntdef.idl	Thu Jan 01 07:00:00 1970
+++ newsomfree3\gastm\gntdef.idl	Sat Mar 16 14:09:23 2024
@@ -0,0 +1,15 @@
+#ifndef gntdef_idl
+#define gntdef_idl
+
+#include <gtdef.idl>
+
+interface NamedTypeDefinition: TypeDefinition
+{
+  attribute NamedType definitionType;
+#ifdef __SOMIDL__
+  implementation {
+  };
+#endif /* __SOMIDL__ */
+};
+
+#endif  /* gtdef_idl */
diff -urN somfree\gastm\gobject.idl newsomfree3\gastm\gobject.idl
--- somfree\gastm\gobject.idl	Thu Jan 01 07:00:00 1970
+++ newsomfree3\gastm\gobject.idl	Sat Mar 16 14:09:23 2024
@@ -0,0 +1,14 @@
+#ifndef gobject_idl
+#define gobject_idl
+
+#include <somobj.idl>
+
+interface GASTMObject: SOMObject
+{
+#ifdef __SOMIDL__
+  implementation {
+  };
+#endif /* __SOMIDL__ */
+};
+
+#endif  /* gobject_idl */
diff -urN somfree\gastm\gpp.idl newsomfree3\gastm\gpp.idl
--- somfree\gastm\gpp.idl	Thu Jan 01 07:00:00 1970
+++ newsomfree3\gastm\gpp.idl	Sat Mar 16 14:09:23 2024
@@ -0,0 +1,15 @@
+#ifndef gpp_idl
+#define gpp_idl
+
+#include <gsynobj.idl>
+
+
+interface PreprocessorElement: GASTMSyntaxObject
+{
+#ifdef __SOMIDL__
+  implementation {
+  };
+#endif /* __SOMIDL__ */
+};
+
+#endif  /* gpp_idl */
diff -urN somfree\gastm\gppcomm.idl newsomfree3\gastm\gppcomm.idl
--- somfree\gastm\gppcomm.idl	Thu Jan 01 07:00:00 1970
+++ newsomfree3\gastm\gppcomm.idl	Sat Mar 16 14:09:23 2024
@@ -0,0 +1,15 @@
+#ifndef gppcomm_idl
+#define gppcomm_idl
+
+#include <gpp.idl>
+
+interface Comment: PreprocessorElement
+{
+  attribute string body;
+#ifdef __SOMIDL__
+  implementation {
+  };
+#endif /* __SOMIDL__ */
+};
+
+#endif  /* gppcomm_idl */
diff -urN somfree\gastm\gppinc.idl newsomfree3\gastm\gppinc.idl
--- somfree\gastm\gppinc.idl	Thu Jan 01 07:00:00 1970
+++ newsomfree3\gastm\gppinc.idl	Sat Mar 16 14:09:24 2024
@@ -0,0 +1,16 @@
+#ifndef gppinc_idl
+#define gppinc_idl
+
+#include <gpp.idl>
+#include <gsrcfilr.idl>
+
+interface IncludeUnit: PreprocessorElement
+{
+  attribute SourceFileReference file;
+#ifdef __SOMIDL__
+  implementation {
+  };
+#endif /* __SOMIDL__ */
+};
+
+#endif  /* gppinc_idl */
diff -urN somfree\gastm\gppmaccl.idl newsomfree3\gastm\gppmaccl.idl
--- somfree\gastm\gppmaccl.idl	Thu Jan 01 07:00:00 1970
+++ newsomfree3\gastm\gppmaccl.idl	Sat Mar 16 14:09:24 2024
@@ -0,0 +1,16 @@
+#ifndef gppmaccl_idl
+#define gppmaccl_idl
+
+#include <gpp.idl>
+#include <gppmacdf.idl>
+
+interface MacroCall: PreprocessorElement
+{
+  attribute MacroDefinition refersTo;
+#ifdef __SOMIDL__
+  implementation {
+  };
+#endif /* __SOMIDL__ */
+};
+
+#endif  /* gppmaccl_idl */
diff -urN somfree\gastm\gppmacdf.idl newsomfree3\gastm\gppmacdf.idl
--- somfree\gastm\gppmacdf.idl	Thu Jan 01 07:00:00 1970
+++ newsomfree3\gastm\gppmacdf.idl	Sat Mar 16 14:09:24 2024
@@ -0,0 +1,16 @@
+#ifndef gppmacdf_idl
+#define gppmacdf_idl
+
+#include <gpp.idl>
+
+interface MacroDefinition: PreprocessorElement
+{
+  attribute string macroName;
+  attribute string body;
+#ifdef __SOMIDL__
+  implementation {
+  };
+#endif /* __SOMIDL__ */
+};
+
+#endif  /* gppmacdf_idl */
diff -urN somfree\gastm\gproject.idl newsomfree3\gastm\gproject.idl
--- somfree\gastm\gproject.idl	Thu Jan 01 07:00:00 1970
+++ newsomfree3\gastm\gproject.idl	Sat Mar 16 14:09:24 2024
@@ -0,0 +1,14 @@
+#include <gsemobj.idl>
+#include <gcompunt.idl>
+#include <ggscope.idl>
+
+interface Project: GASTMSemanticObject
+{
+  typedef sequence<CompilationUnit> CompilationUnitSeq;
+  attribute CompilationUnitSeq files;
+  attribute GlobalScope outerScope;
+#ifdef __SOMIDL__
+  implementation {
+  };
+#endif /* __SOMIDL__ */
+};
diff -urN somfree\gastm\gpscope.idl newsomfree3\gastm\gpscope.idl
--- somfree\gastm\gpscope.idl	Thu Jan 01 07:00:00 1970
+++ newsomfree3\gastm\gpscope.idl	Sat Mar 16 14:09:24 2024
@@ -0,0 +1,9 @@
+#include <gscope.idl>
+
+interface ProgramScope: Scope
+{
+#ifdef __SOMIDL__
+  implementation {
+  };
+#endif /* __SOMIDL__ */
+};
diff -urN somfree\gastm\gscope.idl newsomfree3\gastm\gscope.idl
--- somfree\gastm\gscope.idl	Thu Jan 01 07:00:00 1970
+++ newsomfree3\gastm\gscope.idl	Sat Mar 16 14:09:24 2024
@@ -0,0 +1,19 @@
+#ifndef gscope_idl
+#define gscope_idl
+
+#include <gsemobj.idl>
+#include <gdefobj.idl>
+
+interface Scope: GASTMSemanticObject
+{
+  typedef sequence<Scope> ScopeSeq;
+  typedef sequence<DefinitionObject> DefinitionObjectSeq;
+  attribute ScopeSeq childScope;
+  attribute DefinitionObjectSeq definitionObject;
+#ifdef __SOMIDL__
+  implementation {
+  };
+#endif /* __SOMIDL__ */
+};
+
+#endif  /* gscope_idl */
diff -urN somfree\gastm\gsemobj.idl newsomfree3\gastm\gsemobj.idl
--- somfree\gastm\gsemobj.idl	Thu Jan 01 07:00:00 1970
+++ newsomfree3\gastm\gsemobj.idl	Sat Mar 16 14:09:24 2024
@@ -0,0 +1,14 @@
+#ifndef gsemobj_idl
+#define gsemobj_idl
+
+#include <gobject.idl>
+
+interface GASTMSemanticObject: GASTMObject
+{
+#ifdef __SOMIDL__
+  implementation {
+  };
+#endif /* __SOMIDL__ */
+};
+
+#endif  /* gsemobj_idl */
diff -urN somfree\gastm\gsrcfile.idl newsomfree3\gastm\gsrcfile.idl
--- somfree\gastm\gsrcfile.idl	Thu Jan 01 07:00:00 1970
+++ newsomfree3\gastm\gsrcfile.idl	Sat Mar 16 14:09:24 2024
@@ -0,0 +1,15 @@
+#ifndef gsrcfile_idl
+#define gsrcfile_idl
+
+#include <gsrcobj.idl>
+
+interface SourceFile: GASTMSourceObject
+{
+  attribute string path;
+#ifdef __SOMIDL__
+  implementation {
+  };
+#endif /* __SOMIDL__ */
+};
+
+#endif  /* gsrcfile_idl */
diff -urN somfree\gastm\gsrcfilr.idl newsomfree3\gastm\gsrcfilr.idl
--- somfree\gastm\gsrcfilr.idl	Thu Jan 01 07:00:00 1970
+++ newsomfree3\gastm\gsrcfilr.idl	Sat Mar 16 14:09:24 2024
@@ -0,0 +1,17 @@
+#ifndef gsrcfilr_idl
+#define gsrcfilr_idl
+
+#include <gsrcfile.idl>
+#include <gsrcloc.idl>
+
+interface SourceFileReference: SourceFile
+{
+  attribute SourceLocation locationInfo;
+  attribute SourceFile ofSourceFile;
+#ifdef __SOMIDL__
+  implementation {
+  };
+#endif /* __SOMIDL__ */
+};
+
+#endif  /* gsrcfilr_idl */
diff -urN somfree\gastm\gsrcloc.idl newsomfree3\gastm\gsrcloc.idl
--- somfree\gastm\gsrcloc.idl	Thu Jan 01 07:00:00 1970
+++ newsomfree3\gastm\gsrcloc.idl	Sat Mar 16 14:09:24 2024
@@ -0,0 +1,19 @@
+#ifndef gsrcloc_idl
+#define gsrcloc_idl
+
+#include <gsrcfile.idl>
+
+interface SourceLocation: GASTMSourceObject
+{
+  attribute int startLine;
+  attribute int startColumn;
+  attribute int endLine;
+  attribute int endColumn;
+  attribute SourceFile inSourceFile;
+#ifdef __SOMIDL__
+  implementation {
+  };
+#endif /* __SOMIDL__ */
+};
+
+#endif  /* gsrcloc_idl */
diff -urN somfree\gastm\gsrcobj.idl newsomfree3\gastm\gsrcobj.idl
--- somfree\gastm\gsrcobj.idl	Thu Jan 01 07:00:00 1970
+++ newsomfree3\gastm\gsrcobj.idl	Sat Mar 16 14:09:24 2024
@@ -0,0 +1,14 @@
+#ifndef gsrcobj_idl
+#define gsrcobj_idl
+
+#include <gobject.idl>
+
+interface GASTMSourceObject: GASTMObject
+{
+#ifdef __SOMIDL__
+  implementation {
+  };
+#endif /* __SOMIDL__ */
+};
+
+#endif  /* gsrcobj_idl */
diff -urN somfree\gastm\gsynobj.idl newsomfree3\gastm\gsynobj.idl
--- somfree\gastm\gsynobj.idl	Thu Jan 01 07:00:00 1970
+++ newsomfree3\gastm\gsynobj.idl	Sat Mar 16 14:09:24 2024
@@ -0,0 +1,22 @@
+#ifndef gsynobj_idl
+#define gsynobj_idl
+
+#include <gobject.idl>
+#include <gsrcloc.idl>
+
+interface PreprocessorElement;
+
+interface GASTMSyntaxObject: GASTMObject
+{
+  typedef sequence<PreprocessorElement> PreprocessorElementSeq;
+  typedef sequence<int> AnnotationExpressionSeq; // AnnotationExpression
+  attribute SourceLocation locationInfo;
+  attribute PreprocessorElementSeq preProcessorElement;
+  attribute AnnotationExpressionSeq annotations;
+#ifdef __SOMIDL__
+  implementation {
+  };
+#endif /* __SOMIDL__ */
+};
+
+#endif  /* gsynobj_idl */
diff -urN somfree\gastm\gtdef.idl newsomfree3\gastm\gtdef.idl
--- somfree\gastm\gtdef.idl	Thu Jan 01 07:00:00 1970
+++ newsomfree3\gastm\gtdef.idl	Sat Mar 16 14:09:24 2024
@@ -0,0 +1,15 @@
+#ifndef gtdef_idl
+#define gtdef_idl
+
+#include <gdefobj.idl>
+
+interface TypeDefinition: DefinitionObject
+{
+  attribute Name typeName;
+#ifdef __SOMIDL__
+  implementation {
+  };
+#endif /* __SOMIDL__ */
+};
+
+#endif  /* gtdef_idl */
diff -urN somfree\gastm\gtype.idl newsomfree3\gastm\gtype.idl
--- somfree\gastm\gtype.idl	Thu Jan 01 07:00:00 1970
+++ newsomfree3\gastm\gtype.idl	Sat Mar 16 14:09:24 2024
@@ -0,0 +1,15 @@
+#ifndef gtype_idl
+#define gtype_idl
+
+#include <gsynobj.idl>
+
+interface Type: GASTMSyntaxObject
+{
+  attribute boolean isConst;
+#ifdef __SOMIDL__
+  implementation {
+  };
+#endif /* __SOMIDL__ */
+};
+
+#endif  /* gtype_idl */
diff -urN somfree\gastm\gvdecl.idl newsomfree3\gastm\gvdecl.idl
--- somfree\gastm\gvdecl.idl	Thu Jan 01 07:00:00 1970
+++ newsomfree3\gastm\gvdecl.idl	Sat Mar 16 14:09:24 2024
@@ -0,0 +1,15 @@
+#ifndef gvdecl_idl
+#define gvdecl_idl
+
+#include <gdecl.idl>
+
+interface VariableDeclaration: Declaration
+{
+  attribute boolean isMutable;
+#ifdef __SOMIDL__
+  implementation {
+  };
+#endif /* __SOMIDL__ */
+};
+
+#endif  /* gvdecl_idl */
diff -urN somfree\gastm\gvdef.idl newsomfree3\gastm\gvdef.idl
--- somfree\gastm\gvdef.idl	Thu Jan 01 07:00:00 1970
+++ newsomfree3\gastm\gvdef.idl	Sat Mar 16 14:09:24 2024
@@ -0,0 +1,14 @@
+#ifndef gvdef_idl
+#define gvdef_idl
+
+#include <gddef.idl>
+
+interface VariableDefinition: DataDefinition
+{
+#ifdef __SOMIDL__
+  implementation {
+  };
+#endif /* __SOMIDL__ */
+};
+
+#endif  /* gvdef_idl */
diff -urN somfree\gastm\makedefs.cf newsomfree3\gastm\makedefs.cf
--- somfree\gastm\makedefs.cf	Thu Jan 01 07:00:00 1970
+++ newsomfree3\gastm\makedefs.cf	Sat Mar 16 14:09:24 2024
@@ -0,0 +1,3 @@
+NAME gastm
+DEPENDS irdump
+PROVIDES gastm
diff -urN somfree\gastm\note.txt newsomfree3\gastm\note.txt
--- somfree\gastm\note.txt	Thu Jan 01 07:00:00 1970
+++ newsomfree3\gastm\note.txt	Sat Mar 16 14:09:24 2024
@@ -0,0 +1 @@
+https://download.eclipse.org/modeling/mdt/modisco/nightly/doc/org.eclipse.modisco.doc/javadoc/org/eclipse/modisco/omg/gastm/package-summary.html
\ No newline at end of file
diff -urN somfree\gastm\src\gascope.cpp newsomfree3\gastm\src\gascope.cpp
--- somfree\gastm\src\gascope.cpp	Thu Jan 01 07:00:00 1970
+++ newsomfree3\gastm\src\gascope.cpp	Sat Mar 16 14:09:24 2024
@@ -0,0 +1,7 @@
+#ifndef SOM_Module_gascope_Source
+#define SOM_Module_gascope_Source
+#endif
+#define AggregateScope_Class_Source
+
+#include "gascope.xih"
+
diff -urN somfree\gastm\src\gbscope.cpp newsomfree3\gastm\src\gbscope.cpp
--- somfree\gastm\src\gbscope.cpp	Thu Jan 01 07:00:00 1970
+++ newsomfree3\gastm\src\gbscope.cpp	Sat Mar 16 14:09:24 2024
@@ -0,0 +1,7 @@
+#ifndef SOM_Module_gbscope_Source
+#define SOM_Module_gbscope_Source
+#endif
+#define BlockScope_Class_Source
+
+#include "gbscope.xih"
+
diff -urN somfree\gastm\src\gcompunt.cpp newsomfree3\gastm\src\gcompunt.cpp
--- somfree\gastm\src\gcompunt.cpp	Thu Jan 01 07:00:00 1970
+++ newsomfree3\gastm\src\gcompunt.cpp	Sat Mar 16 14:09:24 2024
@@ -0,0 +1,7 @@
+#ifndef SOM_Module_gcompunt_Source
+#define SOM_Module_gcompunt_Source
+#endif
+#define CompilationUnit_Class_Source
+
+#include "gcompunt.xih"
+
diff -urN somfree\gastm\src\gdefobj.cpp newsomfree3\gastm\src\gdefobj.cpp
--- somfree\gastm\src\gdefobj.cpp	Thu Jan 01 07:00:00 1970
+++ newsomfree3\gastm\src\gdefobj.cpp	Sat Mar 16 14:09:24 2024
@@ -0,0 +1,7 @@
+#ifndef SOM_Module_gdefobj_Source
+#define SOM_Module_gdefobj_Source
+#endif
+#define DefinitionObject_Class_Source
+
+#include "gdefobj.xih"
+
diff -urN somfree\gastm\src\gfscope.cpp newsomfree3\gastm\src\gfscope.cpp
--- somfree\gastm\src\gfscope.cpp	Thu Jan 01 07:00:00 1970
+++ newsomfree3\gastm\src\gfscope.cpp	Sat Mar 16 14:09:24 2024
@@ -0,0 +1,7 @@
+#ifndef SOM_Module_gfscope_Source
+#define SOM_Module_gfscope_Source
+#endif
+#define FunctionScope_Class_Source
+
+#include "gfscope.xih"
+
diff -urN somfree\gastm\src\ggscope.cpp newsomfree3\gastm\src\ggscope.cpp
--- somfree\gastm\src\ggscope.cpp	Thu Jan 01 07:00:00 1970
+++ newsomfree3\gastm\src\ggscope.cpp	Sat Mar 16 14:09:24 2024
@@ -0,0 +1,7 @@
+#ifndef SOM_Module_ggscope_Source
+#define SOM_Module_ggscope_Source
+#endif
+#define GlobalScope_Class_Source
+
+#include "ggscope.xih"
+
diff -urN somfree\gastm\src\gobject.cpp newsomfree3\gastm\src\gobject.cpp
--- somfree\gastm\src\gobject.cpp	Thu Jan 01 07:00:00 1970
+++ newsomfree3\gastm\src\gobject.cpp	Sat Mar 16 14:09:24 2024
@@ -0,0 +1,7 @@
+#ifndef SOM_Module_gobject_Source
+#define SOM_Module_gobject_Source
+#endif
+#define GASTMObject_Class_Source
+
+#include "gobject.xih"
+
diff -urN somfree\gastm\src\gpp.cpp newsomfree3\gastm\src\gpp.cpp
--- somfree\gastm\src\gpp.cpp	Thu Jan 01 07:00:00 1970
+++ newsomfree3\gastm\src\gpp.cpp	Sat Mar 16 14:09:24 2024
@@ -0,0 +1,7 @@
+#ifndef SOM_Module_gpp_Source
+#define SOM_Module_gpp_Source
+#endif
+#define PreprocessorElement_Class_Source
+
+#include "gpp.xih"
+
diff -urN somfree\gastm\src\gppcomm.cpp newsomfree3\gastm\src\gppcomm.cpp
--- somfree\gastm\src\gppcomm.cpp	Thu Jan 01 07:00:00 1970
+++ newsomfree3\gastm\src\gppcomm.cpp	Sat Mar 16 14:09:24 2024
@@ -0,0 +1,7 @@
+#ifndef SOM_Module_gppcomm_Source
+#define SOM_Module_gppcomm_Source
+#endif
+#define Comment_Class_Source
+
+#include "gppcomm.xih"
+
diff -urN somfree\gastm\src\gppinc.cpp newsomfree3\gastm\src\gppinc.cpp
--- somfree\gastm\src\gppinc.cpp	Thu Jan 01 07:00:00 1970
+++ newsomfree3\gastm\src\gppinc.cpp	Sat Mar 16 14:09:24 2024
@@ -0,0 +1,7 @@
+#ifndef SOM_Module_gppinc_Source
+#define SOM_Module_gppinc_Source
+#endif
+#define IncludeUnit_Class_Source
+
+#include "gppinc.xih"
+
diff -urN somfree\gastm\src\gppmaccl.cpp newsomfree3\gastm\src\gppmaccl.cpp
--- somfree\gastm\src\gppmaccl.cpp	Thu Jan 01 07:00:00 1970
+++ newsomfree3\gastm\src\gppmaccl.cpp	Sat Mar 16 14:09:24 2024
@@ -0,0 +1,7 @@
+#ifndef SOM_Module_gppmaccl_Source
+#define SOM_Module_gppmaccl_Source
+#endif
+#define MacroCall_Class_Source
+
+#include "gppmaccl.xih"
+
diff -urN somfree\gastm\src\gppmacdf.cpp newsomfree3\gastm\src\gppmacdf.cpp
--- somfree\gastm\src\gppmacdf.cpp	Thu Jan 01 07:00:00 1970
+++ newsomfree3\gastm\src\gppmacdf.cpp	Sat Mar 16 14:09:24 2024
@@ -0,0 +1,7 @@
+#ifndef SOM_Module_gppmacdf_Source
+#define SOM_Module_gppmacdf_Source
+#endif
+#define MacroDefinition_Class_Source
+
+#include "gppmacdf.xih"
+
diff -urN somfree\gastm\src\gproject.cpp newsomfree3\gastm\src\gproject.cpp
--- somfree\gastm\src\gproject.cpp	Thu Jan 01 07:00:00 1970
+++ newsomfree3\gastm\src\gproject.cpp	Sat Mar 16 14:09:24 2024
@@ -0,0 +1,7 @@
+#ifndef SOM_Module_gproject_Source
+#define SOM_Module_gproject_Source
+#endif
+#define Project_Class_Source
+
+#include "gproject.xih"
+
diff -urN somfree\gastm\src\gpscope.cpp newsomfree3\gastm\src\gpscope.cpp
--- somfree\gastm\src\gpscope.cpp	Thu Jan 01 07:00:00 1970
+++ newsomfree3\gastm\src\gpscope.cpp	Sat Mar 16 14:09:24 2024
@@ -0,0 +1,7 @@
+#ifndef SOM_Module_gpscope_Source
+#define SOM_Module_gpscope_Source
+#endif
+#define ProgramScope_Class_Source
+
+#include "gpscope.xih"
+
diff -urN somfree\gastm\src\gscope.cpp newsomfree3\gastm\src\gscope.cpp
--- somfree\gastm\src\gscope.cpp	Thu Jan 01 07:00:00 1970
+++ newsomfree3\gastm\src\gscope.cpp	Sat Mar 16 14:09:24 2024
@@ -0,0 +1,7 @@
+#ifndef SOM_Module_gscope_Source
+#define SOM_Module_gscope_Source
+#endif
+#define Scope_Class_Source
+
+#include "gscope.xih"
+
diff -urN somfree\gastm\src\gsemobj.cpp newsomfree3\gastm\src\gsemobj.cpp
--- somfree\gastm\src\gsemobj.cpp	Thu Jan 01 07:00:00 1970
+++ newsomfree3\gastm\src\gsemobj.cpp	Sat Mar 16 14:09:24 2024
@@ -0,0 +1,7 @@
+#ifndef SOM_Module_gsemobj_Source
+#define SOM_Module_gsemobj_Source
+#endif
+#define GASTMSemanticObject_Class_Source
+
+#include "gsemobj.xih"
+
diff -urN somfree\gastm\src\gsrcfile.cpp newsomfree3\gastm\src\gsrcfile.cpp
--- somfree\gastm\src\gsrcfile.cpp	Thu Jan 01 07:00:00 1970
+++ newsomfree3\gastm\src\gsrcfile.cpp	Sat Mar 16 14:09:24 2024
@@ -0,0 +1,7 @@
+#ifndef SOM_Module_gsrcfile_Source
+#define SOM_Module_gsrcfile_Source
+#endif
+#define SourceFile_Class_Source
+
+#include "gsrcfile.xih"
+
diff -urN somfree\gastm\src\gsrcfilr.cpp newsomfree3\gastm\src\gsrcfilr.cpp
--- somfree\gastm\src\gsrcfilr.cpp	Thu Jan 01 07:00:00 1970
+++ newsomfree3\gastm\src\gsrcfilr.cpp	Sat Mar 16 14:09:24 2024
@@ -0,0 +1,7 @@
+#ifndef SOM_Module_gsrcfilr_Source
+#define SOM_Module_gsrcfilr_Source
+#endif
+#define SourceFileReference_Class_Source
+
+#include "gsrcfilr.xih"
+
diff -urN somfree\gastm\src\gsrcloc.cpp newsomfree3\gastm\src\gsrcloc.cpp
--- somfree\gastm\src\gsrcloc.cpp	Thu Jan 01 07:00:00 1970
+++ newsomfree3\gastm\src\gsrcloc.cpp	Sat Mar 16 14:09:24 2024
@@ -0,0 +1,7 @@
+#ifndef SOM_Module_gsrcloc_Source
+#define SOM_Module_gsrcloc_Source
+#endif
+#define SourceLocation_Class_Source
+
+#include "gsrcloc.xih"
+
diff -urN somfree\gastm\src\gsrcobj.cpp newsomfree3\gastm\src\gsrcobj.cpp
--- somfree\gastm\src\gsrcobj.cpp	Thu Jan 01 07:00:00 1970
+++ newsomfree3\gastm\src\gsrcobj.cpp	Sat Mar 16 14:09:24 2024
@@ -0,0 +1,7 @@
+#ifndef SOM_Module_gsrcobj_Source
+#define SOM_Module_gsrcobj_Source
+#endif
+#define GASTMSourceObject_Class_Source
+
+#include "gsrcobj.xih"
+
diff -urN somfree\gastm\src\gsynobj.cpp newsomfree3\gastm\src\gsynobj.cpp
--- somfree\gastm\src\gsynobj.cpp	Thu Jan 01 07:00:00 1970
+++ newsomfree3\gastm\src\gsynobj.cpp	Sat Mar 16 14:09:24 2024
@@ -0,0 +1,7 @@
+#ifndef SOM_Module_gsynobj_Source
+#define SOM_Module_gsynobj_Source
+#endif
+#define GASTMSyntaxObject_Class_Source
+
+#include "gsynobj.xih"
+
diff -urN somfree\gastm\win32\gastm.def newsomfree3\gastm\win32\gastm.def
--- somfree\gastm\win32\gastm.def	Thu Jan 01 07:00:00 1970
+++ newsomfree3\gastm\win32\gastm.def	Sat Mar 16 14:09:24 2024
@@ -0,0 +1,7 @@
+LIBRARY gastm
+VERSION		1.0
+EXPORTS
+  GASTMObjectCClassData       @1 DATA
+  GASTMObjectClassData        @2 DATA
+  GASTMObjectNewClass         @3
+   
\ No newline at end of file
diff -urN somfree\gastm\win32\gastm.mak newsomfree3\gastm\win32\gastm.mak
--- somfree\gastm\win32\gastm.mak	Thu Jan 01 07:00:00 1970
+++ newsomfree3\gastm\win32\gastm.mak	Sat Mar 16 14:09:24 2024
@@ -0,0 +1,357 @@
+#
+#  Copyright 2023, Yuri Prokushev
+#
+#  This file is part of osFree project
+#
+#  This program is free software: you can redistribute it and/or modify it
+#  under the terms of the GNU Lesser General Public License as published by the
+#  Free Software Foundation, either version 3 of the License, or (at your
+#  option) any later version.
+# 
+#  This program is distributed in the hope that it will be useful, but WITHOUT
+#  ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+#  FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for
+#  more details.
+#
+#  You should have received a copy of the GNU Lesser General Public License
+#  along with this program.  If not, see <http://www.gnu.org/licenses/>
+#
+
+!include $(MAKEDEFS)
+
+IDLTOOL=$(RHBTOOLS_BIN)\idltool.exe
+SC=$(SOMTOOLS_BIN)\sc.exe
+PDL=$(SOMTOOLS_BIN)\pdl.exe
+SOMIDL_IDL=..\..\somidl
+SOMIDL_HEADERS=$(SOMIDL_IDL)\$(PLATFORM)
+
+GASTM_DIR=..\..\gastm
+SOMC_DIR=..\..\somc
+
+GASTM_INTDIR=$(GASTM_DIR)\$(PLATFORM)\$(BUILDTYPE)
+
+GASTMINCL=-I$(GASTM_DIR) -I$(SOMIDL_IDL)
+
+PUBLIC_IDLS=$(SOMIDL_IDL)\gobject.idl	\
+			$(SOMIDL_IDL)\gsemobj.idl	\
+			$(SOMIDL_IDL)\gsrcfile.idl	\
+			$(SOMIDL_IDL)\gsrcfilr.idl	\
+			$(SOMIDL_IDL)\gcompunt.idl	\
+			$(SOMIDL_IDL)\gsrcloc.idl	\
+			$(SOMIDL_IDL)\gsrcobj.idl	\
+			$(SOMIDL_IDL)\gsynobj.idl	\
+			$(SOMIDL_IDL)\gproject.idl	\
+			$(SOMIDL_IDL)\gscope.idl	\
+			$(SOMIDL_IDL)\gfscope.idl	\
+			$(SOMIDL_IDL)\gascope.idl	\
+			$(SOMIDL_IDL)\gbscope.idl	\
+			$(SOMIDL_IDL)\gpscope.idl	\
+			$(SOMIDL_IDL)\ggscope.idl	\
+			$(SOMIDL_IDL)\gpp.idl	        \
+			$(SOMIDL_IDL)\gppinc.idl        \
+			$(SOMIDL_IDL)\gppmaccl.idl	\
+			$(SOMIDL_IDL)\gppmacdf.idl	\
+			$(SOMIDL_IDL)\gppcomm.idl	\
+			$(SOMIDL_IDL)\gdefobj.idl	
+
+GASTM_IH=	$(GASTM_INTDIR)\gobject.h	\
+			$(GASTM_INTDIR)\gsemobj.h	\
+			$(GASTM_INTDIR)\gsrcfile.h	\
+			$(GASTM_INTDIR)\gsrcfilr.h	\
+			$(GASTM_INTDIR)\gcompunt.h	\
+			$(GASTM_INTDIR)\gsrcloc.h	\
+			$(GASTM_INTDIR)\gsrcobj.h	\
+			$(GASTM_INTDIR)\gsynobj.h	\
+			$(GASTM_INTDIR)\gproject.h	\
+			$(GASTM_INTDIR)\gscope.h	\
+			$(GASTM_INTDIR)\gfscope.h	\
+			$(GASTM_INTDIR)\gascope.h	\
+			$(GASTM_INTDIR)\gbscope.h	\
+			$(GASTM_INTDIR)\gpscope.h	\
+			$(GASTM_INTDIR)\ggscope.h	\
+			$(GASTM_INTDIR)\gpp.h		\
+			$(GASTM_INTDIR)\gppinc.h	\
+			$(GASTM_INTDIR)\gppmaccl.h	\
+			$(GASTM_INTDIR)\gppmacdf.h	\
+			$(GASTM_INTDIR)\gppcomm.h	\
+			$(GASTM_INTDIR)\gdefobj.h	\
+			$(GASTM_INTDIR)\gobject.ih	\
+			$(GASTM_INTDIR)\gsemobj.ih	\
+			$(GASTM_INTDIR)\gsrcfile.ih	\
+			$(GASTM_INTDIR)\gsrcfilr.ih	\
+			$(GASTM_INTDIR)\gcompunt.ih	\
+			$(GASTM_INTDIR)\gsrcloc.ih	\
+			$(GASTM_INTDIR)\gsrcobj.ih	\
+			$(GASTM_INTDIR)\gsynobj.ih	\
+			$(GASTM_INTDIR)\gproject.ih	\
+			$(GASTM_INTDIR)\gscope.ih	\
+			$(GASTM_INTDIR)\gfscope.ih	\
+			$(GASTM_INTDIR)\gascope.ih	\
+			$(GASTM_INTDIR)\gbscope.ih	\
+			$(GASTM_INTDIR)\gpscope.ih	\
+			$(GASTM_INTDIR)\ggscope.ih	\
+			$(GASTM_INTDIR)\gpp.ih		\
+			$(GASTM_INTDIR)\gppinc.ih	\
+			$(GASTM_INTDIR)\gppmaccl.ih	\
+			$(GASTM_INTDIR)\gppmacdf.ih	\
+			$(GASTM_INTDIR)\gppcomm.ih	\
+			$(GASTM_INTDIR)\gdefobj.ih	\
+			$(GASTM_INTDIR)\gobject.xh	\
+			$(GASTM_INTDIR)\gsemobj.xh	\
+			$(GASTM_INTDIR)\gsrcfile.xh	\
+			$(GASTM_INTDIR)\gsrcfilr.xh	\
+			$(GASTM_INTDIR)\gcompunt.xh	\
+			$(GASTM_INTDIR)\gsrcloc.xh	\
+			$(GASTM_INTDIR)\gsrcobj.xh	\
+			$(GASTM_INTDIR)\gsynobj.xh	\
+			$(GASTM_INTDIR)\gproject.xh	\
+			$(GASTM_INTDIR)\gscope.xh	\
+			$(GASTM_INTDIR)\gfscope.xh	\
+			$(GASTM_INTDIR)\gascope.xh	\
+			$(GASTM_INTDIR)\gbscope.xh	\
+			$(GASTM_INTDIR)\gpscope.xh	\
+			$(GASTM_INTDIR)\ggscope.xh	\
+			$(GASTM_INTDIR)\gpp.xh		\
+			$(GASTM_INTDIR)\gppinc.xh	\
+			$(GASTM_INTDIR)\gppmaccl.xh	\
+			$(GASTM_INTDIR)\gppmacdf.xh	\
+			$(GASTM_INTDIR)\gppcomm.xh	\
+			$(GASTM_INTDIR)\gdefobj.xh	\
+			$(GASTM_INTDIR)\gobject.xih	\
+			$(GASTM_INTDIR)\gsemobj.xih	\
+			$(GASTM_INTDIR)\gsrcfile.xih	\
+			$(GASTM_INTDIR)\gsrcfilr.xih	\
+			$(GASTM_INTDIR)\gcompunt.xih	\
+			$(GASTM_INTDIR)\gsrcloc.xih	\
+			$(GASTM_INTDIR)\gsrcobj.xih	\
+			$(GASTM_INTDIR)\gsynobj.xih	\
+			$(GASTM_INTDIR)\gproject.xih	\
+			$(GASTM_INTDIR)\gscope.xih	\
+			$(GASTM_INTDIR)\gfscope.xih	\
+			$(GASTM_INTDIR)\gascope.xih	\
+			$(GASTM_INTDIR)\gbscope.xih	\
+			$(GASTM_INTDIR)\gpscope.xih	\
+			$(GASTM_INTDIR)\ggscope.xih	\
+			$(GASTM_INTDIR)\gpp.xih		\
+			$(GASTM_INTDIR)\gppinc.xih	\
+			$(GASTM_INTDIR)\gppmaccl.xih	\
+			$(GASTM_INTDIR)\gppmacdf.xih	\
+			$(GASTM_INTDIR)\gppcomm.xih	\
+			$(GASTM_INTDIR)\gdefobj.xih	
+
+GASTM_H=	$(SOMIDL_HEADERS)\gobject.h	\
+			$(SOMIDL_HEADERS)\gsemobj.h	\
+			$(SOMIDL_HEADERS)\gsrcfile.h	\
+			$(SOMIDL_HEADERS)\gsrcfilr.h	\
+			$(SOMIDL_HEADERS)\gcompunt.h	\
+			$(SOMIDL_HEADERS)\gsrcloc.h	\
+			$(SOMIDL_HEADERS)\gsrcobj.h	\
+			$(SOMIDL_HEADERS)\gsynobj.h	\
+			$(SOMIDL_HEADERS)\gproject.h	\
+			$(SOMIDL_HEADERS)\gscope.h	\
+			$(SOMIDL_HEADERS)\gfscope.h	\
+			$(SOMIDL_HEADERS)\gascope.h	\
+			$(SOMIDL_HEADERS)\gbscope.h	\
+			$(SOMIDL_HEADERS)\gpscope.h	\
+			$(SOMIDL_HEADERS)\ggscope.h	\
+			$(SOMIDL_HEADERS)\gpp.h		\
+			$(SOMIDL_HEADERS)\gppinc.h	\
+			$(SOMIDL_HEADERS)\gppmaccl.h	\
+			$(SOMIDL_HEADERS)\gppmacdf.h	\
+			$(SOMIDL_HEADERS)\gppcomm.h	\
+			$(SOMIDL_HEADERS)\gdefobj.h	\
+			$(SOMIDL_HEADERS)\gobject.xh	\
+			$(SOMIDL_HEADERS)\gsemobj.xh	\
+			$(SOMIDL_HEADERS)\gsrcfile.xh	\
+			$(SOMIDL_HEADERS)\gsrcfilr.xh	\
+			$(SOMIDL_HEADERS)\gcompunt.xh	\
+			$(SOMIDL_HEADERS)\gsrcloc.xh	\
+			$(SOMIDL_HEADERS)\gsrcobj.xh	\
+			$(SOMIDL_HEADERS)\gsynobj.xh	\
+			$(SOMIDL_HEADERS)\gproject.xh	\
+			$(SOMIDL_HEADERS)\gscope.xh	\
+			$(SOMIDL_HEADERS)\gfscope.xh	\
+			$(SOMIDL_HEADERS)\gascope.xh	\
+			$(SOMIDL_HEADERS)\gbscope.xh	\
+			$(SOMIDL_HEADERS)\gpscope.xh	\
+			$(SOMIDL_HEADERS)\ggscope.xh	\
+			$(SOMIDL_HEADERS)\gpp.xh	\
+			$(SOMIDL_HEADERS)\gppinc.xh	\
+			$(SOMIDL_HEADERS)\gppmaccl.xh	\
+			$(SOMIDL_HEADERS)\gppmacdf.xh	\
+			$(SOMIDL_HEADERS)\gppcomm.xh	\
+			$(SOMIDL_HEADERS)\gdefobj.xh	
+
+
+OUTDIR=$(OUTDIR_BIN)
+INTDIR=$(BUILDTYPE)
+
+DLLNAME=gastm
+
+TARGET_DLL=$(OUTDIR)\$(DLLNAME).dll
+TARGET_PDB=$(OUTDIR)\$(DLLNAME).pdb
+TARGET_MAP=$(INTDIR)\$(DLLNAME).map
+TARGET_DEF=..\$(PLATFORM_DEF)\$(DLLNAME).def
+
+PARTOPTS=	$(STDOPT)								\
+			/DWIN32_LEAN_AND_MEAN 					\
+			/DHAVE_CONFIG_HPP							\
+			/I$(INTDIR)								\
+			/I..\win32								\
+			/I..\include							\
+			/I..\src								\
+			/I..\..\include\$(PLATFORM)				\
+			/I..\..\include\$(PLATFORM_DEF)			\
+			/I..\..\include							\
+			/I..\..\somidl\$(PLATFORM)				\
+			/I..\..\somcdr\$(PLATFORM)\$(BUILDTYPE)	\
+			/I..\..\somcdr\include					\
+			/I..\..\somcdr\src						\
+			/I..\..\rhbmtut\include					\
+			/I..\..\somkpub\include					\
+			/I..\..\somtk\include					\
+			/I..\..\somc\include					\
+			/I..\..\somipc2\include					\
+			$(CC_OUT_PDB)$(TARGET_PDB)	
+
+OBJS=		$(INTDIR)\gobject.obj	\
+		$(INTDIR)\gsemobj.obj	\
+		$(INTDIR)\gsrcfile.obj	\
+		$(INTDIR)\gsrcfilr.obj	\
+		$(INTDIR)\gcompunt.obj	\
+		$(INTDIR)\gsrcloc.obj	\
+		$(INTDIR)\gsrcobj.obj	\
+		$(INTDIR)\gsynobj.obj	\
+		$(INTDIR)\gproject.obj	\
+		$(INTDIR)\gscope.obj	\
+		$(INTDIR)\gfscope.obj	\
+		$(INTDIR)\gascope.obj	\
+		$(INTDIR)\gbscope.obj	\
+		$(INTDIR)\gpscope.obj	\
+		$(INTDIR)\ggscope.obj	\
+		$(INTDIR)\gpp.obj	\
+		$(INTDIR)\gppinc.obj	\
+		$(INTDIR)\gppmaccl.obj	\
+		$(INTDIR)\gppmacdf.obj	\
+		$(INTDIR)\gppcomm.obj	\
+		$(INTDIR)\gdefobj.obj	\
+		$(INTDIR)\link386.obj
+
+DIRS=	$(GASTM_INTDIR)			
+
+all: 	$(DIRS)			\
+		$(PUBLIC_IDLS)	\
+		$(GASTM_H)	\
+		$(GASTM_IH)	\
+		$(TARGET_DLL)
+
+clean:
+	$(CLEAN) $(TARGET_DLL) $(TARGET_PDB) $(TARGET_MAP) $(OBJS) $(INTDIR)\$(DLLNAME).res $(OUTDIR)\$(DLLNAME).exp $(OUTDIR)\$(DLLNAME).lib $(GASTM_IH) $(GASTM_H) $(PUBLIC_IDLS)
+	
+$(TARGET_DLL): $(OBJS) $(OUTDIR) $(TARGET_DEF) $(INTDIR)\$(DLLNAME).res
+	$(CC) $(CC_OUT_DLL)$@ $(OBJS)		\
+			$(INTDIR)\$(DLLNAME).res	\
+			$(CC_OUT_PDB)$(TARGET_PDB)	\
+			$(CC_LINK)					\
+			$(LDFLAGS)					\
+			$(LD_DEF)$(TARGET_DEF)
+	$(POSTLINK_DLL) $@
+
+
+$(INTDIR)\gobject.obj: ..\src\gobject.cpp
+	$(CXX) /c $(PARTOPTS) $(CC_OUT_OBJ)$@ ..\src\gobject.cpp
+
+$(INTDIR)\gsemobj.obj: ..\src\gsemobj.cpp $(INTDIR)
+	$(CXX) /c /I$(INTDIR) $(PARTOPTS) $(CC_OUT_OBJ)$@ ..\src\gsemobj.cpp
+
+$(INTDIR)\gsrcfile.obj: ..\src\gsrcfile.cpp $(INTDIR)
+	$(CXX) /c /I$(INTDIR) $(PARTOPTS) $(CC_OUT_OBJ)$@ ..\src\gsrcfile.cpp
+
+$(INTDIR)\gsrcfilr.obj: ..\src\gsrcfilr.cpp $(INTDIR)
+	$(CXX) /c /I$(INTDIR) $(PARTOPTS) $(CC_OUT_OBJ)$@ ..\src\gsrcfilr.cpp
+
+$(INTDIR)\gcompunt.obj: ..\src\gcompunt.cpp $(INTDIR)
+	$(CXX) /c /I$(INTDIR) $(PARTOPTS) $(CC_OUT_OBJ)$@ ..\src\gcompunt.cpp
+
+$(INTDIR)\gsrcloc.obj: ..\src\gsrcloc.cpp $(INTDIR)
+	$(CXX) /c /I$(INTDIR) $(PARTOPTS) $(CC_OUT_OBJ)$@ ..\src\gsrcloc.cpp
+
+$(INTDIR)\gsrcobj.obj: ..\src\gsrcobj.cpp $(INTDIR)
+	$(CXX) /c /I$(INTDIR) $(PARTOPTS) $(CC_OUT_OBJ)$@ ..\src\gsrcobj.cpp
+
+$(INTDIR)\gsynobj.obj: ..\src\gsynobj.cpp $(INTDIR)
+	$(CXX) /c /I$(INTDIR) $(PARTOPTS) $(CC_OUT_OBJ)$@ ..\src\gsynobj.cpp
+
+$(INTDIR)\gproject.obj: ..\src\gproject.cpp $(INTDIR)
+	$(CXX) /c /I$(INTDIR) $(PARTOPTS) $(CC_OUT_OBJ)$@ ..\src\gproject.cpp
+
+$(INTDIR)\gscope.obj: ..\src\gscope.cpp $(INTDIR)
+	$(CXX) /c /I$(INTDIR) $(PARTOPTS) $(CC_OUT_OBJ)$@ ..\src\gscope.cpp
+
+$(INTDIR)\gfscope.obj: ..\src\gfscope.cpp $(INTDIR)
+	$(CXX) /c /I$(INTDIR) $(PARTOPTS) $(CC_OUT_OBJ)$@ ..\src\gfscope.cpp
+
+$(INTDIR)\gascope.obj: ..\src\gascope.cpp $(INTDIR)
+	$(CXX) /c /I$(INTDIR) $(PARTOPTS) $(CC_OUT_OBJ)$@ ..\src\gascope.cpp
+
+$(INTDIR)\gbscope.obj: ..\src\gbscope.cpp $(INTDIR)
+	$(CXX) /c /I$(INTDIR) $(PARTOPTS) $(CC_OUT_OBJ)$@ ..\src\gbscope.cpp
+
+$(INTDIR)\gpscope.obj: ..\src\gpscope.cpp $(INTDIR)
+	$(CXX) /c /I$(INTDIR) $(PARTOPTS) $(CC_OUT_OBJ)$@ ..\src\gpscope.cpp
+
+$(INTDIR)\ggscope.obj: ..\src\ggscope.cpp $(INTDIR)
+	$(CXX) /c /I$(INTDIR) $(PARTOPTS) $(CC_OUT_OBJ)$@ ..\src\ggscope.cpp
+
+$(INTDIR)\gpp.obj: ..\src\gpp.cpp $(INTDIR)
+	$(CXX) /c /I$(INTDIR) $(PARTOPTS) $(CC_OUT_OBJ)$@ ..\src\gpp.cpp
+
+$(INTDIR)\gppinc.obj: ..\src\gppinc.cpp $(INTDIR)
+	$(CXX) /c /I$(INTDIR) $(PARTOPTS) $(CC_OUT_OBJ)$@ ..\src\gppinc.cpp
+
+$(INTDIR)\gppmaccl.obj: ..\src\gppmaccl.cpp $(INTDIR)
+	$(CXX) /c /I$(INTDIR) $(PARTOPTS) $(CC_OUT_OBJ)$@ ..\src\gppmaccl.cpp
+
+$(INTDIR)\gppmacdf.obj: ..\src\gppmacdf.cpp $(INTDIR)
+	$(CXX) /c /I$(INTDIR) $(PARTOPTS) $(CC_OUT_OBJ)$@ ..\src\gppmacdf.cpp
+
+$(INTDIR)\gppcomm.obj: ..\src\gppcomm.cpp $(INTDIR)
+	$(CXX) /c /I$(INTDIR) $(PARTOPTS) $(CC_OUT_OBJ)$@ ..\src\gppcomm.cpp
+
+$(INTDIR)\gdefobj.obj: ..\src\gdefobj.cpp $(INTDIR)
+	$(CXX) /c /I$(INTDIR) $(PARTOPTS) $(CC_OUT_OBJ)$@ ..\src\gdefobj.cpp
+
+$(INTDIR)\link386.obj: ..\win32\link386.c $(INTDIR)
+	$(CC) /c $(PARTOPTS) $(CC_OUT_OBJ)$@ ..\win32\link386.c
+
+$(INTDIR):
+	mkdir $@
+
+$(INTDIR)\$(DLLNAME).res: ..\win32\$(DLLNAME).rc
+	rc /nologo /r /I.. /I..\..\include\$(PLATFORM) /fo$@ ..\win32\$(DLLNAME).rc
+
+
+$(DIRS):
+	mkdir $@
+
+$(PUBLIC_IDLS):
+	"$(IDLTOOL)" "$(PDL)"		\
+		$(GASTM_DIR)			\
+		-o $@
+
+$(GASTM_IH): 
+	"$(IDLTOOL)" "$(SC)" $(GASTM_DIR)	\
+					-o $@ -p -I$(GASTM_DIR) -I$(SOMIDL_IDL) -I$(SOMC_DIR)\include
+
+$(GASTM_H): 
+	"$(IDLTOOL)" "$(SC)" $(GASTM_DIR)	\
+					-o $@ -I$(GASTM_DIR) -I$(SOMIDL_IDL) -I$(SOMC_DIR)\include
+
+
+dist:
+
+
+
+
+test:
+
diff -urN somfree\gastm\win32\gastm.rc newsomfree3\gastm\win32\gastm.rc
--- somfree\gastm\win32\gastm.rc	Thu Jan 01 07:00:00 1970
+++ newsomfree3\gastm\win32\gastm.rc	Sat Mar 16 14:09:24 2024
@@ -0,0 +1,50 @@
+/**************************************************************************
+ *
+ *  Copyright 2022, Yuri Prokushev
+ *
+ *  This file is part of osFree project
+ *
+ *  This program is free software: you can redistribute it and/or modify it
+ *  under the terms of the GNU Lesser General Public License as published by the
+ *  Free Software Foundation, either version 3 of the License, or (at your
+ *  option) any later version.
+ * 
+ *  This program is distributed in the hope that it will be useful, but WITHOUT
+ *  ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ *  FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for
+ *  more details.
+ *
+ *  You should have received a copy of the GNU Lesser General Public License
+ *  along with this program.  If not, see <http://www.gnu.org/licenses/>
+ *
+ */
+
+#include <windows.h>
+#include <depvers.h>
+
+1 VERSIONINFO
+	PRODUCTVERSION DEPVERS_somtkpkg_INT4
+	FILEOS VOS__WINDOWS32
+	FILEVERSION DEPVERS_som_INT4
+	FILETYPE VFT_DLL
+BEGIN
+	BLOCK "StringFileInfo"
+	BEGIN
+		BLOCK "140904E4"
+		BEGIN
+			VALUE "CompanyName","Yuri Prokushev\000\000"
+			VALUE "LegalCopyright","Copyright й Yuri Prokushev 2023\000\000"
+			VALUE "ProductName",DEPVERS_somtkpkg_PRODUCTNAME
+			VALUE "ProductVersion",DEPVERS_somtkpkg_STR4
+			VALUE "Comments","Uncontrolled Release\000\000"
+			VALUE "FileDescription","SOM kernel\000\000"
+			VALUE "FileVersion",DEPVERS_som_STR4
+			VALUE "InternalName","gastm\000\000"
+			VALUE "OriginalFilename","GASTM.DLL\000\000"
+		END
+	END
+    BLOCK "VarFileInfo"
+    BEGIN
+        VALUE "Translation", 0x1409, 1252
+    END
+END
diff -urN somfree\gastm\win32\link386.c newsomfree3\gastm\win32\link386.c
--- somfree\gastm\win32\link386.c	Thu Jan 01 07:00:00 1970
+++ newsomfree3\gastm\win32\link386.c	Sat Mar 16 14:09:25 2024
@@ -0,0 +1,24 @@
+/**************************************************************************
+ *
+ *  Copyright 2008, Roger Brown
+ *
+ *  This file is part of Roger Brown's Toolkit.
+ *
+ *  This program is free software: you can redistribute it and/or modify it
+ *  under the terms of the GNU Lesser General Public License as published by the
+ *  Free Software Foundation, either version 3 of the License, or (at your
+ *  option) any later version.
+ * 
+ *  This program is distributed in the hope that it will be useful, but WITHOUT
+ *  ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ *  FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for
+ *  more details.
+ *
+ *  You should have received a copy of the GNU Lesser General Public License
+ *  along with this program.  If not, see <http://www.gnu.org/licenses/>
+ *
+ */
+
+#define LINK386_SOM
+
+#include <link386.h>
diff -urN somfree\include\win32\link386.h newsomfree3\include\win32\link386.h
--- somfree\include\win32\link386.h	Sun Mar 17 21:36:10 2024
+++ newsomfree3\include\win32\link386.h	Sat Mar 16 14:09:25 2024
@@ -59,6 +59,14 @@
 #	pragma comment(lib,"som.lib")
 #endif
 
+#ifdef LINK386_SOMC
+#	pragma comment(lib,"somc.lib")
+#endif
+
+#ifdef LINK386_SOME
+#	pragma comment(lib,"some.lib")
+#endif
+
 #ifdef LINK386_SOMREF
 #	pragma comment(lib,"somref.lib")
 #endif
diff -urN somfree\note.txt newsomfree3\note.txt
--- somfree\note.txt	Thu Jan 01 07:00:00 1970
+++ newsomfree3\note.txt	Sat Mar 16 14:09:25 2024
@@ -0,0 +1,12 @@
+SOMWM35I.DLL     IBM VAC 3.5 Dynamic Runtime Emulation
+                 Implemented all things required for IBM SOM 3.0 for NT Emitters execution.
+
+Found bugs:
+
+None yet...
+
+Fixed bugs:
+*MethodDebugs macros doesn't produce debug code controlled by SOM_TraceLevel variable
+SOM_Error macro doesn't exists
+SOM_Tracle macro doesn't produce debug code controlled by SOM_TraceLevel variable
+SOM_Test macro not defined
diff -urN somfree\sc\src\sc.c newsomfree3\sc\src\sc.c
--- somfree\sc\src\sc.c	Sun Mar 17 21:36:11 2024
+++ newsomfree3\sc\src\sc.c	Sat Mar 16 14:09:25 2024
@@ -1,8 +1,10 @@
 /**************************************************************************
  *
  *  Copyright 2008, Roger Brown
+ *  Copyright 2022, Yuri Prokushev
  *
  *  This file is part of Roger Brown's Toolkit.
+ *  This file is part of osFree project.
  *
  *  This program is free software: you can redistribute it and/or modify it
  *  under the terms of the GNU Lesser General Public License as published by the
@@ -29,18 +31,27 @@
  * SMINCLUDE include dirs for IDL files
  * SMKNOWNEXTS add headers to user written emitters
  * SOMIR for IR emitter
- * SMTMP for temporary variables
+ * SMTMP for temporary variables (@todo)
+ * SMADDSTAR (@todo)
  */
 
 #include <rhbopt.h>
 #include <stdio.h>
 #include <stdlib.h>
 #include <string.h>
+#include <sys/stat.h>
+#ifdef _WIN32
+#include <io.h>
+#else
+#include <unistd.h>
+#endif
 
 #ifdef _WIN32
 #include <windows.h>
 #endif
 
+//#define _USE_PIPES_
+
 typedef struct 
 {
 	size_t _length,_maximum;
@@ -122,7 +133,7 @@
 		while (p[len])
 		{
 			if (p[len]==
-#ifdef _WIN32
+#if defined(_WIN32) || defined(__OS2__) || defined(__DOS__)
 				';'
 #else
 				':'
@@ -156,6 +167,7 @@
 	}
 }
 
+#ifdef _USE_PIPES_
 static BOOL shareable(HANDLE *ph)
 {
 	return DuplicateHandle(
@@ -167,10 +179,12 @@
 		TRUE,
 		DUPLICATE_SAME_ACCESS|DUPLICATE_CLOSE_SOURCE);
 }
+#endif
 
 static int load_somir(const char *app,const char *f)
 {
 	int retVal=1;
+#ifdef _WIN32
 	HMODULE hMod=GetModuleHandle(NULL);
 	if (hMod)
 	{
@@ -215,10 +229,78 @@
 	{
 		fprintf(stderr,"%s: failed to create \"%s\"\n",app,f);
 	}
-
+#else
+#endif
 	return retVal;
 }
 
+/*
+
+Options found in SOM Compiler but not know how it works
+
+e not found info yet
+q not found info yet
+
+*/
+
+void usage(void)
+{
+  printf("usage: sc [-C:D:E:I:S:VU:cd:hi:m:prsvw] f1 f2 ...\n");
+  printf("Where:\n");
+  printf("        -C <n>            - size of comment buffer (default: 200000)\n");
+  printf("        -D <DEFINE>       - same as -D option for cpp.\n");
+  printf("        -E <var>=<value>  - set environment variable.\n");
+  printf("        -I <INCLUDE>      - same as -I option for cpp.\n");
+  printf("        -S <n>            - size of string buffer (default: 200000)\n");
+  printf("        -U <UNDEFINE>     - same as -U option for cpp.\n");
+  printf("        -V                - show version number of compiler.\n");
+  printf("        -c                - ignore all comments.\n");
+  printf("        -d <dir>          - output directory for each emitted file.\n");
+  printf("        -o <dir>          - -d option alias.\n");
+  printf("        -h                - this message.\n");
+  printf("        -?                - -h option alias.\n");
+  printf("        -i <file>         - use this file name as supplied.\n");
+  printf("        -m <name[=value]> - add global modifier.\n");
+  printf("        -p                - shorthand for -D__PRIVATE__.\n");
+  printf("        -r                - check releaseorder entries exist (default: FALSE).\n");
+  printf("        -s <string>       - replace SMEMIT variable with <string>\n");
+  printf("        -e <string>       - -s option alias.\n");
+  printf("        -u                - update interface repository.\n");
+  printf("        -v                - verbose debugging mode (default: FALSE).\n");
+  printf("        -w                - don't display warnings (default: FALSE).\n");
+  printf("        -\%                - show percent of processed files.\n");
+  printf("\n");
+  printf("Modifiers:\n");
+  printf("        addprefixes : adds 'functionprefix' to method names in template file\n");
+  printf("        [no]addstar : [no]add '*' to C bindings for interface references.\n");
+  printf("              corba : check the source for CORBA compliance.\n");
+  printf("                csc : force running of OIDL compiler.\n");
+  printf("         emitappend : append the emitted files at the end of existing file.\n");
+  printf("           noheader : don't add a header to the emitted file.\n");
+  printf("              noint : don't warn about 'int' causing portability problems.\n");
+  printf("             nolock : don't lock the IR during update.\n");
+  printf("               nopp : don't run the source through the pre-processor.\n");
+  printf("               notc : don't use typecodes for emit information.\n");
+  printf("         nouseshort : don't generate short names for types.\n");
+  printf("          pp=<path> : specify a local pre-processor to use.\n");
+  printf("           tcconsts : generate CORBA TypeCode constants.\n");
+  printf("\n");
+  printf("Note: All command-line modifiers can be set in the environment\n");
+  printf("by changing them to UPPERCASE and preappending 'SM' to them.\n");
+  printf("\n");
+  printf("Environment Variables (current state):\n");
+  printf("        SMEMIT=%s\n", getenv("SMEMIT"));
+  printf("                : emitters to run (default : h;ih).\n");
+  printf("        SMINCLUDE=%s\n", getenv("SMINCLUDE"));
+  printf("                : where to search for .idl and .efw files.\n");
+  printf("        SMKNOWNEXTS=%s\n", getenv("SMKNOWNEXTS"));
+  printf("                : add headers to user written emitters.\n");
+  printf("        SMADDSTAR=%s\n", getenv("SMADDSTAR"));
+  printf("                : add or no '*' to C bindings for interface references.\n");
+  printf("        SMEMITAPPEND=%s\n", getenv("SMEMITAPPEND"));
+  printf("                : append the emitted files at the end of existing file.\n");
+}
+
 int main(int argc,char **argv)
 {
 	item *emitters=NULL;
@@ -226,9 +308,15 @@
 	char *outputDir=NULL;
 	item *includes=NULL;
 	item *defines=NULL;
+	item *undefines=NULL;
 	item *modifiers=NULL;
 	int i=1;
 	int update=0;
+	int verbose=1;
+	int warnings=0;
+	int releaseorder=0;
+	int nocomments=1;
+	int showpercent=0;
 	char *app=argv[0];
 	static _IDL_SEQUENCE_char zero={1,1,""};
 
@@ -236,10 +324,19 @@
 
 #ifdef _PLATFORM_WIN32_
 	add_many(&defines,"_PLATFORM_WIN32_");
-#else
-#error missing _PLATFORM_WIN32_
+	add_many(&defines,"_WIN32");
+#endif
+
+#ifdef _PLATFORM_UNIX_
+	add_many(&defines,"_PLATFORM_UNIX_");
+#endif
+
+#ifdef _PLATFORM_X11_
+	add_many(&defines,"_PLATFORM_X11_");
 #endif
 
+	add_many(&defines,"__SOMIDL_VERSION_1__");
+
 	while (i < argc)
 	{
 		char *p=argv[i++];
@@ -252,10 +349,20 @@
 		{
 			switch (p[1])
 			{
-			case 'p':
+			case 'p': // Alias for -D__PRIVATE__
 				add_many(&defines,"__PRIVATE__");
 				break;
-			case 'D':
+			case 'E': // Set environment variable
+				if (p[2])
+				{
+					setenv(p+2,"1",1);
+				}
+				else
+				{
+					setenv(argv[i++],"1",1);
+				}
+				break;
+			case 'D': // DEFINE
 				if (p[2])
 				{
 					add_many(&defines,p+2);
@@ -265,7 +372,18 @@
 					add_many(&defines,argv[i++]);
 				}
 				break;
-			case 'm':
+			case 'U': // UNDEFINE
+				if (p[2])
+				{
+					add_many(&undefines,p+2);
+				}
+				else
+				{
+					add_many(&undefines,argv[i++]);
+				}
+				break;
+			case 'a': // Undocumented. Same as -m. Comes from SOM 1.0 Compiler and was named as global attribute.
+			case 'm': // Global modifier
 				if (p[2])
 				{
 					add_many(&modifiers,p+2);
@@ -275,7 +393,7 @@
 					add_many(&modifiers,argv[i++]);
 				}
 				break;
-			case 'I':
+			case 'I': // Includes
 				if (p[2])
 				{
 					add_many(&includes,p+2);
@@ -285,8 +403,8 @@
 					add_many(&includes,argv[i++]);
 				}
 				break;
-			case 's':
-			case 'e':
+			case 's': // Emitters list
+			case 'e': // Seems to be this option used by original SOM Compiler for another tasks
 				if (p[2])
 				{
 					add_many(&emitters,p+2);
@@ -296,8 +414,8 @@
 					add_many(&emitters,argv[i++]);
 				}
 				break;
-			case 'd':
-			case 'o':
+			case 'd': // Output directory
+			case 'o': // Output directory
 				if (outputDir)
 				{
 					fprintf(stderr,"%s: output dir already set\n",app);
@@ -312,11 +430,64 @@
 					outputDir=argv[i++];
 				}
 				break;
-			case 'u':
+			case 'u': // update IR
 				update=1;
+				add_many(&emitters,"ir");
+				add_many(&modifiers,"updateir");
+				break;
+			case 'h': // Help
+			case 'H': // Help
+			case '?': // Help
+				usage();
+				return 0;
+			case 'q': // unknown. Seems to be passed to somipc
+				break;
+			case 0x01: // Easter egg. Info about authors
+				printf("somFree Compiler\n");
+				break;
+			case 'C': // comment buffer //ignored
+				break;
+			case 'S': // string buffer //ignored
+				break;
+			case 'v': // verbose mode
+				verbose=1;
+				break;
+			case 'w': // show warnings
+				warnings=1;
+				break;
+			case '%': // show percent
+				showpercent=1;
+				break;
+			case 'c': // ignore all comments
+				nocomments=1;
+				break;
+			case 'r': // check releaseorder
+				releaseorder=1;
+				break;
+			case 'V':
+				printf("somFree Compiler: 'sc', Version: 1.00.\n");
+				printf("Copyright 2008, Roger Brown\n");
+				printf("Copyright 2022, Yuri Prokushev\n");
+				printf("This file is part of Roger Brown's Toolkit.\n");
+				printf("This file is part of osFree project.\n");
+				printf("Date Last Compiled: [" __DATE__ "]\n");
+				return 0;
+			case 'i':
+/*				item *t=itemNew(p,strlen(p));
+				if (idls)
+				{
+					item *p=idls;
+					while (p->next) p=p->next;
+					p->next=t;
+				}
+				else
+				{
+					idls=t;
+				}*/
 				break;
 			default:
 				fprintf(stderr,"%s: unknown switch - \"%s\"\n",app,p);
+				usage();
 				return 1;
 			}
 		}
@@ -367,21 +538,32 @@
 
 			while (emitter)
 			{
-				_IDL_SEQUENCE_char somcpp={0,0,NULL};
-				_IDL_SEQUENCE_char somipc={0,0,NULL};
-				_IDL_SEQUENCE_char idlname={0,0,NULL};
+				_IDL_SEQUENCE_char somcpp={0,0,NULL};	// SOM IDL Pre-Processor
+				_IDL_SEQUENCE_char somipc={0,0,NULL};	// SOM IDL Compiler (no Emitter Framework)
+				_IDL_SEQUENCE_char somipc2={0,0,NULL};	// SOM IDL Compiler (Emitter Framework) 
+				_IDL_SEQUENCE_char spp={0,0,NULL};	// SOM OIDL Pre-Processor
+				_IDL_SEQUENCE_char somopc={0,0,NULL};	// SOM OIDL Compiler (CSC to IDL converter)
+				_IDL_SEQUENCE_char idlname={0,0,NULL};	// IDL FQFN
 				char buf[512];
+#ifdef _WIN32
 				long len=GetModuleFileName(NULL,buf,sizeof(buf));
+#else
+				long len=1;
+#endif
 				item *t;
 				size_t ul=0,ul2=0;
 				int appPathSpaces=has_spaces(buf,len);
 
+#ifndef _WIN32
+				buf[0]=0x0;
+#endif
+
 				/* get to start of file name */
 
 				while (len--)
 				{
 					if (
-#ifdef _WIN32
+#if defined(_WIN32) || defined(__OS2__) || defined(__DOS__)
 						(buf[len]=='/')||
 #endif
 						(buf[len]=='\\'))
@@ -393,12 +575,15 @@
 
 				if (appPathSpaces)
 				{
+					add_str(&somipc2,"\"");
 					add_str(&somipc,"\"");
 					add_str(&somcpp,"\"");
 				}
 
-				strncpy(buf+len,"somipc.exe",sizeof(buf)-len);
+				strncpy(buf+len,"somipc2.exe",sizeof(buf)-len);
+				add_str(&somipc2,buf);
 
+				strncpy(buf+len,"somipc.exe",sizeof(buf)-len);
 				add_str(&somipc,buf);
 
 				strncpy(buf+len,"somcpp.exe",sizeof(buf)-len);
@@ -407,6 +592,7 @@
 
 				if (appPathSpaces)
 				{
+					add_str(&somipc2,"\"");
 					add_str(&somipc,"\"");
 					add_str(&somcpp,"\"");
 				}
@@ -455,6 +641,16 @@
 					t=t->next;
 				}
 
+				t=undefines;
+
+				while (t)
+				{
+					add_str(&somcpp," -U");
+					add_seq(&somcpp,&t->data);
+
+					t=t->next;
+				}
+
 				t=includes;
 
 				while (t)
@@ -470,17 +666,45 @@
 				}
 
 				{
+					add_str(&somipc2," -s");
 					add_str(&somipc," -s");
+					add_seq(&somipc2,&emitter->data);
 					add_seq(&somipc,&emitter->data);
 				}
 
+				if (verbose)
+				{
+					add_str(&somipc2," -v ");
+					add_str(&somipc," -v ");
+				}
+
+				if (warnings)
+				{
+					add_str(&somipc2," -w ");
+					add_str(&somipc," -w ");
+				}
+
+				if (releaseorder)
+				{
+					add_str(&somipc2," -r ");
+					add_str(&somipc," -r ");
+				}
+
+				if (nocomments)
+				{
+					add_str(&somipc2," -c ");
+					add_str(&somipc," -c ");
+				} else {
+					add_str(&somcpp," -C ");
+				}
+
+				add_str(&somipc2," -o ");
 				add_str(&somipc," -o ");
 
 				if ((emitter->data._length==2)&&(!memcmp(emitter->data._buffer,"ir",2)))
 				{
 					char *ir=getenv("SOMIR");
 					char *filename;
-					long attr;
 
 					if (!ir) 
 					{
@@ -498,6 +722,10 @@
 
 /*					fprintf(stderr,"%s: ir output file is \"%s\"\n",app,filename);*/
 
+#if 0
+					{
+					long attr;
+
 					attr=GetFileAttributes(filename);
 
 					if (attr < 0)
@@ -509,20 +737,47 @@
 							return 1;
 						}
 					}
+					}
+#else
+					{
+					struct stat   buffer;
 
+					if (!(stat(filename, &buffer) == 0))
+					{
+						fprintf(stderr,"%s,\"%s\" does not exist\n",app,filename);
+
+						if (load_somir(app,filename))
+						{
+							return 1;
+						}
+					}
+					}
+#endif
+					add_str(&somipc2,filename);
 					add_str(&somipc,filename);
+					add_str(&somipc2," ");
 					add_str(&somipc," ");
 				}
 				else
 				{
 					if (outputDir)
 					{
+						add_str(&somipc2,outputDir);
 						add_str(&somipc,outputDir);
+#if defined(_WIN32) || defined(__OS2__) || defined(__DOS__)
+						add_str(&somipc2,"\\");
 						add_str(&somipc,"\\");
+#else
+						add_str(&somipc2,"/");
+						add_str(&somipc,"/");
+#endif
 					}
 
+					add_seq(&somipc2,&idlname);
 					add_seq(&somipc,&idlname);
+					add_str(&somipc2,".");
 					add_str(&somipc,".");
+					add_seq(&somipc2,&emitter->data);
 					add_seq(&somipc,&emitter->data);
 				}
 
@@ -530,21 +785,19 @@
 
 				while (t)
 				{
+					add_str(&somipc2," -m ");
 					add_str(&somipc," -m ");
+					add_seq(&somipc2,&t->data);
 					add_seq(&somipc,&t->data);
 
 					t=t->next;
 				}
 
+#ifdef _USE_PIPES_
+				{
 				add_seq(&somcpp,&zero);
+					add_seq(&somipc2,&zero);
 				add_seq(&somipc,&zero);
-
-#if 1
-				printf("somcpp: %s\n",somcpp._buffer);
-				printf("somipc: %s\n",somipc._buffer);
-#endif
-
-				{
 					STARTUPINFO cpp_startup,somipc_startup;
 					PROCESS_INFORMATION cpp_pinfo={0,0,0,0},somipc_pinfo={0,0,0,0};
 					BOOL b=TRUE;
@@ -662,7 +915,93 @@
 						return 1;
 					}
 				}
+#else
+				{
+					char name2[L_tmpnam];
+					int cppExitCode;
+					int somipcExitCode;
+					_IDL_SEQUENCE_char tmpf={0,0,NULL};
+					char *tmpdir = "/tmp";		// Default value for most UNIXes
+
+					tmpnam(name2);
+#if defined(_WIN32) || defined(__OS2__) || defined(__DOS__)
+					tmpdir = getenv("TMP");
+#endif
+					add_str(&tmpf, tmpdir);
+#if defined(_WIN32) || defined(__OS2__) || defined(__DOS__)
+					add_str(&tmpf,"\\");
+#else
+					add_str(&tmpf,"/");
+#endif
+					add_str(&tmpf,&name2);
+
+					add_str(&somcpp," ");
+					add_seq(&somcpp,&idl->data);
+					add_str(&somcpp," > ");
+					add_seq(&somcpp,&tmpf);
+
+					add_str(&somipc2," ");
+					add_str(&somipc," ");
+					add_seq(&somipc2,&tmpf);
+					add_seq(&somipc,&tmpf);
+
+					add_seq(&somcpp,&zero);
+					add_seq(&somipc2,&zero);
+					add_seq(&somipc,&zero);
+
+					if (verbose)
+					{
+						add_str(&somipc2," -v ");
+						add_str(&somipc," -v ");
+
+						printf("Running shell command:\n");
+						printf("%s\n",somcpp._buffer);
+					}
+
+					cppExitCode=system(somcpp._buffer);
+
+					if (verbose)
+					{
+						printf("%s\n",somipc2._buffer);
+					}
+					somipcExitCode=system(somipc2._buffer);
+					#ifdef __LINUX__
+					if (somipcExitCode==127)
+					#endif
+					#ifdef _WIN32
+					if (somipcExitCode==1)
+					#endif
+					#ifdef __OS2__
+					if (somipcExitCode==1041)
+					#endif
+					{
+						if (verbose)
+						{
+							printf("%s\n",somipc._buffer);
+						}
+						somipcExitCode=system(somipc._buffer);
+					}
+					if (verbose)
+					{
+						if (somipcExitCode)
+						{
+							printf("Status: %d\n", somipcExitCode);
+						}
+					}
 
+					unlink(tmpf._buffer);
+					if (verbose)
+					{
+						printf("Removed  \"%s\"\n", tmpf._buffer);
+					}
+
+					if (somipcExitCode || cppExitCode)
+					{
+						return cppExitCode ? cppExitCode : somipcExitCode;
+					}
+
+				}
+#endif
 				emitter=emitter->next;
 			}
 
diff -urN somfree\somc\include\emitlib.h newsomfree3\somc\include\emitlib.h
--- somfree\somc\include\emitlib.h	Thu Jan 01 07:00:00 1970
+++ newsomfree3\somc\include\emitlib.h	Sat Mar 16 14:09:25 2024
@@ -0,0 +1,228 @@
+/**************************************************************************
+ *
+ *  Copyright 2022, Yuri Prokushev
+ *
+ *  This file is part of osFree project
+ *
+ *  This program is free software: you can redistribute it and/or modify it
+ *  under the terms of the GNU Lesser General Public License as published by the
+ *  Free Software Foundation, either version 3 of the License, or (at your
+ *  option) any later version.
+ * 
+ *  This program is distributed in the hope that it will be useful, but WITHOUT
+ *  ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ *  FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for
+ *  more details.
+ *
+ *  You should have received a copy of the GNU Lesser General Public License
+ *  along with this program.  If not, see <http://www.gnu.org/licenses/>
+ *
+ */
+
+#ifndef emitlib_h
+#define emitlib_h
+#ifdef _WIN32
+#include <windows.h>
+#endif
+#include <io.h>	
+#include <stdio.h>
+#include <stdlib.h>
+
+#include <smstd.h>
+#include <sm.h>
+#include <symtab.h>
+#include <smlib.h>
+
+#ifndef SOMObject
+  #define SOMObject void *
+  #include <somcorba.h>
+  #undef SOMObject
+#else
+  #include <somcorba.h>
+#endif /* !SOMObject */
+
+#include <sctypes.h>
+
+#ifdef __cplusplus
+ extern "C" {
+#endif
+
+#include <optlink.h>
+
+#ifndef _IDL_SEQUENCE_string_defined
+#define _IDL_SEQUENCE_string_defined
+SOM_SEQUENCE_TYPEDEF (string);
+#endif /* _IDL_SEQUENCE_string_defined */
+
+#define MAX_COMMENT_ARG_LIST_LENGTH (MAX_ARG_LIST_LENGTH * 2)
+#define MAX_DESCRIPTOR_LENGTH       512
+#define PASSTHRU_STRIP              0x2
+#define SMMETA_PREFIX               "M_"
+
+#if defined(_OS2) || defined(_WDOS)
+    #define SMDELIMITER   ';'
+#else
+    #define SMDELIMITER   ':'
+#endif /* _OS2 || _WDOS */
+
+/*
+ * Macro version of single line functions
+ */
+#define somtattExists(ep,s)          (somtgetatt(ep,s) ? TRUE : FALSE)
+#define somtlookupComment(n)         (n ? n : "")
+
+/* typedef needed by somtGetReintroducedMethods: */
+typedef SOM_SEQUENCE(Entry *) _IDL_SEQUENCE_EntryPtr;
+
+/* a False value is an error */
+/* pick values so one can test for abistyle_2 or abistyle_2_3 by bitwise and.
+   e.g. (cur_abi & abistyle_2) == True indicates cur_abi is _2 or _2_3 */
+enum SOMTABIStyle { SOMTABIStyle_unknown = 0,
+                    SOMTABIStyle_2 = 0x01,   /* 001 */
+                    SOMTABIStyle_3 = 0x02,   /* 010 */
+                    SOMTABIStyle_2_3 = 0x03, /* 011 */
+                    SOMTABIStyle_4 = 0x04,   /* 100 */
+                    SOMTABIStyle_3_4 = 0x06, /* 110 */
+                    SOMTABIStyle_2_3_4 = 0x07/* 111 */
+            };
+
+/*
+ * External function prototypes
+ */
+// Here old Optlink caling convention functions having SOMLINK equals
+#ifndef SOM_SOMC_NO_BACKCOMPAT
+SOMEXTERN Entry * OPTLINK_DECL somtnthArg(Entry * method, int n);
+SOMEXTERN FILE * OPTLINK_DECL somtemitModule(char *file, Entry *cls, char *ext);
+SOMEXTERN Mlist * OPTLINK_DECL somtallocDataList(Entry *cls);
+SOMEXTERN Mlist * OPTLINK_DECL somtallocMethodList(Entry *cls, boolean all);
+SOMEXTERN char * OPTLINK_DECL somtclsfilename(Entry * cls);
+SOMEXTERN char * OPTLINK_DECL somtclsname(Entry * cls);
+SOMEXTERN char * OPTLINK_DECL somtfindMethodName(const char *bp, char *name);
+SOMEXTERN char * OPTLINK_DECL somtfullPrototype(char *buf, Entry * method, char *sep, int varargs);
+SOMEXTERN char * OPTLINK_DECL somtfullTypedef(char *buf, Entry * cls, Entry * method);
+SOMEXTERN char * OPTLINK_DECL somtgetNonRepeatedParent(Entry *cls, int i);
+SOMEXTERN char * OPTLINK_DECL somtgetatt(Entry * ep, char *s);
+SOMEXTERN char * OPTLINK_DECL somtgetdatt(Entry * ep, char *s);
+SOMEXTERN enum SOMTABIStyle  OPTLINK_DECL somtgetAbistyle( Entry * ep );
+SOMEXTERN char * OPTLINK_DECL somtimplicit(Entry *ep, boolean shortform, char *buf);
+SOMEXTERN char * OPTLINK_DECL somtimplicitArgs(Entry *ep);
+SOMEXTERN char * OPTLINK_DECL somtincludeOnce(Entry *cls, char *ext, char *buf);
+SOMEXTERN char * OPTLINK_DECL somtpclsfilename(Entry *parent);
+SOMEXTERN char * OPTLINK_DECL somtpclsname(Entry *parent);
+SOMEXTERN char * OPTLINK_DECL somtprefixedPrototype(char *buf, Entry * method, char *sep, int varargs, char *prefix);
+SOMEXTERN char * OPTLINK_DECL somtreplaceDataName(char *buf, Entry * data, char *replace);
+SOMEXTERN char * OPTLINK_DECL somtrmSelf(char *str);
+SOMEXTERN char * OPTLINK_DECL somtshortArgList(char *buf, Entry * method, char *sep, boolean varargs, boolean addself);
+SOMEXTERN int  OPTLINK_DECL somtimplicitMeta(Entry *cls);
+SOMEXTERN int  OPTLINK_DECL somtlistAttribute(FILE * fp, int n, AttList * ap, char *s, boolean value, boolean breakLine, boolean firstComma);
+SOMEXTERN int  OPTLINK_DECL somtnewMethodsCount(Entry * cls, int meta, boolean procflg);
+SOMEXTERN int  OPTLINK_DECL somtprivateMethodsCount(Entry * cls, int meta);
+SOMEXTERN void  OPTLINK_DECL somtaddHeader(char *file, FILE *fp, char *ext);
+SOMEXTERN void  OPTLINK_DECL somtcleanFiles(int status);
+SOMEXTERN void  OPTLINK_DECL somtdeclareIdlVarargs(FILE *fp, Entry *ep);
+SOMEXTERN void  OPTLINK_DECL somtdymain(char *file, Entry *cls, EmitFn emitfn, char *emitter, int first, char *version, Stab *stab);
+SOMEXTERN void  OPTLINK_DECL somtemitModuleTypes(FILE *fp, Entry *ep, Stab *stab);
+SOMEXTERN long  OPTLINK_DECL somtemitPassthru(FILE * fp, Entry * cls, char *name, int mode, char *att);
+SOMEXTERN void  OPTLINK_DECL somtfreeDataList(Mlist *mlist);
+SOMEXTERN void  OPTLINK_DECL somtfreeMethodList(Mlist *mlist);
+SOMEXTERN void  OPTLINK_DECL somtfullComment(FILE * fp, char *fmt,...);
+SOMEXTERN void  OPTLINK_DECL somthandleDiskFull(FILE *fp);
+SOMEXTERN void  OPTLINK_DECL somtinitialiseMeta(Entry * cls, Stab * stab, boolean meta, int imp);
+SOMEXTERN void  OPTLINK_DECL somtoidlComment(FILE * fp, int min, int max, char style, char *comment);
+SOMEXTERN void  OPTLINK_DECL somtscmsg(Entry *cls, Entry *ep, char *fmt, ...);
+SOMEXTERN void  OPTLINK_DECL somtshortDefine(FILE *fp, Entry *ep, char *fmt, ...);
+SOMEXTERN void  OPTLINK_DECL somtuninitialiseMeta(Entry * cls);
+SOMEXTERN FILE * OPTLINK_DECL somtobseleteHeaderFile(char *file, Entry *cls, char *ext, char *newext);
+SOMEXTERN char * OPTLINK_DECL somtwidenType(Entry *ep, char *args, char *type);
+SOMEXTERN void  OPTLINK_DECL somtgenAttStubs(FILE *fp, Entry *cls, char *prefix, char *classprefix);
+SOMEXTERN void  OPTLINK_DECL somtstrictidl(FILE *fp);
+SOMEXTERN void  OPTLINK_DECL somtcreateTypeCodes (Stab *stab);
+SOMEXTERN TypeCode * OPTLINK_DECL somtemitTcConstant (TypeCode t, FILE *f, char *name, TypeCode *alreadyDone);
+SOMEXTERN void  OPTLINK_DECL somtemitPredefinedTcConstants (FILE *f);
+SOMEXTERN Entry * OPTLINK_DECL somtAncestorClass(Entry *cls, char *name);
+SOMEXTERN short  OPTLINK_DECL somttcAlignment (TypeCode t, Environment *ev);
+SOMEXTERN long  OPTLINK_DECL somttcSize (TypeCode t, Environment *ev);
+SOMEXTERN TCKind  OPTLINK_DECL somttcKind (TypeCode t, Environment *ev);
+SOMEXTERN sequence(string)  OPTLINK_DECL somttcSeqFromListString (string s);
+SOMEXTERN _IDL_SEQUENCE_EntryPtr  OPTLINK_DECL somtGetReintroducedMethods(Entry *cls);
+#endif
+
+SOMEXTERN Entry * SOMLINK somtnthArgSL(Entry * method, int n);
+SOMEXTERN FILE * SOMLINK somtemitModuleSL(char *file, Entry *cls, char *ext);
+SOMEXTERN Mlist * SOMLINK somtallocDataListSL(Entry *cls);
+SOMEXTERN Mlist * SOMLINK somtallocMethodListSL(Entry *cls, boolean all);
+SOMEXTERN char * SOMLINK somtclsfilenameSL(Entry * cls);
+SOMEXTERN char * SOMLINK somtclsnameSL(Entry * cls);
+SOMEXTERN char * SOMLINK somtfindMethodNameSL(const char *bp, char *name);
+SOMEXTERN char * SOMLINK somtfullPrototypeSL(char *buf, Entry * method, char *sep, int varargs);
+SOMEXTERN char * SOMLINK somtfullTypedefSL(char *buf, Entry * cls, Entry * method);
+SOMEXTERN char * SOMLINK somtgetNonRepeatedParentSL(Entry *cls, int i);
+SOMEXTERN char * SOMLINK somtgetattSL(Entry * ep, char *s);
+SOMEXTERN char * SOMLINK somtgetdattSL(Entry * ep, char *s);
+SOMEXTERN enum SOMTABIStyle  SOMLINK somtgetAbistyleSL( Entry * ep );
+SOMEXTERN char * SOMLINK somtimplicitSL(Entry *ep, boolean shortform, char *buf);
+SOMEXTERN char * SOMLINK somtimplicitArgsSL(Entry *ep);
+SOMEXTERN char * SOMLINK somtincludeOnceSL(Entry *cls, char *ext, char *buf);
+SOMEXTERN char * SOMLINK somtpclsfilenameSL(Entry *parent);
+SOMEXTERN char * SOMLINK somtpclsnameSL(Entry *parent);
+SOMEXTERN char * SOMLINK somtprefixedPrototypeSL(char *buf, Entry * method, char *sep, int varargs, char *prefix);
+SOMEXTERN char * SOMLINK somtreplaceDataNameSL(char *buf, Entry * data, char *replace);
+SOMEXTERN char * SOMLINK somtrmSelfSL(char *str);
+SOMEXTERN char * SOMLINK somtshortArgListSL(char *buf, Entry * method, char *sep, boolean varargs, boolean addself);
+SOMEXTERN int  SOMLINK somtimplicitMetaSL(Entry *cls);
+SOMEXTERN int  SOMLINK somtlistAttributeSL(FILE * fp, int n, AttList * ap, char *s, boolean value, boolean breakLine, boolean firstComma);
+SOMEXTERN int  SOMLINK somtnewMethodsCountSL(Entry * cls, int meta, boolean procflg);
+SOMEXTERN int  SOMLINK somtprivateMethodsCountSL(Entry * cls, int meta);
+SOMEXTERN void  SOMLINK somtaddHeaderSL(char *file, FILE *fp, char *ext);
+SOMEXTERN void  SOMLINK somtcleanFilesSL(int status);
+SOMEXTERN void  SOMLINK somtdeclareIdlVarargsSL(FILE *fp, Entry *ep);
+SOMEXTERN void  SOMLINK somtdymainSL(char *file, Entry *cls, EmitFn emitfn, char *emitter, int first, char *version, Stab *stab);
+SOMEXTERN void  SOMLINK somtemitModuleTypesSL(FILE *fp, Entry *ep, Stab *stab);
+SOMEXTERN long  SOMLINK somtemitPassthruSL(FILE * fp, Entry * cls, char *name, int mode, char *att);
+SOMEXTERN void  SOMLINK somtfreeDataListSL(Mlist *mlist);
+SOMEXTERN void  SOMLINK somtfreeMethodListSL(Mlist *mlist);
+SOMEXTERN void  SOMLINK somtfullCommentSL(FILE * fp, char *fmt,...);
+SOMEXTERN void  SOMLINK somthandleDiskFullSL(FILE *fp);
+SOMEXTERN void  SOMLINK somtinitialiseMetaSL(Entry * cls, Stab * stab, boolean meta, int imp);
+SOMEXTERN void  SOMLINK somtoidlCommentSL(FILE * fp, int min, int max, char style, char *comment);
+SOMEXTERN void  SOMLINK somtscmsgSL(Entry *cls, Entry *ep, char *fmt, ...);
+SOMEXTERN void  SOMLINK somtshortDefineSL(FILE *fp, Entry *ep, char *fmt, ...);
+SOMEXTERN void  SOMLINK somtuninitialiseMetaSL(Entry * cls);
+SOMEXTERN FILE * SOMLINK somtobseleteHeaderFileSL(char *file, Entry *cls, char *ext, char *newext);
+SOMEXTERN char * SOMLINK somtwidenTypeSL(Entry *ep, char *args, char *type);
+SOMEXTERN void  SOMLINK somtgenAttStubsSL(FILE *fp, Entry *cls, char *prefix, char *classprefix);
+SOMEXTERN void  SOMLINK somtstrictidlSL(FILE *fp);
+SOMEXTERN void  SOMLINK somtcreateTypeCodesSL(Stab *stab);
+SOMEXTERN TypeCode * SOMLINK somtemitTcConstantSL(TypeCode t, FILE *f, char *name, TypeCode *alreadyDone);
+SOMEXTERN void  SOMLINK somtemitPredefinedTcConstantsSL(FILE *f);
+SOMEXTERN Entry * SOMLINK somtAncestorClassSL(Entry *cls, char *name);
+SOMEXTERN short  SOMLINK somttcAlignmentSL(TypeCode t, Environment *ev);
+SOMEXTERN long  SOMLINK somttcSizeSL(TypeCode t, Environment *ev);
+SOMEXTERN TCKind  SOMLINK somttcKindSL(TypeCode t, Environment *ev);
+SOMEXTERN sequence(string)  SOMLINK somttcSeqFromListStringSL(string s);
+SOMEXTERN _IDL_SEQUENCE_EntryPtr  SOMLINK somtGetReintroducedMethodsSL(Entry *cls);
+
+/*
+ * Global variables
+ */
+SOMEXTERN global int somtCPP;          /* C++ bindings */
+SOMEXTERN global boolean somtclassIdlCall;/* IDL Calling convention */
+SOMEXTERN global char *somtclassName;  /* Current Class Name */
+SOMEXTERN global char *somtclassPrefix;/* Current Class Prefix */
+SOMEXTERN global char *somtg_somlink;  /* Set to "SOMLINK" when required - csc, psc emitters turn this off. */
+SOMEXTERN global char *somtmajorVersion; /* Major version number for class */
+SOMEXTERN global char *somtminorVersion; /* Minor version number for class */
+SOMEXTERN global int somtmeta;         /* TRUE when in implicit meta mode */
+SOMEXTERN global char *somtmp;         /* Set to SMMETA_PREFIX when somtmeta is TRUE */
+SOMEXTERN global Entry *somtsomcls;    /* Pointer to SOMClass Entry in Symbol Table */
+
+
+/* somFree private */
+
+SOMEXTERN AttList * SOMLINK somtaddModifierSL(AttList *ap, char * modifier, char * value);
+
+#ifdef __cplusplus
+ }
+#endif
+
+#endif
diff -urN somfree\somc\include\optlink.h newsomfree3\somc\include\optlink.h
--- somfree\somc\include\optlink.h	Thu Jan 01 07:00:00 1970
+++ newsomfree3\somc\include\optlink.h	Sat Mar 16 14:09:25 2024
@@ -0,0 +1,46 @@
+/**************************************************************************
+ *
+ *  Copyright 2022, Yuri Prokushev
+ *
+ *  This file is part of osFree project
+ *
+ *  This program is free software: you can redistribute it and/or modify it
+ *  under the terms of the GNU Lesser General Public License as published by the
+ *  Free Software Foundation, either version 3 of the License, or (at your
+ *  option) any later version.
+ * 
+ *  This program is distributed in the hope that it will be useful, but WITHOUT
+ *  ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ *  FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for
+ *  more details.
+ *
+ *  You should have received a copy of the GNU Lesser General Public License
+ *  along with this program.  If not, see <http://www.gnu.org/licenses/>
+ *
+ */
+
+// OPTLINK emulation for MSVC
+#if defined(_WIN32) && defined(_M_IX86) && !defined(_WIN64)
+        #define OPTLINK_3ARGS(a,b,c)            \
+                        __asm { mov             a,eax   }       \
+                        __asm { mov             b,edx   }       \
+                        __asm { mov             c,ecx   }
+        #define OPTLINK_2ARGS(a,b)            \
+                        __asm { mov             a,eax   }       \
+                        __asm { mov             b,edx   }       
+	#define OPTLINK_2ARGS_DWORD_BYTE(a,b)            \
+                        __asm { mov             a,eax   }       \
+                        __asm { mov             b,dl    }       
+        #define OPTLINK_1ARG(a)            \
+                        __asm { mov             a,eax   }
+        #define OPTLINK_1ARG_BYTE(a)            \
+                        __asm { mov             a,al   }
+        #define OPTLINK_DECL    __cdecl
+#else
+        #define OPTLINK_3ARGS(a,b,c)
+        #define OPTLINK_2ARGS(a,b)
+	#define OPTLINK_2ARGS_DWORD_BYTE(a,b)
+        #define OPTLINK_1ARG(a)
+        #define OPTLINK_1ARG_BYTE(a)
+        #define OPTLINK_DECL
+#endif
diff -urN somfree\somc\include\sctypes.h newsomfree3\somc\include\sctypes.h
--- somfree\somc\include\sctypes.h	Thu Jan 01 07:00:00 1970
+++ newsomfree3\somc\include\sctypes.h	Sat Mar 16 14:09:25 2024
@@ -0,0 +1,26 @@
+#ifndef __SOMIDL__
+
+#ifdef __cplusplus
+#include <scentry.xh>
+#else
+#include <scentry.h>
+#endif
+
+#ifdef SOM_STRICT_IDL
+SOMEXTERN SOMTEntryC SOMLINK somtGetObjectWrapper(Entry *ep);
+SOMEXTERN void SOMLINK printEntry(SOMTEntryC entry, int level);
+SOMEXTERN void SOMLINK dumpEntry(SOMTEntryC entry, int level);
+#else
+SOMEXTERN SOMTEntryC * SOMLINK somtGetObjectWrapper(Entry * ep);
+SOMEXTERN void SOMLINK printEntry(SOMTEntryC * entry, int level);
+SOMEXTERN void SOMLINK dumpEntry(SOMTEntryC * entry, int level);
+#endif
+SOMEXTERN void SOMLINK somtShowEntry(Entry * ep);
+SOMEXTERN char * SOMLINK somtStrDup(char *str);
+SOMEXTERN char * SOMLINK somtStrCat(int count,...);
+SOMEXTERN char * SOMLINK somtMakeIncludeStr(boolean local, char *stem, char *suffix);
+SOMEXTERN char * SOMLINK somtNewSymbol(char *prefix, char *stem);
+SOMEXTERN char * SOMLINK somtGetFileStem(char *fullName);
+SOMEXTERN char * SOMLINK somtEntryTypeName(SOMTTypes type);
+
+#endif /* __SOMIDL__ */
diff -urN somfree\somc\include\sm.h newsomfree3\somc\include\sm.h
--- somfree\somc\include\sm.h	Thu Jan 01 07:00:00 1970
+++ newsomfree3\somc\include\sm.h	Sat Mar 16 14:09:25 2024
@@ -0,0 +1,697 @@
+/**************************************************************************
+ *
+ *  Copyright 2022, Yuri Prokushev
+ *
+ *  This file is part of osFree project
+ *
+ *  This program is free software: you can redistribute it and/or modify it
+ *  under the terms of the GNU Lesser General Public License as published by the
+ *  Free Software Foundation, either version 3 of the License, or (at your
+ *  option) any later version.
+ * 
+ *  This program is distributed in the hope that it will be useful, but WITHOUT
+ *  ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ *  FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for
+ *  more details.
+ *
+ *  You should have received a copy of the GNU Lesser General Public License
+ *  along with this program.  If not, see <http://www.gnu.org/licenses/>
+ *
+ */
+
+#ifndef sm_h
+#define sm_h
+
+#include <smcidl.h>
+
+#ifdef __SOMIDL__
+
+/*
+ * For now we don't tell the IR about the internal structures of sm.h:
+ * these are not required dynamically, and we have all the information we
+ * want from the individual classes:
+ * To make the IDL compiler happy though we have to give some types for
+ * the following:
+ */
+
+typedef void *Entry;
+typedef void *Mlist;
+typedef void *AttList;
+typedef void *NumberList;
+typedef void *SwitchBody;
+
+#else
+//typedef void *Stab;
+
+#define _DBCS         1
+#ifndef __SCLITE__
+#define SOMDESCRIPTOR 1
+#endif
+
+#if defined(__OS2__) || defined(_WDOS) || defined(__WINDOWS__) || defined(_WIN32)
+    #define SMTMP   "\\"
+    #define SMSLASH   '\\'
+#else
+    #define SMTMP   "/tmp"
+    #define SMSLASH   '/'
+#endif /* __OS2__ || _WDOS ||  _WIN32 ||  */
+
+#ifndef SOMEXTERN
+    #ifdef __cplusplus
+	#define SOMEXTERN extern "C"
+    #else
+	#define SOMEXTERN extern
+    #endif /* __cplusplus */
+#endif /* SOMEXTERN */
+
+#ifndef SOMLINK
+#	ifdef _WIN32
+#			define SOMLINK  __stdcall
+#	else
+#		ifdef __OS2__
+#			if defined(__BORLANDC__) || defined(__BCPLUSPLUS__))
+#				define SOMLINK __syscall
+#			else
+#				define SOMLINK _System
+#			endif
+#		else
+#			define SOMLINK
+#		endif
+#	endif
+#endif
+
+#ifndef SOMDLLIMPORT
+#	if defined(_WIN32) || defined(HAVE_DECLSPEC_DLLIMPORT)
+#		define SOMDLLIMPORT  __declspec(dllimport)
+#	endif
+#endif
+
+#ifndef SOM_BOOLEAN
+  #define SOM_BOOLEAN
+  typedef unsigned char boolean;
+#endif /* SOM_BOOLEAN */
+
+#ifndef SOM_TYPECODE
+  #define SOM_TYPECODE
+  typedef void * TypeCode;
+#endif /* SOM_TYPECODE */
+
+/*
+ * Types of symbol table entries.
+ * Those wtih _BTYPE are base types,
+ * Those with _PTYPE are pre-declare types: such as unions, structs, enums.
+ * These are typically for forward references.  It is an error to mention
+ * a _PTYPE without some form of pointer reference.
+ * ISCONTYPE returns TRUE if its a constructed type.  This is used for
+ * typedefs as we can give the same name to a typedef of a constructed type.
+ */
+
+#define ISMETHODTYPE(t)  (t == SOMTNewMethodE || t == SOMTOverrideMethodE || \
+			  t == SOMTOverriddenMethodE)
+#define ISPTYPE(t)       (t == SOMTStructPE || t == SOMTEnumPE || \
+			  t == SOMTUnionPE)
+#define ISCONTYPE(t)     (t == SOMTStructE || t == SOMTUnionE)
+#define ISSTYPE(t)       (t == SOMTStructSE || t == SOMTUnionSE)
+#define ISBTYPE(t)       (t == SOMTAnyBE || t == SOMTBooleanBE || \
+			  t == SOMTCharBE || t == SOMTDoubleBE || \
+			  t == SOMTEnumBE || t == SOMTFloatBE || \
+			  t == SOMTLongBE || t == SOMTOctetBE || \
+			  t == SOMTShortBE || t == SOMTStringBE || \
+			  t == SOMTTypeCodeBE || t == SOMTTypedefBE || \
+			  t == SOMTUnsignedLongBE || \
+			  t == SOMTUnsignedShortBE ||\
+			  t == SOMTVoidPtrBE || t == SOMTVoidBE)
+
+#define SMIN            0x1
+#define SMOUT           0x2
+#define SMINOUT         0x3
+
+
+/*
+ * OIDL Compatibility.
+ */
+#define OVERRIDE            SOMTOverrideMethodE
+#define NEW                 SOMTNewMethodE
+#define ALLMETHODS          SMALLMETHODS_TYPE
+
+#define PUBLIC              0x1
+#define PRIVATE             0x2
+#define PRIV_OR_PUB         (PRIVATE|PUBLIC)
+
+
+/*
+ * These macros and types are to deal with the different extensions that
+ * IDL vs OIDL introduce.
+ */
+_typedef struct {
+    char *ext;
+    char *ext_tmp;
+    char *public_ext;
+    char *private_ext;
+    char *throw_away_comment;
+    char *header_comment;
+    char *precompiler;
+    char *output_ext;
+    char *comment_ext;
+    char *filestem;
+} _name(SMEXT);
+
+#define SM_IDL_EXT                      "idl"
+#define SM_IDL_TMP_EXT                  "id2"
+#define SM_IDL_PUBLIC_EXT               "dl"
+#define SM_IDL_PRIVATE_EXT              "pdl"
+#define SM_IDL_THROWAWAY_COMMENT        "//# "
+
+#define SM_EXT                          somtext.ext
+#define SM_EXT_TMP                      somtext.ext_tmp
+#define SM_PUBLIC_EXT                   somtext.public_ext
+#define SM_PRIVATE_EXT                  somtext.private_ext
+#define SM_THROW_AWAY_COMMENT           somtext.throw_away_comment
+#define SM_HEADER_COMMENT               somtext.header_comment
+#define SM_PRECOMPILER                  somtext.precompiler
+#define SM_OUTPUT_EXT                   somtext.output_ext
+#define SM_COMMENT_EXT                  somtext.comment_ext
+#define SM_FILE_STEM                    somtext.filestem
+
+#define SM_COMMENT_STYLE_START          1
+#define END_OF_COMMENT                  "@#$%!^%&*(~)+_) End of SOM Comment"
+#ifdef __RESTRICT_MEMORY__
+#define MAX_COMMENT_SIZE                24576
+#define HASH_SIZE                         109
+#else
+#define MAX_COMMENT_SIZE                49152
+#define HASH_SIZE                         401
+#endif
+#define LARGEBUF                         4096
+
+/*
+ *  Useful Macros.
+ */
+
+#define smmalloc(nbytes)    somtsmalloc (nbytes, FALSE)
+#define smcalloc(nbytes)    somtsmalloc (nbytes, TRUE)
+
+#endif /* __SOMIDL__ */
+
+/*
+ * These structures have been written so that they can be
+ * included multiple times for the SOM Compiler, for the Emitter Framework,
+ * and for IDL.
+ */
+
+_typedef enum SOMTTypes _pack {
+    SOMTAnyBE,
+    SOMTArgumentE,
+    SOMTAttE,
+    SOMTBadEntryE,
+    SOMTBaseE,
+    SOMTBooleanBE,
+    SOMTCaseEntryE,
+    SOMTCaseListE,
+    SOMTCaseSTME,
+    SOMTCharBE,
+    SOMTClassE,
+    SOMTConstE,
+    SOMTCopyrightE,
+    SOMTDataE,
+    SOMTDclListE,
+    SOMTDefaultE,
+    SOMTDoubleBE,
+    SOMTEBaseE,
+    SOMTEEnumE,
+    SOMTEnumBE,
+    SOMTEnumE,
+    SOMTEnumPE,
+    SOMTFloatBE,
+    SOMTGroupE,
+    SOMTLongBE,
+    SOMTMetaE,
+    SOMTModuleE,
+    SOMTNegativeBE,
+    SOMTNewMethodE,
+    SOMTOctetBE,
+    SOMTOverriddenMethodE,
+    SOMTOverrideMethodE,
+    SOMTPassthruE,
+    SOMTSequenceE,
+    SOMTSequenceTDE,
+    SOMTShortBE,
+    SOMTStringBE,
+    SOMTStringE,
+    SOMTStructE,
+    SOMTStructPE,
+    SOMTStructSE,
+    SOMTTyDclE,
+    SOMTTypeCodeBE,
+    SOMTTypedefBE,
+    SOMTTypedefE,
+    SOMTUnionE,
+    SOMTUnionPE,
+    SOMTUnionSE,
+    SOMTUnsignedLongBE,
+    SOMTUnsignedShortBE,
+    SOMTVoidBE,
+    SOMTVoidPtrBE,
+    SOMTEmitterBeginE,
+    SOMTEmitterEndE
+} _name(SOMTTypes);
+
+enum SOMTTargetTypeT {
+    somtPrivateE,
+    somtPublicE,
+    somtImplementationE,
+    somtAllE
+};
+
+#ifndef __SOMIDL__
+
+typedef enum SOMTTargetTypeT SOMTTargetTypeT;
+
+/*
+ * Map the basic structures, NOT Classes, onto typenames.
+ */
+#define _Att             Att
+#define _AttList         AttList
+#define _CaseEntry       CaseEntry
+#define _Class           Class
+#define _Const           Const
+#define _ConstUnion      ConstUnion
+#define _Entry           Entry
+#define _EntryUnion      EntryUnion
+#define _EnumName        EnumName
+#define _Enumerator      Enumerator
+#define _Meta            Meta
+#define _Method_OR_Data  Method_OR_Data
+#define _Mlist           Mlist
+#define _Module          Module
+#define _NameList        NameList
+#define _NumberList      NumberList
+#define _Parent          Parent
+#define _Passthru        Passthru
+#define _Sequence        Sequence
+#define _Simple          Simple
+#define _String          String
+#define _Struct          Struct
+#define _SwitchBody      SwitchBody
+#define _Typedef         Typedef
+#define _Union           Union
+
+/*
+ * #define all the framework class types:
+ */
+#define _SOMTAttributeEntryC      _Entry
+#define _SOMTBaseClassEntryC      _Entry
+#define _SOMTClassEntryC          _Entry
+#define _SOMTCommonEntryC         _Entry
+#define _SOMTDataEntryC           _Entry
+#define _SOMTEmitC                _Entry
+#define _SOMTEntryC               _Entry
+#define _SOMTMetaClassEntryC      _Entry
+#define _SOMTMethodEntryC         _Entry
+#define _SOMTParameterEntryC      _Entry
+#define _SOMTPassthruEntryC       _Entry
+#define _SOMTStructEntryC         _Entry
+#define _SOMTUnionEntryC          _Entry
+#define _SOMTEnumEntryC           _Entry
+#define _SOMTConstEntryC          _Entry
+#define _SOMTSequenceEntryC       _Entry
+#define _SOMTStringEntryC         _Entry
+#define _SOMTEnumNameEntryC       _Entry
+#define _SOMTModuleEntryC         _Entry
+
+/*
+ * These too are possible contenders for class types
+ * so lets prime them now.
+ */
+#define _SOMTAttListC            _struct _AttList
+#define _SOMTMlistC              _struct _Mlist
+#define _SOMTNumberListC         _struct _NumberList
+#define _SOMTNameListC           _struct _NameList
+#define _SOMTSwitchBodyC         _struct _SwitchBody
+#define _SOMTModuleC             _struct _Module
+
+/* 
+ * Forward reference the main Entry/OEntry structure.
+ */
+_typedef struct  _Entry _name(_Entry);
+
+/*
+ *  AttList is used for attributes, and release order.
+ */
+_typedef struct _AttList {
+    char *name;                        /* Name of attribute */
+    char *value;                       /* Value of attribute */
+    _SOMTAttListC *next;               /* Next attribute */
+} _name(_AttList);
+
+typedef struct ReleaseOrder {
+    char *name;                        /* Name of attribute */
+    char *value;                       /* Value of attribute */
+    _SOMTAttListC *next;               /* Next attribute */
+    /* Same as AttList above for binary compatibility */
+    _AttList *staticlist;
+    _AttList *protectedlist;
+    _AttList *publiclist;
+    _AttList *privatelist;
+} ReleaseOrder;
+
+/*
+ * Mlist is used as a linked list for Entry pointers.
+ */
+_typedef struct _Mlist {
+    _SOMTEntryC *ep;
+    _SOMTMlistC *next;
+} _name(_Mlist);
+
+/*
+ * NumberList is used for lists of Numbers.
+ */
+_typedef struct _NumberList {
+    unsigned long n;
+    _SOMTNumberListC *next;
+} _name(_NumberList);
+
+
+/*
+ * NameList is used for lists of Names.
+ */
+_typedef struct _NameList {
+    char *name;
+    _SOMTNameListC *next;
+} _name(_NameList);
+
+_typedef struct _CaseEntry {
+    _NameList *labels;                 /* list of case labels */
+    _SOMTEntryC *type;                 /* Type of switch */
+    _SOMTEntryC *dcl;                  /* Declarator for this type */
+} _name(_CaseEntry);
+
+_typedef struct _SwitchBody {
+    _CaseEntry *entry;
+    _SOMTSwitchBodyC *next;
+} _name(_SwitchBody);
+
+_typedef struct _Class {               /* SOMTClassE */
+    char *file;                        /* File name of the class */
+    _SOMTMetaClassEntryC *meta;        /* Pointer to meta class statement. OIDL
+					* Compatibility */
+    _SOMTBaseClassEntryC *parent;      /* Pointer to parent class statement.
+					* OIDL Compatibility */
+    _Mlist *parents;                   /* Pointer to list of parent class
+					* statements. OIDL Compatibility */
+    _AttList *release;                 /* Release order associated with class */
+    _SOMTPassthruEntryC *passthrus;    /* List of passthrus for this class */
+    _SOMTDataEntryC *data;             /* List of instance data declarations */
+    TypeCode dataTc;                   /* Instance data struct TypeCode */
+    short methodcnt;                   /* Number of NEW methods in the class */
+    _SOMTMethodEntryC *methods;        /* Pointer to first method */
+    _Mlist *inherited;                 /* Pointer to inherited non/overridden
+					* methods */
+    _Mlist *pubdefs;                   /* Public IDL type definitions i.e.
+					* those types that are defined in the
+					* "interface" section */
+
+    _SOMTModuleEntryC *mod;            /* This is set to the containing module,
+					* Otherwise NULL. */
+    _SOMTClassEntryC *cls;             /* If this Class is a meta class, then
+					* this points to the Class of which
+					* this is a meta class for, otherwise
+					* NULL */
+    char isforward;                    /* 1 if forward ref, 0 otherwise */
+} _name(_Class);
+
+_typedef struct _Meta {                /* SOMTMetaE */
+    char *file;                        /* File name of the meta class */
+    _SOMTClassEntryC *metadef;         /* Pointer to the meta class defn */
+} _name(_Meta);
+
+_typedef struct _Parent {              /* SOMTBaseE */
+    _SOMTClassEntryC *parentdef;       /* Pointer to the parent class defn */
+} _name(_Parent);
+
+_typedef struct _Passthru {            /* SOMTPassthruE */
+    _SOMTPassthruEntryC *next;         /* Pointer to next passthru */
+} _name(_Passthru);
+
+_typedef struct _Method_OR_Data {      /* SOMTNewMethodE, SOMTOverrideMethodE,
+					* SOMTOverriddenMethodE, SOMTDataE,
+					* SOMTArgumentE, SOMTTypedefBE.
+					* At present we store all of our
+					* information for a METHOD declaration
+					* and a DATA declartion in the
+					* Method_OR_Data structure.  This is
+					* convienient since we use the same
+					* parsing code to parse a method
+					* prototype as we do a data
+					* declaration. In addition, with the
+					* exception of omethod and oparent all
+					* of the other fields are pontentially
+					* used by a data declaration. */
+    _SOMTEntryC *eptype;               /* Structured form of the char *type
+					* entry. IDL Extension. */
+    char *ptrs;                        /* Pointers to type. IDL Extension */
+    _NumberList *array;                /* List of array dimensions. IDL
+					* Extension. */
+    char *arrays;                      /* String version of array dimensions,
+					* same information in the NumberList
+					* array, but retained for OIDL
+					* compatibility. */
+    char *defn;                        /* Un-parsed defn of method call. OIDL
+					* compatibility. */
+    char *type;                        /* [Return] type of method. OIDL
+					* compatibility. */
+    char varargs;                      /* Method has a varargs parameter */
+    char isprivate;                    /* Method is 1=PRIVATE, 0=PUBLIC */
+    char inoutmode;                    /* In, out, inout. */
+    char isselfref;                    /* If =1 then arg points to self */
+    char isoneway;                     /* If =1 then oneway method */
+    short argcnt;                      /* Number of arguments */
+    _SOMTParameterEntryC *args;        /* Structured list of argument
+					* declarations */
+    _SOMTMethodEntryC *omethod;        /* If method is overridden the original
+					* method defn, otherwise NULL. */
+    _SOMTClassEntryC *oparent;         /* If method is overridden the original
+					* parent defn, otherwise current
+					* parent. */
+    _SOMTEntryC *group;                /* Pointer to group method appears in.
+					* OIDL Compatibility. */
+    _SOMTMethodEntryC *next;           /* Next method/data/arg in class */
+    char **ctxsa;                      /* context string literal array */
+    _Mlist *raiseslist;                /* list of exceptions */
+} _name(_Method_OR_Data);
+
+_typedef struct _Struct {              /* SOMTStructE, SOMTStructSE */
+    _Mlist *dcllist;                   /* list of declarators */
+    _SOMTClassEntryC *cls;             /* Class defined in for scoping */
+    char isexcept;                     /* TRUE if exception, otherwise FALSE */
+    char ismutref;                     /* TRUE if mutually-referential, 
+					* otherwise FALSE  */
+} _name(_Struct);
+
+_typedef struct _Typedef {             /* SOMTTypedefE, SOMTTyDclE */
+    _SOMTEntryC *type;
+    _Mlist *dcllist;                   /* List of declarators */
+    _SOMTEntryC *next;                 /* FIX: Migration for old compiler
+					* Should really turn all of our list of
+					* Entries into Mlists. */
+} _name(_Typedef);
+
+_typedef struct _Union {               /* SOMTUnionE, SOMTUnionSE */
+    _SOMTEntryC *type;                 /* Switch type */
+    _SwitchBody *swbody;               /* Body of switch */
+    char ismutref;                     /* TRUE if mutually-referential, 
+					* otherwise FALSE */
+} _name(_Union);
+
+_typedef struct _Enumerator {          /* SOMTEnumE */
+    _Mlist *names;                     /* list of enumerator names */
+} _name(_Enumerator);
+
+_typedef union _ConstUnion _switch(SOMTTypes) {
+    _case(SOMTShortBE)
+    _case(SOMTLongBE)
+    _case(SOMTUnsignedShortBE)
+    _case(SOMTCharBE)
+    _case(SOMTBooleanBE)
+    _case(SOMTEnumBE)
+    _case(SOMTUnsignedLongBE)
+	unsigned long ul;
+    _case(SOMTNegativeBE)
+	long l;
+    _case(SOMTFloatBE)
+    _case(SOMTDoubleBE)
+	char *d;                       /* Due to errors in AIX compiler we, use
+					  strings for floats and doubles! */
+    _case(SOMTStringBE)
+	char *s;
+} _name(_ConstUnion);
+
+_typedef struct _Const {               /* SOMTConstE */
+    _SOMTEntryC *type;                 /* Type of constant */
+    char *s;                           /* String value of expression */
+    SOMTTypes utype;                   /* Union type - if we had one. */
+    _ConstUnion u;                     /* Numeric Value of constant */
+} _name(_Const);
+
+_typedef struct _Att {                 /* SOMTAttE */
+    char isreadonly;                   /* Read-only or not */
+    _SOMTEntryC *type;                 /* Simple type. */
+    _Mlist *dcllist;                   /* list of declarators */
+    _Mlist *get;                       /* list of get methods  */
+    _Mlist *set;                       /* list of set methods  */
+} _name(_Att);
+
+_typedef struct _Sequence {            /* SOMTSequenceE, SOMTSequenceTDE */
+    _SOMTEntryC *type;                 /* Simple type */
+    long n;                            /* positive int const */
+    _SOMTEntryC *seqty;                /* Pointer to extra Seq. Typedef */
+} _name(_Sequence);
+
+_typedef struct _String {              /* SOMTStringE */
+    long n;                            /* length of string */
+} _name(_String);
+
+_typedef struct _EnumName {            /* SOMTEnumBE */
+    _SOMTEnumEntryC *ep;               /* pointer to ENUM Entry */
+    unsigned long value;               /* Value of Enumeration */
+} _name(_EnumName);
+
+_typedef struct _Module {              /* SOMTModuleE */
+    _Mlist *defs;                      /* list of module definitions */
+    _SOMTModuleEntryC *mod;            /* This is set to the containing module,
+					* Otherwise NULL. */
+    char *file;                        /* File in which Module appears */
+} _name(_Module);
+
+/*
+ * The union of all of these different types
+ */
+_typedef union _EntryUnion _switch(SOMTTypes)
+{
+    _case(SOMTClassE)
+	_Class c;
+    _case(SOMTMetaE)
+	_Meta mt;
+    _case(SOMTBaseE)
+	_Parent p;
+    _case(SOMTPassthruE)
+	_Passthru pt;
+    _case(SOMTNewMethodE)
+    _case(SOMTOverrideMethodE)
+    _case(SOMTOverriddenMethodE)
+    _case(SOMTDataE)
+    _case(SOMTArgumentE)
+    _case(SOMTTypedefBE)
+    _case(SOMTVoidPtrBE)
+	_Method_OR_Data m;
+    _case(SOMTStructE)
+	_Struct struc;
+    _case(SOMTTyDclE)
+    _case(SOMTTypedefE)
+	_Typedef ty;
+    _case(SOMTUnionE)
+    _case(SOMTUnionSE)
+	_Union un;
+    _case(SOMTEnumE)
+	_Enumerator enumerator;
+    _case(SOMTConstE)
+	_Const con;
+    _case(SOMTAttE)
+	_Att att;
+    _case(SOMTSequenceE)
+    _case(SOMTSequenceTDE)
+	_Sequence seq;
+    _case(SOMTStringE)
+	_String str;
+    _case(SOMTEnumBE)
+	_EnumName enumN;
+    _case(SOMTModuleE)
+	_Module mod;
+} _name(_EntryUnion);
+
+/*
+ *  Entry is the main data structure for storing classes, methods, passthrus,
+ *  groups, and data.
+ */
+
+struct _Entry {
+    char *name;                        /* Name of entry */
+    SOMTTypes type;                    /* SOMTClassE, SMMETHOD_TYPE, etc */
+    char **sname;                      /* Scoped name */
+    char *comment;                     /* Comment associated with entry */
+    _AttList *atts;                    /* List of attributes */
+    TypeCode tc;                       /* TypeCode if appropriate, or NULL */
+    long lineno;                       /* Line number in source file */
+#ifdef SOMTEntryC
+    SOMTEntryC *objref;                /* Points to the object containing this
+					* entry */
+#else
+    _SOMTEntryC *objref;               /* Points to the object containing this
+					* entry */
+#endif
+    char isref;                        /* TRUE if this is a reference to the
+					* real type, rather than a declaration
+					* of it. */
+    _EntryUnion u;
+#ifdef __PRIVATE__
+    RHBelement *data;
+    char *filestem;
+#endif    
+};
+
+/*
+ * Attempt to reset the world by #undef as much as possible.
+ */
+#undef _Att
+#undef _AttList
+#undef _CaseEntry
+#undef _Class
+#undef _Const
+#undef _ConstUnion
+#undef _Entry
+#undef _EntryUnion
+#undef _EnumName
+#undef _Enumerator
+#undef _Meta
+#undef _Method_OR_Data
+#undef _Mlist
+#undef _Module
+#undef _NameList
+#undef _NumberList
+#undef _Parent
+#undef _Passthru
+#undef _SOMTAttListC
+#undef _SOMTAttributeEntryC
+#undef _SOMTBaseClassEntryC
+#undef _SOMTClassEntryC
+#undef _SOMTCommonEntryC
+#undef _SOMTConstEntryC
+#undef _SOMTDataEntryC
+#undef _SOMTEmitC
+#undef _SOMTEntryC
+#undef _SOMTEnumEntryC
+#undef _SOMTEnumNameEntryC
+#undef _SOMTMetaClassEntryC
+#undef _SOMTMethodEntryC
+#undef _SOMTMlistC
+#undef _SOMTModuleC
+#undef _SOMTModuleEntryC
+#undef _SOMTNameListC
+#undef _SOMTNumberListC
+#undef _SOMTParameterEntryC
+#undef _SOMTPassthruEntryC
+#undef _SOMTSequenceEntryC
+#undef _SOMTStringEntryC
+#undef _SOMTStructEntryC
+#undef _SOMTSwitchBodyC
+#undef _SOMTUnionEntryC
+#undef _Sequence
+#undef _Simple
+#undef _String
+#undef _Struct
+#undef _SwitchBody
+#undef _Typedef
+#undef _Union
+
+#endif /* __SOMIDL__ */
+#endif /* sm_h */
diff -urN somfree\somc\include\sm.xh newsomfree3\somc\include\sm.xh
--- somfree\somc\include\sm.xh	Thu Jan 01 07:00:00 1970
+++ newsomfree3\somc\include\sm.xh	Sat Mar 16 14:09:25 2024
@@ -0,0 +1,27 @@
+/**************************************************************************
+ *
+ *  Copyright 2022, Yuri Prokushev
+ *
+ *  This file is part of osFree project
+ *
+ *  This program is free software: you can redistribute it and/or modify it
+ *  under the terms of the GNU Lesser General Public License as published by the
+ *  Free Software Foundation, either version 3 of the License, or (at your
+ *  option) any later version.
+ * 
+ *  This program is distributed in the hope that it will be useful, but WITHOUT
+ *  ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ *  FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for
+ *  more details.
+ *
+ *  You should have received a copy of the GNU Lesser General Public License
+ *  along with this program.  If not, see <http://www.gnu.org/licenses/>
+ *
+ */
+
+#ifndef sm_xh
+#define sm_xh
+
+#include <sm.h>
+
+#endif /* sm_xh */
diff -urN somfree\somc\include\smcidl.h newsomfree3\somc\include\smcidl.h
--- somfree\somc\include\smcidl.h	Thu Jan 01 07:00:00 1970
+++ newsomfree3\somc\include\smcidl.h	Sat Mar 16 14:09:25 2024
@@ -0,0 +1,53 @@
+/**************************************************************************
+ *
+ *  Copyright 2022, Yuri Prokushev
+ *
+ *  This file is part of osFree project
+ *
+ *  This program is free software: you can redistribute it and/or modify it
+ *  under the terms of the GNU Lesser General Public License as published by the
+ *  Free Software Foundation, either version 3 of the License, or (at your
+ *  option) any later version.
+ * 
+ *  This program is distributed in the hope that it will be useful, but WITHOUT
+ *  ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ *  FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for
+ *  more details.
+ *
+ *  You should have received a copy of the GNU Lesser General Public License
+ *  along with this program.  If not, see <http://www.gnu.org/licenses/>
+ *
+ */
+
+#undef _case
+#undef _switch
+#undef _struct
+#undef _typedef
+#undef _name
+
+#ifdef __SOMIDL__
+    /*
+     * The _case and _switch macro are for IDL Unions.
+     */
+    #define _case(n)                       case n:
+    #define _switch(t)                     switch(t)
+    #define _struct
+    #define _typedef
+    #define _pack
+    #define _name(name)
+#else
+    #define _case(n)
+    #define _switch(t)
+    #define _struct                        struct
+    #define _typedef                       typedef
+#ifdef _MSC_VER
+# ifdef _cplusplus
+    #define _pack                          : unsigned char
+# else
+    #define _pack
+# endif
+#else
+    #define _pack
+#endif
+    #define _name(name)                    name
+#endif
diff -urN somfree\somc\include\smcidl.xh newsomfree3\somc\include\smcidl.xh
--- somfree\somc\include\smcidl.xh	Thu Jan 01 07:00:00 1970
+++ newsomfree3\somc\include\smcidl.xh	Sat Mar 16 14:09:25 2024
@@ -0,0 +1,27 @@
+/**************************************************************************
+ *
+ *  Copyright 2022, Yuri Prokushev
+ *
+ *  This file is part of osFree project
+ *
+ *  This program is free software: you can redistribute it and/or modify it
+ *  under the terms of the GNU Lesser General Public License as published by the
+ *  Free Software Foundation, either version 3 of the License, or (at your
+ *  option) any later version.
+ * 
+ *  This program is distributed in the hope that it will be useful, but WITHOUT
+ *  ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ *  FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for
+ *  more details.
+ *
+ *  You should have received a copy of the GNU Lesser General Public License
+ *  along with this program.  If not, see <http://www.gnu.org/licenses/>
+ *
+ */
+
+#ifndef smcidl_xh
+#define smcidl_xh
+
+#include <smcidl.h>
+
+#endif /* smcidl_xh */
diff -urN somfree\somc\include\smlib.h newsomfree3\somc\include\smlib.h
--- somfree\somc\include\smlib.h	Thu Jan 01 07:00:00 1970
+++ newsomfree3\somc\include\smlib.h	Sat Mar 16 14:09:25 2024
@@ -0,0 +1,452 @@
+/**************************************************************************
+ *
+ *  Copyright 2022, Yuri Prokushev
+ *
+ *  This file is part of osFree project
+ *
+ *  This program is free software: you can redistribute it and/or modify it
+ *  under the terms of the GNU Lesser General Public License as published by the
+ *  Free Software Foundation, either version 3 of the License, or (at your
+ *  option) any later version.
+ * 
+ *  This program is distributed in the hope that it will be useful, but WITHOUT
+ *  ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ *  FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for
+ *  more details.
+ *
+ *  You should have received a copy of the GNU Lesser General Public License
+ *  along with this program.  If not, see <http://www.gnu.org/licenses/>
+ *
+ */
+
+#ifndef smlib_h
+#define smlib_h
+#include <somc_msg.h>
+#include <setjmp.h>
+#include <sm.h>
+#include <optlink.h>
+
+#define basemalloc  malloc
+#define basefree    free
+#define baserealloc realloc
+#define basecalloc  calloc
+
+
+#define SOMTOVERRIDE_TYPE(ep) (ep->type == SOMTOverrideMethodE || ep->u.m.omethod)
+#define SOMTVALIDENTRY(e,m) ((somtgetatt(e, "class") ? TRUE : FALSE) == m)
+#define SMUNKNOWNTYPE(e)    fprintf(stderr, "\"%s\": %d " \
+                                      "[%d]. \"%s\"\n", __FILE__, __LINE__,\
+                                       e->type, e->name)
+#define somtfindBaseType(ep) (somtfindBaseEp(ep)->type)
+/*
+ * Error handling macros.  We keep a track of our various errors & warnings
+ * in a global structure so that emitters can also post errors.
+ * They can do this in one of two ways - calling the somtwarn, somterror,
+ * somtfatal, somtinternal functions, or using these macros.
+ */
+#define SMANYERRORS()       (somtg_f.ERROR || somtg_f.FATAL || somtg_f.INTERNAL)
+#define SMANYFATAL()        (somtg_f.FATAL || somtg_f.INTERNAL)
+#define SMWARNCOUNT()       (somtg_f.WARN)
+#define SMERRORCOUNT()      (somtg_f.ERROR + somtg_f.FATAL + somtg_f.INTERNAL)
+#define SMPOSTERROR(type)   (somtg_f.type++)
+#define SOMTSTAR            (somtaddstar ? "*" : "")
+#define SOMTQUAL(cls)       (cls->sname && cls->sname[1])
+#define MSGSET STK
+#ifdef __RESTRICT_MEMORY__
+#define MAX_MSGSIZE 256
+#else
+#define MAX_MSGSIZE 500
+#endif
+
+/*
+ * setjmp/longjmp exit details
+ */
+
+typedef struct {
+    jmp_buf jmpbuf;
+    boolean called;
+    int  status;
+} SOMTExitBuf;
+
+#define SOMTSETEXIT(buf)    if (!buf.called) setjmp(buf.jmpbuf)
+
+#define SOMT_IDL_SEQUENCE_LEN_1  13             /* IDL_SEQUENCE */
+#define SOMT_IDL_SEQUENCE_LEN_2  22             /* seq<%10d> */
+#define SOMT_IDL_SEQUENCE_LEN (SOMT_IDL_SEQUENCE_LEN_1+SOMT_IDL_SEQUENCE_LEN_2)
+#define SOMT_REMOVE_IDL_SEQUENCE(s)   ((*s == '/') ? \
+                                         s+SOMT_IDL_SEQUENCE_LEN_2 : s)
+
+/*
+ * DBCS enabling macros
+ */
+#ifdef _DBCS
+  #define DBCSBLANK        0x8140
+  #define DBCSTOINT(buf)   ((((int)*(buf))<<8)+((int)*((buf)+1)))
+  #define DBCSCOPY(buf,c)  if(isDBCS(c))\
+    {*(buf)++=(char)((c)>>8);*(buf)++=(char)((c)&0xFF);}\
+    else *(buf)++=(char)(c)
+  #define DBCSSCAN(buf)    somtdbcsScan((char **)&(buf))
+  #define DBCSINCR(buf)    ((buf) += isDBCS(*(buf))? 2: 1)
+  #define DBCSCHAR(buf)    (isDBCS(*(buf)) ? DBCSTOINT(buf) : (int)(*(buf)))
+  #define DBCS_output      dbcsOutput
+  #define dbcsOutput(c,fp) ((isDBCS(c) && (putc((char)(c>>8), fp) == EOF)) \
+                                           ? EOF \
+                                           : putc((char) (c&0x00FF), fp))
+  #define DBCS_strchr      somtdbcsStrchr
+  #define DBCS_strrchr     somtdbcsStrrchr
+  #define DBCS_strstr      somtdbcsStrstr
+  #define DBCS_preincr     somtdbcsPreincr
+  #define DBCS_postincr    somtdbcsPostincr
+  #define isDBCS           somtisDbcs
+  #define DBCS_isspace(c)  ((c >= 0) && (c < 256) && isspace(c))
+#else
+  #define DBCSCOPY(buf,c)  (*(buf)++=(char)(c))
+  #define DBCSSCAN(buf)    ((int)(*(buf)++))
+  #define DBCSINCR(buf)    (++(buf))
+  #define DBCSCHAR(buf)    ((int)(*(buf)))
+  #define DBCS_output      putc
+  #define DBCS_strchr      strchr
+  #define DBCS_strrchr     strrchr
+  #define DBCS_strstr      strstr
+  #define DBCS_preincr     ++
+  #define DBCS_postincr(x) ((x)++)
+  #define isDBCS(s)        (FALSE)
+  #define DBCS_isspace(c)  (isspace(c))
+#endif /* _DBCS */
+
+/*
+ * ISO LATIN 8859.1 Characater Set
+ */
+#define SOMTISALNUM(c)        (isalnum(c) || c == '_' || IS_ISO_LATIN_8859_1(c))
+#define ISO_LATIN_8859_1_START  192
+#define ISO_LATIN_8859_1_FINISH 255
+#define IS_ISO_LATIN_8859_1(c)  (c >= ISO_LATIN_8859_1_START && \
+                                 c <= ISO_LATIN_8859_1_FINISH && \
+                                 c != 215 && c != 247)
+
+/*
+ * Enum for parent traversal.
+ */
+typedef enum _SMTraverse {SMTraverseAll, SMTraverseOnce, SMTraverseMany}
+        SMTraverse;
+
+/*
+ * Command line flags and error structure.
+ */
+typedef struct {
+    unsigned verbose:1;
+    unsigned quiet:1;
+    unsigned warn:1;
+    unsigned extra:1;
+    unsigned comments:1;
+    AttList *atts;
+    unsigned lex:1;
+    unsigned yacc:1;
+    unsigned release:1;
+    unsigned stab:1;
+    unsigned qualify:1;
+    unsigned idl:1;
+#ifdef __RESTRICT_MEMORY__
+#define MAX_NO_EMITTERS 4
+#else
+#define MAX_NO_EMITTERS 32
+#endif
+    char *emitters[MAX_NO_EMITTERS];
+    char *progname;
+    int _ERROR;
+    int WARN;
+    int FATAL;
+    int INTERNAL;
+    unsigned append:1;          /* Append to files, like -memitappend */
+    unsigned level2:1;          /* level 2 extensions */
+    unsigned noint:1;           /* no "int" warning */
+    size_t commentsize;         /* size of comment buffer */
+    unsigned useshort:1;        /* use short names */
+    AttList *pragmas;           /* list of pragmas */
+    Mlist *glbemits;            /* list of types to globally emit */
+    unsigned fullyqualified:1;  /* TRUE if names have been fullyqualified */
+    unsigned tcdone:1;          /* TRUE if typecodes have been created */
+    unsigned relchk:1;          /* TRUE if you want release order checking */
+    unsigned binary:1;          /* TRUE if somtopenEmitFile should fopen in binary mode */
+} Flags;
+
+/*
+ * Global variables - that are really macros
+ */
+
+#define somtcommentsize      somtg_f.commentsize
+#define somtpragmaList       somtg_f.pragmas
+#define somtglbemits         somtg_f.glbemits
+#define somtfullyqualified   somtg_f.fullyqualified
+#define somttcdone           somtg_f.tcdone
+#define somtrelchk           somtg_f.relchk
+
+#define ARG_STRING          ((*argc)--, *(*argv)++)
+#define MAX_ARG_LIST_LENGTH 2048
+#define SOMTSABUF           (4*(FILENAME_MAX+2)+1) /* ::id::id::id::id */
+#define SOMT_MSG_SIZE       MAX_ARG_LIST_LENGTH + SOMTSABUF
+
+typedef struct {
+    char *name;
+    char *desc;
+    short len;
+} BaseType;
+
+/*
+ * Emitter function prototype:
+ */
+typedef FILE* (*EmitFn)(char*,Entry*,Stab*);
+
+// Here old Optlink caling convention functions having SOMLINK equals
+#ifndef SOM_SOMC_NO_BACKCOMPAT
+SOMEXTERN int OPTLINK_DECL somttraverseParents(FILE *fp, Entry * cls, Entry *arg, int (*fn)(FILE*,Entry*,Entry*), SMTraverse flg);
+SOMEXTERN Entry * OPTLINK_DECL somtfindBaseEp(Entry *ep);
+SOMEXTERN Entry * OPTLINK_DECL somtgetType(char *name, SOMTTypes type);
+SOMEXTERN FILE * OPTLINK_DECL somtokfopen(char *path, char *mode);
+SOMEXTERN int  OPTLINK_DECL somtokfprintf(FILE *, const char *, ...);
+SOMEXTERN int  OPTLINK_DECL somtokfputs(const char *, FILE *);
+SOMEXTERN int  OPTLINK_DECL somtokfputc(const char, FILE *);
+SOMEXTERN char * OPTLINK_DECL somtokfgets(char *, int, FILE *);
+SOMEXTERN void  OPTLINK_DECL somtokrewind(FILE *);
+SOMEXTERN int  OPTLINK_DECL somtokrename(const char*, const char *);
+SOMEXTERN FILE * OPTLINK_DECL somtopenEmitFile(char *file, char *ext);
+SOMEXTERN BOOL  OPTLINK_DECL somtisDbcs(int c);
+SOMEXTERN boolean  OPTLINK_DECL somtremoveExt(char *name, char *ext, char *buf);
+SOMEXTERN char * OPTLINK_DECL somtaddExt(char *name, char *ext, char *buf);
+SOMEXTERN char * OPTLINK_DECL somtarrayToPtr(Entry *ep, char *stars, char *buf);
+SOMEXTERN char * OPTLINK_DECL somtattNormalise(char *name, char *buf);
+SOMEXTERN char * OPTLINK_DECL somtbasename(char *path);
+SOMEXTERN char * OPTLINK_DECL somtctos(Const *con, char *buf);
+SOMEXTERN char * OPTLINK_DECL somtdbcsPostincr(char **p);
+SOMEXTERN char * OPTLINK_DECL somtdbcsPreincr(char **p);
+SOMEXTERN char * OPTLINK_DECL somtdbcsStrchr(char *s, int c);
+SOMEXTERN char * OPTLINK_DECL somtdbcsStrrchr(char *s, int c);
+SOMEXTERN char * OPTLINK_DECL somtdbcsStrstr(char *s1, char *s2);
+SOMEXTERN char * OPTLINK_DECL somteptotype(Entry *ep, char *ptrs, char *buf);
+SOMEXTERN char * OPTLINK_DECL somtgetDesc(Stab *stab, Entry *cls, Entry *method, char *desc, BOOL addQuotes, BOOL use, BOOL versflg);
+SOMEXTERN char * OPTLINK_DECL somtgetVersion(char *sccsid, char *version);
+SOMEXTERN char * OPTLINK_DECL somtgetgatt(char *s);
+SOMEXTERN char * OPTLINK_DECL somtnextword(const char *s, char *buf);
+SOMEXTERN char * OPTLINK_DECL somtnormaliseDesc(char *desc, char *normal);
+SOMEXTERN char * OPTLINK_DECL somtsatos(char **sa, char *sep, char *buf);
+SOMEXTERN char * OPTLINK_DECL somtsearchFile(char *file, char *path, char *envvar);
+SOMEXTERN char * OPTLINK_DECL somtskipws(const char *s);
+SOMEXTERN char * OPTLINK_DECL somtstringFmt(char *fmt, ...);
+SOMEXTERN char * OPTLINK_DECL somttype(SOMTTypes type);
+SOMEXTERN char * OPTLINK_DECL somtuniqFmt(MemBuf *membuf, char *fmt, ...);
+SOMEXTERN int  OPTLINK_DECL somtargFlag(int *argc, char ***argv);
+SOMEXTERN int  OPTLINK_DECL somtattjoin(register AttList *ap1, AttList *ap2);
+SOMEXTERN int  OPTLINK_DECL somtdbcsLastChar(char *buf);
+SOMEXTERN int  OPTLINK_DECL somtdbcsScan(char **buf);
+SOMEXTERN int  OPTLINK_DECL somtdiskFull(FILE *fp);
+SOMEXTERN int  OPTLINK_DECL somtfclose(FILE *fp);
+SOMEXTERN int  OPTLINK_DECL somtfexists(char *file);
+SOMEXTERN int  OPTLINK_DECL somtisparent(Entry *cls, Entry *parent);
+SOMEXTERN int  OPTLINK_DECL somtmget(int setnum, int msgnum, char *msgbuf);
+SOMEXTERN int  OPTLINK_DECL somtmopen(char *filename);
+SOMEXTERN int  OPTLINK_DECL somtmprintf(int setnum, int msgnum, ...);
+SOMEXTERN int  OPTLINK_DECL somtokremove(char *file);
+SOMEXTERN int  OPTLINK_DECL somtunload(void *modHandle);
+SOMEXTERN int  OPTLINK_DECL somtwriteaccess(char *file);
+
+// Allocate memory size of nbytes and filled with zeroes if clear flag is set
+SOMEXTERN void * OPTLINK_DECL somtsmalloc(size_t nbytes, BYTE clear);
+SOMEXTERN void  OPTLINK_DECL somtaddGAtt(MemBuf **membuf, AttList **ap, char *buf);
+SOMEXTERN void  OPTLINK_DECL somtcalcFileName(char *def, char *over, char *ext);
+SOMEXTERN void  OPTLINK_DECL somtcleanFilesFatal(int status);
+SOMEXTERN void  OPTLINK_DECL somtemitTypes(FILE *fp, Mlist *mp, Stab *stab);
+SOMEXTERN void  OPTLINK_DECL somterror(char *file, long lineno, char *fmt, ...);
+SOMEXTERN void  OPTLINK_DECL somtfatal(char *file, long lineno, char *fmt, ...);
+SOMEXTERN void  OPTLINK_DECL somtinternal(char *file, long lineno, char *fmt, ...);
+SOMEXTERN void  OPTLINK_DECL somtmclose(void);
+SOMEXTERN void  OPTLINK_DECL somtmsg(char *file, long lineno, char *fmt, ...);
+SOMEXTERN void  OPTLINK_DECL somtreadDescFile(Stab *stab, char *file);
+SOMEXTERN void  OPTLINK_DECL somtsetDefaultDesc(Stab *stab);
+SOMEXTERN void  OPTLINK_DECL somtsetEmitSignals(void(*cleanup) (int), void (*internal) (int));
+SOMEXTERN void  OPTLINK_DECL somtsetTypeDefn(Entry *type, Entry *ep, char *ptrs, Entry *ret, BOOL array);
+SOMEXTERN void  OPTLINK_DECL somtsetext(int csc);
+SOMEXTERN void  OPTLINK_DECL somtshowVersion(char *s, char *progname, char *sccsid);
+SOMEXTERN void  OPTLINK_DECL somtsmfree(void *first, ...);
+SOMEXTERN void  OPTLINK_DECL somtunsetEmitSignals(void);
+SOMEXTERN void  OPTLINK_DECL somtwarn(char *file, long lineno, char *fmt, ...);
+SOMEXTERN char * OPTLINK_DECL somtuppercase(char *s, char *buf);
+SOMEXTERN char * OPTLINK_DECL somtlowercase(char *s, char *buf);
+SOMEXTERN char * OPTLINK_DECL somtdbcsuppercase(char *s, char *buf);
+SOMEXTERN char * OPTLINK_DECL somtdbcslowercase(char *s, char *buf);
+SOMEXTERN void  OPTLINK_DECL somtresetEmitSignals(void);
+SOMEXTERN size_t  OPTLINK_DECL somtsizeofEntry(SOMTTypes type);
+SOMEXTERN char * OPTLINK_DECL somtepname(Entry *ep, char *buf, BOOL suppressImpctxCheck);
+SOMEXTERN char * OPTLINK_DECL somtgenSeqName(long n, Entry *base, char *buf, BOOL fullname);
+SOMEXTERN void  OPTLINK_DECL somtmrifatal(char *file, long lineno, int msgnum,...);
+SOMEXTERN void  OPTLINK_DECL somtmriinternal(char *file, long lineno, int msgnum,...);
+SOMEXTERN void  OPTLINK_DECL somtmrierror(char *file, long lineno, int msgnum,...);
+SOMEXTERN void  OPTLINK_DECL somtmrimsg(char *file, long lineno, int msgnum,...);
+SOMEXTERN void  OPTLINK_DECL somtmriwarn(char *file, long lineno, int msgnum,...);
+SOMEXTERN void  OPTLINK_DECL somtsetInternalMessages(char *too_long, char *cant_continue, char *segv, char *bus);
+SOMEXTERN boolean  OPTLINK_DECL somtisvoid(Entry *type, char *defn);
+SOMEXTERN BOOL  OPTLINK_DECL somtreturnsStruct(Entry *ep);
+SOMEXTERN BOOL  OPTLINK_DECL somtreturnsPtr(Entry *ep);
+SOMEXTERN char * OPTLINK_DECL somtsimpleName(Entry *ep);
+SOMEXTERN void  OPTLINK_DECL somtqualifyNames(Stab * stab, BOOL fully);
+SOMEXTERN Entry * OPTLINK_DECL somtfindBaseEpNonPtr(Entry *ep);
+SOMEXTERN BOOL  OPTLINK_DECL somtprocessTraps(void);
+SOMEXTERN Mlist * OPTLINK_DECL somtallocMlist(Entry * ep);
+SOMEXTERN Mlist * OPTLINK_DECL somtmlistend(Mlist * mp, char *name);
+SOMEXTERN BOOL  OPTLINK_DECL somtisMutRef(Entry *ep, Mlist *seen, BOOL isself, long level);
+SOMEXTERN Mlist *  OPTLINK_DECL somtfreeMlist(Mlist *mp);
+SOMEXTERN Mlist *  OPTLINK_DECL somtdupMlist(Mlist *mp, Entry *ep);
+SOMEXTERN void  OPTLINK_DECL somtfreeWorld();
+SOMEXTERN void  OPTLINK_DECL somtInitialiseEmitlib(void);
+SOMEXTERN void  OPTLINK_DECL somtInitialiseSmmeta(void);
+SOMEXTERN void  OPTLINK_DECL somtInitialiseCreatetc(void);
+SOMEXTERN void  OPTLINK_DECL somtInitialiseSmtypes(void);
+SOMEXTERN void  OPTLINK_DECL somtInitialiseSomc(void);
+SOMEXTERN void  OPTLINK_DECL somtInitialiseSmsmall(void);
+SOMEXTERN void  OPTLINK_DECL somtexit(SOMTExitBuf *ebuf, int status);
+SOMEXTERN void  OPTLINK_DECL somtdymain(char *file, Entry *cls, EmitFn emitfn, char *emitter, int first, char *version, Stab *stab);
+SOMEXTERN void  OPTLINK_DECL somtaddHeader(char *file, FILE *fp, char *ext);
+#endif
+
+SOMEXTERN int SOMLINK somttraverseParentsSL(FILE *fp, Entry * cls, Entry *arg, int (*fn)(FILE*,Entry*,Entry*), SMTraverse flg);
+
+SOMEXTERN EmitFn  SOMLINK somtloadSL(char *fileName, char *functionName, void **modHandle);
+SOMEXTERN Entry * SOMLINK somtfindBaseEpSL(Entry *ep);
+SOMEXTERN Entry * SOMLINK somtgetTypeSL(char *name, SOMTTypes type);
+SOMEXTERN FILE * SOMLINK somtokfopenSL(char *path, char *mode);
+SOMEXTERN int  SOMLINK somtokfprintfSL(FILE *, const char *, ...);
+SOMEXTERN int  SOMLINK somtokfputsSL(const char *, FILE *);
+SOMEXTERN int  SOMLINK somtokfputcSL(const char, FILE *);
+SOMEXTERN char * SOMLINK somtokfgetsSL(char *, int, FILE *);
+SOMEXTERN void  SOMLINK somtokrewindSL(FILE *);
+SOMEXTERN int  SOMLINK somtokrenameSL(const char*, const char *);
+SOMEXTERN FILE * SOMLINK somtopenEmitFileSL(char *file, char *ext);
+SOMEXTERN BOOL  SOMLINK somtisDbcsSL(int c);
+SOMEXTERN BOOL  SOMLINK somtremoveExtSL(char *name, char *ext, char *buf);
+SOMEXTERN char * SOMLINK somtaddExtSL(char *name, char *ext, char *buf);
+SOMEXTERN char * SOMLINK somtarrayToPtrSL(Entry *ep, char *stars, char *buf);
+SOMEXTERN char * SOMLINK somtattNormaliseSL(char *name, char *buf);
+SOMEXTERN char * SOMLINK somtbasenameSL(char *path);
+SOMEXTERN char * SOMLINK somtctosSL(Const *con, char *buf);
+SOMEXTERN char * SOMLINK somtdbcsPostincrSL(char **p);
+SOMEXTERN char * SOMLINK somtdbcsPreincrSL(char **p);
+SOMEXTERN char * SOMLINK somtdbcsStrchrSL(char *s, int c);
+SOMEXTERN char * SOMLINK somtdbcsStrrchrSL(char *s, int c);
+SOMEXTERN char * SOMLINK somtdbcsStrstrSL(char *s1, char *s2);
+SOMEXTERN char * SOMLINK somteptotypeSL(Entry *ep, char *ptrs, char *buf);
+SOMEXTERN char * SOMLINK somtgetDescSL(Stab *stab, Entry *cls, Entry *method, char *desc, BOOL addQuotes, BOOL use, BOOL versflg);
+SOMEXTERN char * SOMLINK somtgetVersionSL(char *sccsid, char *version);
+SOMEXTERN char * SOMLINK somtgetgattSL(char *s);
+SOMEXTERN char * SOMLINK somtnextwordSL(const char *s, char *buf);
+SOMEXTERN char * SOMLINK somtnormaliseDescSL(char *desc, char *normal);
+SOMEXTERN char * SOMLINK somtsatosSL(char **sa, char *sep, char *buf);
+SOMEXTERN char * SOMLINK somtsearchFileSL(char *file, char *path, char *envvar);
+SOMEXTERN char * SOMLINK somtskipwsSL(const char *s);
+SOMEXTERN char * SOMLINK somtstringFmtSL(char *fmt, ...);
+SOMEXTERN char * SOMLINK somttypeSL(SOMTTypes type);
+SOMEXTERN char * SOMLINK somtuniqFmtSL(MemBuf *membuf, char *fmt, ...);
+SOMEXTERN int SOMLINK somtargFlagSL(int *argc, char ***argv);
+SOMEXTERN int SOMLINK somtattjoinSL(register AttList *ap1, AttList *ap2);
+SOMEXTERN int SOMLINK somtdbcsLastCharSL(char *buf);
+SOMEXTERN int SOMLINK somtdbcsScanSL(char **buf);
+SOMEXTERN int SOMLINK somtdiskFullSL(FILE *fp);
+SOMEXTERN int SOMLINK somtfcloseSL(FILE *fp);
+SOMEXTERN int SOMLINK somtfexistsSL(char *file);
+SOMEXTERN int SOMLINK somtisparentSL(Entry *cls, Entry *parent);
+SOMEXTERN int SOMLINK somtmgetSL(int setnum, int msgnum, char *msgbuf);
+SOMEXTERN int SOMLINK somtmopenSL(char *filename);
+SOMEXTERN int SOMLINK somtmprintfSL(int setnum, int msgnum, ...);
+SOMEXTERN int SOMLINK somtokremoveSL(char *file);
+SOMEXTERN int SOMLINK somtunloadSL(void *modHandle);
+SOMEXTERN int SOMLINK somtwriteaccessSL(char *file);
+
+// Allocate memory size of nbytes and filled with zeroes if clear flag is set
+SOMEXTERN void * SOMLINK somtsmallocSL(size_t nbytes, BOOL clear);
+SOMEXTERN void SOMLINK somtaddGAttSL(MemBuf **membuf, AttList **ap, char *buf);
+SOMEXTERN void SOMLINK somtcalcFileNameSL(char *def, char *over, char *ext);
+SOMEXTERN void SOMLINK somtcleanFilesFatalSL(int status);
+SOMEXTERN void SOMLINK somtemitTypesSL(FILE *fp, Mlist *mp, Stab *stab);
+SOMEXTERN void SOMLINK somterrorSL(char *file, long lineno, char *fmt, ...);
+SOMEXTERN void SOMLINK somtfatalSL(char *file, long lineno, char *fmt, ...);
+SOMEXTERN void SOMLINK somtinternalSL(char *file, long lineno, char *fmt, ...);
+SOMEXTERN void SOMLINK somtmcloseSL(void);
+SOMEXTERN void SOMLINK somtmsgSL(char *file, long lineno, char *fmt, ...);
+SOMEXTERN void SOMLINK somtreadDescFileSL(Stab *stab, char *file);
+SOMEXTERN void SOMLINK somtsetDefaultDescSL(Stab *stab);
+SOMEXTERN void SOMLINK somtsetEmitSignalsSL(void(*cleanup) (int), void (*internal) (int));
+SOMEXTERN void SOMLINK somtsetTypeDefnSL(Entry *type, Entry *ep, char *ptrs, Entry *ret, BOOL array);
+SOMEXTERN void SOMLINK somtsetextSL(int csc);
+SOMEXTERN void SOMLINK somtshowVersionSL(char *s, char *progname, char *sccsid);
+SOMEXTERN void SOMLINK somtsmfreeSL(void *first, ...);
+SOMEXTERN void SOMLINK somtunsetEmitSignalsSL(void);
+SOMEXTERN void SOMLINK somtwarnSL(char *file, long lineno, char *fmt, ...);
+SOMEXTERN char * SOMLINK somtuppercaseSL(char *s, char *buf);
+SOMEXTERN char * SOMLINK somtlowercaseSL(char *s, char *buf);
+SOMEXTERN char * SOMLINK somtdbcsuppercaseSL(char *s, char *buf);
+SOMEXTERN char * SOMLINK somtdbcslowercaseSL(char *s, char *buf);
+SOMEXTERN void SOMLINK somtresetEmitSignalsSL(void);
+SOMEXTERN size_t SOMLINK somtsizeofEntrySL(SOMTTypes type);
+SOMEXTERN char * SOMLINK somtepnameSL(Entry *ep, char *buf, BOOL suppressImpctxCheck);
+SOMEXTERN char * SOMLINK somtgenSeqNameSL(long n, Entry *base, char *buf, BOOL fullname);
+SOMEXTERN void SOMLINK somtmrifatalSL(char *file, long lineno, int msgnum,...);
+SOMEXTERN void SOMLINK somtmriinternalSL(char *file, long lineno, int msgnum,...);
+SOMEXTERN void SOMLINK somtmrierrorSL(char *file, long lineno, int msgnum,...);
+SOMEXTERN void SOMLINK somtmrimsgSL(char *file, long lineno, int msgnum,...);
+SOMEXTERN void SOMLINK somtmriwarnSL(char *file, long lineno, int msgnum,...);
+SOMEXTERN void SOMLINK somtsetInternalMessagesSL(char *too_long, char *cant_continue, char *segv, char *bus);
+SOMEXTERN BOOL SOMLINK somtisvoidSL(Entry *type, char *defn);
+SOMEXTERN BOOL SOMLINK somtreturnsStructSL(Entry *ep);
+SOMEXTERN BOOL SOMLINK somtreturnsPtrSL(Entry *ep);
+SOMEXTERN char * SOMLINK somtsimpleNameSL(Entry *ep);
+SOMEXTERN void SOMLINK somtqualifyNamesSL(Stab * stab, BOOL fully);
+SOMEXTERN Entry * SOMLINK somtfindBaseEpNonPtrSL(Entry *ep);
+SOMEXTERN BOOL SOMLINK somtprocessTrapsSL(void);
+SOMEXTERN Mlist * SOMLINK somtallocMlistSL(Entry * ep);
+SOMEXTERN Mlist * SOMLINK somtmlistendSL(Mlist * mp, char *name);
+SOMEXTERN BOOL SOMLINK somtisMutRefSL(Entry *ep, Mlist *seen, BOOL isself, long level);
+SOMEXTERN Mlist * SOMLINK somtfreeMlistSL(Mlist *mp);
+SOMEXTERN Mlist * SOMLINK somtdupMlistSL(Mlist *mp, Entry *ep);
+SOMEXTERN void SOMLINK somtfreeWorldSL();
+SOMEXTERN void SOMLINK somtInitialiseEmitlibSL(void);
+SOMEXTERN void SOMLINK somtInitialiseSmmetaSL(void);
+SOMEXTERN void SOMLINK somtInitialiseCreatetcSL(void);
+SOMEXTERN void SOMLINK somtInitialiseSmtypesSL(void);
+SOMEXTERN void SOMLINK somtInitialiseSomcSL(void);
+SOMEXTERN void SOMLINK somtInitialiseSmsmallSL(void);
+SOMEXTERN void SOMLINK somtexitSL(SOMTExitBuf *ebuf, int status);
+SOMEXTERN void SOMLINK somtdymainSL(char *file, Entry *cls, EmitFn emitfn, char *emitter, int first, char *version, Stab *stab);
+SOMEXTERN void SOMLINK somtaddHeaderSL(char *file, FILE *fp, char *ext);
+
+/*
+ * Global variables
+ */
+
+SOMEXTERN global Flags somtg_f;        /* Command line flags structure */
+SOMEXTERN global MemBuf *somtg_membuf; /* Memory buffer for string allocation */
+SOMEXTERN global Mlist *somtglbdefs;   /* Global defs */
+SOMEXTERN global SMEXT somtext;        /* Different idl/oidl extensions */
+SOMEXTERN global Stab *somtstab;       /* Pointer to symbol table */
+SOMEXTERN global BOOL somtaddstar;     /* Cached copy of global WIN32_DLLIMPORT modifier */
+SOMEXTERN global BOOL somtrmstar;      /* Cached copy of global WIN32_DLLIMPORT modifier */
+SOMEXTERN global char *somtg_buf;      /* Comment/pass thru buffer */
+SOMEXTERN global char *somtg_sccsid;   /* version information string */
+SOMEXTERN global char somtfilePath[];  /* input file full path */
+SOMEXTERN global char somtfileStem[];  /* infput file stem */
+SOMEXTERN global char somtoutPath[];   /* output file */
+SOMEXTERN global char *(*somtgetAtt) (AttList *, char *, char **);
+SOMEXTERN global Entry *somtmodule;    /* Pinter to last module encountered */
+SOMEXTERN global Mlist *somtclassList; /* List of classes that sc emits */
+SOMEXTERN global long somtsaved;       /* Bytes saved due to various optimisations steps */
+SOMEXTERN global void *(*somtmalloc)(size_t nbytes); 
+SOMEXTERN global void (*somtfree)(void *bp);        
+SOMEXTERN global void *(*somtcalloc)(size_t nmemb, size_t size);
+SOMEXTERN global void *(*somtrealloc)(void *bp, size_t nbytes); 
+SOMEXTERN global void (*somtcleanup_f) (int); /* cleanup signal function to call */
+SOMEXTERN global void (*somtinternal_f) (int);/* internal signal function to call */
+SOMEXTERN global int somtopenEmitFileCalled; 
+SOMEXTERN global SOMTExitBuf somtipcbuf;  /* global WIN32_DLLIMPORT buffer for the setjmp/longjmp */
+SOMEXTERN global SOMTExitBuf somtscbuf;   /* global WIN32_DLLIMPORT buffer for the setjmp/longjmp */
+SOMEXTERN global void *somtemitReturns; /* Emitter returns */
+SOMEXTERN global void (*somtrealExit)(int status); /* real exit to call */
+
+
+#endif
diff -urN somfree\somc\include\smstd.h newsomfree3\somc\include\smstd.h
--- somfree\somc\include\smstd.h	Thu Jan 01 07:00:00 1970
+++ newsomfree3\somc\include\smstd.h	Sat Mar 16 14:09:25 2024
@@ -0,0 +1,61 @@
+/**************************************************************************
+ *
+ *  Copyright 2022, Yuri Prokushev
+ *
+ *  This file is part of osFree project
+ *
+ *  This program is free software: you can redistribute it and/or modify it
+ *  under the terms of the GNU Lesser General Public License as published by the
+ *  Free Software Foundation, either version 3 of the License, or (at your
+ *  option) any later version.
+ * 
+ *  This program is distributed in the hope that it will be useful, but WITHOUT
+ *  ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ *  FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for
+ *  more details.
+ *
+ *  You should have received a copy of the GNU Lesser General Public License
+ *  along with this program.  If not, see <http://www.gnu.org/licenses/>
+ *
+ */
+
+#ifndef smstd_h
+#define smstd_h
+
+#ifdef __cplusplus      /* Turn off inlining of strcmp, etc for C++ */
+#undef __STR__
+#endif
+
+#include <stdio.h>
+#include <string.h>
+#include <sys/types.h>
+#include <stdlib.h>
+
+#ifndef TRUE
+    #define TRUE 1
+#endif
+#ifndef FALSE
+    #define FALSE 0
+#endif
+
+/*
+ *  Standard typedefs:
+ */
+//typedef int bool;
+
+#ifndef global
+  #define global SOMDLLIMPORT /* Maps onto nothing, used as a prefix to global variables */
+#endif
+
+/*
+ *  Standard NULL casts:
+ */
+#ifndef NULL
+#define NULL   0
+#endif
+#define CNULL       ((char *)0)
+#define FNULL       ((FILE *)0)
+#define VNULL       ((void *)0)
+#define INULL       ((int  *)0)
+
+#endif /* smstd_h */
diff -urN somfree\somc\include\somc_msg.h newsomfree3\somc\include\somc_msg.h
--- somfree\somc\include\somc_msg.h	Thu Jan 01 07:00:00 1970
+++ newsomfree3\somc\include\somc_msg.h	Sat Mar 16 14:09:25 2024
@@ -0,0 +1,262 @@
+/**************************************************************************
+ *
+ *  Copyright 2022, Yuri Prokushev
+ *
+ *  This file is part of osFree project
+ *
+ *  This program is free software: you can redistribute it and/or modify it
+ *  under the terms of the GNU Lesser General Public License as published by the
+ *  Free Software Foundation, either version 3 of the License, or (at your
+ *  option) any later version.
+ * 
+ *  This program is distributed in the hope that it will be useful, but WITHOUT
+ *  ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ *  FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for
+ *  more details.
+ *
+ *  You should have received a copy of the GNU Lesser General Public License
+ *  along with this program.  If not, see <http://www.gnu.org/licenses/>
+ *
+ */
+
+#if defined(__OS2__) || defined(_OS2) || defined(_WDOS) || defined(_WIN16) || defined(_WIN32) || defined(__WINDOWS__)
+  #define STK 1
+  #define SOMT_NAME_TOO_LONG 1
+  #define SOMT_COMMENT_TOO_LONG 2
+  #define SOMT_PROTO_TOO_LONG 3
+  #define SOMT_SYNTAX_ERROR 4
+  #define SOMT_NO_FUNC_NAME 5
+  #define SOMT_EOF 6
+  #define SOMT_MISSING_PAREN 7
+  #define SOMT_MISSING_BRACKET 8
+  #define SOMT_MISSING_QUOTE 9
+  #define SOMT_FILE_NOT_FOUND 10
+  #define SOMT_FILE_READONLY 11
+  #define SOMT_FILE_UPDATED 12
+  #define SOMT_DONE 13
+  #define SOMT_LOW_MEMORY 14
+  #define SOMT_NO_TABLE_ENTRY 15
+  #define SOMT_NO_SECTION_START 16
+  #define SOMT_NO_SECTION_NAME 17
+  #define SOMT_NONMETHOD_ENTRY1 18
+  #define SOMT_NONMETHOD_ENTRY2 19
+  #define SOMT_NO_SYMBOLS_FILE 20
+  #define SOMT_REMOVING_STRUCT 21
+  #define SOMT_REMOVING_UNION 22
+  #define SOMT_IGNORE_RPTD_GEN_APPLY 23
+  #define SOMT_NO_APPLY_NAME 24
+  #define SOMT_PARENT_NOT_FOUND 25
+  #define SOMT_CANT_OVERRIDE 26
+  #define SOMT_USE_XPH_EMITTER 27
+  #define SOMT_BAD_INCLUDE 28
+  #define SOMT_CANT_OPEN 29
+  #define SOMT_STRING_TOO_LONG1 30
+  #define SOMT_STRING_TOO_LONG2 31
+  #define SOMT_DISK_FULL 32
+  #define SOMT_CANT_CONTINUE 33
+  #define SOMT_USER_INTERRUPT 34
+  #define SOMT_AMBIGUITY 35
+  #define SOMT_BAD_MAJOR_VERSION 36
+  #define SOMT_BAD_MINOR_VERSION 37
+  #define SOMT_BAD_FILESTEM 38
+  #define SOMT_BAD_FNPREFIX 39
+  #define SOMT_BAD_EXTPREFIX 40
+  #define SOMT_BAD_EXTSTEM 41
+  #define SOMT_PRIVATE_XOR_PUBLIC 42
+  #define SOMT_BAD_PRIVATE 43
+  #define SOMT_BAD_PUBLIC 44
+  #define SOMT_BEFORE_XOR_AFTER 45
+  #define SOMT_BAD_BEFORE 46
+  #define SOMT_BAD_AFTER 47
+  #define SOMT_NO_MAJOR_VERSION 48
+  #define SOMT_NO_MINOR_VERSION 49
+  #define SOMT_IO_FILES_SAME 50
+  #define SOMT_NO_STAR_TO_REMOVE 51
+  #define SOMT_NO_DESCRIPTOR 52
+  #define SOMT_ALREADY_SET_DESCRIPTOR 53
+  #define SOMT_BAD_DESCRIPTOR_FORMAT 54
+  #define SOMT_CANT_ALLOC1 55
+  #define SOMT_CANT_ALLOC2 56
+  #define SOMT_VERSION 57
+  #define SOMT_COPYRIGHT 58
+  #define SOMT_LICENSED 59
+  #define SOMT_RESTRICTED 60
+  #define SOMT_DISCLOSURE 61
+  #define SOMT_DATE_MODIFIED 62
+  #define SOMT_DATE_COMPILED 63
+  #define SOMT_TWO_SOURCE_FILES 64
+  #define SOMT_NO_SOURCE_FILE 65
+  #define SOMT_UNKNOWN_ENTRY_TYPE 66
+  #define SOMT_CANT_REMOVE 67
+  #define SOMT_REMOVED_FILE 68
+  #define SOMT_NO_CLASS_NAME 69
+  #define SOMT_BAD_OVERRIDE 70
+  #define SOMT_DUPLICATE_ID 71
+  #define SOMT_DOTS_INVALID 72
+  #define SOMT_IGNORE_PARENT 73
+  #define SOMT_ALREADY_USED 74
+  #define SOMT_ALREADY_DEFINED 75
+  #define SOMT_ALREADY_DECLARED 76
+  #define SOMT_ALREADY_DECLARED_IN 77
+  #define SOMT_ALREADY_DECLARED_IN_MOD 78
+  #define SOMT_IGNORE_MODIFIER 79
+  #define SOMT_IGNORE_METACLASS 80
+  #define SOMT_USE_PRIVATE 81
+  #define SOMT_FN_XOR_EXT_PREFIX 82
+  #define SOMT_MODIFIER_CLASH 83
+  #define SOMT_BAD_INHERIT_LIST 84
+  #define SOMT_NO_PARENT 85
+  #define SOMT_NOT_DECLARED 86
+  #define SOMT_NOT_A_PARENT 87
+  #define SOMT_SIGNATURES_DIFFER 88
+  #define SOMT_PARENT_REPEATED 89
+  #define SOMT_OVERRIDE_NOT_IN_BASE 90
+  #define SOMT_NO_OVERRIDE 91
+  #define SOMT_PROCEDURE 92
+  #define SOMT_NO_PROTOTYPE 93
+  #define SOMT_ALREADY_CLASS_NAME 94
+  #define SOMT_SCOPE_EMPTY 95
+  #define SOMT_SCOPE_OVERRUN 96
+  #define SOMT_CANT_FIND_EMITTER 97
+  #define SOMT_INVALID_UFLAG 98
+  #define SOMT_STATUS 99
+  #define SOMT_UNKNOWN_OPTION 100
+  #define SOMT_NEED_ARGUMENT 101
+  #define SOMT_BAD_RELEASE 102
+  #define SOMT_RELEASE_NOT_METHOD 103
+  #define SOMT_ADDING_TO_RELEASE 104
+  #define SOMT_LOADING 105
+  #define SOMT_UNLOADING 106
+  #define SOMT_CANNOT_LOAD 107
+  #define SOMT_CANNOT_UNLOAD 108
+  #define SOMT_LINE_TOO_LONG 109
+  #define SOMT_TOKEN_TOO_LONG 110
+  #define SOMT_UNEXPECTED_DBCS 111
+  #define SOMT_NO_END_PASSTHRU 112
+  #define SOMT_NEWLINE_IN_MODIFIER 113
+  #define SOMT_ERROR_REMOVING_TEMPFILE 114
+  #define SOMT_CANT_RUN_SHELL_CMD 115
+  #define SOMT_BUS_ERROR 116
+  #define SOMT_SEGMENTATION_FAULT 117
+  #define SOMT_EMPTY_SOURCE 118
+  #define SOMT_BAD_DELIMITER 119
+  #define SOMT_BAD_COMMENT_PLACE 120
+  #define SOMT_NO_CLASS_SECTION 121
+  #define SOMT_DUPLICATE_STATEMENT 122
+  #define SOMT_DUPLICATE_RELEASE 123
+  #define SOMT_BAD_STRING_SIZE 124
+  #define SOMT_BAD_COMMENT_SIZE 125
+  #define SOMT_NO_STRUCT_MEMBERS 126
+  #define SOMT_NOT_A_CONSTANT 127
+  #define SOMT_ILLEGAL_USE_RELEASE 128
+  #define SOMT_CLASS_REQD_FOR_METACLASS 129
+  #define SOMT_METACLASS_MUST_DIFFER 130
+  #define SOMT_OUT_OF_RANGE 131
+  #define SOMT_INVALID_OPERAND 132
+  #define SOMT_NO_NESTED_STRUCTS 133
+  #define SOMT_UNKNOWN_SIZE 134
+  #define SOMT_REPEATED_PARAMETER 135
+  #define SOMT_NO_ARRAY_ATTRIBUTES 136
+  #define SOMT_TYPE_MISMATCH 137
+  #define SOMT_CANT_APPLY 138
+  #define SOMT_UNDEFINED_OPERATOR 139
+  #define SOMT_DUPLICATE_CASE 140
+  #define SOMT_MULTIPLE_DEFAULTS 141
+  #define SOMT_IMPLEMENTATION_ALREADY_DECLARED 142
+  #define SOMT_ONLY_SHORT_OR_LONG 143
+  #define SOMT_NOT_AN_EXCEPTION 144
+  #define SOMT_NO_MULTIPLE_INHERITANCE 145
+  #define SOMT_BAD_METACLASS 146
+  #define SOMT_IGNORE_REPEATED_METACLASS 147
+  #define SOMT_NONPORTABLE_INT 148
+  #define SOMT_IS_NEGATIVE 149
+  #define SOMT_EXCEPTION_EXPECTS_BRACES 150
+  #define SOMT_MIXED_TYPE_ILLEGAL 151
+  #define SOMT_UNDEFINED_FOR_STRINGS 152
+  #define SOMT_BAD_CASE_EXPRESSION 153
+  #define SOMT_CASE_EXPRESSION_MISMATCH 154
+  #define SOMT_CASE_TOO_BIG 155
+  #define SOMT_NONCORBA_STARS 156
+  #define SOMT_NONCORBA_IMPL_SECTION 157
+  #define SOMT_NONCORBA_UNSIGNEDS 158
+  #define SOMT_RUNNING_SHELL 159
+  #define SOMT_NUMBER_ERRORS 160
+  #define SOMT_SHOW_USAGE1 161
+  #define SOMT_SHOW_USAGE2 162
+  #define SOMT_SHOW_USAGE3 163
+  #define SOMT_SHOW_USAGE4 164
+  #define SOMT_SHOW_USAGE5 165
+  #define SOMT_SHOW_USAGE6 166
+  #define SOMT_SHOW_USAGE7 167
+  #define SOMT_SHOW_USAGE8 168
+  #define SOMT_SHOW_USAGE9 169
+  #define SOMT_SHOW_USAGE10 170
+  #define SOMT_SHOW_USAGE11 171
+  #define SOMT_SHOW_USAGE12 172
+  #define SOMT_SHOW_USAGE13 173
+  #define SOMT_SHOW_USAGE14 174
+  #define SOMT_SHOW_USAGE15 175
+  #define SOMT_SHOW_USAGE16 176
+  #define SOMT_SHOW_USAGE17 177
+  #define SOMT_SHOW_USAGE18 178
+  #define SOMT_SHOW_USAGE19 179
+  #define SOMT_SHOW_USAGE20 180
+  #define SOMT_SHOW_MODS 181
+  #define SOMT_SHOW_MODS01 182
+  #define SOMT_SHOW_MODS02 183
+  #define SOMT_SHOW_MODS03 184
+  #define SOMT_SHOW_MODS04 185
+  #define SOMT_SHOW_MODS05 186
+  #define SOMT_SHOW_MODS06 187
+  #define SOMT_SHOW_MODS07 188
+  #define SOMT_SHOW_MODS08 189
+  #define SOMT_SHOW_MODS09 190
+  #define SOMT_SHOW_MODS10 191
+  #define SOMT_SHOW_MODS11 192
+  #define SOMT_SHOW_MODS12 193
+  #define SOMT_SHOW_MODS13 194
+  #define SOMT_SHOW_MODS14 195
+  #define SOMT_SHOW_MODS15 196
+  #define SOMT_SHOW_VARS 197
+  #define SOMT_SHOW_VARS1 198
+  #define SOMT_SHOW_VARS2 199
+  #define SOMT_SHOW_VARS3 200
+  #define SOMT_SHOW_VARS4 201
+  #define SOMT_SHOW_VARS5 202
+  #define SOMT_SHOW_PRAGMAS 203
+  #define SOMT_SHOW_PRAGMAS1 204
+  #define SOMT_SHOW_PRAGMAS2 205
+  #define SOMT_SHOW_PRAGMAS3 206
+  #define SOMT_NO_IMPL_FILE 207
+  #define SOMT_ATTRIBUTE_TOO_LONG 208
+  #define SOMT_OUTLINE_TOO_LONG 209
+  #define SOMT_IR_FOREIGN1 210
+  #define SOMT_IR_FOREIGN2 211
+  #define SOMT_IR_MISSINGALIGN 212
+  #define SOMT_IR_TYPEERROR 213
+  #define SOMT_IR_UNEXPECTED 214
+  #define SOMT_IR_MBRERROR 215
+  #define SOMT_IR_ERRORTOTAL 216
+  #define SOMT_IR_OPENERROR 217
+  #define SOMT_IR_OPENFAIL 218
+  #define SOMT_BAD_RIGHT_SHIFT 219
+  #define SOMT_DIFF_SILE_STEM 220
+  #define SOMT_QUALIFYING 221
+  #define SOMT_UNQUALIFYING 222
+  #define SOMT_NO_SEQ_PTRS 223
+  #define SOMT_NO_STRING_PTRS 224
+  #define SOMT_UNION_PTR_TYPE 225
+  #define SOMT_FINAL_VA_LIST 226
+  #define SOMT_BAD_COMID 227
+  #define SOMT_BAD_INITOV 228
+  #define SOMT_REINTRO_HIDE 229
+  #define SOMT_NO_OBJWRAPPER 230
+  #define SOMT_BAD_ENTRY 231
+  #define SOMT_ADDING_DATA_TO_RELEASE 232
+  #define SOMT_BAD_MIGRATION 233
+  #define SOMT_somtImplemented 234
+  #define SOMT_somtOverridden 235
+  #define SOMT_somtInherited 236
+  #define SOMT_somtAllVisible 237
+  #define SOMT_somtAll 238
+#endif
diff -urN somfree\somc\include\symtab.h newsomfree3\somc\include\symtab.h
--- somfree\somc\include\symtab.h	Thu Jan 01 07:00:00 1970
+++ newsomfree3\somc\include\symtab.h	Sun Mar 17 10:44:40 2024
@@ -0,0 +1,166 @@
+/**************************************************************************
+ *
+ *  Copyright 2022, Yuri Prokushev
+ *
+ *  This file is part of osFree project
+ *
+ *  This program is free software: you can redistribute it and/or modify it
+ *  under the terms of the GNU Lesser General Public License as published by the
+ *  Free Software Foundation, either version 3 of the License, or (at your
+ *  option) any later version.
+ * 
+ *  This program is distributed in the hope that it will be useful, but WITHOUT
+ *  ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ *  FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for
+ *  more details.
+ *
+ *  You should have received a copy of the GNU Lesser General Public License
+ *  along with this program.  If not, see <http://www.gnu.org/licenses/>
+ *
+ */
+
+/*
+ * This is implementation of Symbol Tables for SOM Compiler.
+ */
+
+#ifndef symtab_h
+#define symtab_h
+
+#include <stddef.h>
+
+#include <smcidl.h>
+#include <sm.h>
+
+//#include <som.h>
+
+#ifdef _WIN32
+#include <windows.h>
+#endif
+
+#ifdef __OS2__
+#include <os2.h>
+#endif
+
+#define SepNULL     (Sep *) NULL
+
+/*
+ * Forward reference the Symbol table:
+ */
+struct Stab;
+
+/*               
+ * Default Entry for a symbol table
+ */
+_typedef struct SEntry {
+    char *name;
+} _name(SEntry);
+
+/*
+ * Keyword structure.
+ */
+_typedef struct KeyTabEntry {
+    char *kword;
+    long token;
+} _name(KeytabEntry);
+
+/*
+ * Symbol table entry linked list
+ */
+_typedef struct Sep {
+    size_t posn;
+    SEntry *ep;		// Entry
+    struct Sep *next;	// Next liked list item
+} _name(Sep);
+
+/*
+ *  MemBuf is the structure used to allocate new memory in contiguous blocks.
+ *  We can use it for unique strings too if the uniq flag is set when calling
+ *  somtcreateMemBuf().
+ */
+_typedef struct MemBuf {
+    char *base;
+    size_t size;
+    size_t nelms;
+    char *cur;
+    _struct Stab *stab;
+} _name(MemBuf);
+
+/*
+ * Basic Symbol Table/Hash table (STab) structure.
+ */
+_typedef struct Stab {
+    size_t size;		// Size of buscet
+    long entrysize;		// Size of entry?
+    size_t nelms;		// Number of elements
+    Sep *base;			// Start slot
+    Sep *limit;			// Max of slots
+    Sep *buf;			// Start of buffer
+    MemBuf *membuf;             // Parent(?) memory buffer which stores Stab
+    BOOL ignorecase;		// Ignore case os string
+} _name(Stab);
+
+#ifndef __SOMIDL__
+
+#include <optlink.h>
+
+// Here old Optlink caling convention functions having SOMLINK equals
+#ifndef SOM_SOMC_NO_BACKCOMPAT
+SOMEXTERN char * OPTLINK_DECL somtallocBuf(MemBuf *membuf, void *buf, long len);
+SOMEXTERN char * OPTLINK_DECL somtuniqString(MemBuf *membuf, char *s);
+SOMEXTERN long  OPTLINK_DECL somtkeyword(KeytabEntry *keytab, char *kword, long keytabsize);
+SOMEXTERN void * OPTLINK_DECL somtaddEntry(Stab *stab, char *name, void *ep);
+SOMEXTERN void * OPTLINK_DECL somtgetEntry(Stab *stab, char *name);
+SOMEXTERN void * OPTLINK_DECL somtstabFirst(Stab *stab, Sep **sepp);
+SOMEXTERN void * OPTLINK_DECL somtstabFirstName(Stab *stab, char *name, Sep **sepp);
+SOMEXTERN void * OPTLINK_DECL somtstabNext(Stab *stab, Sep **sepp);
+SOMEXTERN void * OPTLINK_DECL somtstabNextName(Stab *stab, Sep **sepp);
+SOMEXTERN void  OPTLINK_DECL somtcreateMemBuf(MemBuf **membufp, size_t bufsize, long stabsize);
+SOMEXTERN void  OPTLINK_DECL somtcreateStab(Stab *stab, long stabsize, long entrysize);
+SOMEXTERN int  OPTLINK_DECL somticstrcmp(char *s, char *t);
+SOMEXTERN void * OPTLINK_DECL somtaddEntryBuf(Stab *stab, char *name, void *ep, void *buf, size_t len);
+SOMEXTERN void  OPTLINK_DECL somtfreeStab(Stab *stab, BOOL freeEp);
+#else
+#define somtallocBuf somtallocBufSL
+#define somtuniqString somtuniqStringSL
+#define somtkeyword somtkeywordSL
+#define somtaddEntry somtaddEntrySL
+#define somtgetEntry somtgetEntrySL
+#define somtstabFirst somtstabFirstSL
+#define somtstabFirstName somtstabFirstNameSL
+#define somtstabNext somtstabNextSL
+#define somtstabNextName somtstabNextNameSL
+#define somtcreateMemBuf somtcreateMemBufSL
+#define somtcreateStab somtcreateStabSL
+#define somticstrcmp somticstrcmpSL
+#define somtaddEntryBuf somtaddEntryBufSL
+#define somtfreeStab somtfreeStabSL
+#endif
+
+SOMEXTERN char * SOMLINK somtallocBufSL(MemBuf *membuf, void *buf, long len);
+SOMEXTERN char * SOMLINK somtuniqStringSL(MemBuf *membuf, char *s);
+SOMEXTERN long SOMLINK somtkeywordSL(KeytabEntry *keytab, char *kword, long keytabsize);
+
+// Add 'ep' Entry structure to 'stab' Symbol Table under 'name' symbol
+SOMEXTERN void * SOMLINK somtaddEntrySL(Stab *stab, char *name, void *ep);
+
+SOMEXTERN void * SOMLINK somtgetEntrySL(Stab *stab, char *name);
+SOMEXTERN void * SOMLINK somtstabFirstSL(Stab *stab, Sep **sepp);
+SOMEXTERN void * SOMLINK somtstabFirstNameSL(Stab *stab, char *name, Sep **sepp);
+SOMEXTERN void * SOMLINK somtstabNextSL(Stab *stab, Sep **sepp);
+SOMEXTERN void * SOMLINK somtstabNextNameSL(Stab *stab, Sep **sepp);
+SOMEXTERN void SOMLINK somtcreateMemBufSL(MemBuf **membufp, size_t bufsize, long stabsize);
+
+// Initialize Symbol Table.
+// Initialize 'stab' structure and allocate Hash index table slots (stabsize) for Entries by 'entrysize'.
+SOMEXTERN void SOMLINK somtcreateStabSL(Stab *stab, long stabsize, long entrysize);
+
+// Case-insenstive ANSI string  comparation
+SOMEXTERN int SOMLINK somticstrcmpSL(char *s, char *t);
+
+SOMEXTERN void * SOMLINK somtaddEntryBufSL(Stab *stab, char *name, void *ep, void *buf, size_t len);
+
+
+SOMEXTERN void SOMLINK somtfreeStabSL(Stab *stab, BOOL freeEp);
+
+#endif  /* __SOMIDL__ */
+#endif  /* symtab_h */
diff -urN somfree\somc\makedefs.cf newsomfree3\somc\makedefs.cf
--- somfree\somc\makedefs.cf	Thu Jan 01 07:00:00 1970
+++ newsomfree3\somc\makedefs.cf	Sat Mar 16 14:09:25 2024
@@ -0,0 +1,3 @@
+NAME somc
+DEPENDS someprep
+PROVIDES somc
diff -urN somfree\somc\src\emitlib.c newsomfree3\somc\src\emitlib.c
--- somfree\somc\src\emitlib.c	Thu Jan 01 07:00:00 1970
+++ newsomfree3\somc\src\emitlib.c	Sat Mar 16 14:09:25 2024
@@ -0,0 +1,727 @@
+#define global
+#include <emitlib.h>
+
+global int somtCPP;          /* C++ bindings */
+global boolean somtclassIdlCall;/* IDL Calling convention */
+global char *somtclassName;  /* Current Class Name */
+global char *somtclassPrefix;/* Current Class Prefix */
+global char *somtg_somlink;  /* Set to "SOMLINK" when required - csc, psc emitters turn this off. */
+global char *somtmajorVersion; /* Major version number for class */
+global char *somtminorVersion; /* Minor version number for class */
+global int somtmeta;         /* TRUE when in implicit meta mode */
+global char *somtmp;         /* Set to SMMETA_PREFIX when somtmeta is TRUE */
+global Entry *somtsomcls;    /* Pointer to SOMClass Entry in Symbol Table */
+
+// Use IBM SOM 3.0 ABI for non SOMLINK functions (1) or IBM SOM 2.1 ABI (0)
+SOMEXTERN int somtSOM30ABI;
+
+#ifndef SOM_SOMC_NO_BACKCOMPAT
+SOMEXTERN Entry * OPTLINK_DECL somtnthArg(Entry * method, int n)
+{
+  return NULL;
+}
+
+SOMEXTERN FILE * OPTLINK_DECL somtemitModule(char *file, Entry *cls, char *ext)
+{
+  if (somtSOM30ABI)
+  {
+    OPTLINK_3ARGS(file, cls, ext);
+  }
+
+  return somtemitModuleSL(file, cls, ext);
+}
+
+SOMEXTERN Mlist * OPTLINK_DECL somtallocDataList(Entry *cls)
+{
+  return NULL;
+}
+
+SOMEXTERN Mlist * OPTLINK_DECL somtallocMethodList(Entry *cls, boolean all)
+{
+  return NULL;
+}
+
+SOMEXTERN char * OPTLINK_DECL somtclsfilename(Entry * cls)
+{
+  return NULL;
+}
+
+SOMEXTERN char * OPTLINK_DECL somtclsname(Entry * cls)
+{
+  if (somtSOM30ABI)
+  {
+    OPTLINK_1ARG(cls);
+  }
+
+  return somtclsnameSL(cls);
+}
+
+SOMEXTERN char * OPTLINK_DECL somtfindMethodName(const char *bp, char *name)
+{
+  return NULL;
+}
+
+SOMEXTERN char * OPTLINK_DECL somtfullPrototype(char *buf, Entry * method, char *sep, int varargs)
+{
+  return NULL;
+}
+
+SOMEXTERN char * OPTLINK_DECL somtfullTypedef(char *buf, Entry * cls, Entry * method)
+{
+  return NULL;
+}
+
+SOMEXTERN char * OPTLINK_DECL somtgetNonRepeatedParent(Entry *cls, int i)
+{
+  return NULL;
+}
+
+
+SOMEXTERN char * OPTLINK_DECL somtgetdatt(Entry * ep, char *s)
+{
+  return NULL;
+}
+
+SOMEXTERN enum SOMTABIStyle  OPTLINK_DECL somtgetAbistyle( Entry * ep )
+{
+  return SOMTABIStyle_unknown;
+}
+
+SOMEXTERN char * OPTLINK_DECL somtimplicit(Entry *ep, boolean shortform, char *buf)
+{
+  return NULL;
+}
+
+SOMEXTERN char * OPTLINK_DECL somtimplicitArgs(Entry *ep)
+{
+  return NULL;
+}
+
+SOMEXTERN char * OPTLINK_DECL somtincludeOnce(Entry *cls, char *ext, char *buf)
+{
+  if (somtSOM30ABI)
+  {
+    OPTLINK_3ARGS(cls, ext, buf);
+  }
+
+  return somtincludeOnceSL(cls, ext, buf);
+}
+
+SOMEXTERN char * OPTLINK_DECL somtpclsfilename(Entry *parent)
+{
+  return NULL;
+}
+
+SOMEXTERN char * OPTLINK_DECL somtpclsname(Entry *parent)
+{
+  return NULL;
+}
+
+SOMEXTERN char * OPTLINK_DECL somtprefixedPrototype(char *buf, Entry * method, char *sep, int varargs, char *prefix)
+{
+  return NULL;
+}
+
+SOMEXTERN char * OPTLINK_DECL somtreplaceDataName(char *buf, Entry * data, char *replace)
+{
+  return NULL;
+}
+
+SOMEXTERN char * OPTLINK_DECL somtrmSelf(char *str)
+{
+  return NULL;
+}
+
+SOMEXTERN char * OPTLINK_DECL somtshortArgList(char *buf, Entry * method, char *sep, boolean varargs, boolean addself)
+{
+  return NULL;
+}
+
+SOMEXTERN int  OPTLINK_DECL somtimplicitMeta(Entry *cls)
+{
+  return 0;
+}
+
+SOMEXTERN int  OPTLINK_DECL somtlistAttribute(FILE * fp, int n, AttList * ap, char *s, boolean value, boolean breakLine, boolean firstComma)
+{
+  return 0;
+}
+
+SOMEXTERN int  OPTLINK_DECL somtnewMethodsCount(Entry * cls, int meta, boolean procflg)
+{
+  return 0;
+}
+
+SOMEXTERN int  OPTLINK_DECL somtprivateMethodsCount(Entry * cls, int meta)
+{
+  return 0;
+}
+
+SOMEXTERN void  OPTLINK_DECL somtaddHeader(char *file, FILE *fp, char *ext)
+{
+  if (somtSOM30ABI)
+  {
+    OPTLINK_3ARGS(file, fp, ext);
+  }
+
+  somtaddHeaderSL(file, fp, ext);
+}
+
+SOMEXTERN void  OPTLINK_DECL somtcleanFiles(int status)
+{
+  if (somtSOM30ABI)
+  {
+    OPTLINK_1ARG(status);
+  }
+  
+  somtcleanFilesSL(status);
+}
+
+SOMEXTERN void  OPTLINK_DECL somtdeclareIdlVarargs(FILE *fp, Entry *ep)
+{
+}
+
+SOMEXTERN void  OPTLINK_DECL somtdymain(char *file, Entry *cls, EmitFn emitfn, char *emitter, int first, char *version, Stab *stab)
+{
+  if (somtSOM30ABI)
+  {
+    OPTLINK_3ARGS(file, cls, emitfn);
+  }
+
+  somtdymainSL(file, cls, emitfn, emitter, first, version, stab);
+}
+
+SOMEXTERN void  OPTLINK_DECL somtemitModuleTypes(FILE *fp, Entry *ep, Stab *stab)
+{
+}
+
+SOMEXTERN long  OPTLINK_DECL somtemitPassthru(FILE * fp, Entry * cls, char *name, int mode, char *att)
+{
+  return 0;
+}
+
+SOMEXTERN void  OPTLINK_DECL somtfreeDataList(Mlist *mlist)
+{
+}
+
+SOMEXTERN void  OPTLINK_DECL somtfreeMethodList(Mlist *mlist)
+{
+}
+
+SOMEXTERN void  OPTLINK_DECL somtfullComment(FILE * fp, char *fmt,...)
+{
+  va_list args;
+  if (somtSOM30ABI)
+  {
+    OPTLINK_2ARGS(fp, fmt);
+  }
+
+  va_start (args, fmt);
+  vsprintf(somtg_buf, fmt, args);
+  va_end (args);
+
+  somtoidlCommentSL(fp, 0, 65, 'c', somtg_buf);
+}
+
+SOMEXTERN void  OPTLINK_DECL somthandleDiskFull(FILE *fp)
+{
+}
+
+char *nullStr="";
+
+SOMEXTERN void  OPTLINK_DECL somtinitialiseMeta(Entry * cls, Stab * stab, boolean meta, int imp)
+{
+  if (!somtsomcls)
+  {
+    somtsomcls=somtgetEntry(stab, "SOMClass");
+  }
+  
+  if (!imp)
+  {
+    
+  }
+
+  if (meta)
+  {
+  }
+  else
+  {
+    somtmeta=0;
+    somtmp=nullStr;
+  }
+}
+
+SOMEXTERN void  OPTLINK_DECL somtoidlComment(FILE * fp, int min, int max, char style, char *comment)
+{
+  if (somtSOM30ABI)
+  {
+    OPTLINK_3ARGS(fp, min, max);
+  }
+
+  somtoidlCommentSL(fp, min, max, style, comment);
+}
+
+SOMEXTERN void  OPTLINK_DECL somtscmsg(Entry *cls, Entry *ep, char *fmt, ...)
+{
+}
+
+SOMEXTERN void  OPTLINK_DECL somtshortDefine(FILE *fp, Entry *ep, char *fmt, ...)
+{
+}
+
+SOMEXTERN void  OPTLINK_DECL somtuninitialiseMeta(Entry * cls)
+{
+}
+
+SOMEXTERN FILE * OPTLINK_DECL somtobseleteHeaderFile(char *file, Entry *cls, char *ext, char *newext)
+{
+  if (somtSOM30ABI)
+  {
+    OPTLINK_3ARGS(file, cls, ext);
+  }
+
+  return somtobseleteHeaderFileSL(file, cls, ext, newext);
+}
+
+SOMEXTERN char * OPTLINK_DECL somtwidenType(Entry *ep, char *args, char *type)
+{
+  return NULL;
+}
+
+SOMEXTERN void  OPTLINK_DECL somtgenAttStubs(FILE *fp, Entry *cls, char *prefix, char *classprefix)
+{
+}
+
+SOMEXTERN void  OPTLINK_DECL somtstrictidl(FILE *fp)
+{
+  if (somtSOM30ABI)
+  {
+    OPTLINK_1ARG(fp);
+  }
+
+  somtstrictidlSL(fp);
+}
+
+SOMEXTERN void  OPTLINK_DECL somtcreateTypeCodes (Stab *stab)
+{
+}
+
+SOMEXTERN TypeCode * OPTLINK_DECL somtemitTcConstant (TypeCode t, FILE *f, char *name, TypeCode *alreadyDone)
+{
+  return NULL;
+}
+
+SOMEXTERN void  OPTLINK_DECL somtemitPredefinedTcConstants (FILE *f)
+{
+}
+
+SOMEXTERN Entry * OPTLINK_DECL somtAncestorClass(Entry *cls, char *name)
+{
+  return NULL;
+}
+
+SOMEXTERN short  OPTLINK_DECL somttcAlignment (TypeCode t, Environment *ev)
+{
+  return 0;
+}
+
+SOMEXTERN long  OPTLINK_DECL somttcSize (TypeCode t, Environment *ev)
+{
+  return 0;
+}
+
+SOMEXTERN TCKind  OPTLINK_DECL somttcKind (TypeCode t, Environment *ev)
+{
+  return (TCKind)NULL;
+}
+
+SOMEXTERN sequence(string)  OPTLINK_DECL somttcSeqFromListString (string s)
+{
+  sequence(string) st={0,0,NULL};
+  return st;
+}
+
+SOMEXTERN _IDL_SEQUENCE_EntryPtr  OPTLINK_DECL somtGetReintroducedMethods(Entry *cls)
+{
+  _IDL_SEQUENCE_EntryPtr seq={0,0,NULL};
+  return seq;
+}
+
+#endif
+
+SOMEXTERN Entry * SOMLINK somtnthArgSL(Entry * method, int n)
+{
+  return NULL;
+}
+
+SOMEXTERN FILE * SOMLINK somtemitModuleSL(char *file, Entry *cls, char *ext)
+{
+  return somtopenEmitFileSL(file, ext);
+}
+
+SOMEXTERN Mlist * SOMLINK somtallocDataListSL(Entry *cls)
+{
+  return NULL;
+}
+
+SOMEXTERN Mlist * SOMLINK somtallocMethodListSL(Entry *cls, boolean all)
+{
+  return NULL;
+}
+
+SOMEXTERN char * SOMLINK somtclsfilenameSL(Entry * cls)
+{
+  return NULL;
+}
+
+char classnamebuf[260];
+
+SOMEXTERN char * SOMLINK somtclsnameSL(Entry * cls)
+{
+  if (somtmeta)
+  {
+    return cls->name;
+  }
+  else
+  {
+    if (cls)
+    {
+      if(cls==somtsomcls)
+      {
+        if(!strcmp("SOMObject", cls->name))
+        {
+          sprintf(classnamebuf, "M_%s", cls->name);
+          return classnamebuf;
+        }
+      }
+    }
+    strcpy(classnamebuf, somtsomcls->name);
+  }
+
+  return classnamebuf;
+}
+
+SOMEXTERN char * SOMLINK somtfindMethodNameSL(const char *bp, char *name)
+{
+  return NULL;
+}
+
+SOMEXTERN char * SOMLINK somtfullPrototypeSL(char *buf, Entry * method, char *sep, int varargs)
+{
+  return NULL;
+}
+
+SOMEXTERN char * SOMLINK somtfullTypedefSL(char *buf, Entry * cls, Entry * method)
+{
+  return NULL;
+}
+
+SOMEXTERN char * SOMLINK somtgetNonRepeatedParentSL(Entry *cls, int i)
+{
+  return NULL;
+}
+
+SOMEXTERN char * SOMLINK somtgetdattSL(Entry * ep, char *s)
+{
+  return NULL;
+}
+
+SOMEXTERN enum SOMTABIStyle  SOMLINK somtgetAbistyleSL( Entry * ep )
+{
+  return SOMTABIStyle_2;
+}
+
+SOMEXTERN char * SOMLINK somtimplicitSL(Entry *ep, boolean shortform, char *buf)
+{
+  return NULL;
+}
+
+SOMEXTERN char * SOMLINK somtimplicitArgsSL(Entry *ep)
+{
+  return NULL;
+}
+
+SOMEXTERN char * SOMLINK somtincludeOnceSL(Entry *cls, char *ext, char *buf)
+{
+  sprintf(buf, "SOM_%s_%s", somtclsnameSL(cls), ext); 
+  return buf;
+}
+
+SOMEXTERN char * SOMLINK somtpclsfilenameSL(Entry *parent)
+{
+  return NULL;
+}
+
+SOMEXTERN char * SOMLINK somtpclsnameSL(Entry *parent)
+{
+  return NULL;
+}
+
+SOMEXTERN char * SOMLINK somtprefixedPrototypeSL(char *buf, Entry * method, char *sep, int varargs, char *prefix)
+{
+  return NULL;
+}
+
+SOMEXTERN char * SOMLINK somtreplaceDataNameSL(char *buf, Entry * data, char *replace)
+{
+  return NULL;
+}
+
+SOMEXTERN char * SOMLINK somtrmSelfSL(char *str)
+{
+  return NULL;
+}
+
+SOMEXTERN char * SOMLINK somtshortArgListSL(char *buf, Entry * method, char *sep, boolean varargs, boolean addself)
+{
+  return NULL;
+}
+
+SOMEXTERN int  SOMLINK somtimplicitMetaSL(Entry *cls)
+{
+  return 0;
+}
+
+SOMEXTERN int  SOMLINK somtlistAttributeSL(FILE * fp, int n, AttList * ap, char *s, boolean value, boolean breakLine, boolean firstComma)
+{
+  return 0;
+}
+
+SOMEXTERN int  SOMLINK somtnewMethodsCountSL(Entry * cls, int meta, boolean procflg)
+{
+  return 0;
+}
+
+SOMEXTERN int  SOMLINK somtprivateMethodsCountSL(Entry * cls, int meta)
+{
+  return 0;
+}
+
+SOMEXTERN void  SOMLINK somtaddHeaderSL(char *file, FILE *fp, char *ext)
+{
+}
+
+SOMEXTERN void  SOMLINK somtcleanFilesSL(int status)
+{
+  if (somtoutPath) somtokremove(somtoutPath);
+  somtexit(&somtipcbuf, -1);
+}
+
+SOMEXTERN void  SOMLINK somtdeclareIdlVarargsSL(FILE *fp, Entry *ep)
+{
+}
+
+SOMEXTERN void  SOMLINK somtdymainSL(char *file, Entry *cls, EmitFn emitfn, char *emitter, int first, char *version, Stab *stab)
+{
+}
+
+SOMEXTERN void  SOMLINK somtemitModuleTypesSL(FILE *fp, Entry *ep, Stab *stab)
+{
+}
+
+SOMEXTERN long  SOMLINK somtemitPassthruSL(FILE * fp, Entry * cls, char *name, int mode, char *att)
+{
+  return 0;
+}
+
+SOMEXTERN void  SOMLINK somtfreeDataListSL(Mlist *mlist)
+{
+}
+
+SOMEXTERN void  SOMLINK somtfreeMethodListSL(Mlist *mlist)
+{
+}
+
+SOMEXTERN void  SOMLINK somtfullCommentSL(FILE * fp, char *fmt,...)
+{
+  va_list args;
+
+  va_start (args, fmt);
+  vsprintf(somtg_buf, fmt, args);
+  va_end (args);
+
+  somtoidlCommentSL(fp, 0, 65, 'c', somtg_buf);
+}
+
+SOMEXTERN void  SOMLINK somthandleDiskFullSL(FILE *fp)
+{
+}
+
+SOMEXTERN void  SOMLINK somtinitialiseMetaSL(Entry * cls, Stab * stab, boolean meta, int imp)
+{
+}
+
+SOMEXTERN void  SOMLINK somtoidlCommentSL(FILE * fp, int min_, int max_, char style, char *comment)
+{
+  string line;
+  string buf;
+  string prefix;
+  int buflen;
+
+  if (comment && comment[0])
+  {
+    if (comment[0]==0x01) // comment style passed in comment string
+    {
+      if(!style)  // if style 0 then style in comment string
+      {
+        style=comment[0];
+      }
+      comment+=2;
+    }
+
+    switch (style)
+    {
+      case '/':
+      case '#':
+      case 'c':
+      case 's':
+      case 'd':
+      case '+':
+        break;
+      default: style='c';
+    }
+
+    prefix=(string)malloc(80);
+
+    for(buflen=0;buflen<=min_;buflen++)
+    {
+      prefix[buflen]=' ';
+    }
+    prefix[buflen]=0x0;
+
+    fprintf(fp, "\n");
+    if (style=='c') fprintf(fp, "/*\n");
+  
+    buf = strdup(comment);
+
+    line = strtok(buf, "\n");
+    while(line) 
+    {
+      fprintf(fp, prefix);
+      switch (style)
+      {
+        case '/': fprintf(fp, "//# %s\n", line);
+          break;
+        case '#': fprintf(fp, "# %s\n", line);
+          break;
+        case 'c': fprintf(fp, " * %s \n", line);
+          break;
+        case 's': fprintf(fp, "-- %s\n", line);
+          break;
+        case 'd': fprintf(fp, "; %s \n", line);
+          break;
+        case '+': fprintf(fp, "//  %s\n", line);
+          break;
+      }
+      line  = strtok(NULL, "\n");
+    }
+
+    if (style=='c') fprintf(fp, " */\n");
+
+    free(buf);
+    free(prefix);
+  }
+}
+
+SOMEXTERN void  SOMLINK somtscmsgSL(Entry *cls, Entry *ep, char *fmt, ...)
+{
+}
+
+SOMEXTERN void  SOMLINK somtshortDefineSL(FILE *fp, Entry *ep, char *fmt, ...)
+{
+}
+
+SOMEXTERN void  SOMLINK somtuninitialiseMetaSL(Entry * cls)
+{
+}
+
+SOMEXTERN FILE * SOMLINK somtobseleteHeaderFileSL(char *file, Entry *cls, char *ext, char *newext)
+{
+  FILE * fp;
+  char buf[4048];
+
+  if (cls)
+  {
+    if (cls->type==SOMTClassE)
+    {
+      fp=somtopenEmitFileSL(file, ext);
+      somtincludeOnceSL(cls, newext, buf);
+      fprintf(fp, "\n#ifndef %s\n", buf);
+      somtfullCommentSL(fp, "The %s emitter simply includes the .%s file now.\nAnd can be removed from you SMEMIT environment and your source files.", ext, newext);
+      fprintf(fp, "\n#include <%s.%s>\n", somtfileStem, newext);
+      fprintf(fp, "\n#endif /* %s */\n", buf);
+      return fp;
+    }
+ 
+    if (cls->type==SOMTModuleE)
+    {
+      return somtemitModuleSL(file, cls, ext);
+    }
+
+  }
+  return NULL;
+}
+
+SOMEXTERN char * SOMLINK somtwidenTypeSL(Entry *ep, char *args, char *type)
+{
+  return NULL;
+}
+
+SOMEXTERN void  SOMLINK somtgenAttStubsSL(FILE *fp, Entry *cls, char *prefix, char *classprefix)
+{
+}
+
+SOMEXTERN void  SOMLINK somtstrictidlSL(FILE *fp)
+{
+  if (somtaddstar)
+  {
+    somtfullComment( fp, "The SOM_STRICT_IDL macro means that we can ignore stars\nin our declarations of objects.");
+    fprintf(fp,"#define SOM_STRICT_IDL 1");
+  }
+}
+
+SOMEXTERN void  SOMLINK somtcreateTypeCodesSL(Stab *stab)
+{
+}
+
+SOMEXTERN TypeCode * SOMLINK somtemitTcConstantSL(TypeCode t, FILE *f, char *name, TypeCode *alreadyDone)
+{
+  return NULL;
+}
+
+SOMEXTERN void  SOMLINK somtemitPredefinedTcConstantsSL(FILE *f)
+{
+}
+
+SOMEXTERN Entry * SOMLINK somtAncestorClassSL(Entry *cls, char *name)
+{
+  return NULL;
+}
+
+SOMEXTERN short  SOMLINK somttcAlignmentSL(TypeCode t, Environment *ev)
+{
+  return 0;
+}
+
+SOMEXTERN long  SOMLINK somttcSizeSL(TypeCode t, Environment *ev)
+{
+  return 0;
+}
+
+SOMEXTERN TCKind  SOMLINK somttcKindSL(TypeCode t, Environment *ev)
+{
+  return (TCKind)NULL;
+}
+
+SOMEXTERN sequence(string)  SOMLINK somttcSeqFromListStringSL(string s)
+{
+  sequence(string) st={0,0,NULL};
+  return st;
+}
+
+SOMEXTERN _IDL_SEQUENCE_EntryPtr  SOMLINK somtGetReintroducedMethodsSL(Entry *cls)
+{
+  _IDL_SEQUENCE_EntryPtr seq={0,0,NULL};
+  return seq;
+}
+
diff -urN somfree\somc\src\fio.c newsomfree3\somc\src\fio.c
--- somfree\somc\src\fio.c	Thu Jan 01 07:00:00 1970
+++ newsomfree3\somc\src\fio.c	Sat Mar 16 14:09:25 2024
@@ -0,0 +1,29 @@
+/**************************************************************************
+ *
+ *  Copyright 2022, Yuri Prokushev
+ *
+ *  This file is part of osFree project
+ *
+ *  This program is free software: you can redistribute it and/or modify it
+ *  under the terms of the GNU Lesser General Public License as published by the
+ *  Free Software Foundation, either version 3 of the License, or (at your
+ *  option) any later version.
+ * 
+ *  This program is distributed in the hope that it will be useful, but WITHOUT
+ *  ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ *  FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for
+ *  more details.
+ *
+ *  You should have received a copy of the GNU Lesser General Public License
+ *  along with this program.  If not, see <http://www.gnu.org/licenses/>
+ *
+ */
+
+/*
+
+  File related functions.
+
+  This "wrappers" around standard C Library.
+
+*/
+
diff -urN somfree\somc\src\list.txt newsomfree3\somc\src\list.txt
--- somfree\somc\src\list.txt	Thu Jan 01 07:00:00 1970
+++ newsomfree3\somc\src\list.txt	Sat Mar 16 14:09:25 2024
@@ -0,0 +1,132 @@
+Functions USED by IBM emitters
+				30nt	30os2	21nt	21os2
+somtdbcsStrchr			+		+
+somtdbcsStrstr			+		+
+somtfexists			+		+
+somtgetVersion			+		+
+somtgetatt			+		+
+somtgetAtt			+		+
+somtgetgatt			+		+
+somthandleDiskFull		+		+
+somtisDbcs			+		+
+somtmrierror			+		+
+somtmrifatal			+		+
+somtmrimsg			+		+
+somtmriwarn			+		+
+somtoidlComment			+		+
+somtokfopen			+		+
+somtsmalloc			+		+
+somtsmfree			+		+
+somttcSeqFromListString		+		+
+somtwriteaccess			+		+
+somtclassList			+		+
+somtclassPrefix			+		+
+somtfcloseSL			+		-
+somtfclose			-		+
+somtg_f				+		+
+somtmodule			+		+
+somtopenEmitFileSL		+		-
+somtopenEmitFile		-		+
+somtresetEmitSignalsSL		+		-
+somtresetEmitSignals		-		+
+somtunsetEmitSignalsSL		+		-
+somtunsetEmitSignals		-		+
+somtAncestorClass		+		+
+somtGetReintroducedMethods	+		+
+somtParentNumFromName		+		?
+somtfullPrototype		+		+
+somtgetAbistyle			+		-
+somtclassIdlCall		+		+
+somtnotc			+		-
+somtattNormalise		+		-
+somtemitModule			+		+
+somtgetdatt			+		+
+somtlistAttribute		+		-
+somtrmSelf			+		+
+somtext				+		-
+somtg_somlink			+		+
+somtdbcslowercase		+		+
+somtaddstar			+		+
+somterrorSL			+		-
+somtfilePath			+		+
+somtfileStem			+		+
+somtg_sccsid			+		+
+somtaddExt			+		-
+somtaddHeader			+		-
+somtdbcsStrrchr			+		+
+somtimplicitMeta		+		+
+somtinitialiseMeta		+		+
+somtnextword			+		-
+somtokremove			+		+
+somtremoveExt			+		-
+somtskipws			+		-
+somtuninitialiseMeta		+		+
+somtoutPath			+		+
+somtDllStem			+		-
+somtdbcsScan			+		-
+somtincludeOnce			+		+
+somtfullComment			+		+
+somtemitModuleTypes		+		+
+somtemitPassthru		+		+
+somtemitTypes			+		+
+somtemitPredefinedTypeCode	+		-
+somteptotype			+		-
+somtfindBaseEp			+		-
+somtfullTypedef			+		+
+somtimplicitArgs		+		+
+somtisvoid			+		-
+somtmriinternal			+		+
+somtnthArg			+		+
+somtpclsfilename		+		+
+somtprefixedPrototype		+		+
+somtreturnsStruct		+		+
+somtshortArgList		+		+
+somtshortDefine			+		+
+somtstrictidl			+		+
+somtobseleteHeaderFile		+		-
+somtimplicit			+		-
+somtmajorVersion		+		+
+somtminorVersion		+		+
+somtmeta			+		+
+somtclsname			+		+
+somtcreateTypeCodes		+		+
+somtdeclareIdlVarargs		+		+
+somtfindMethodName		+		+
+somtsatos			+		+
+somttcAlignment			+		+
+somttcKind			+		+
+somttcSize			+		+
+somtallocMlist			+		-
+somtmlistend			+		-
+somtbasename			+		-
+somtctos			+		+
+somtglbdefs			+		+
+somtaddEntry			+		+
+somtcreateStab			+		+
+somtgetEntry			+		+
+somtpclsname			+		+
+somtCPP				+		+
+somtokrewind			-		+
+somtokfgets			-		+
+somtokfputc			-		+
+somtokrename			-		+
+somtokfprintf			-		+
+somtreplaceDataName		-		+
+somtinternal			-		+
+somtokfputs			-		+
+somtstringFmt			-		+
+somtcleanFilesFatal		-		+
+somtstabNext			-		+
+somtmp				-		+
+somtnewMethodsCount		-		+
+somtsomcls			-		+
+somtgetNonRepeatedParent	-		+
+somtgenAttStubs			-		+
+somtstabFirst			-		+
+somtprivateMethodsCount		-		+
+
+
+
+Under 30nt all functions without SL is a Optlink version. somFree somc.dll switches Optlink SOMLINK calling convention
+via function somtloadSL (not exist in original somc.dll) depending on succes load of emitSL or emit function. Under
+windows calling convention switches. Under other OSes always SOMLINK is used.
diff -urN somfree\somc\src\modifiers.c newsomfree3\somc\src\modifiers.c
--- somfree\somc\src\modifiers.c	Thu Jan 01 07:00:00 1970
+++ newsomfree3\somc\src\modifiers.c	Sat Mar 16 14:09:25 2024
@@ -0,0 +1,70 @@
+/**************************************************************************
+ *
+ *  Copyright 2022, Yuri Prokushev
+ *
+ *  This file is part of osFree project
+ *
+ *  This program is free software: you can redistribute it and/or modify it
+ *  under the terms of the GNU Lesser General Public License as published by the
+ *  Free Software Foundation, either version 3 of the License, or (at your
+ *  option) any later version.
+ * 
+ *  This program is distributed in the hope that it will be useful, but WITHOUT
+ *  ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ *  FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for
+ *  more details.
+ *
+ *  You should have received a copy of the GNU Lesser General Public License
+ *  along with this program.  If not, see <http://www.gnu.org/licenses/>
+ *
+ */
+
+/*
+
+  Modifiers related functions.
+
+  In OILD used term 'attribute', but in IDL used term 'modifier' because attribute is another meaning.
+
+*/
+
+#define global
+#include <emitlib.h>
+
+// Use IBM SOM 3.0 ABI for non SOMLINK functions (1) or IBM SOM 2.1 ABI (0)
+SOMEXTERN int somtSOM30ABI;
+
+global char *(*somtgetAtt) (AttList *, char *, char **);
+
+SOMEXTERN char * OPTLINK_DECL somtgetatt(Entry * ep, char *s)
+{
+  return NULL;
+}
+
+SOMEXTERN char * SOMLINK somtgetattSL(Entry * ep, char *s)
+{
+  return NULL;
+}
+
+SOMEXTERN AttList * SOMLINK somtaddModifierSL(AttList *ap, char * modifier, char * value)
+{
+  AttList * res=ap;
+  AttList * cur=ap;
+
+  if (!res)
+  {
+    res=(AttList *)somtsmallocSL(sizeof(AttList), TRUE);
+    cur=res;
+  } else {
+    while (cur->next)
+    {
+      cur=cur->next;
+    }
+    cur->next=(AttList *)somtsmallocSL(sizeof(AttList), TRUE);
+    cur=cur->next;
+  }
+
+  cur->name=strdup(modifier);
+  if (value) cur->value=strdup(value);
+
+  return res;
+}
diff -urN somfree\somc\src\notes.txt newsomfree3\somc\src\notes.txt
--- somfree\somc\src\notes.txt	Thu Jan 01 07:00:00 1970
+++ newsomfree3\somc\src\notes.txt	Sat Mar 16 14:09:25 2024
@@ -0,0 +1,12 @@
+todo:
+
+somtfree - uses default calling convention of library. So, for IBM SOM 3.0 NT required to be Optlink. But this is variable,
+not function. So, not clear how to correctly handle it...
+
+not to do:
+
+somtsetext - єяЁрты хЄ эрёЄЁющъющ Ёрё°шЁхэшщ Їрщыют, р Єръцх тэєЄЁхээшь Їыруюь, юёє∙хёЄты Є№ ыш яЁхюсЁрчютрэшх шьхэ ьюфшЇшърЄюЁют,
+             Єръцх юяЁхфхы хЄ Єшя√ ъюьхэЄрЁшхт, шьхэр ъюьяшы ЄюЁют ш шь  рЄЁшсєЄр filestem (т oidl шёяюы№чєхЄё  file stem).
+             ╧ю ёєЄш, эрёЄЁрштрхЄ somc эр ЄюЄ шыш шэющ ЇюЁьрЄ т√тюфр (IDL/OIDL) ш ярЁёшэур.
+
+somtattMap - яЁхюсЁрчєхЄ classdata ш classmethod т class. ┬ юяшёрэшш эшуфх эх эр°хы, тшфшью уфх-Єю т ёЄрЁ√ї OIDL шёяюы№чютрыюё№.
diff -urN somfree\somc\src\smlib.c newsomfree3\somc\src\smlib.c
--- somfree\somc\src\smlib.c	Thu Jan 01 07:00:00 1970
+++ newsomfree3\somc\src\smlib.c	Sat Mar 16 14:09:25 2024
@@ -0,0 +1,253 @@
+#define global
+#include <emitlib.h>
+
+#ifndef SOM_SOMC_NO_BACKCOMPAT
+
+// Use IBM SOM 3.0 ABI for non SOMLINK functions (1) or IBM SOM 2.1 ABI (0)
+SOMEXTERN int somtSOM30ABI;
+
+SOMEXTERN EmitFn  SOMLINK somtloadSL(char *fileName, char *functionName, void **modHandle)
+{
+  EmitFn proc=NULL;
+  HMODULE hmod=NULL;
+
+  #ifdef _WIN32
+  hmod=LoadLibraryA(fileName);
+  if (hmod) proc=(EmitFn)GetProcAddress(hmod, functionName);
+  #endif
+
+  #ifdef _OS2_
+  APIRET rc = 0;
+  UCHAR szErrorName[CCHMAXPATH];   /* CCHMAXPATH defined in bsedos.h */
+
+  /* Load module.           */
+  rc=DosLoadModule(szErrorName, CCHMAXPATH-1, fileName, &hmod);
+  if (!rc) rc = DosQueryProcAddr(hmod, 0, functionName, (PFN *) proc);
+  if (rc) {hmod=NULL; proc=NULL;}
+  #endif
+
+  if (modHandle) *modHandle=hmod;
+
+  if ((void *)proc) 
+  {
+    if (!strcmp(fileName, "emitSL")) somtSOM30ABI=1;
+    if (!strcmp(fileName, "emit")) somtSOM30ABI=0;
+  };
+
+  return proc;
+}
+
+SOMEXTERN char * OPTLINK_DECL somttype(SOMTTypes stype)
+{
+  if (somtSOM30ABI)
+  {
+    unsigned char t=(unsigned char)stype;
+    OPTLINK_1ARG_BYTE(t);
+  }
+
+  return somttypeSL(stype);
+}
+
+#endif
+
+SOMEXTERN char * SOMLINK somttypeSL(SOMTTypes type)
+{
+  char * result = NULL;
+  switch ( type )
+  {
+    case SOMTAnyBE:
+      result="SOMTAnyBE";
+      break;
+    case     SOMTArgumentE:
+      result="SOMTArgumentE";
+      break;
+    case     SOMTAttE:
+      result="SOMTAttE";
+      break;
+    case     SOMTBadEntryE:
+      result="SOMTBadEntryE";
+      break;
+    case     SOMTBaseE:
+      result="SOMTBaseE";
+      break;
+    case     SOMTBooleanBE:
+      result="SOMTBooleanBE";
+      break;
+    case     SOMTCaseEntryE:
+      result="SOMTCaseEntryE";
+      break;
+    case     SOMTCaseListE:
+      result="SOMTCaseListE";
+      break;
+    case     SOMTCaseSTME:
+      result="SOMTCaseSTME";
+      break;
+    case     SOMTCharBE:
+      result="SOMTCharBE";
+      break;
+    case     SOMTClassE:
+      result="SOMTClassE";
+      break;
+    case     SOMTConstE:
+      result="SOMTConstE";
+      break;
+    case     SOMTCopyrightE:
+      result="SOMTCopyrightE";
+      break;
+    case     SOMTDataE:
+      result="SOMTDataE";
+      break;
+    case     SOMTDclListE:
+      result="SOMTDclListE";
+      break;
+    case     SOMTDefaultE:
+      result="SOMTDefaultE";
+      break;
+    case     SOMTDoubleBE:
+      result="SOMTDoubleBE";
+      break;
+    case     SOMTEBaseE:
+      result="SOMTEBaseE";
+      break;
+    case     SOMTEEnumE:
+      result="SOMTEEnumE";
+      break;
+    case     SOMTEnumBE:
+      result="SOMTEnumBE";
+      break;
+    case     SOMTEnumE:
+      result="SOMTEnumE";
+      break;
+    case     SOMTEnumPE:
+      result="SOMTEnumPE";
+      break;
+    case     SOMTFloatBE:
+      result="SOMTFloatBE";
+      break;
+    case     SOMTGroupE:
+      result="SOMTGroupE";
+      break;
+    case     SOMTLongBE:
+      result="SOMTLongBE";
+      break;
+    case     SOMTMetaE:
+      result="SOMTMetaE";
+      break;
+    case     SOMTModuleE:
+      result="SOMTModuleE";
+      break;
+    case     SOMTNegativeBE:
+      result="SOMTNegativeBE";
+      break;
+    case     SOMTNewMethodE:
+      result="SOMTNewMethodE";
+      break;
+    case     SOMTOctetBE:
+      result="SOMTOctetBE";
+      break;
+    case     SOMTOverriddenMethodE:
+      result="SOMTOverriddenMethodE";
+      break;
+    case     SOMTOverrideMethodE:
+      result="SOMTOverrideMethodE";
+      break;
+    case     SOMTPassthruE:
+      result="SOMTPassthruE";
+      break;
+    case     SOMTSequenceE:
+      result="SOMTSequenceE";
+      break;
+    case     SOMTSequenceTDE:
+      result="SOMTSequenceTDE";
+      break;
+    case     SOMTShortBE:
+      result="SOMTShortBE";
+      break;
+    case     SOMTStringBE:
+      result="SOMTStringBE";
+      break;
+    case     SOMTStringE:
+      result="SOMTStringE";
+      break;
+    case     SOMTStructE:
+      result="SOMTStructE";
+      break;
+    case     SOMTStructPE:
+      result="SOMTStructPE";
+      break;
+    case     SOMTStructSE:
+      result="SOMTStructSE";
+      break;
+    case     SOMTTyDclE:
+      result="SOMTTyDclE";
+      break;
+    case     SOMTTypeCodeBE:
+      result="SOMTTypeCodeBE";
+      break;
+    case     SOMTTypedefBE:
+      result="SOMTTypedefBE";
+      break;
+    case     SOMTTypedefE:
+      result="SOMTTypedefE";
+      break;
+    case     SOMTUnionE:
+      result="SOMTUnionE";
+      break;
+    case     SOMTUnionPE:
+      result="SOMTUnionPE";
+      break;
+    case     SOMTUnionSE:
+      result="SOMTUnionSE";
+      break;
+    case     SOMTUnsignedLongBE:
+      result="SOMTUnsignedLongBE";
+      break;
+    case     SOMTUnsignedShortBE:
+      result="SOMTUnsignedShortBE";
+      break;
+    case     SOMTVoidBE:
+      result="SOMTVoidBE";
+      break;
+    case     SOMTVoidPtrBE:
+      result="SOMTVoidPtrBE";
+      break;
+// This is special case SOMTTypes used on call of emitter start and emitter end
+/*    case     SOMTEmitterBeginE:
+      result="SOMTEmitterBeginE";
+      break;
+    case     SOMTEmitterEndE:
+      result="SOMTEmitterEndE";
+      break; */
+    default:
+      somterrorSL(__FILE__, __LINE__, "Unknown entry type: %d.\n", type);
+  }
+  return result;
+}
+
+global Flags somtg_f;        /* Command line flags structure */
+global MemBuf *somtg_membuf; /* Memory buffer for string allocation */
+global Mlist *somtglbdefs;   /* Global defs */
+global SMEXT somtext;        /* Different idl/oidl extensions */
+global Stab *somtstab;       /* Pointer to symbol table */
+global BOOL somtaddstar;     /* Cached copy of global WIN32_DLLIMPORT modifier */
+global BOOL somtrmstar;      /* Cached copy of global WIN32_DLLIMPORT modifier */
+global char *somtg_buf;      /* Comment/pass thru buffer */
+global char *somtg_sccsid;   /* version information string */
+global char somtfilePath[255];  /* input file full path */
+global char somtfileStem[255];  /* infput file stem */
+global char somtoutPath[255];   /* output file */
+global Entry *somtmodule;    /* Pointer to last module encountered */
+global Mlist *somtclassList; /* List of classes that sc emits */
+global long somtsaved;       /* Bytes saved due to various optimisations steps */
+global void *(*somtmalloc)(size_t nbytes) = malloc; 
+global void (*somtfree)(void *bp) = free;
+global void *(*somtcalloc)(size_t nmemb, size_t size);
+global void *(*somtrealloc)(void *bp, size_t nbytes); 
+global void (*somtcleanup_f) (int); /* cleanup signal function to call */
+global void (*somtinternal_f) (int);/* internal signal function to call */
+global int somtopenEmitFileCalled; 
+global SOMTExitBuf somtipcbuf;  /* global WIN32_DLLIMPORT buffer for the setjmp/longjmp */
+global SOMTExitBuf somtscbuf;   /* global WIN32_DLLIMPORT buffer for the setjmp/longjmp */
+global void *somtemitReturns; /* Emitter returns */
+global void (*somtrealExit)(int status); /* real exit to call */
+
diff -urN somfree\somc\src\somc.c newsomfree3\somc\src\somc.c
--- somfree\somc\src\somc.c	Thu Jan 01 07:00:00 1970
+++ newsomfree3\somc\src\somc.c	Sat Mar 16 14:09:25 2024
@@ -0,0 +1,1948 @@
+/**************************************************************************
+ *
+ *  Copyright 2022, Yuri Prokushev
+ *
+ *  This file is part of osFree project
+ *
+ *  This program is free software: you can redistribute it and/or modify it
+ *  under the terms of the GNU Lesser General Public License as published by the
+ *  Free Software Foundation, either version 3 of the License, or (at your
+ *  option) any later version.
+ * 
+ *  This program is distributed in the hope that it will be useful, but WITHOUT
+ *  ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ *  FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for
+ *  more details.
+ *
+ *  You should have received a copy of the GNU Lesser General Public License
+ *  along with this program.  If not, see <http://www.gnu.org/licenses/>
+ *
+ */
+
+#define global
+#include <emitlib.h>
+
+#include <direct.h> // _getcwd
+
+// Use IBM SOM 3.0 ABI for non SOMLINK functions (1) or IBM SOM 2.1 ABI (0)
+int somtSOM30ABI=0;
+
+SOMEXTERN FILE * SOMLINK somtopenEmitFileSL (char *file, char *ext)
+{
+  somtopenEmitFileCalled=1;
+//  somtremoveExt(file, filename, fileext);
+//  somtaddExt();
+  // ╨Ч╨┤╨╡╤Б╤М ╨╜╨╡╨╛╨▒╤Е╨╛╨┤╨╕╨╝╨╛ ╨┐╤А╨╡╨┤╨▓╨░╤А╨╕╤В╨╡╨╗╤М╨╜╨╛ ╨┤╨╛╨▒╨░╨▓╨╕╤В╤М ╨╕╨╗╨╕ ╨╖╨░╨╝╨╡╨╜╨╕╤В╤М ╤А╨░╤Б╤И╨╕╤А╨╡╨╜╨╕╨╡ ╨╜╨░ ext
+  return fopen(file, "w");
+};
+
+#ifndef SOM_SOMC_NO_BACKCOMPAT
+SOMEXTERN FILE * OPTLINK_DECL somtopenEmitFile (char *file, char *ext)
+{
+  if (somtSOM30ABI)
+  {
+    OPTLINK_2ARGS(file,ext);
+  }
+
+  return somtopenEmitFileSL (file, ext);
+};
+#endif
+
+SOMEXTERN int SOMLINK somtfcloseSL (FILE *fp)
+{
+  return fclose(fp);
+}
+
+#ifndef SOM_SOMC_NO_BACKCOMPAT
+SOMEXTERN int OPTLINK_DECL somtfclose (FILE *fp)
+{
+  if (somtSOM30ABI)
+  {
+    OPTLINK_1ARG(fp);
+  }
+  return somtfcloseSL (fp);
+}
+#endif
+
+#ifndef SOM_SOMC_NO_BACKCOMPAT
+SOMEXTERN void OPTLINK_DECL somtmsg(char *file, long lineno, char *fmt, ...)
+{
+  va_list args;
+
+  if (somtSOM30ABI)
+  {
+    OPTLINK_3ARGS(file, lineno, fmt);
+  }
+
+  printf("(%s: %d) ", file, lineno);
+  va_start(args, fmt);
+  vprintf(fmt, args);
+  va_end( args );
+  printf("\n");
+}
+#endif
+
+
+SOMEXTERN void SOMLINK somtmsgSL(char *file, long lineno, char *fmt, ...)
+{
+  va_list args;
+
+  printf("(%s: %d) ", file, lineno);
+  va_start(args, fmt);
+  vprintf(fmt, args);
+  va_end( args );
+  printf("\n");
+}
+
+#ifndef SOM_SOMC_NO_BACKCOMPAT
+SOMEXTERN void OPTLINK_DECL somtwarn(char *file, long lineno, char *fmt, ...)
+{
+  va_list args;
+
+  if (somtSOM30ABI)
+  {
+    OPTLINK_3ARGS(file, lineno, fmt);
+  }
+
+  printf("warning: (%s: %d) ", file, lineno);
+  va_start(args, fmt);
+  vprintf(fmt, args);
+  va_end( args );
+  printf("\n");
+}
+#endif
+
+SOMEXTERN void SOMLINK somtwarnSL(char *file, long lineno, char *fmt, ...)
+{
+  va_list args;
+
+  printf("warning: (%s: %d) ", file, lineno);
+  va_start(args, fmt);
+  vprintf(fmt, args);
+  va_end( args );
+  printf("\n");
+}
+
+//SOMEXTERN void SOMLINK somtresetEmitSignalsSL();
+//SOMEXTERN void SOMLINK somtunsetEmitSignalsSL(void);
+//SOMEXTERN void somtresetEmitSignals();
+//SOMEXTERN void somtunsetEmitSignals(void);
+
+#ifndef SOM_SOMC_NO_BACKCOMPAT
+SOMEXTERN void OPTLINK_DECL somterror(char *file, long lineno, char *fmt, ...)
+{
+  va_list args;
+
+  if (somtSOM30ABI)
+  {
+    OPTLINK_3ARGS(file, lineno, fmt);
+  }
+
+  printf("error: (%s: %d) ", file, lineno);
+  va_start(args, fmt);
+  vprintf(fmt, args);
+  va_end( args );
+  printf("\n");
+}
+#endif
+
+SOMEXTERN void SOMLINK somterrorSL(char *file, long lineno, char *fmt, ...)
+{
+  va_list args;
+
+  printf("error: (%s: %d) ", file, lineno);
+  va_start(args, fmt);
+  vprintf(fmt, args);
+  va_end( args );
+  printf("\n");
+}
+
+#ifndef SOM_SOMC_NO_BACKCOMPAT
+SOMEXTERN void OPTLINK_DECL somtfatal(char *file, long lineno, char *fmt, ...)
+{
+  va_list args;
+
+  if (somtSOM30ABI)
+  {
+    OPTLINK_3ARGS(file, lineno, fmt);
+  }
+
+  printf("fatal error: (%s: %d) ", file, lineno);
+  va_start(args, fmt);
+  vprintf(fmt, args);
+  va_end( args );
+  printf("\n");
+}
+#endif
+
+SOMEXTERN void SOMLINK somtfatalSL(char *file, long lineno, char *fmt, ...)
+{
+  va_list args;
+
+  printf("Fatal error: (%s: %d) ", file, lineno);
+  va_start(args, fmt);
+  vprintf(fmt, args);
+  va_end( args );
+  printf("\n");
+}
+
+#ifndef SOM_SOMC_NO_BACKCOMPAT
+SOMEXTERN void OPTLINK_DECL somtinternal(char *file, long lineno, char *fmt, ...)
+{
+  va_list args;
+
+  if (somtSOM30ABI)
+  {
+    OPTLINK_3ARGS(file, lineno, fmt);
+  }
+
+  printf("internal error: (%s: %d) ", file, lineno);
+  va_start(args, fmt);
+  vprintf(fmt, args);
+  va_end( args );
+  printf("\n");
+}
+#endif
+
+SOMEXTERN void SOMLINK somtinternalSL(char *file, long lineno, char *fmt, ...)
+{
+  va_list args;
+
+  printf("internal error: (%s: %d) ", file, lineno);
+  va_start(args, fmt);
+  vprintf(fmt, args);
+  va_end( args );
+  printf("\n");
+}
+
+SOMEXTERN BOOL OPTLINK_DECL somtfexists(char *file)
+{
+  if (somtSOM30ABI)
+  {
+    OPTLINK_1ARG(file);
+  }
+
+  return somtfexistsSL(file);
+}
+
+SOMEXTERN BOOL SOMLINK somtfexistsSL(char *file)
+{
+  return (_access(file, 4)==0);  // Try RO access
+}
+
+SOMEXTERN char * OPTLINK_DECL somtsearchFile(char *file, char *fullpath, char *env)
+{
+  if (somtSOM30ABI)
+  {
+    OPTLINK_3ARGS(file, fullpath, env);
+  }
+
+  return somtsearchFileSL(file, fullpath, env);
+}
+
+SOMEXTERN char * SOMLINK somtsearchFileSL(char *file, char *fullpath, char *env)
+{
+  char *path;
+#if defined(_WIN32) || defined(__OS2__) || defined(__DOS__)
+  char magic=';';
+#else
+  char magic=':';
+#endif
+
+  if (!file) return NULL;
+  if (!file[0]) return NULL;
+
+  if (somtfexistsSL(file))
+  {
+    return strcpy(fullpath, file);
+  }
+  else
+  {
+    if (file[0]=='/') return NULL;
+#if defined(_WIN32) || defined(__OS2__) || defined(__DOS__)
+    if (file[0]=='\\') return NULL;
+    if (file[1]==':') return NULL;
+#endif
+
+    path=getenv(env);
+
+#if !defined(_WIN32) || !defined(__OS2__) || !defined(__DOS__)
+    if (!path) path="/bin:/usr/bin:";
+#endif
+
+    if (path)
+    {
+      while (*path)
+      {
+        char buf[1024];
+        char *q;
+
+        q=buf;
+
+        while ((*path)&&(*path !=magic))
+        {
+          *q=*path;
+          path++;
+          q++;
+        }
+        *q=0;
+        if (*path) path++;
+
+        if (!buf[0])
+        {
+          _getcwd(buf,sizeof(buf));
+        }
+
+        if (buf[0])
+        {
+          if (!strcmp(buf,"."))
+          {
+            _getcwd(buf,sizeof(buf));
+          }
+          sprintf("%s%c",buf, SMSLASH);
+          strncat(buf,file,sizeof(buf)-1);
+
+          if (somtfexistsSL(buf))
+          {
+            return strcpy(fullpath,buf);
+          }
+        }
+      }
+    }
+    return NULL;
+  }
+}
+
+#ifndef SOM_SOMC_NO_BACKCOMPAT
+SOMEXTERN int OPTLINK_DECL somttraverseParents(FILE *fp, Entry * cls, Entry *arg, int (*fn)(FILE*,Entry*,Entry*), SMTraverse flg)
+{
+  if (somtSOM30ABI)
+  {
+    OPTLINK_3ARGS(fp, cls, arg);
+  }
+
+  return somttraverseParentsSL(fp, cls, arg, fn, flg);
+}
+
+SOMEXTERN Entry * OPTLINK_DECL somtfindBaseEp(Entry *ep)
+{
+  if (somtSOM30ABI)
+  {
+    OPTLINK_1ARG(ep);
+  }
+
+  return somtfindBaseEpSL(ep);
+}
+
+SOMEXTERN Entry * OPTLINK_DECL somtgetType(char *name, SOMTTypes ttype)
+{
+  if (somtSOM30ABI)
+  {
+    unsigned char t=(unsigned char)ttype;
+    OPTLINK_2ARGS_DWORD_BYTE(name, t);
+  }
+
+  return somtgetTypeSL(name, ttype);
+}
+
+SOMEXTERN FILE * OPTLINK_DECL somtokfopen(char *path, char *mode)
+{
+  if (somtSOM30ABI)
+  {
+    OPTLINK_2ARGS(path, mode);
+  }
+
+  return somtokfopenSL(path, mode);
+}
+
+SOMEXTERN int  OPTLINK_DECL somtokfprintf(FILE * fp, const char * fmt, ...)
+{
+  return 0;
+}
+
+/*
+SOMEXTERN int  OPTLINK_DECL somtokfputs(const char * c, FILE * f)
+{
+  OPTLINK_2ARGS(c, f);
+
+  return somtokfputsSL(c, f);
+}
+
+SOMEXTERN int OPTLINK_DECL somtokfputc(const char c, FILE * f)
+{
+  OPTLINK_2ARGS(c, f);
+
+  return somtokfputcSL(c, f);
+}
+
+SOMEXTERN char * OPTLINK_DECL somtokfgets(char * c, int n, FILE * f)
+{
+  OPTLINK_3ARGS(c, n, f);
+
+  return somtokfgetsSL(c, n, f);
+}
+
+SOMEXTERN void  OPTLINK_DECL somtokrewind(FILE * f)
+{
+  OPTLINK_1ARG(f);
+
+  somtokrewindSL(f);
+}
+*/
+
+SOMEXTERN int  OPTLINK_DECL somtokrename(const char * a, const char * b)
+{
+  if (somtSOM30ABI)
+  {
+    OPTLINK_2ARGS(a, b);
+  }
+
+  return somtokrenameSL(a, b);
+}
+SOMEXTERN BOOL OPTLINK_DECL somtisDbcs(int c)
+{
+  if (somtSOM30ABI)
+  {
+    OPTLINK_1ARG(c);
+  }
+
+  return somtisDbcsSL(c);
+}
+
+SOMEXTERN boolean OPTLINK_DECL somtremoveExt(char *name, char *ext, char *buf)
+{
+  if (somtSOM30ABI)
+  {
+    OPTLINK_3ARGS(name, ext, buf);
+  }
+
+  return somtremoveExtSL(name, ext, buf);
+}
+
+SOMEXTERN char * OPTLINK_DECL somtaddExt(char *name, char *ext, char *buf)
+{
+  if (somtSOM30ABI)
+  {
+    OPTLINK_3ARGS(name, ext, buf);
+  }
+
+  return somtaddExtSL(name, ext, buf);
+}
+
+SOMEXTERN char * OPTLINK_DECL somtarrayToPtr(Entry *ep, char *stars, char *buf)
+{
+  if (somtSOM30ABI)
+  {
+    OPTLINK_3ARGS(ep, stars, buf);
+  }
+
+  return somtarrayToPtrSL(ep, stars, buf);
+}
+
+SOMEXTERN char * OPTLINK_DECL somtattNormalise(char *name, char *buf)
+{
+  if (somtSOM30ABI)
+  {
+    OPTLINK_2ARGS(name, buf);
+  }
+
+  return somtattNormaliseSL(name, buf);
+}
+
+SOMEXTERN char * OPTLINK_DECL somtbasename(char *path)
+{
+  if (somtSOM30ABI)
+  {
+    OPTLINK_1ARG(path);
+  }
+
+  return somtbasenameSL(path);
+}
+
+SOMEXTERN char * OPTLINK_DECL somtctos(Const *con, char *buf)
+{
+  if (somtSOM30ABI)
+  {
+    OPTLINK_2ARGS(con, buf);
+  }
+
+  return somtctosSL(con, buf);
+}
+
+SOMEXTERN char * OPTLINK_DECL somtdbcsPostincr(char **p)
+{
+  if (somtSOM30ABI)
+  {
+    OPTLINK_1ARG(p);
+  }
+
+  return somtdbcsPostincrSL(p);
+}
+
+SOMEXTERN char * OPTLINK_DECL somtdbcsPreincr(char **p)
+{
+  if (somtSOM30ABI)
+  {
+    OPTLINK_1ARG(p);
+  }
+
+  return somtdbcsPreincrSL(p);
+}
+
+SOMEXTERN char * OPTLINK_DECL somtdbcsStrchr(char *s, int c)
+{
+  if (somtSOM30ABI)
+  {
+    OPTLINK_2ARGS(s, c);
+  }
+
+  return somtdbcsStrchrSL(s, c);
+}
+
+SOMEXTERN char * OPTLINK_DECL somtdbcsStrrchr(char *s, int c)
+{
+  if (somtSOM30ABI)
+  {
+    OPTLINK_2ARGS(s, c);
+  }
+
+  return somtdbcsStrrchrSL(s, c);
+}
+
+SOMEXTERN char * OPTLINK_DECL somtdbcsStrstr(char *s1, char *s2)
+{
+  if (somtSOM30ABI)
+  {
+    OPTLINK_2ARGS(s1, s2);
+  }
+
+  return somtdbcsStrstrSL(s1, s2);
+}
+
+SOMEXTERN char * OPTLINK_DECL somteptotype(Entry *ep, char *ptrs, char *buf)
+{
+  if (somtSOM30ABI)
+  {
+    OPTLINK_3ARGS(ep, ptrs, buf);
+  }
+
+  return somteptotypeSL(ep, ptrs, buf);
+}
+
+SOMEXTERN char * OPTLINK_DECL somtgetDesc(Stab *stab, Entry *cls, Entry *method, char *desc, BOOL addQuotes, BOOL use, BOOL versflg)
+{
+  if (somtSOM30ABI)
+  {
+    OPTLINK_3ARGS(stab, cls, method);
+  }
+
+  return somtgetDescSL(stab, cls, method, desc, addQuotes, use, versflg);
+}
+
+SOMEXTERN char * OPTLINK_DECL somtgetVersion(char *sccsid, char *version)
+{
+  if (somtSOM30ABI)
+  {
+    OPTLINK_2ARGS(sccsid, version);
+  }
+
+  return somtgetVersionSL(sccsid, version);
+}
+
+SOMEXTERN char * OPTLINK_DECL somtgetgatt(char *s)
+{
+  if (somtSOM30ABI)
+  {
+    OPTLINK_1ARG(s);
+  }
+
+  return somtgetgattSL(s);
+}
+
+SOMEXTERN char * OPTLINK_DECL somtnextword(const char *s, char *buf)
+{
+  if (somtSOM30ABI)
+  {
+    OPTLINK_2ARGS(s, buf);
+  }
+
+  return somtnextwordSL(s, buf);
+}
+
+SOMEXTERN char * OPTLINK_DECL somtnormaliseDesc(char *desc, char *normal)
+{
+  if (somtSOM30ABI)
+  {
+    OPTLINK_2ARGS(desc, normal);
+  }
+
+  return somtnormaliseDescSL(desc, normal);
+}
+
+SOMEXTERN char * OPTLINK_DECL somtsatos(char **sa, char *sep, char *buf)
+{
+  if (somtSOM30ABI)
+  {
+    OPTLINK_3ARGS(sa, sep, buf);
+  }
+
+  return somtsatosSL(sa, sep, buf);
+}
+
+SOMEXTERN char * OPTLINK_DECL somtskipws(const char *s)
+{
+  if (somtSOM30ABI)
+  {
+    OPTLINK_1ARG(s);
+  }
+
+  return somtskipwsSL(s);
+}
+
+SOMEXTERN char * OPTLINK_DECL somtstringFmt(char *fmt, ...)
+{
+  if (somtSOM30ABI)
+  {
+    OPTLINK_1ARG(fmt);
+  }
+
+  va_list args;
+
+  va_start (args, fmt);
+  vsprintf(somtg_buf, fmt, args);
+  va_end (args);
+
+  return strcpy((char *)somtsmalloc(strlen(somtg_buf)+1, 0), somtg_buf);
+}
+
+SOMEXTERN char * OPTLINK_DECL somtuniqFmt(MemBuf *membuf, char *fmt, ...)
+{
+  va_list args;
+
+  if (somtSOM30ABI)
+  {
+    OPTLINK_2ARGS(membuf, fmt);
+  }
+
+  va_start (args, fmt);
+  vsprintf(somtg_buf, fmt, args);
+  va_end (args);
+
+  return somtuniqStringSL(membuf, somtg_buf);
+}
+
+SOMEXTERN int  OPTLINK_DECL somtargFlag(int *argc, char ***argv)
+{
+  if (somtSOM30ABI)
+  {
+    OPTLINK_2ARGS(argc, argv);
+  }
+
+  return somtargFlagSL(argc, argv);
+}
+
+SOMEXTERN int  OPTLINK_DECL somtattjoin(register AttList *ap1, AttList *ap2)
+{
+  if (somtSOM30ABI)
+  {
+    OPTLINK_2ARGS(ap1, ap2);
+  }
+
+  return somtattjoinSL(ap1, ap2);
+}
+
+SOMEXTERN int  OPTLINK_DECL somtdbcsLastChar(char *buf)
+{
+  if (somtSOM30ABI)
+  {
+    OPTLINK_1ARG(buf);
+  }
+
+  return somtdbcsLastCharSL(buf);
+}
+
+SOMEXTERN int  OPTLINK_DECL somtdbcsScan(char **buf)
+{
+  if (somtSOM30ABI)
+  {
+    OPTLINK_1ARG(buf);
+  }
+
+  return somtdbcsScanSL(buf);
+}
+
+SOMEXTERN int  OPTLINK_DECL somtdiskFull(FILE *fp)
+{
+  if (somtSOM30ABI)
+  {
+    OPTLINK_1ARG(fp);
+  }
+
+  return somtdiskFullSL(fp);
+}
+
+SOMEXTERN int  OPTLINK_DECL somtisparent(Entry *cls, Entry *parent)
+{
+  if (somtSOM30ABI)
+  {
+    OPTLINK_2ARGS(cls, parent);
+  }
+
+  return somtisparentSL(cls, parent);
+}
+
+SOMEXTERN int  OPTLINK_DECL somtmget(int setnum, int msgnum, char *msgbuf)
+{
+  if (somtSOM30ABI)
+  {
+    OPTLINK_3ARGS(setnum, msgnum, msgbuf);
+  }
+
+  return somtmgetSL(setnum, msgnum, msgbuf);
+}
+
+SOMEXTERN int  OPTLINK_DECL somtmopen(char *filename)
+{
+  if (somtSOM30ABI)
+  {
+    OPTLINK_1ARG(filename);
+  }
+
+  return somtmopenSL(filename);
+}
+
+SOMEXTERN int  OPTLINK_DECL somtmprintf(int setnum, int msgnum, ...)
+{
+  return 0;
+}
+
+SOMEXTERN int  OPTLINK_DECL somtokremove(char *file)
+{
+  if (somtSOM30ABI)
+  {
+    OPTLINK_1ARG(file);
+  }
+
+  return somtokremoveSL(file);
+}
+
+SOMEXTERN int  OPTLINK_DECL somtunload(void *modHandle)
+{
+  if (somtSOM30ABI)
+  {
+    OPTLINK_1ARG(modHandle);
+  }
+
+  return somtunloadSL(modHandle);
+}
+
+SOMEXTERN int  OPTLINK_DECL somtwriteaccess(char *file)
+{
+  if (somtSOM30ABI)
+  {
+    OPTLINK_1ARG(file);
+  }
+
+  return somtwriteaccessSL(file);
+}
+
+SOMEXTERN void * OPTLINK_DECL somtsmalloc(size_t nbytes, BYTE clear)
+{
+  if (somtSOM30ABI)
+  {
+    OPTLINK_2ARGS_DWORD_BYTE(nbytes, clear);
+  }
+
+  return somtsmallocSL(nbytes, clear);
+}
+
+SOMEXTERN void  OPTLINK_DECL somtaddGAtt(MemBuf **membuf, AttList **ap, char *buf)
+{
+  if (somtSOM30ABI)
+  {
+    OPTLINK_3ARGS(membuf, ap, buf);
+  }
+
+  somtaddGAttSL(membuf, ap, buf);
+}
+
+SOMEXTERN void  OPTLINK_DECL somtcalcFileName(char *def, char *over, char *ext)
+{
+  if (somtSOM30ABI)
+  {
+    OPTLINK_3ARGS(def, over, ext);
+  }
+
+  somtcalcFileNameSL(def, over, ext);
+}
+
+SOMEXTERN void  OPTLINK_DECL somtcleanFilesFatal(int status)
+{
+  if (somtSOM30ABI)
+  {
+    OPTLINK_1ARG(status);
+  }
+
+  somtcleanFilesFatalSL(status);
+}
+
+SOMEXTERN void  OPTLINK_DECL somtemitTypes(FILE *fp, Mlist *mp, Stab *stab)
+{
+  if (somtSOM30ABI)
+  {
+    OPTLINK_3ARGS(fp, mp, stab);
+  }
+
+  somtemitTypesSL(fp, mp, stab);
+}
+
+SOMEXTERN void  OPTLINK_DECL somtmclose(void)
+{
+  somtmcloseSL();
+}
+
+SOMEXTERN void  OPTLINK_DECL somtreadDescFile(Stab *stab, char *file)
+{
+  if (somtSOM30ABI)
+  {
+    OPTLINK_2ARGS(stab, file);
+  }
+
+  somtreadDescFileSL(stab, file);
+}
+
+SOMEXTERN void  OPTLINK_DECL somtsetDefaultDesc(Stab *stab)
+{
+  if (somtSOM30ABI)
+  {
+    OPTLINK_1ARG(stab);
+  }
+
+  somtsetDefaultDescSL(stab);
+}
+
+SOMEXTERN void  OPTLINK_DECL somtsetEmitSignals(void(*cleanup) (int), void (*internal) (int))
+{
+  if (somtSOM30ABI)
+  {
+    OPTLINK_2ARGS(cleanup, internal);
+  }
+
+  somtsetEmitSignalsSL(cleanup, internal);
+}
+
+SOMEXTERN void  OPTLINK_DECL somtsetTypeDefn(Entry *etype, Entry *ep, char *ptrs, Entry *ret, BOOL array)
+{
+  if (somtSOM30ABI)
+  {
+    OPTLINK_3ARGS(etype, ep, ptrs);
+  }
+
+  somtsetTypeDefnSL(etype, ep, ptrs, ret, array);
+}
+
+SOMEXTERN void  OPTLINK_DECL somtshowVersion(char *s, char *progname, char *sccsid)
+{
+  if (somtSOM30ABI)
+  {
+    OPTLINK_3ARGS(s, progname, sccsid);
+  }
+
+  somtshowVersionSL(s, progname, sccsid);
+}
+
+SOMEXTERN void  OPTLINK_DECL somtsmfree(void *first, ...)
+{
+}
+
+SOMEXTERN void  OPTLINK_DECL somtunsetEmitSignals(void)
+{
+  if (somtSOM30ABI)
+  {
+    somtunsetEmitSignalsSL();
+  }
+}
+
+SOMEXTERN char * OPTLINK_DECL somtuppercase(char *s, char *buf)
+{
+  if (somtSOM30ABI)
+  {
+    OPTLINK_2ARGS(s, buf);
+  }
+
+  return somtuppercaseSL(s, buf);
+}
+
+SOMEXTERN char * OPTLINK_DECL somtlowercase(char *s, char *buf)
+{
+  if (somtSOM30ABI)
+  {
+    OPTLINK_2ARGS(s, buf);
+  }
+
+  return somtlowercaseSL(s, buf);
+}
+
+SOMEXTERN char * OPTLINK_DECL somtdbcsuppercase(char *s, char *buf)
+{
+  if (somtSOM30ABI)
+  {
+    OPTLINK_2ARGS(s, buf);
+  }
+
+  return somtdbcsuppercaseSL(s, buf);
+}
+
+SOMEXTERN char * OPTLINK_DECL somtdbcslowercase(char *s, char *buf)
+{
+  if (somtSOM30ABI)
+  {
+    OPTLINK_2ARGS(s, buf);
+  }
+
+  return somtdbcslowercaseSL(s, buf);
+}
+
+SOMEXTERN void  OPTLINK_DECL somtresetEmitSignals(void)
+{
+  somtresetEmitSignalsSL();
+}
+
+SOMEXTERN size_t  OPTLINK_DECL somtsizeofEntry(SOMTTypes stype)
+{
+  if (somtSOM30ABI)
+  {
+    unsigned char t=(unsigned char)stype;
+    OPTLINK_1ARG_BYTE(t);
+  }
+
+  return somtsizeofEntrySL(stype);
+}
+
+SOMEXTERN char * OPTLINK_DECL somtepname(Entry *ep, char *buf, BOOL suppressImpctxCheck)
+{
+  if (somtSOM30ABI)
+  {
+    OPTLINK_3ARGS(ep, buf, suppressImpctxCheck);
+  }
+
+  return somtepnameSL(ep, buf, suppressImpctxCheck);
+}
+
+SOMEXTERN char * OPTLINK_DECL somtgenSeqName(long n, Entry *base, char *buf, BOOL fullname)
+{
+  if (somtSOM30ABI)
+  {
+    OPTLINK_3ARGS(n, base, buf);
+  }
+
+  return somtgenSeqNameSL(n, base, buf, fullname);
+}
+
+SOMEXTERN void  OPTLINK_DECL somtmrifatal(char *file, long lineno, int msgnum,...)
+{
+}
+
+SOMEXTERN void  OPTLINK_DECL somtmriinternal(char *file, long lineno, int msgnum,...)
+{
+}
+
+SOMEXTERN void  OPTLINK_DECL somtmrierror(char *file, long lineno, int msgnum,...)
+{
+}
+
+SOMEXTERN void  OPTLINK_DECL somtmrimsg(char *file, long lineno, int msgnum,...)
+{
+}
+
+SOMEXTERN void  OPTLINK_DECL somtmriwarn(char *file, long lineno, int msgnum,...)
+{
+}
+
+SOMEXTERN void  OPTLINK_DECL somtsetInternalMessages(char *too_long, char *cant_continue, char *segv, char *bus)
+{
+  if (somtSOM30ABI)
+  {
+    OPTLINK_3ARGS(too_long, cant_continue, segv);
+  }
+
+  somtsetInternalMessagesSL(too_long, cant_continue, segv, bus);
+}
+
+SOMEXTERN boolean OPTLINK_DECL somtisvoid(Entry *etype, char *defn)
+{
+  if (somtSOM30ABI)
+  {
+    OPTLINK_2ARGS(etype, defn);
+  }
+
+  return somtisvoidSL(etype, defn);
+}
+
+SOMEXTERN BOOL  OPTLINK_DECL somtreturnsStruct(Entry *ep)
+{
+  if (somtSOM30ABI)
+  {
+    OPTLINK_1ARG(ep);
+  }
+
+  return somtreturnsStructSL(ep);
+}
+
+SOMEXTERN BOOL  OPTLINK_DECL somtreturnsPtr(Entry *ep)
+{
+  if (somtSOM30ABI)
+  {
+    OPTLINK_1ARG(ep);
+  }
+
+  return somtreturnsPtrSL(ep);
+}
+
+SOMEXTERN char * OPTLINK_DECL somtsimpleName(Entry *ep)
+{
+  if (somtSOM30ABI)
+  {
+    OPTLINK_1ARG(ep);
+  }
+
+  return somtsimpleNameSL(ep);
+}
+
+SOMEXTERN void  OPTLINK_DECL somtqualifyNames(Stab * stab, BOOL fully)
+{
+  if (somtSOM30ABI)
+  {
+    OPTLINK_2ARGS(stab, fully);
+  }
+
+  somtqualifyNamesSL(stab, fully);
+}
+
+SOMEXTERN Entry * OPTLINK_DECL somtfindBaseEpNonPtr(Entry *ep)
+{
+  if (somtSOM30ABI)
+  {
+    OPTLINK_1ARG(ep);
+  }
+
+  return somtfindBaseEpNonPtrSL(ep);
+}
+
+SOMEXTERN BOOL  OPTLINK_DECL somtprocessTraps(void)
+{
+  return somtprocessTrapsSL();
+}
+
+SOMEXTERN Mlist * OPTLINK_DECL somtallocMlist(Entry * ep)
+{
+  if (somtSOM30ABI)
+  {
+    OPTLINK_1ARG(ep);
+  }
+
+  return somtallocMlistSL(ep);
+}
+
+SOMEXTERN Mlist * OPTLINK_DECL somtmlistend(Mlist * mp, char *name)
+{
+  if (somtSOM30ABI)
+  {
+    OPTLINK_2ARGS(mp, name);
+  }
+
+  return somtmlistendSL(mp, name);
+}
+
+SOMEXTERN BOOL  OPTLINK_DECL somtisMutRef(Entry *ep, Mlist *seen, BOOL isself, long level)
+{
+  if (somtSOM30ABI)
+  {
+    OPTLINK_3ARGS(ep, seen, isself);
+  }
+
+  return somtisMutRefSL(ep, seen, isself, level);
+}
+
+SOMEXTERN Mlist *  OPTLINK_DECL somtfreeMlist(Mlist *mp)
+{
+  if (somtSOM30ABI)
+  {
+    OPTLINK_1ARG(mp);
+  }
+
+  return somtfreeMlistSL(mp);
+}
+
+SOMEXTERN Mlist *  OPTLINK_DECL somtdupMlist(Mlist *mp, Entry *ep)
+{
+  if (somtSOM30ABI)
+  {
+    OPTLINK_2ARGS(mp, ep);
+  }
+
+  return somtdupMlistSL(mp, ep);
+}
+
+SOMEXTERN void  OPTLINK_DECL somtfreeWorld()
+{
+  somtfreeWorldSL();
+}
+
+SOMEXTERN void  OPTLINK_DECL somtInitialiseEmitlib(void)
+{
+  somtInitialiseEmitlibSL();
+}
+
+SOMEXTERN void  OPTLINK_DECL somtInitialiseSmmeta(void)
+{
+  somtInitialiseSmmetaSL();
+}
+
+SOMEXTERN void  OPTLINK_DECL somtInitialiseCreatetc(void)
+{
+  somtInitialiseCreatetcSL();
+}
+
+SOMEXTERN void  OPTLINK_DECL somtInitialiseSmtypes(void)
+{
+  somtInitialiseSmtypesSL();
+}
+
+SOMEXTERN void  OPTLINK_DECL somtInitialiseSomc(void)
+{
+  somtInitialiseSomcSL();
+}
+
+SOMEXTERN void  OPTLINK_DECL somtInitialiseSmsmall(void)
+{
+  somtInitialiseSmsmallSL();
+}
+
+SOMEXTERN void  OPTLINK_DECL somtexit(SOMTExitBuf *ebuf, int status)
+{
+  if (somtSOM30ABI)
+  {
+    OPTLINK_2ARGS(ebuf, status);
+  }
+
+  somtexitSL(ebuf, status);
+}
+
+#endif
+
+SOMEXTERN int SOMLINK somttraverseParentsSL(FILE *fp, Entry * cls, Entry *arg, int (*fn)(FILE*,Entry*,Entry*), SMTraverse flg)
+{
+  return 0;
+}
+
+
+SOMEXTERN Entry * SOMLINK somtfindBaseEpSL(Entry *ep)
+{
+  return NULL;
+}
+
+SOMEXTERN Entry * SOMLINK somtgetTypeSL(char *name, SOMTTypes type)
+{
+  return NULL;
+}
+
+SOMEXTERN FILE * SOMLINK somtokfopenSL(char *path, char *mode)
+{
+  FILE *rc;
+
+  rc=fopen(path, mode);
+
+  if (!rc)
+  {
+    fprintf(stderr, "\"%s\", ", path);
+    perror("fopen");
+    somtexitSL(&somtipcbuf, -1);
+  }
+
+  return rc;
+}
+
+SOMEXTERN int  SOMLINK somtokfprintfSL(FILE * fp, const char * fmt, ...)
+{
+  return 0;
+}
+
+SOMEXTERN int  SOMLINK somtokfputsSL(const char * s, FILE * fp)
+{
+  return 0;
+}
+
+SOMEXTERN int  SOMLINK somtokfputcSL(const char c, FILE * fp)
+{
+  return 0;
+}
+
+SOMEXTERN char * SOMLINK somtokfgetsSL(char * s, int sz, FILE * fp)
+{
+  return NULL;
+}
+
+SOMEXTERN void  SOMLINK somtokrewindSL(FILE * fp)
+{
+}
+
+SOMEXTERN int  SOMLINK somtokrenameSL(const char* s, const char * t)
+{
+  return 0;
+}
+
+SOMEXTERN BOOL  SOMLINK somtisDbcsSL(int c)
+{
+  return FALSE;
+}
+
+SOMEXTERN BOOL  SOMLINK somtremoveExtSL(char *name, char *ext, char *buf)
+{
+  char * extpos;
+
+  strcpy(ext, name);
+  extpos=strrchr(ext, '.');
+  if (extpos)
+  {
+    ext[extpos-ext]=0x0;
+    strcpy(buf, ext);
+    return TRUE ;
+  }
+  return FALSE;
+}
+
+SOMEXTERN char * SOMLINK somtaddExtSL(char *name, char *ext, char *buf)
+{
+  sprintf(buf, "%s%s%s", name, ".", ext);
+  return buf;
+}
+
+SOMEXTERN char * SOMLINK somtarrayToPtrSL(Entry *ep, char *stars, char *buf)
+{
+  return NULL;
+}
+
+SOMEXTERN char * SOMLINK somtattNormaliseSL(char *name, char *buf)
+{
+  while(*name)
+  {
+    if (*name!=' ')
+    {
+      *buf=tolower(*name);
+      buf++;
+    }
+    name++;
+  }
+
+  return buf;
+}
+
+SOMEXTERN char * SOMLINK somtbasenameSL(char *path)
+{
+  // @fix use MAX_PATH constant
+  char buf[260];
+  char * bufpos;
+
+  strcpy(buf, path);
+  bufpos=strrchr(buf, '/');
+  if(!bufpos) bufpos=strrchr(buf, '\\');
+  if (bufpos) 
+  {
+    *bufpos=0x00;
+    return (bufpos+1);
+  }
+  return path;
+}
+
+SOMEXTERN char * SOMLINK somtctosSL(Const *con, char *buf)
+{
+  return NULL;
+}
+
+SOMEXTERN char * SOMLINK somtdbcsPostincrSL(char **p)
+{
+  return NULL;
+}
+
+SOMEXTERN char * SOMLINK somtdbcsPreincrSL(char **p)
+{
+  return NULL;
+}
+
+SOMEXTERN char * SOMLINK somtdbcsStrchrSL(char *s, int c)
+{
+  return NULL;
+}
+
+SOMEXTERN char * SOMLINK somtdbcsStrrchrSL(char *s, int c)
+{
+  return NULL;
+}
+
+SOMEXTERN char * SOMLINK somtdbcsStrstrSL(char *s1, char *s2)
+{
+  return NULL;
+}
+
+SOMEXTERN char * SOMLINK somteptotypeSL(Entry *ep, char *ptrs, char *buf)
+{
+  return NULL;
+}
+
+SOMEXTERN char * SOMLINK somtgetDescSL(Stab *stab, Entry *cls, Entry *method, char *desc, BOOL addQuotes, BOOL use, BOOL versflg)
+{
+  return NULL;
+}
+
+SOMEXTERN char * SOMLINK somtgetVersionSL(char *sccsid, char *version)
+{
+  return NULL;
+}
+
+SOMEXTERN char * SOMLINK somtgetgattSL(char *s)
+{
+  return NULL;
+}
+
+SOMEXTERN char * SOMLINK somtnextwordSL(const char *s, char *buf)
+{
+  return NULL;
+}
+
+SOMEXTERN char * SOMLINK somtnormaliseDescSL(char *desc, char *normal)
+{
+  return NULL;
+}
+
+SOMEXTERN char * SOMLINK somtsatosSL(char **sa, char *sep, char *buf)
+{
+  return NULL;
+}
+
+SOMEXTERN char * SOMLINK somtskipwsSL(const char *s)
+{
+  return NULL;
+}
+
+SOMEXTERN char * SOMLINK somtstringFmtSL(char *fmt, ...)
+{
+  va_list args;
+
+  va_start (args, fmt);
+  vsprintf(somtg_buf, fmt, args);
+  va_end (args);
+
+  return strcpy((char *)somtsmalloc(strlen(somtg_buf)+1, 0), somtg_buf);
+}
+
+
+SOMEXTERN char * SOMLINK somtuniqFmtSL(MemBuf *membuf, char *fmt, ...)
+{
+  va_list args;
+
+  va_start (args, fmt);
+  vsprintf(somtg_buf, fmt, args);
+  va_end (args);
+
+  return somtuniqStringSL(membuf, somtg_buf);
+}
+
+SOMEXTERN int SOMLINK somtargFlagSL(int *argc, char ***argv)
+{
+  return 0;
+}
+
+SOMEXTERN int SOMLINK somtattjoinSL(register AttList *ap1, AttList *ap2)
+{
+  return 0;
+}
+
+SOMEXTERN int SOMLINK somtdbcsLastCharSL(char *buf)
+{
+  return 0;
+}
+
+SOMEXTERN int SOMLINK somtdbcsScanSL(char **buf)
+{
+  return 0;
+}
+
+SOMEXTERN int SOMLINK somtdiskFullSL(FILE *fp)
+{
+  return 0;
+}
+
+SOMEXTERN int SOMLINK somtisparentSL(Entry *cls, Entry *parent)
+{
+  return 0;
+}
+
+SOMEXTERN int SOMLINK somtmgetSL(int setnum, int msgnum, char *msgbuf)
+{
+  return 0;
+}
+
+SOMEXTERN int SOMLINK somtmopenSL(char *filename)
+{
+  return 0;
+}
+
+SOMEXTERN int SOMLINK somtmprintfSL(int setnum, int msgnum, ...)
+{
+  return 0;
+}
+
+SOMEXTERN int SOMLINK somtokremoveSL(char *file)
+{
+ 
+  if (file)
+  {
+    if(somtfexistsSL(file))
+    {
+      return(remove(file));
+    }
+  } 
+  return -1;
+}
+
+SOMEXTERN int SOMLINK somtunloadSL(void *modHandle)
+{
+  return 0;
+}
+
+SOMEXTERN int SOMLINK somtwriteaccessSL(char *file)
+{
+  return 0;
+}
+
+SOMEXTERN void * SOMLINK somtsmallocSL(size_t nbytes, BOOL clear)
+{
+  void * buf=NULL;
+
+  buf=somtmalloc(nbytes);
+  if (buf&&clear) memset(buf, 0, nbytes);
+  return buf;
+}
+
+SOMEXTERN void SOMLINK somtaddGAttSL(MemBuf **membuf, AttList **ap, char *buf)
+{
+}
+
+SOMEXTERN void SOMLINK somtcalcFileNameSL(char *def, char *over, char *ext)
+{
+  char * nullstr="";
+  if(!def) def = nullstr;
+  if(!over) over = nullstr;
+  if(!def[0] && !over[0]) somtfatalSL(__FILE__, __LINE__, "error");
+  //@fix not finished yet
+}
+
+SOMEXTERN void SOMLINK somtcleanFilesFatalSL(int status)
+{
+  if (somtopenEmitFileCalled)
+  {
+    if (somtoutPath) somtokremoveSL(somtoutPath);
+  }
+  somtexitSL(&somtipcbuf, -1);
+}
+
+SOMEXTERN void SOMLINK somtemitTypesSL(FILE *fp, Mlist *mp, Stab *stab)
+{
+}
+
+SOMEXTERN void SOMLINK somtmcloseSL(void)
+{
+}
+
+SOMEXTERN void SOMLINK somtreadDescFileSL(Stab *stab, char *file)
+{
+}
+
+SOMEXTERN void SOMLINK somtsetDefaultDescSL(Stab *stab)
+{
+}
+
+SOMEXTERN void SOMLINK somtsetTypeDefnSL(Entry *type, Entry *ep, char *ptrs, Entry *ret, BOOL array)
+{
+}
+
+SOMEXTERN void SOMLINK somtshowVersionSL(char *s, char *progname, char *sccsid)
+{
+}
+
+SOMEXTERN void SOMLINK somtsmfreeSL(void *first, ...)
+{
+}
+
+SOMEXTERN void SOMLINK somtunsetEmitSignalsSL(void)
+{
+}
+
+SOMEXTERN char * SOMLINK somtuppercaseSL(char *s, char *buf)
+{
+  while (*s) {
+    *buf=toupper(*s);
+    s++;
+    buf++;
+  }
+  *buf=0;
+  return buf;
+}
+
+SOMEXTERN char * SOMLINK somtlowercaseSL(char *s, char *buf)
+{
+  while (*s) {
+    *buf=tolower(*s);
+    s++;
+    buf++;
+  }
+  *buf=0;
+  return buf;
+}
+
+SOMEXTERN char * SOMLINK somtdbcsuppercaseSL(char *s, char *buf)
+{
+  return NULL;
+}
+
+SOMEXTERN char * SOMLINK somtdbcslowercaseSL(char *s, char *buf)
+{
+  return NULL;
+}
+
+SOMEXTERN void SOMLINK somtresetEmitSignalsSL(void)
+{
+}
+
+SOMEXTERN size_t SOMLINK somtsizeofEntrySL(SOMTTypes type)
+{
+  size_t sz=0x24; // default size of entry structure without union
+
+  switch(type)
+  {
+    case SOMTClassE:
+	sz+=sizeof(Class);
+    case SOMTMetaE:
+	sz+=sizeof(Meta);
+    case SOMTBaseE:
+	sz+=sizeof(Parent);
+    case SOMTPassthruE:
+	sz+=sizeof(Passthru);
+    case SOMTNewMethodE:
+    case SOMTOverrideMethodE:
+    case SOMTOverriddenMethodE:
+    case SOMTDataE:
+    case SOMTArgumentE:
+    case SOMTTypedefBE:
+    case SOMTVoidPtrBE:
+	sz+=sizeof(Method_OR_Data);
+    case SOMTStructE:
+	sz+=sizeof(Struct);
+    case SOMTTyDclE:
+    case SOMTTypedefE:
+	sz+=sizeof(Typedef);
+    case SOMTUnionE:
+    case SOMTUnionSE:
+	sz+=sizeof(Union);
+    case SOMTEnumE:
+	sz+=sizeof(Enumerator);
+    case SOMTConstE:
+	sz+=sizeof(Const);
+    case SOMTAttE:
+	sz+=sizeof(Att);
+    case SOMTSequenceE:
+    case SOMTSequenceTDE:
+	sz+=sizeof(Sequence);
+    case SOMTStringE:
+	sz+=sizeof(String);
+    case SOMTEnumBE:
+	sz+=sizeof(EnumName);
+    case SOMTModuleE:
+	sz+=sizeof(Module);
+  }
+
+  return sz;
+}
+
+SOMEXTERN char * SOMLINK somtepnameSL(Entry *ep, char *buf, BOOL suppressImpctxCheck)
+{
+  return NULL;
+}
+
+SOMEXTERN char * SOMLINK somtgenSeqNameSL(long n, Entry *base, char *buf, BOOL fullname)
+{
+  return NULL;
+}
+
+SOMEXTERN void SOMLINK somtmrifatalSL(char *file, long lineno, int msgnum,...)
+{
+}
+
+SOMEXTERN void SOMLINK somtmriinternalSL(char *file, long lineno, int msgnum,...)
+{
+}
+
+SOMEXTERN void SOMLINK somtmrierrorSL(char *file, long lineno, int msgnum,...)
+{
+}
+
+SOMEXTERN void SOMLINK somtmrimsgSL(char *file, long lineno, int msgnum,...)
+{
+}
+
+SOMEXTERN void SOMLINK somtmriwarnSL(char *file, long lineno, int msgnum,...)
+{
+}
+
+SOMEXTERN void SOMLINK somtsetInternalMessagesSL(char *too_long, char *cant_continue, char *segv, char *bus)
+{
+}
+
+SOMEXTERN BOOL SOMLINK somtisvoidSL(Entry *type, char *defn)
+{
+  if (type->type)
+  {
+    if (type->type==SOMTVoidBE) return FALSE;
+  } 
+  else
+  {
+    if ((!strcmp(defn, "void")) ||
+        (!strcmp(defn, "VOID")) ||
+        (!strcmp(defn, "PMVOID"))
+        ) return FALSE;
+  }
+  return FALSE;
+}
+
+SOMEXTERN BOOL SOMLINK somtreturnsStructSL(Entry *ep)
+{
+  return FALSE;
+}
+
+SOMEXTERN BOOL SOMLINK somtreturnsPtrSL(Entry *ep)
+{
+  return FALSE;
+}
+
+SOMEXTERN char * SOMLINK somtsimpleNameSL(Entry *ep)
+{
+  return NULL;
+}
+
+SOMEXTERN void SOMLINK somtqualifyNamesSL(Stab * stab, BOOL fully)
+{
+}
+
+SOMEXTERN Entry * SOMLINK somtfindBaseEpNonPtrSL(Entry *ep)
+{
+  return NULL;
+}
+
+SOMEXTERN BOOL SOMLINK somtprocessTrapsSL(void)
+{
+  return FALSE;
+}
+
+SOMEXTERN Mlist * SOMLINK somtallocMlistSL(Entry * ep)
+{
+  return NULL;
+}
+
+SOMEXTERN Mlist * SOMLINK somtmlistendSL(Mlist * mp, char *name)
+{
+  return NULL;
+}
+
+SOMEXTERN BOOL SOMLINK somtisMutRefSL(Entry *ep, Mlist *seen, BOOL isself, long level)
+{
+  return FALSE;
+}
+
+SOMEXTERN Mlist * SOMLINK somtfreeMlistSL(Mlist *mp)
+{
+  return NULL;
+}
+
+SOMEXTERN Mlist * SOMLINK somtdupMlistSL(Mlist *mp, Entry *ep)
+{
+  return NULL;
+}
+
+SOMEXTERN void SOMLINK somtfreeWorldSL()
+{
+}
+
+SOMEXTERN void SOMLINK somtInitialiseEmitlibSL(void)
+{
+}
+
+SOMEXTERN void SOMLINK somtInitialiseSmmetaSL(void)
+{
+}
+
+SOMEXTERN void SOMLINK somtInitialiseCreatetcSL(void)
+{
+}
+
+SOMEXTERN void SOMLINK somtInitialiseSmtypesSL(void)
+{
+}
+
+SOMEXTERN void SOMLINK somtInitialiseSomcSL(void)
+{
+}
+
+SOMEXTERN void SOMLINK somtInitialiseSmsmallSL(void)
+{
+}
+
+SOMEXTERN void SOMLINK somtexitSL(SOMTExitBuf *ebuf, int status)
+{
+}
+
+SOMEXTERN void SOMLINK somtsetEmitSignalsSL(void(*cleanup) (int), void (*internal) (int))
+{
+}
+
+
+/*
+     1        00050973        TCCalloc
+     2        0005097C        TCFree
+     3        00050983        TCMalloc
+     4        0005098C        TCRealloc
+     5        00050996        _DLL_InitTerm
+     6        000509A4        get_double_alignment
+     7        000509B9        somVaBuf_add
+     8        000509C6        somVaBuf_create
+     9        000509D6        somVaBuf_destroy
+    10        000509E7        somVaBuf_get_valist
+    11        000509FB        somtAncestorClass
+    12        00050A0D        somtCPP
+    13        00050A15        somtDllStem
+    14        00050A21        somtGetReintroducedMethods
+    15        00050A3C        somtInitialiseCreatetc
+    16        00050A53        somtInitialiseEmitlib
+    17        00050A69        somtInitialiseSmmeta
+    18        00050A7E        somtInitialiseSmsmall
+    19        00050A94        somtInitialiseSmtypes
+    20        00050AAA        somtInitialiseSomc
+    21        00050ABD        somtParentNumFromName
+    22        00050AD3        somtaddEntry
+    23        00050AE0        somtaddEntryBuf
+    24        00050AF0        somtaddExt
+    25        00050AFB        somtaddGAtt
+    26        00050B07        somtaddHeader
+    27        00050B15        somtaddstar
+    28        00050B21        somtallocBuf
+    29        00050B2E        somtallocDataList
+    30        00050B40        somtallocMethodList
+    31        00050B54        somtallocMlist
+    32        00050B63        somtargFlag
+    33        00050B6F        somtarrayToPtr
+-    34        00050B7E        somtattMap
+    35        00050B89        somtattNormalise
+-    36        00050B9A        somtattalloc
+    37        00050BA7        somtattjoin
+    38        00050BB3        somtbasename
+    39        00050BC0        somtcalcFileName
+    40        00050BD1        somtcalloc
+    41        00050BDC        somtclassIdlCall
+    42        00050BED        somtclassList
+    43        00050BFB        somtclassName
+    44        00050C09        somtclassPrefix
+    45        00050C19        somtcleanFiles
+    46        00050C28        somtcleanFilesFatal
+    47        00050C3C        somtcleanup_f
+    48        00050C4A        somtclsfilename
++    49        00050C5A        somtclsname
+    50        00050C66        somtcreateMemBuf
+    51        00050C77        somtcreateStab
+    52        00050C86        somtcreateTypeCodes
+    53        00050C9A        somtctos
+    54        00050CA3        somtdbcsLastChar
+    55        00050CB4        somtdbcsPostincr
+    56        00050CC5        somtdbcsPreincr
+    57        00050CD5        somtdbcsScan
+    58        00050CE2        somtdbcsStrchr
+    59        00050CF1        somtdbcsStrrchr
+    60        00050D01        somtdbcsStrstr
+    61        00050D10        somtdbcslowercase
+    62        00050D22        somtdbcsuppercase
+    63        00050D34        somtdeclareIdlVarargs
+    64        00050D4A        somtdiskFull
+    65        00050D57        somtdupMlist
+    66        00050D64        somtdymain
+    67        00050D6F        somtemitClassDataTokens
+    68        00050D87        somtemitModule
+    69        00050D96        somtemitModuleTypes
+    70        00050DAA        somtemitPassthru
+    71        00050DBB        somtemitPredefinedTcConstants
+    72        00050DD9        somtemitPredefinedTypeCode
+    73        00050DF4        somtemitReturns
+    74        00050E04        somtemitTcConstant
+    75        00050E17        somtemitTypes
+    76        00050E25        somtepname
+    77        00050E30        somteptotype
++    78        00050E3D        somterror
++    79        00050E47        somterrorSL
+    80        00050E53        somtexit
+    81        00050E5C        somtext
++    82        00050E64        somtfatal
++    83        00050E6E        somtfatalSL
++    84        00050E7A        somtfclose
++    85        00050E85        somtfcloseSL
++    86        00050E92        somtfexists
+    87        00050E9E        somtfilePath
+    88        00050EAB        somtfileStem
+    89        00050EB8        somtfindBaseEp
+    90        00050EC7        somtfindBaseEpNonPtr
+    91        00050EDC        somtfindMethodName
+    92        00050EEF        somtfree
+    93        00050EF8        somtfreeDataList
+    94        00050F09        somtfreeMethodList
+    95        00050F1C        somtfreeMlist
+    96        00050F2A        somtfreeStab
+    97        00050F37        somtfreeWorld
+    98        00050F45        somtfullComment
+    99        00050F55        somtfullPrototype
+   100        00050F67        somtfullTypedef
+   101        00050F77        somtg_buf
+   102        00050F81        somtg_f
+   103        00050F89        somtg_membuf
+   104        00050F96        somtg_sccsid
+   105        00050FA3        somtg_somlink
+   106        00050FB1        somtgenAttStubs
+   107        00050FC1        somtgenSeqName
+   108        00050FD0        somtgetAbistyle
+   109        00050FE0        somtgetAtt
+   110        00050FEB        somtgetDesc
+   111        00050FF7        somtgetEntry
+   112        00051004        somtgetNonRepeatedParent
+-   113        0005101D        somtgetOidlAtt
+   114        0005102C        somtgetType
+   115        00051038        somtgetVersion
+-   116        00051047        somtgetap
+   117        00051051        somtgetatt
+   118        0005105C        somtgetdatt
+   119        00051068        somtgetgatt
+   120        00051074        somtglbdefs
+   121        00051080        somthandleDiskFull
+   122        00051093        somticstrcmp
+   123        000510A0        somtimplicit
+   124        000510AD        somtimplicitArgs
+   125        000510BE        somtimplicitMeta
+   126        000510CF        somtincludeOnce
+-   127        000510DF        somtinitMalloc
+   128        000510EE        somtinitialiseMeta
++   129        00051101        somtinternal
++   130        0005110E        somtinternalSL
+   131        0005111D        somtinternal_f
+   132        0005112C        somtipcbuf
+   133        00051137        somtisDbcs
+   134        00051142        somtisInheritedModifierSet
+   135        0005115D        somtisMutRef
+   136        0005116A        somtisSpecialMethod
+   137        0005117E        somtisparent
+   138        0005118B        somtisvoid
+   139        00051196        somtkeyword
+   140        000511A2        somtlistAttribute
++   141        000511B4        somtload
+   142        000511BD        somtlowercase
+   143        000511CB        somtmajorVersion
+   144        000511DC        somtmalloc
+   145        000511E7        somtmclose
+   146        000511F2        somtmeta
+   147        000511FB        somtmget
+   148        00051204        somtminorVersion
+   149        00051215        somtmlistend
+   150        00051222        somtmodule
+   151        0005122D        somtmopen
+   152        00051237        somtmp
+   153        0005123E        somtmprintf
+   154        0005124A        somtmrierror
+   155        00051257        somtmrifatal
+   156        00051264        somtmriinternal
+   157        00051274        somtmrimsg
+   158        0005127F        somtmriwarn
++   159        0005128B        somtmsg
++   160        00051293        somtmsgSL
+   161        0005129D        somtnewMethodsCount
+   162        000512B1        somtnextword
+   163        000512BE        somtnotc
+   164        000512C7        somtnthArg
+   165        000512D2        somtobseleteHeaderFile
+   166        000512E9        somtoidlComment
+   167        000512F9        somtokfopen
+   168        00051305        somtokremove
++   169        00051312        somtopenEmitFile
+   170        00051323        somtopenEmitFileCalled
++   171        0005133A        somtopenEmitFileSL
+   172        0005134D        somtoutPath
+   173        00051359        somtpclsfilename
+   174        0005136A        somtpclsname
+   175        00051377        somtprefixedPrototype
+   176        0005138D        somtprivateMethodsCount
+   177        000513A5        somtprocessTraps
+   178        000513B6        somtqualifyNames
+   179        000513C7        somtreadDescFile
+   180        000513D8        somtrealExit
+   181        000513E5        somtrealloc
+   182        000513F1        somtremoveExt
+   183        000513FF        somtreplaceDataName
+   184        00051413        somtresetEmitSignals
+   185        00051428        somtresetEmitSignalsSL
+   186        0005143F        somtreturnsPtr
+   187        0005144E        somtreturnsStruct
+   188        00051460        somtrmSelf
+   189        0005146B        somtrmstar
+   190        00051476        somtsatos
+   191        00051480        somtsaved
+   192        0005148A        somtscbuf
+   193        00051494        somtscmsg
++   194        0005149E        somtsearchFile
+   195        000514AD        somtsetDefaultDesc
+   196        000514C0        somtsetEmitSignals
+   197        000514D3        somtsetInternalMessages
+   198        000514EB        somtsetTypeDefn
+-   199        000514FB        somtsetext
+   200        00051506        somtshortArgList
+   201        00051517        somtshortDefine
+   202        00051527        somtshowVersion
+   203        00051537        somtsimpleName
+   204        00051546        somtsizeofEntry
+   205        00051556        somtskipws
+   206        00051561        somtsmalloc
+   207        0005156D        somtsmfree
+   208        00051578        somtsomcls
+   209        00051583        somtstab
+   210        0005158C        somtstabFirst
+   211        0005159A        somtstabFirstName
+   212        000515AC        somtstabNext
+   213        000515B9        somtstabNextName
+   214        000515CA        somtstrictidl
+   215        000515D8        somtstringFmt
+   216        000515E6        somttcAlignment
+   217        000515F6        somttcKind
+   218        00051601        somttcPrint
+   219        0005160D        somttcSeqFromListString
+   220        00051625        somttcSize
+   221        00051630        somttraverseParents
+   222        00051644        somttype
+   223        0005164D        somtuninitialiseMeta
+   224        00051662        somtuniqFmt
+   225        0005166E        somtuniqString
+   226        0005167D        somtunload
+   227        00051688        somtunsetEmitSignals
+   228        0005169D        somtunsetEmitSignalsSL
+   229        000516B4        somtuppercase
++   230        000516C2        somtwarn
++   231        000516CB        somtwarnSL
+   232        000516D6        somtwidenType
+   233        000516E4        somtwriteaccess
+   234        000516F4        somvalistGetTarget
+   235        00051707        somvalistSetTarget
+   236        0005171A        tciPrintf
+   237        00051724        tciSetException
+*/
+
diff -urN somfree\somc\src\symtab.c newsomfree3\somc\src\symtab.c
--- somfree\somc\src\symtab.c	Thu Jan 01 07:00:00 1970
+++ newsomfree3\somc\src\symtab.c	Sat Mar 16 14:09:25 2024
@@ -0,0 +1,403 @@
+/**************************************************************************
+ *
+ *  Copyright 2022, Yuri Prokushev
+ *
+ *  This file is part of osFree project
+ *
+ *  This program is free software: you can redistribute it and/or modify it
+ *  under the terms of the GNU Lesser General Public License as published by the
+ *  Free Software Foundation, either version 3 of the License, or (at your
+ *  option) any later version.
+ * 
+ *  This program is distributed in the hope that it will be useful, but WITHOUT
+ *  ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ *  FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for
+ *  more details.
+ *
+ *  You should have received a copy of the GNU Lesser General Public License
+ *  along with this program.  If not, see <http://www.gnu.org/licenses/>
+ *
+ */
+
+#define global
+#include <emitlib.h>
+
+
+#ifndef SOM_SOMC_NO_BACKCOMPAT
+// Use IBM SOM 3.0 ABI for non SOMLINK functions (1) or IBM SOM 2.1 ABI (0)
+SOMEXTERN int somtSOM30ABI;
+
+SOMEXTERN char * OPTLINK_DECL somtallocBuf(MemBuf *membuf, void *buf, long len)
+{
+  if (somtSOM30ABI)
+  {
+    OPTLINK_3ARGS(membuf, buf, len);
+  }
+
+  return somtallocBufSL(membuf, buf, len);
+}
+
+SOMEXTERN char * OPTLINK_DECL somtuniqString(MemBuf *membuf, char *s)
+{
+  if (somtSOM30ABI)
+  {
+    OPTLINK_2ARGS(membuf, s);
+  }
+
+  return somtuniqStringSL(membuf, s);
+}
+
+SOMEXTERN long OPTLINK_DECL somtkeyword(KeytabEntry *keytab, char *kword, long keytabsize)
+{
+  if (somtSOM30ABI)
+  {
+    OPTLINK_3ARGS(keytab, kword, keytabsize);
+  }
+
+  return somtkeywordSL(keytab, kword, keytabsize);
+}
+
+SOMEXTERN void * OPTLINK_DECL somtaddEntry(Stab *stab, char *name, void *ep)
+{
+  if (somtSOM30ABI)
+  {
+    OPTLINK_3ARGS(stab, name, ep);
+  }
+
+  return somtaddEntrySL(stab, name, ep);
+}
+
+SOMEXTERN void * OPTLINK_DECL somtgetEntry(Stab *stab, char *name)
+{
+  if (somtSOM30ABI)
+  {
+    OPTLINK_2ARGS(stab, name);
+  }
+
+  return somtgetEntrySL(stab, name);
+}
+
+SOMEXTERN void * OPTLINK_DECL somtstabFirst(Stab *stab, Sep **sepp)
+{
+  if (somtSOM30ABI)
+  {
+    OPTLINK_2ARGS(stab, sepp);
+  }
+
+  return somtstabFirstSL(stab, sepp);
+}
+
+SOMEXTERN void * OPTLINK_DECL somtstabFirstName(Stab *stab, char *name, Sep **sepp)
+{
+  if (somtSOM30ABI)
+  {
+    OPTLINK_3ARGS(stab, name, sepp);
+  }
+
+  return somtstabFirstNameSL(stab, name, sepp);
+}
+
+SOMEXTERN void * OPTLINK_DECL somtstabNext(Stab *stab, Sep **sepp)
+{
+  if (somtSOM30ABI)
+  {
+    OPTLINK_2ARGS(stab, sepp);
+  }
+
+  return somtstabNextSL(stab, sepp);
+}
+
+SOMEXTERN void * OPTLINK_DECL somtstabNextName(Stab *stab, Sep **sepp)
+{
+  if (somtSOM30ABI)
+  {
+    OPTLINK_2ARGS(stab, sepp);
+  }
+
+  return somtstabNextNameSL(stab, sepp);
+}
+
+SOMEXTERN void OPTLINK_DECL somtcreateMemBuf(MemBuf **membufp, size_t bufsize, long stabsize)
+{
+  if (somtSOM30ABI)
+  {
+    OPTLINK_3ARGS(membufp, bufsize, stabsize);
+  }
+
+  somtcreateMemBufSL(membufp, bufsize, stabsize);
+}
+
+SOMEXTERN void OPTLINK_DECL somtcreateStab(Stab *stab, long stabsize, long entrysize)
+{
+  if (somtSOM30ABI)
+  {
+    OPTLINK_3ARGS(stab, stabsize, entrysize);
+  }
+
+  somtcreateStabSL(stab, stabsize, entrysize);
+}
+
+SOMEXTERN int OPTLINK_DECL somticstrcmp(char *s, char *t)
+{
+  if (somtSOM30ABI)
+  {
+    OPTLINK_2ARGS(s, t);
+  }
+
+  return somticstrcmpSL(s, t);
+}
+
+SOMEXTERN void * OPTLINK_DECL somtaddEntryBuf(Stab *stab, char *name, void *ep, void *buf, size_t len)
+{
+  if (somtSOM30ABI)
+  {
+    OPTLINK_3ARGS(stab, name, ep);
+  }
+
+  return somtaddEntryBufSL(stab, name, ep, buf, len);
+}
+
+SOMEXTERN void OPTLINK_DECL somtfreeStab(Stab *stab, BOOL freeEp)
+{
+  if (somtSOM30ABI)
+  {
+    OPTLINK_2ARGS(stab, freeEp);
+  }
+
+  somtfreeStabSL(stab, freeEp);
+}
+
+#endif
+
+SOMEXTERN char * SOMLINK somtallocBufSL(MemBuf *membuf, void *buf, long len)
+{
+  return NULL;
+}
+
+SOMEXTERN char * SOMLINK somtuniqStringSL(MemBuf *membuf, char *s)
+{
+  char * rc=NULL;
+  SEntry * ep;
+
+  if (s)
+  {
+    ep=(SEntry *) somtgetEntry(membuf->stab, s);
+    if (ep)
+    {
+      rc=ep->name;
+    }
+    else
+    {
+      rc=somtallocBuf(membuf, s, strlen(s)+1);
+      somtaddEntry(membuf->stab, rc, ep);
+    }
+  }
+  return rc;
+}
+
+SOMEXTERN long SOMLINK somtkeywordSL(KeytabEntry *keytab, char *kword, long keytabsize)
+{
+  int rc=0;
+  for(int i=0;i<keytabsize/(int)sizeof(KeytabEntry);i++)
+  {
+    if (!strcmp(keytab->kword, kword))
+    {
+      rc=keytab->token;
+      break;
+    }
+    keytab++;
+  }
+  return rc;
+}
+
+// Calcualte hash index to include in Stab slot
+size_t getHashIndex(Stab *stab, char *name)
+{
+  size_t index=0;
+  if (name)
+  {
+    while(name[0]!=0)
+    {
+      index=index+tolower(name[0]);
+      name++;
+    }
+    if (index) index=(index % (stab->size-1)) + 1;
+  }
+  return index;
+}
+
+Sep * addItem(Stab *stab, Sep *sep, char *name, void *ep, void *epbuf, int entrysize)
+{
+  if (!epbuf) epbuf=somtsmallocSL(entrysize, 0);
+  memcpy(epbuf, ep, entrysize);
+  sep->ep=(SEntry *)epbuf;
+  sep->next=(Sep *)somtsmallocSL(sizeof(Sep), TRUE);
+  stab->nelms++;
+  return (Sep *)sep->ep;
+}
+                             
+SOMEXTERN void * SOMLINK somtaddEntrySL(Stab *stab, char *name, void *ep)
+{
+  Sep * buf=stab->buf+getHashIndex(stab, name);
+  while(buf->ep)
+  {
+    buf=buf->next;
+  }
+  return addItem(stab, buf, name, ep, NULL, stab->entrysize) ;
+}
+
+SOMEXTERN void * SOMLINK somtaddEntryBufSL(Stab *stab, char *name, void *ep, void *epbuf, size_t len)
+{
+  Sep * buf=stab->buf+getHashIndex(stab, name);
+  while(buf->ep)
+  {
+    buf=buf->next;
+  }
+
+  return addItem(stab, buf, name, ep, epbuf, len);
+}
+
+
+SOMEXTERN void * SOMLINK somtgetEntrySL(Stab *stab, char *name)
+{
+  Sep * buf=stab->buf+getHashIndex(stab, name);
+  while(buf->ep)
+  { 
+    if (stab->ignorecase && !somticstrcmpSL(buf->ep->name, name)) break;
+    if ((!stab->ignorecase) && !strcmp(buf->ep->name, name)) break;
+    buf=buf->next;
+  }
+
+  return buf->ep;
+}
+
+Sep * slot = NULL;
+Sep * sep = NULL;
+
+SOMEXTERN void * SOMLINK somtstabFirstSL(Stab *stab, Sep **sepp)
+{
+  slot=stab->buf;
+  sep=slot;
+  return somtstabNextSL(stab, sepp);
+}
+
+SOMEXTERN void * SOMLINK somtstabNextSL(Stab *stab, Sep **sepp)
+{
+  void * rc = NULL;
+
+  if (slot)
+  {
+    while(!sep->ep)
+    {
+      slot++;
+      if (slot==stab->limit) 
+      {
+        slot=NULL;
+        return NULL;
+      }
+      sep=slot;
+    }
+
+    rc=sep->ep;
+    if (sepp) *sepp=sep;
+    sep=sep->next;
+  }
+
+  return rc;
+}
+
+char * searchname = NULL;
+
+SOMEXTERN void * SOMLINK somtstabFirstNameSL(Stab *stab, char *name, Sep **sepp)
+{
+  sep=stab->buf+getHashIndex(stab, name);
+
+  if (sep->ep)
+  { 
+    do
+    {
+      if (stab->ignorecase)
+      {
+        if (!somticstrcmp(sep->ep->name, name)) break;
+      }
+      else
+      {
+        if (!strcmp(sep->ep->name, name)) break;
+      }
+      sep=sep->next;
+    } while(sep->ep);
+  }
+
+  searchname=name;
+  if (sepp) *sepp=sep;
+  
+  return sep->ep;
+}
+
+
+SOMEXTERN void * SOMLINK somtstabNextNameSL(Stab *stab, Sep **sepp)
+{
+  if (sep->ep)
+  { 
+    do
+    {
+      if (stab->ignorecase)
+      {
+        if (!somticstrcmpSL(sep->ep->name, searchname)) break;
+      }
+      else
+      {
+        if (!strcmp(sep->ep->name, searchname)) break;
+      }
+      sep=sep->next;
+    } while(sep->ep);
+  }
+
+  if (sepp) *sepp=sep;
+  
+  return sep->ep;
+}
+
+void * globalbuf;
+
+SOMEXTERN void SOMLINK somtcreateMemBufSL(MemBuf **membufp, size_t bufsize, long stabsize)
+{
+  MemBuf * membuf = *membufp;
+  if (!membuf)
+  {
+    membuf=(MemBuf *)somtsmallocSL(sizeof(MemBuf), 1);
+  }
+  membuf->size=bufsize;
+  membuf->cur=(char *)somtsmallocSL(bufsize, 0);
+  if (stabsize)
+  {
+    membuf->stab=(Stab *) somtsmallocSL(sizeof(Stab), 0);
+    somtcreateStabSL(membuf->stab, stabsize, sizeof(SEntry));
+    membuf->stab->membuf=membuf;
+//    somtallocBufSL((MemBuf *)membuf->base, globalbuf, 1);
+  }
+}
+
+SOMEXTERN void SOMLINK somtcreateStabSL(Stab *stab, long stabsize, long entrysize)
+{
+  if (stab)
+  {
+    stab->size=stabsize;
+    stab->entrysize=entrysize;
+    stab->buf=(Sep *)somtsmallocSL(stabsize*sizeof(Sep), TRUE);
+    stab->base=stab->buf;
+    stab->limit=stab->buf+stabsize/* *sizeof(Sep) */;
+    stab->nelms=0;
+    stab->membuf=NULL;
+  }
+}
+
+SOMEXTERN int SOMLINK somticstrcmpSL(char *s, char *t)
+{
+  return _stricmp(s, t);
+}
+
+SOMEXTERN void SOMLINK somtfreeStabSL(Stab *stab, BOOL freeEp)
+{
+}
+
diff -urN somfree\somc\win32\somc.def newsomfree3\somc\win32\somc.def
--- somfree\somc\win32\somc.def	Thu Jan 01 07:00:00 1970
+++ newsomfree3\somc\win32\somc.def	Sat Mar 16 14:09:25 2024
@@ -0,0 +1,271 @@
+;
+; Copyright 2022, Yuri Prokushev
+;
+; This file is part of osFree project
+;
+; This program is free software: you can redistribute it and/or modify it
+; under the terms of the GNU Lesser General Public License as published by the
+; Free Software Foundation, either version 3 of the License, or (at your
+; option) any later version.
+; 
+; This program is distributed in the hope that it will be useful, but WITHOUT
+; ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+; FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for
+; more details.
+;
+; You should have received a copy of the GNU Lesser General Public License
+; along with this program.  If not, see <http://www.gnu.org/licenses/>
+;
+
+LIBRARY		SOMC
+VERSION		1.0
+EXPORTS
+;        TCCalloc
+;        TCFree
+;        TCMalloc
+;        TCRealloc
+;        _DLL_InitTerm
+;        get_double_alignment
+;        somVaBuf_add
+;        somVaBuf_create
+;        somVaBuf_destroy
+;        somVaBuf_get_valist
+        somtAncestorClass
+        somtCPP
+;        somtDllStem
+        somtGetReintroducedMethods
+        somtInitialiseCreatetc
+        somtInitialiseEmitlib
+        somtInitialiseSmmeta
+        somtInitialiseSmsmall
+        somtInitialiseSmtypes
+        somtInitialiseSomc
+;        somtParentNumFromName
+        somtaddEntry
+        somtaddEntryBuf
+        somtaddExt
+        somtaddGAtt
+        somtaddHeader
+        somtaddstar
+        somtallocBuf
+        somtallocDataList
+        somtallocMethodList
+        somtallocMlist
+        somtargFlag
+        somtarrayToPtr
+;        somtattMap
+        somtattNormalise
+;        somtattalloc
+        somtattjoin
+        somtbasename
+        somtcalcFileName
+        somtcalloc
+        somtclassIdlCall
+        somtclassList
+        somtclassName
+        somtclassPrefix
+        somtcleanFiles
+        somtcleanFilesFatal
+        somtcleanup_f
+        somtclsfilename
+        somtclsname
+        somtcreateMemBuf
+        somtcreateStab
+        somtcreateTypeCodes
+        somtctos
+        somtdbcsLastChar
+        somtdbcsPostincr
+        somtdbcsPreincr
+        somtdbcsScan
+        somtdbcsStrchr
+        somtdbcsStrrchr
+        somtdbcsStrstr
+        somtdbcslowercase
+        somtdbcsuppercase
+        somtdeclareIdlVarargs
+        somtdiskFull
+        somtdupMlist
+        somtdymain
+;        somtemitClassDataTokens
+        somtemitModule
+        somtemitModuleTypes
+        somtemitPassthru
+        somtemitPredefinedTcConstants
+;        somtemitPredefinedTypeCode
+        somtemitReturns
+        somtemitTcConstant
+        somtemitTypes
+        somtepname
+        somteptotype
+        somterror
+        somterrorSL
+        somtexit
+        somtext
+        somtfatal
+        somtfatalSL
+        somtfclose
+        somtfcloseSL
+        somtfexists
+        somtfilePath
+        somtfileStem
+        somtfindBaseEp
+        somtfindBaseEpNonPtr
+        somtfindMethodName
+        somtfree
+        somtfreeDataList
+        somtfreeMethodList
+        somtfreeMlist
+        somtfreeStab
+        somtfreeWorld
+        somtfullComment
+        somtfullPrototype
+        somtfullTypedef
+        somtg_buf
+        somtg_f
+        somtg_membuf
+        somtg_sccsid
+        somtg_somlink
+        somtgenAttStubs
+        somtgenSeqName
+        somtgetAbistyle
+        somtgetAtt
+        somtgetDesc
+        somtgetEntry
+        somtgetNonRepeatedParent
+;        somtgetOidlAtt
+        somtgetType
+        somtgetVersion
+;        somtgetap
+        somtgetatt
+        somtgetdatt
+        somtgetgatt
+        somtglbdefs
+        somthandleDiskFull
+        somticstrcmp
+        somtimplicit
+        somtimplicitArgs
+        somtimplicitMeta
+        somtincludeOnce
+;        somtinitMalloc
+        somtinitialiseMeta
+        somtinternal
+        somtinternalSL
+        somtinternal_f
+        somtipcbuf
+        somtisDbcs
+;        somtisInheritedModifierSet
+        somtisMutRef
+;        somtisSpecialMethod
+        somtisparent
+        somtisvoid
+        somtkeyword
+        somtlistAttribute
+;        somtload
+        somtlowercase
+        somtmajorVersion
+        somtmalloc
+        somtmclose
+        somtmeta
+        somtmget
+        somtminorVersion
+        somtmlistend
+        somtmodule
+        somtmopen
+        somtmp
+        somtmprintf
+        somtmrierror
+        somtmrifatal
+        somtmriinternal
+        somtmrimsg
+        somtmriwarn
+        somtmsg
+        somtmsgSL
+        somtnewMethodsCount
+        somtnextword
+;        somtnotc
+        somtnthArg
+        somtobseleteHeaderFile
+        somtoidlComment
+        somtokfopen
+        somtokremove
+        somtopenEmitFile
+        somtopenEmitFileCalled
+        somtopenEmitFileSL
+        somtoutPath
+        somtpclsfilename
+        somtpclsname
+        somtprefixedPrototype
+        somtprivateMethodsCount
+        somtprocessTraps
+        somtqualifyNames
+        somtreadDescFile
+        somtrealExit
+        somtrealloc
+        somtremoveExt
+        somtreplaceDataName
+        somtresetEmitSignals
+        somtresetEmitSignalsSL
+        somtreturnsPtr
+        somtreturnsStruct
+        somtrmSelf
+        somtrmstar
+        somtsatos
+        somtsaved
+        somtscbuf
+        somtscmsg
+        somtsearchFile
+        somtsetDefaultDesc
+        somtsetEmitSignals
+        somtsetInternalMessages
+        somtsetTypeDefn
+;        somtsetext
+        somtshortArgList
+        somtshortDefine
+        somtshowVersion
+        somtsimpleName
+        somtsizeofEntry
+        somtskipws
+        somtsmalloc
+        somtsmfree
+        somtsomcls
+        somtstab
+        somtstabFirst
+        somtstabFirstName
+        somtstabNext
+        somtstabNextName
+        somtstrictidl
+        somtstringFmt
+        somttcAlignment
+        somttcKind
+;        somttcPrint
+        somttcSeqFromListString
+        somttcSize
+        somttraverseParents
+        somttype
+        somtuninitialiseMeta
+        somtuniqFmt
+        somtuniqString
+        somtunload
+        somtunsetEmitSignals
+        somtunsetEmitSignalsSL
+        somtuppercase
+        somtwarn
+        somtwarnSL
+        somtwidenType
+        somtwriteaccess
+;        somvalistGetTarget
+;        somvalistSetTarget
+;        tciPrintf
+;        tciSetException
+
+; somFree extensions
+        somttypeSL
+        somtloadSL
+        somtcreateStabSL
+        somtaddEntrySL
+        somtgetEntrySL
+	somtsmallocSL
+	somtaddModifierSL
+        somtgetattSL
+        somtsearchFileSL
+
diff -urN somfree\somc\win32\somc.mak newsomfree3\somc\win32\somc.mak
--- somfree\somc\win32\somc.mak	Thu Jan 01 07:00:00 1970
+++ newsomfree3\somc\win32\somc.mak	Sat Mar 16 14:09:25 2024
@@ -0,0 +1,98 @@
+#
+#  Copyright 2022, Yuri Prokushev
+#
+#  This file is part of osFree project
+#
+#  This program is free software: you can redistribute it and/or modify it
+#  under the terms of the GNU Lesser General Public License as published by the
+#  Free Software Foundation, either version 3 of the License, or (at your
+#  option) any later version.
+# 
+#  This program is distributed in the hope that it will be useful, but WITHOUT
+#  ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+#  FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for
+#  more details.
+#
+#  You should have received a copy of the GNU Lesser General Public License
+#  along with this program.  If not, see <http://www.gnu.org/licenses/>
+#
+
+!include $(MAKEDEFS)
+
+OUTDIR=$(OUTDIR_BIN)
+INTDIR=$(BUILDTYPE)
+
+DLLNAME=somc
+
+TARGET_DLL=$(OUTDIR)\$(DLLNAME).dll
+TARGET_PDB=$(OUTDIR)\$(DLLNAME).pdb
+TARGET_MAP=$(INTDIR)\$(DLLNAME).map
+TARGET_DEF=..\$(PLATFORM_DEF)\$(DLLNAME).def
+
+PARTOPTS=	$(STDOPT)								\
+			/DWIN32_LEAN_AND_MEAN 					\
+			/DHAVE_CONFIG_H							\
+			/I$(INTDIR)								\
+			/I..\win32								\
+			/I..\include							\
+			/I..\src								\
+			/I..\..\include\$(PLATFORM)				\
+			/I..\..\include\$(PLATFORM_DEF)			\
+			/I..\..\include							\
+			/I..\..\somidl\$(PLATFORM)				\
+			/I..\..\somcdr\$(PLATFORM)\$(BUILDTYPE)	\
+			/I..\..\somcdr\include					\
+			/I..\..\somcdr\src						\
+			/I..\..\rhbmtut\include					\
+			/I..\..\somkpub\include					\
+			/I..\..\somtk\include					\
+			$(CC_OUT_PDB)$(TARGET_PDB)	
+
+OBJS=	$(INTDIR)\somc.obj	\
+		$(INTDIR)\symtab.obj	\
+		$(INTDIR)\emitlib.obj	\
+		$(INTDIR)\modifiers.obj	\
+		$(INTDIR)\smlib.obj
+
+all: $(TARGET_DLL)
+
+clean:
+	$(CLEAN) $(TARGET_DLL) $(TARGET_PDB) $(TARGET_MAP) $(OBJS) $(INTDIR)\$(DLLNAME).res $(OUTDIR)\$(DLLNAME).exp $(OUTDIR)\$(DLLNAME).lib
+	
+$(TARGET_DLL): $(OBJS) $(OUTDIR) $(TARGET_DEF) $(INTDIR)\$(DLLNAME).res
+	$(CC) $(CC_OUT_DLL)$@ $(OBJS)		\
+			$(INTDIR)\$(DLLNAME).res	\
+			$(CC_OUT_PDB)$(TARGET_PDB)	\
+			$(CC_LINK)					\
+			$(LDFLAGS)					\
+			$(LD_DEF)$(TARGET_DEF)
+	$(POSTLINK_DLL) $@
+
+$(INTDIR)\somc.obj: ..\src\somc.c $(INTDIR)
+	$(CC) /c $(PARTOPTS) $(CC_OUT_OBJ)$@ ..\src\somc.c
+
+$(INTDIR)\symtab.obj: ..\src\symtab.c $(INTDIR)
+	$(CC) /c $(PARTOPTS) $(CC_OUT_OBJ)$@ ..\src\symtab.c
+
+$(INTDIR)\emitlib.obj: ..\src\emitlib.c $(INTDIR)
+	$(CC) /c $(PARTOPTS) $(CC_OUT_OBJ)$@ ..\src\emitlib.c
+
+$(INTDIR)\smlib.obj: ..\src\smlib.c $(INTDIR)
+	$(CC) /c $(PARTOPTS) $(CC_OUT_OBJ)$@ ..\src\smlib.c
+
+$(INTDIR)\modifiers.obj: ..\src\modifiers.c $(INTDIR)
+	$(CC) /c $(PARTOPTS) $(CC_OUT_OBJ)$@ ..\src\modifiers.c
+
+$(INTDIR):
+	mkdir $@
+
+$(INTDIR)\$(DLLNAME).res: ..\win32\$(DLLNAME).rc
+	rc /nologo /r /I.. /I..\..\include\$(PLATFORM) /fo$@ ..\win32\$(DLLNAME).rc
+
+dist:
+
+
+
+
+test:
+
diff -urN somfree\somc\win32\somc.rc newsomfree3\somc\win32\somc.rc
--- somfree\somc\win32\somc.rc	Thu Jan 01 07:00:00 1970
+++ newsomfree3\somc\win32\somc.rc	Sat Mar 16 14:09:25 2024
@@ -0,0 +1,50 @@
+/**************************************************************************
+ *
+ *  Copyright 2022, Yuri Prokushev
+ *
+ *  This file is part of osFree project
+ *
+ *  This program is free software: you can redistribute it and/or modify it
+ *  under the terms of the GNU Lesser General Public License as published by the
+ *  Free Software Foundation, either version 3 of the License, or (at your
+ *  option) any later version.
+ * 
+ *  This program is distributed in the hope that it will be useful, but WITHOUT
+ *  ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ *  FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for
+ *  more details.
+ *
+ *  You should have received a copy of the GNU Lesser General Public License
+ *  along with this program.  If not, see <http://www.gnu.org/licenses/>
+ *
+ */
+
+#include <windows.h>
+#include <depvers.h>
+
+1 VERSIONINFO
+	PRODUCTVERSION DEPVERS_somtkpkg_INT4
+	FILEOS VOS__WINDOWS32
+	FILEVERSION DEPVERS_som_INT4
+	FILETYPE VFT_DLL
+BEGIN
+	BLOCK "StringFileInfo"
+	BEGIN
+		BLOCK "140904E4"
+		BEGIN
+			VALUE "CompanyName","Yuri Prokushev\000\000"
+			VALUE "LegalCopyright","Copyright й Yuri Prokushev 2021\000\000"
+			VALUE "ProductName",DEPVERS_somtkpkg_PRODUCTNAME
+			VALUE "ProductVersion",DEPVERS_somtkpkg_STR4
+			VALUE "Comments","Uncontrolled Release\000\000"
+			VALUE "FileDescription","SOM kernel\000\000"
+			VALUE "FileVersion",DEPVERS_som_STR4
+			VALUE "InternalName","somc\000\000"
+			VALUE "OriginalFilename","SOMC.DLL\000\000"
+		END
+	END
+    BLOCK "VarFileInfo"
+    BEGIN
+        VALUE "Translation", 0x1409, 1252
+    END
+END
diff -urN somfree\somcorb2\os2\somcorba.cmd newsomfree3\somcorb2\os2\somcorba.cmd
--- somfree\somcorb2\os2\somcorba.cmd	Thu Jan 01 07:00:00 1970
+++ newsomfree3\somcorb2\os2\somcorba.cmd	Sat Mar 16 14:09:26 2024
@@ -0,0 +1,34 @@
+@echo off
+
+if "%SOMBASE%"=="" goto sombase
+
+if not exist %SOMBASE%\include\somcorba.gen goto normal
+echo Generating CORBA C bindings in progress...
+goto end
+
+:normal
+echo Generating the CORBA C Bindings:
+set SC=%SOMBASE%\bin\sc.exe
+cd %SOMBASE%\include
+attrib -R som.h
+attrib -R gen_c.efw
+attrib -R gen_emit.efw
+attrib -R gen_make.efw
+attrib -R gen_mk32.efw
+copy som.hc       som.h > NUL
+copy gen_c.efc    gen_c.efw  > NUL
+copy gen_emit.efc gen_emit.efw  > NUL
+copy gen_make.efc gen_make.efw  > NUL
+copy gen_mk32.efc gen_mk32.efw > NUL
+set SMADDSTAR=
+echo somcorba.gen  > somcorba.gen
+%SC% -%% -S150000 -mnoaddstar -mnochk -sh *.idl
+if exist somdtype.idl %SC% -mnoaddstar -mnochk -sh -DEMIT_SOMDTYPES somdtype.idl
+if not errorlevel 0 goto end
+goto end
+
+:sombase
+echo SOMBASE should be set before running somcorba.
+goto end
+
+:end
diff -urN somfree\somcorb2\win32\somcorba.cmd newsomfree3\somcorb2\win32\somcorba.cmd
--- somfree\somcorb2\win32\somcorba.cmd	Thu Jan 01 07:00:00 1970
+++ newsomfree3\somcorb2\win32\somcorba.cmd	Sat Mar 16 14:09:26 2024
@@ -0,0 +1,41 @@
+@echo off
+
+if "%ProgramFiles%\somtk\bin\" == "%~dp0" set SOMBASE=%ProgramFiles%\somtk
+if "%ProgramFiles(x86)%\somtk\bin\" == "%~dp0" set SOMBASE=%ProgramFiles(x86)%\somtk
+if "%ProgramFiles(Arm)%\somtk\bin\" == "%~dp0" set SOMBASE=%ProgramFiles(Arm)%\somtk
+if "%ProgramW6432%\somtk\bin\" == "%~dp0" set SOMBASE=%ProgramW6432%\somtk
+
+if "%SOMBASE%x" == "x" if exist "%ProgramFiles%\somtk" set SOMBASE=%ProgramFiles%\somtk
+
+if "%SOMBASE%"=="" goto sombase
+
+if not exist %SOMBASE%\include\somcorba.gen goto normal
+echo Generating CORBA C bindings in progress...
+goto end
+
+:normal
+echo Generating the CORBA C Bindings:
+set SC=%SOMBASE%\bin\sc.exe
+cd %SOMBASE%\include
+attrib -R som.h
+attrib -R gen_c.efw
+attrib -R gen_emit.efw
+attrib -R gen_make.efw
+attrib -R gen_mk32.efw
+copy som.hc       som.h > NUL
+copy gen_c.efc    gen_c.efw  > NUL
+copy gen_emit.efc gen_emit.efw  > NUL
+copy gen_make.efc gen_make.efw  > NUL
+copy gen_mk32.efc gen_mk32.efw > NUL
+set SMADDSTAR=
+echo somcorba.gen  > somcorba.gen
+%SC% -%% -S150000 -mnoaddstar -mnochk -sh *.idl
+if exist somdtype.idl %SC% -mnoaddstar -mnochk -sh -DEMIT_SOMDTYPES somdtype.idl
+if not errorlevel 0 goto end
+goto end
+
+:sombase
+echo SOMBASE should be set before running somcorba.
+goto end
+
+:end
diff -urN somfree\somdsrv\makedefs.cf newsomfree3\somdsrv\makedefs.cf
--- somfree\somdsrv\makedefs.cf	Thu Jan 01 07:00:00 1970
+++ newsomfree3\somdsrv\makedefs.cf	Sat Mar 16 14:09:26 2024
@@ -0,0 +1,4 @@
+NAME somdsvr
+DEPENDS somtklib
+PROVIDES somdsvr
+VERSION 1.0
diff -urN somfree\somdsrv\src\somdsvr.c newsomfree3\somdsrv\src\somdsvr.c
--- somfree\somdsrv\src\somdsvr.c	Thu Jan 01 07:00:00 1970
+++ newsomfree3\somdsrv\src\somdsvr.c	Sat Mar 16 14:09:26 2024
@@ -0,0 +1,973 @@
+/**************************************************************************
+ *
+ *  Copyright 2008, Roger Brown
+ *
+ *  This file is part of Roger Brown's Toolkit.
+ *
+ *  This program is free software: you can redistribute it and/or modify it
+ *  under the terms of the GNU Lesser General Public License as published by the
+ *  Free Software Foundation, either version 3 of the License, or (at your
+ *  option) any later version.
+ * 
+ *  This program is distributed in the hope that it will be useful, but WITHOUT
+ *  ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ *  FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for
+ *  more details.
+ *
+ *  You should have received a copy of the GNU Lesser General Public License
+ *  along with this program.  If not, see <http://www.gnu.org/licenses/>
+ *
+ */
+
+/*
+ * $Id: somdsvr.c 7 2013-01-19 00:54:38Z somtoolkit $
+ */
+
+#include <rhbopt.h>
+
+#ifdef _WIN32
+	#include <windows.h>
+#endif
+
+#include <rhbsomex.h>
+
+#ifdef __cplusplus
+	#include <som.xh>
+	#include <somir.xh>
+	#include <somd.xh>
+	#include <impldef.xh>
+	#include <implrep.xh>
+	#include <emtypes.xh>
+	#include <emregdat.xh>
+	#include <eman.xh>
+#else
+	#include <som.h>
+	#include <somir.h>
+	#include <somd.h>
+	#include <impldef.h>
+	#include <implrep.h>
+	#include <emtypes.h>
+	#include <emregdat.h>
+	#include <eman.h>
+#endif
+
+#include <signal.h>
+#include <stdio.h>
+#include <stdlib.h>
+#include <rhbsomex.h>
+
+#ifdef _DEBUG
+	#include <sys/types.h>
+	#include <sys/stat.h>
+#endif
+
+#ifdef _WIN32
+	#include <process.h>
+#endif
+
+#if defined(_PLATFORM_UNIX_) && defined(__AUX__)
+	#ifdef __cplusplus
+		extern "C" int getpid(void);
+	#else
+		extern int getpid();
+	#endif
+#else
+	#ifdef HAVE_UNISTD_H
+		#include <unistd.h>
+	#endif
+#endif
+
+#ifdef __cplusplus
+/* mappings from C mappings */
+#define ImplRepository_find_impldef_by_alias(a,b,c)				a->find_impldef_by_alias(b,c)
+#define ImplRepository_find_impldef(a,b,c)						a->find_impldef(b,c)
+#define SOMObject_somFree(a)									a->somFree()
+#define SOMOA_interrupt_server(a,b)								a->interrupt_server(b)
+#define SOMOA_deactivate_impl(a,b,c)							a->deactivate_impl(b,c)
+#define SOMOA_impl_is_ready(a,b,c)								a->impl_is_ready(b,c)
+#define ImplementationDefNew()									new ImplementationDef
+#define SOMOANew()												new SOMOA
+#define SOMObject_somPrintSelf(a)								a->somPrintSelf()
+#define ImplementationDef__get_impl_hostname(a,b)				a->_get_impl_hostname(b)
+#define ImplementationDef__get_impl_id(a,b)						a->_get_impl_id(b)
+#define SOMOA_execute_request_loop(a,b,c)						a->execute_request_loop(b,c)
+#define SOMObject_somDumpSelf(a,b)								a->somDumpSelf(b)
+#define SOMEEManNew()											new SOMEEMan
+#define SOMOA_execute_next_request(a,b,c)						a->execute_next_request(b,c)
+#define SOMOA_somDuplicateReference(a)							a->somDuplicateReference()
+#define SOMOA_somRelease(a)										a->somRelease()
+#define SOMEEMRegisterDataNew()									new SOMEEMRegisterData
+#define SOMEEMan_someUnRegister(a,b,c)							a->someUnRegister(b,c)
+#define SOMEEMRegisterData_someClearRegData(a,b)				a->someClearRegData(b)
+#define SOMEEMRegisterData_someSetRegDataEventMask(a,b,c,d)		a->someSetRegDataEventMask(b,c,d)
+#define SOMEEMRegisterData_someSetRegDataSink(a,b,c)			a->someSetRegDataSink(b,c)
+#define SOMEEMRegisterData_someSetRegDataSinkMask(a,b,c)		a->someSetRegDataSinkMask(b,c)
+#define SOMEEMRegisterData_someSetRegDataClientType(a,b,c)		a->someSetRegDataClientType(b,c)
+#define SOMEEMan_someRegisterProc(a,b,c,d,e)					a->someRegisterProc(b,c,d,e)
+#define SOMEEMan_someQueueEvent(a,b,c)							a->someQueueEvent(b,c)
+#define SOMEClientEventNew()									new SOMEClientEvent
+#define SOMEClientEvent_somevSetEventClientType(a,b,c)			a->somevSetEventClientType(b,c)
+#define SOMEClientEvent_somevSetEventClientData(a,b,c)			a->somevSetEventClientData(b,c)
+#endif
+
+#ifdef _WIN32
+typedef void (* signal_handler_t)(int);
+#else
+#if defined(__cplusplus)
+extern "C"
+{
+#endif
+typedef void (* signal_handler_t)(int);
+
+#ifdef USE_THREADS
+static
+	#if defined(USE_PTHREADS)
+		void *
+	#else
+		DWORD CALLBACK 
+	#endif
+		run_impl_r(void *pv);
+
+	#ifdef USE_PTHREADS
+		#ifdef HAVE_PTHREAD_ATFORK
+			static void somdsvr_prepare(void);
+			static void somdsvr_parent(void);
+			static void somdsvr_child(void);
+		#endif
+	#endif
+
+	#if  defined(USE_PTHREADS)
+	static void signal_thread(int sig);
+	#endif
+#endif
+
+#if defined(__cplusplus)
+}
+#endif
+#endif
+
+struct run_impl_t
+{
+#ifdef USE_THREADS
+	#ifdef USE_PTHREADS
+		pthread_t thr_main,thr_child;
+		int pid_main;
+	#else
+		DWORD dw_main,dw_child;
+		HANDLE h_child;
+	#endif
+	Environment *ev;
+	int completed;
+#else
+	#ifdef USE_POSIX_SIGNALS
+		sigset_t pending;
+	#else
+		#error catch for moment
+	#endif
+	char *eventName;
+	SOMEClientEvent SOMSTAR clientEvent;
+	SOMEEMRegisterData SOMSTAR regData;
+	long token;
+	SOMEEMan SOMSTAR emanObject;
+	Environment ev;
+#endif
+};
+
+static struct run_impl_t *g_run_impl;
+static boolean somdsvr_quit_flag;
+static boolean check_for_quit(void);
+
+#if defined(_WIN32) && defined(USE_THREADS)
+static DWORD dwProcess;
+#endif
+
+static int main_pid;
+
+#ifndef RHBSOM_Trace
+#define  RHBSOM_Trace(x)     { char *p; p=x; somPrintf("%s:%d,%s\n",__FILE__,__LINE__,p); }
+#endif
+
+#ifdef __cplusplus
+	extern "C" {
+#endif
+#ifdef HAVE_ATEXIT
+static 
+	#ifdef HAVE_ATEXIT_VOID
+		void 
+	#endif
+	atexit_callback(void)
+{
+	if (getpid()==main_pid)
+	{
+		if (SOMD_SOMOAObject)
+		{
+			if (SOMD_ImplDefObject)
+			{
+				Environment ev;
+				SOM_InitEnvironment(&ev);
+				SOMOA_deactivate_impl(SOMD_SOMOAObject,&ev,SOMD_ImplDefObject);
+				SOM_UninitEnvironment(&ev);
+			}
+		}
+	}
+}
+#endif
+
+static void my_signal_handler(int i)
+{
+#ifdef _DEBUG
+	{
+		char buf[256];
+#	ifdef HAVE_SNPRINTF
+		int k=snprintf(buf,sizeof(buf),"%ld:%s:my_signal_handler(%d)\n",
+					(long)getpid(),__FILE__,i);
+#	else
+		int k=sprintf(buf,"%ld:%s,my_signal_handler(%d)\n",
+					(long)getpid(),__FILE__,i);
+#	endif
+#	ifdef _WIN32
+		DWORD dw=0;
+		WriteFile(GetStdHandle(STD_ERROR_HANDLE),buf,k,&dw,NULL);
+#	else
+		write(2,buf,k);
+#	endif
+	}
+#endif
+
+	if (g_run_impl)
+	{
+#ifdef USE_THREADS
+	#ifdef USE_PTHREADS
+		pthread_kill(g_run_impl->thr_main,i);
+	#else
+		BOOL b=PostThreadMessage(g_run_impl->dw_main,WM_QUIT,0,0);
+		RHBOPT_ASSERT(b)
+	#endif
+#else
+	#ifdef USE_POSIX_SIGNALS
+		sigaddset(&g_run_impl->pending,i);
+	#else
+		#error catch for moment
+	#endif
+
+		SOMEEMan_someQueueEvent(g_run_impl->emanObject,&g_run_impl->ev,g_run_impl->clientEvent);
+#endif
+	}
+}
+#ifdef __cplusplus
+	}
+#endif
+
+#ifndef USE_THREADS
+static void SOMLINK somdsvr_callback(void *,void *);
+#endif
+
+#ifdef USE_SIGNALS
+	#if defined(HAVE_SA_HANDLER_VOID_INT) || defined(_WIN32)
+		#define alloc_handler(x,y)		(y)
+	#else
+		typedef void (*sa_handler_t)(void);
+
+		struct signal_mapper_t
+		{
+			signal_handler_t handler;
+			int signum;
+			sa_handler_t mapper;
+		};
+
+		#define DEF_SIG_HANDLER(x)	\
+			static void sig_handler_##x(void); \
+			static struct signal_mapper_t sig_mapper_##x={NULL,x,sig_handler_##x}; \
+			static void sig_handler_##x(void) { sig_mapper_##x.handler(x); }
+
+		#define DEF_SIG_ENTRY(x)   &sig_mapper_##x
+
+		DEF_SIG_HANDLER(SIGABRT)
+		#ifdef SIGBUS
+		DEF_SIG_HANDLER(SIGBUS)
+		#endif
+		DEF_SIG_HANDLER(SIGFPE)
+		#ifdef SIGHUP
+		DEF_SIG_HANDLER(SIGHUP)
+		#endif
+		DEF_SIG_HANDLER(SIGILL)
+		DEF_SIG_HANDLER(SIGINT)
+		#ifdef SIGQUIT
+		DEF_SIG_HANDLER(SIGQUIT)
+		#endif
+		#ifdef SIGBREAK
+		DEF_SIG_HANDLER(SIGBREAK)
+		#endif
+		DEF_SIG_HANDLER(SIGSEGV)
+		DEF_SIG_HANDLER(SIGTERM)
+
+		static sa_handler_t alloc_handler(int num,signal_handler_t handler)
+		{
+			static struct signal_mapper_t *map[]={
+				DEF_SIG_ENTRY(SIGABRT),
+		#ifdef SIGBUS
+				DEF_SIG_ENTRY(SIGBUS),
+		#endif
+				DEF_SIG_ENTRY(SIGFPE),
+		#ifdef SIGHUP
+				DEF_SIG_ENTRY(SIGHUP),
+		#endif
+				DEF_SIG_ENTRY(SIGILL),
+				DEF_SIG_ENTRY(SIGINT),
+		#ifdef SIGQUIT
+				DEF_SIG_ENTRY(SIGQUIT),
+		#endif
+		#ifdef SIGBREAK
+				DEF_SIG_ENTRY(SIGBREAK),
+		#endif
+				DEF_SIG_ENTRY(SIGSEGV),
+				DEF_SIG_ENTRY(SIGTERM)
+			};
+			int x=sizeof(map)/sizeof(map[0]);
+			struct signal_mapper_t **p=map;
+
+			while (x--)
+			{
+				struct signal_mapper_t *q=*p++;
+
+				if (q->signum==num)
+				{
+					q->handler=handler;
+					return q->mapper;
+				}
+			}
+
+			RHBOPT_ASSERT(!num)
+
+			return NULL;
+		}
+	#endif /* HAVE_SA_HANDLER_VOID_INT */
+#endif /* USE_SIGNALS */
+
+static void install_signal(int signum,signal_handler_t handler)
+{
+#ifdef USE_SIGNALS
+	#ifdef USE_SIGACTION
+		struct sigaction sa;
+		memset(&sa,0,sizeof(sa));
+		sa.sa_handler=alloc_handler(signum,handler);
+	#ifdef SA_RESTART
+		sa.sa_flags=SA_RESTART;
+	#endif
+		sigaction(signum,&sa,NULL);
+	#else
+		signal(signum,handler);
+	#endif
+#endif
+}
+
+#ifdef USE_THREADS
+#if defined(USE_PTHREADS)
+static void *run_impl_r(void *pv)
+#else
+static DWORD CALLBACK run_impl_r(void *pv)
+#endif
+{
+	struct run_impl_t *data=(struct run_impl_t *)pv;
+	SOMOA_execute_request_loop(SOMD_SOMOAObject,data->ev,SOMD_WAIT);
+	data->completed=1;
+#ifdef USE_PTHREADS
+	kill(data->pid_main,SIGTERM);
+	pthread_kill(data->thr_main,SIGTERM);
+	return NULL;
+#else
+	PostThreadMessage(data->dw_main,WM_QUIT,0,0);
+	return 0;
+#endif
+}
+#else
+static void SOMLINK sink_callback(SOMEEvent SOMSTAR a,void *pv)
+{
+	struct run_impl_t *data=(struct run_impl_t *)pv;
+#ifdef NSIG
+	int i=NSIG;
+#else
+	int i=sizeof(data->pending)<<3;
+#endif
+
+	SOMObject_somDumpSelf(a,0);
+
+	while (i--)
+	{
+		switch (i)
+		{
+		case SIGINT:
+#ifdef SIGQUIT
+		case SIGQUIT:
+#endif
+		case SIGTERM:
+#ifdef SIGBREAK
+		case SIGBREAK:
+#endif
+#ifdef SIGHUP
+		case SIGHUP:
+#endif
+			{
+#ifdef USE_SIGNALS
+				boolean b=sigismember(&data->pending,i);
+				sigdelset(&data->pending,i);
+#else
+				boolean b=0;
+#endif
+				if (b)
+				{
+					somPrintf("sink_callback(%d)\n",i);
+					switch (i)
+					{
+			#ifdef SIGBREAK
+					case SIGBREAK:
+			#endif
+			#ifdef SIGQUIT
+					case SIGQUIT:
+			#endif
+					case SIGTERM:
+						switch (i)
+						{
+						case SIGTERM: somPrintf("SIGTERM\n"); break;
+						case SIGQUIT: somPrintf("SIGQUIT\n"); break;
+			#ifdef SIGBREAK
+						case SIGBREAK: somPrintf("SIGBREAK\n"); break;
+			#endif
+						default: somPrintf("signal(%d)\n",i); break;
+						}
+
+						somPrintf("%s:%d quitting due to %d...\n",__FILE__,__LINE__,i);
+						somdsvr_quit_flag=1;
+						if (SOMD_SOMOAObject)
+						{
+							Environment ev;
+							SOM_InitEnvironment(&ev);
+							SOMOA_interrupt_server(SOMD_SOMOAObject,&ev);
+							SOM_UninitEnvironment(&ev);
+						}
+						break;
+					case SIGINT:
+						somPrintf("SIGINT\n");
+						break;
+			#ifdef SIGHUP
+					case SIGHUP:
+						somPrintf("SIGHUP\n");
+						break;
+			#endif
+					}
+				}
+			}
+		}
+	}
+}
+#endif
+
+static void run_impl(ImplementationDef SOMSTAR impl,
+				Environment *ev,
+				int argc,
+				char **argv
+#ifndef USE_THREADS
+				,SOMEEMan SOMSTAR eman
+#endif
+				)
+{
+	RHBOPT_unused(argc);
+
+	if (ev->_major)
+	{
+		somPrintf("%s\n",somExceptionId(ev));
+		return;
+	}
+
+	SOMD_ImplDefObject=impl;
+
+/*	SOMObject_somDumpSelf(impl,0);*/
+
+	RHBSOM_Trace("run_impl, creating SOMOA_impl_is_ready")
+
+	SOMOA_impl_is_ready(SOMD_SOMOAObject,ev,impl);
+
+	if (ev->_major)
+	{
+		somPrintf("%s\n",somExceptionId(ev));
+	}
+	else
+	{
+		char *q=ImplementationDef__get_impl_id(impl,ev);
+
+		if (q)
+		{
+			somPrintf("%s %s ready\n",argv[0],q);
+
+			SOMFree(q);
+		}
+
+		if (!somdsvr_quit_flag)
+		{
+			struct run_impl_t data;
+#ifdef USE_THREADS
+	#if defined(USE_PTHREADS)
+			sigset_t sigs;
+			void *pv=NULL;
+	#endif
+			data.completed=0;
+			data.ev=ev;
+	#if defined(USE_PTHREADS)
+			sigemptyset(&sigs);
+			sigaddset(&sigs,SIGINT);
+			sigaddset(&sigs,SIGTERM);
+	#ifdef SIGQUIT
+			sigaddset(&sigs,SIGQUIT);
+	#endif
+	#ifdef SIGBREAK
+			sigaddset(&sigs,SIGBREAK);
+	#endif
+#endif
+
+#ifdef USE_PTHREADS
+			data.pid_main=getpid();
+			data.thr_main=pthread_self();
+			pthread_create(&data.thr_child,RHBOPT_pthread_attr_default,run_impl_r,&data);
+#else
+			data.dw_main=GetCurrentThreadId();
+			data.h_child=CreateThread(NULL,0,run_impl_r,&data,0,&data.dw_child);
+#endif
+			g_run_impl=&data;
+
+			while (!data.completed)
+			{
+				int quit=0;
+				int i=0;
+#ifdef USE_PTHREADS
+				sigwait(&sigs,&i);
+				switch (i)
+				{
+#ifdef SIGBREAK
+				case SIGBREAK:
+#endif
+				case SIGTERM:
+				case SIGQUIT:
+					quit=1;
+					break;
+				}
+#else
+				MSG msg;
+				if (GetMessage(&msg,0,0,0))
+				{
+					TranslateMessage(&msg);
+					DispatchMessage(&msg);
+				}
+				if (msg.message==WM_QUIT) quit=1;
+#endif
+				if (quit && SOMD_SOMOAObject && !data.completed)
+				{
+					Environment ev2;
+					SOM_InitEnvironment(&ev2);
+					SOMOA_interrupt_server(SOMD_SOMOAObject,&ev2);
+					SOM_UninitEnvironment(&ev2);
+				}
+			}
+			g_run_impl=NULL;
+#ifdef USE_PTHREADS
+			pthread_join(data.thr_child,&pv);
+#else
+			WaitForSingleObject(data.h_child,INFINITE);
+			CloseHandle(data.h_child);
+#endif
+#else
+			SOM_InitEnvironment(&data.ev);
+			data.emanObject=eman;
+			data.eventName=(char *)"signal";
+			data.clientEvent=SOMEClientEventNew();
+			SOMEClientEvent_somevSetEventClientType(data.clientEvent,ev,data.eventName);
+			SOMEClientEvent_somevSetEventClientData(data.clientEvent,ev,&data);
+	#ifdef USE_POSIX_SIGNALS
+			sigemptyset(&data.pending);
+	#else
+		#error catch for moment
+	#endif
+			data.regData=SOMEEMRegisterDataNew();
+			SOMEEMRegisterData_someClearRegData(data.regData,ev);
+#ifdef __cplusplus
+			data.regData->someSetRegDataEventMask(ev,EMClientEvent,NULL);
+#else
+			somva_SOMEEMRegisterData_someSetRegDataEventMask(data.regData,ev,EMClientEvent,NULL);
+#endif
+			SOMEEMRegisterData_someSetRegDataClientType(data.regData,ev,data.eventName);
+			data.token=SOMEEMan_someRegisterProc(eman,ev,data.regData,sink_callback,&data);
+			g_run_impl=&data;
+			SOMOA_execute_request_loop(SOMD_SOMOAObject,ev,SOMD_WAIT);
+			g_run_impl=NULL;
+			SOMEEMan_someUnRegister(eman,ev,data.token);
+			SOMObject_somFree(data.regData);
+			SOMObject_somFree(data.clientEvent);
+			SOM_UninitEnvironment(&data.ev);
+#endif
+		}
+	}
+
+	if (!ev->_major)
+	{
+		SOMOA_deactivate_impl(SOMD_SOMOAObject,ev,impl);
+	}
+
+	SOMD_ImplDefObject=NULL;
+}
+
+#ifndef USE_THREADS
+static void SOMLINK somdsvr_callback(void *a,void *b)
+{
+	Environment ev;
+/*	somPrintf("somdsvr_callback(%s,%d)\n",__FILE__,__LINE__);*/
+	RHBOPT_unused(a);
+	RHBOPT_unused(b);
+	SOM_InitEnvironment(&ev);
+	if (SOMD_SOMOAObject) SOMOA_execute_next_request(SOMD_SOMOAObject,&ev,SOMD_NO_WAIT);
+	SOM_UninitEnvironment(&ev);
+}
+#endif
+
+static boolean check_for_quit(void)
+{
+#ifdef _WIN32
+	MSG msg;
+	if (PeekMessage(&msg,(HWND)-1L,WM_QUIT,WM_QUIT,PM_NOREMOVE))
+	{
+		somPrintf("PeekMessage reports a WM_QUIT waiting\n");
+		return 1;
+	}
+#endif
+
+	if (somdsvr_quit_flag) return 1;
+
+	return 0;
+}
+
+#ifdef USE_THREADS
+	#if defined(USE_PTHREADS)
+	static void signal_thread(int sig)
+	{
+		RHBOPT_unused(sig);
+	#ifdef USE_PTHREADS
+		#ifdef PTHREAD_CANCELED
+			pthread_exit((char *)PTHREAD_CANCELED);
+		#else
+			pthread_exit((char *)-1);
+		#endif
+	#else
+		pth_exit(PTH_CANCELED);
+	#endif
+	}
+	#endif
+	#ifdef USE_PTHREADS
+		#ifdef HAVE_PTHREAD_ATFORK
+			static void somdsvr_prepare(void)
+			{
+/*				somStartCriticalSection();*/
+			}
+			static void somdsvr_parent(void)
+			{
+/*				somEndCriticalSection();*/
+			}
+			static void somdsvr_child(void)
+			{
+/*				somEndCriticalSection();*/
+			}
+		#endif
+	#endif
+#endif
+
+int main(int argc,char **argv)
+{
+Environment ev;
+/*SOMClassMgr SOMSTAR clsMgr;*/
+int i=1;
+ImplementationDef SOMSTAR impl=NULL;
+#ifdef USE_SELECT
+SOMEEMan SOMSTAR eman=NULL;
+#endif
+
+#ifdef USE_POSIX_SIGNALS
+	{
+		sigset_t sigs;
+		sigemptyset(&sigs);
+		sigaddset(&sigs,SIGTERM);
+		sigaddset(&sigs,SIGINT);
+		sigaddset(&sigs,SIGHUP);
+	#ifdef SIGBREAK
+		sigaddset(&sigs,SIGBREAK);
+	#endif
+	#ifdef SIGQUIT
+		sigaddset(&sigs,SIGQUIT);
+	#endif
+
+		install_signal(SIGINT,my_signal_handler);
+		install_signal(SIGTERM,my_signal_handler);
+		install_signal(SIGHUP,my_signal_handler);
+	#ifdef SIGQUIT
+		install_signal(SIGQUIT,my_signal_handler);
+	#endif
+	#ifdef SIGBREAK
+		install_signal(SIGBREAK,my_signal_handler);
+	#endif
+
+	#ifdef USE_PTHREADS
+		pthread_sigmask(SIG_BLOCK,&sigs,NULL);
+	#else
+		sigprocmask(SIG_BLOCK,&sigs,NULL);
+	#endif
+
+	}
+#else
+	signal(SIGTERM,my_signal_handler);
+	signal(SIGINT,my_signal_handler);
+	signal(SIGBREAK,my_signal_handler);
+#endif
+
+#if defined(_WIN32) && defined(_DEBUG) && (0)
+	Sleep(5000);
+#endif
+
+#ifdef USE_THREADS
+	#ifdef USE_SIGACTION
+	{
+static struct sigaction sa;
+#ifdef SA_RESTART
+		sa.sa_flags=SA_RESTART;
+#endif
+#ifdef SIGBUS
+		sa.sa_handler=alloc_handler(SIGBUS,signal_thread);
+		sigaction(SIGBUS,&sa,NULL);
+#endif
+		sa.sa_handler=alloc_handler(SIGSEGV,signal_thread);
+		sigaction(SIGSEGV,&sa,NULL);
+		sa.sa_handler=alloc_handler(SIGILL,signal_thread);
+		sigaction(SIGILL,&sa,NULL);
+		sa.sa_handler=alloc_handler(SIGFPE,signal_thread);
+		sigaction(SIGFPE,&sa,NULL);
+		sa.sa_handler=alloc_handler(SIGABRT,signal_thread);
+		sigaction(SIGABRT,&sa,NULL);
+	}
+	#else
+		#if defined(USE_PTHREADS)
+			#error
+		#endif
+	#endif
+#endif
+
+	main_pid=getpid();
+
+#ifdef HAVE_ATEXIT
+	atexit(atexit_callback);
+#else
+	#ifdef _WIN32
+		#error what happened here?
+	#endif
+#endif
+
+	RHBSOM_Trace("main, about to call somEnvironmentNew")
+
+	/* clsMgr= */ somMainProgram();
+
+	RHBSOM_Trace("main, about to call SOM_InitEnvironment")
+
+#ifdef USE_THREADS
+	#ifdef USE_PTHREADS
+		#ifdef HAVE_PTHREAD_ATFORK
+			pthread_atfork(
+				somdsvr_prepare,
+				somdsvr_parent,
+				somdsvr_child);
+		#endif
+	#endif
+#endif
+
+	SOM_InitEnvironment(&ev);
+
+	RHBSOM_Trace("main, about to call SOMD_Init")
+
+	SOMD_Init(&ev);
+
+	if (ev._major)
+	{
+		somPrintf("somdsvr: %s\n",somExceptionId(&ev));
+		somExceptionFree(&ev);
+
+		somEnvironmentEnd();
+
+		return 1;
+	}
+
+	RHBSOM_Trace("main, SOMD_Init returned")
+
+	if (ev._major)
+	{
+		char *p=somExceptionId(&ev);
+		somPrintf("%s\n",p);
+		somExceptionFree(&ev);
+	}
+
+#ifdef USE_SELECT
+	RHBSOM_Trace("starting eman")
+
+	eman=SOMEEManNew();
+	if (eman)
+	{
+		SOMD_RegisterCallback(eman,somdsvr_callback);
+	}
+#endif
+
+	SOMD_SOMOAObject=SOMOANew();
+
+	if (SOMD_SOMOAObject)
+	{
+#if defined(USE_POSIX_SIGNALS) && !defined(USE_THREADS)
+		sigset_t old_mask,sigs;
+		sigemptyset(&sigs);
+		sigaddset(&sigs,SIGINT);
+		sigaddset(&sigs,SIGTERM);
+		sigprocmask(SIG_UNBLOCK,&sigs,&old_mask);
+#endif
+
+		if (SOMD_ImplRepObject && !check_for_quit())
+		{
+			while (i < argc)
+			{
+				if (0==strcmp(argv[i],"-a"))
+				{
+					i++;
+
+					if (i < argc)
+					{
+						char *a;
+						a=argv[i];
+						if (a)
+						{
+							impl=ImplRepository_find_impldef_by_alias(
+									SOMD_ImplRepObject,
+									&ev,
+									a);
+
+							if (!impl)
+							{
+								if (!ev._major)
+								{
+									somSetException(&ev,SYSTEM_EXCEPTION,ex_StExcep_BAD_PARAM,0);
+								}
+							}
+						}
+					}
+				}
+				else
+				{
+					impl=ImplRepository_find_impldef(
+							SOMD_ImplRepObject,
+							&ev,
+							argv[i]);
+
+					if (!impl)
+					{
+						if (!ev._major)
+						{
+							somSetException(&ev,SYSTEM_EXCEPTION,ex_StExcep_BAD_PARAM,0);
+						}
+					}
+				}
+
+				i++;
+			}
+		}
+
+		RHBSOM_Trace("main, checking environment again")
+
+		if (!ev._major)
+		{
+			RHBSOM_Trace("main, trying to run server")
+
+			if (impl)
+			{
+				run_impl(impl,&ev,argc,argv
+#ifndef USE_THREADS
+				,eman
+#endif
+				);
+
+				somReleaseObjectReference(impl);
+			}
+		}
+		
+		#if defined(USE_POSIX_SIGNALS) && !defined(USE_THREADS)
+			sigprocmask(SIG_BLOCK,&sigs,NULL);			
+		#endif
+
+		if (SOMD_SOMOAObject)
+		{
+			SOMObject SOMSTAR obj=NULL;
+/*			somStartCriticalSection();*/
+			obj=SOMD_SOMOAObject;
+			SOMD_SOMOAObject=NULL;
+/*			somEndCriticalSection();*/
+			if (obj) somReleaseObjectReference(obj);
+		}
+	}
+
+	if (ev._major)
+	{
+		char *p=somExceptionId(&ev);
+		somPrintf("%s\n",p);
+		somExceptionFree(&ev);
+		impl=0;
+	}
+
+#ifdef USE_SELECT
+	if (eman)
+	{
+		SOMD_RegisterCallback(NULL,NULL);
+		somReleaseObjectReference(eman);
+		eman=NULL;
+	}
+#endif
+
+	RHBSOM_Trace("main, calling SOMD_Uninit")
+
+	SOMD_Uninit(&ev);
+
+	RHBSOM_Trace("main, calling SOM_UninitEnvironment")
+
+	SOM_UninitEnvironment(&ev);
+
+	RHBSOM_Trace("main, calling somEnvironmentEnd")
+
+	somPrintf("%s finished\n",argv[0]);
+
+	somEnvironmentEnd();
+
+	RHBSOM_Trace("main, ended")
+
+	return 0;
+}
+
+#if defined(_WIN32) && !defined(_CONSOLE)
+int WINAPI WinMain(HINSTANCE hInstance,HINSTANCE hPrev,LPSTR lpCmdLine,INT nCmdShow)
+{
+	char buf[256];
+	if (GetModuleFileName(hInstance,buf,sizeof(buf)))
+	{
+		char *p=lpCmdLine;
+		char *argv[3]={buf,NULL,NULL};
+		int argc=1;
+		if (p) 
+		{
+			while (*p)
+			{
+				if (*p > ' ') break;
+				p++;
+			}
+		}
+		if (p) if (*p) argv[argc++]=p;
+		return main(argc,argv);
+	}
+
+	return 1;
+}
+#endif
diff -urN somfree\somdsrv\src\somdsvr.cpp newsomfree3\somdsrv\src\somdsvr.cpp
--- somfree\somdsrv\src\somdsvr.cpp	Thu Jan 01 07:00:00 1970
+++ newsomfree3\somdsrv\src\somdsvr.cpp	Sat Mar 16 14:09:26 2024
@@ -0,0 +1 @@
+#include <somdsvr.c>
diff -urN somfree\somdsrv\unix\somdsvr.mak newsomfree3\somdsrv\unix\somdsvr.mak
--- somfree\somdsrv\unix\somdsvr.mak	Thu Jan 01 07:00:00 1970
+++ newsomfree3\somdsrv\unix\somdsvr.mak	Sat Mar 16 14:09:26 2024
@@ -0,0 +1,70 @@
+#
+#  Copyright 2008, Roger Brown
+#
+#  This file is part of Roger Brown's Toolkit.
+#
+#  This program is free software: you can redistribute it and/or modify it
+#  under the terms of the GNU Lesser General Public License as published by the
+#  Free Software Foundation, either version 3 of the License, or (at your
+#  option) any later version.
+# 
+#  This program is distributed in the hope that it will be useful, but WITHOUT
+#  ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+#  FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for
+#  more details.
+#
+#  You should have received a copy of the GNU Lesser General Public License
+#  along with this program.  If not, see <http://www.gnu.org/licenses/>
+#
+#  $Id: somdsvr.mak 50 2020-06-07 21:17:38Z somtoolkit $
+
+include $(MAKEDEFS)
+
+TARGET=$(OUTDIR_BIN)/$(EXEPREFIX)somdsvr$(EXESUFFIX)
+TARGET_C=$(OUTDIR_BIN)/$(EXEPREFIX)somdsvr-c$(EXESUFFIX)
+TARGET_CPP=$(OUTDIR_BIN)/$(EXEPREFIX)somdsvr-cpp$(EXESUFFIX)
+INCL=		-I. \
+			-I.. \
+			-I../../somidl/$(PLATFORM) \
+			-I../../somkpub/include		\
+			-I../../somtk/include		\
+			$(STDINCL)
+OBJS_CPP=$(INTDIR)/somdsvr-cpp.o
+OBJS_C=$(INTDIR)/somdsvr-c.o
+
+all: $(TARGET_C) $(TARGET_CPP) $(TARGET)
+
+clean:
+	$(CLEAN) $(TARGET) $(TARGET_C) $(TARGET_CPP) $(OBJS_C) $(OBJS_CPP)
+
+$(INTDIR)/somdsvr-cpp.o: ../src/somdsvr.cpp ../src/somdsvr.c
+	$(CXX_EXE) -I../src $(STDOPTXX) $(INCL)  -c ../src/somdsvr.cpp -o $@
+
+$(INTDIR)/somdsvr-c.o: ../src/somdsvr.c
+	$(CC_EXE) $(STDOPT) $(INCL)  -c ../src/somdsvr.c -o $@
+
+$(TARGET_CPP): $(OBJS_CPP)
+	$(LINKAPPXX) $(LINKAPP_HEAD) $(OBJS_CPP) -o $@ \
+		`$(SHLB_REF) somd somd` \
+		`$(SHLB_REF) somem somem` \
+		`$(SHLB_REF) somref somref` \
+		`$(SHLB_REF) som som` \
+		`$(SHLB_REF) somos somos` \
+		`$(SHLB_MAP) somdsvr somdsvr-cpp` \
+		$(UUIDLIBS) $(STDLIBXX) $(LINKAPP_TAIL)
+
+$(TARGET_C): $(OBJS_C)
+	$(LINKAPP) $(LINKAPP_HEAD) $(OBJS_C) -o $@ \
+		`$(SHLB_REF) somd somd` \
+		`$(SHLB_REF) somem somem` \
+		`$(SHLB_REF) somref somref` \
+		`$(SHLB_REF) som som` \
+		`$(SHLB_REF) somos somos` \
+		`$(SHLB_MAP) somdsvr somdsvr-c` \
+		$(UUIDLIBS) $(STDLIB) $(LINKAPP_TAIL)
+
+$(TARGET): 
+	cd `dirname $@`; ln -s `basename $(TARGET_C)` `basename $@`
+
+dist install test:
+
diff -urN somfree\somdsrv\win32\link386.c newsomfree3\somdsrv\win32\link386.c
--- somfree\somdsrv\win32\link386.c	Thu Jan 01 07:00:00 1970
+++ newsomfree3\somdsrv\win32\link386.c	Sat Mar 16 14:09:26 2024
@@ -0,0 +1,25 @@
+/**************************************************************************
+ *
+ *  Copyright 2008, Roger Brown
+ *
+ *  This file is part of Roger Brown's Toolkit.
+ *
+ *  This program is free software: you can redistribute it and/or modify it
+ *  under the terms of the GNU Lesser General Public License as published by the
+ *  Free Software Foundation, either version 3 of the License, or (at your
+ *  option) any later version.
+ * 
+ *  This program is distributed in the hope that it will be useful, but WITHOUT
+ *  ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ *  FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for
+ *  more details.
+ *
+ *  You should have received a copy of the GNU Lesser General Public License
+ *  along with this program.  If not, see <http://www.gnu.org/licenses/>
+ *
+ */
+
+#define LINK386_SOMTK
+#define LINK386_USER32
+
+#include <link386.h>
diff -urN somfree\somdsrv\win32\somdsvr.mak newsomfree3\somdsrv\win32\somdsvr.mak
--- somfree\somdsrv\win32\somdsvr.mak	Thu Jan 01 07:00:00 1970
+++ newsomfree3\somdsrv\win32\somdsvr.mak	Sat Mar 16 14:09:26 2024
@@ -0,0 +1,85 @@
+#
+#  Copyright 2008, Roger Brown
+#
+#  This file is part of Roger Brown's Toolkit.
+#
+#  This program is free software: you can redistribute it and/or modify it
+#  under the terms of the GNU Lesser General Public License as published by the
+#  Free Software Foundation, either version 3 of the License, or (at your
+#  option) any later version.
+# 
+#  This program is distributed in the hope that it will be useful, but WITHOUT
+#  ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+#  FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for
+#  more details.
+#
+#  You should have received a copy of the GNU Lesser General Public License
+#  along with this program.  If not, see <http://www.gnu.org/licenses/>
+#
+#  $Id: somdsvr.mak 35 2020-06-07 02:05:42Z somtoolkit $
+
+!include $(MAKEDEFS)
+
+OUTDIR=$(OUTDIR_BIN)
+INTDIR=$(BUILDTYPE)
+
+APPNAME=somdsvr
+
+OBJS=	$(INTDIR)\$(APPNAME).obj	\
+		$(INTDIR)\link386.obj 
+
+TARGET_EXE=$(OUTDIR)\$(APPNAME).exe
+TARGET_PDB=$(OUTDIR)\$(APPNAME).pdb
+TARGET_MAP=$(INTDIR)\$(APPNAME).map
+
+PARTOPTS=	$(STDOPT)					\
+			/DHAVE_CONFIG_H				\
+			/D_CONSOLE					\
+			/DWIN32_LEAN_AND_MEAN		\
+			/D_CONSOLE					\
+			/I..\..\include\$(PLATFORM)	\
+			/I..\..\include\$(PLATFORM_DEF)	\
+			/I..\..\include				\
+			/I..\..\somidl\$(PLATFORM)	\
+			/I..\..\somkpub\include		\
+			/I..\..\somtk\include		\
+			$(CC_OUT_PDB)$(TARGET_PDB)
+
+all: $(TARGET_EXE)
+
+clean:
+	$(CLEAN) $(TARGET_EXE)				\
+			 $(TARGET_PDB)				\
+			 $(TARGET_MAP)				\
+			 $(OBJS)					\
+			 $(INTDIR)\$(APPNAME).res	\
+			 $(OUTDIR)\$(APPNAME).lib
+	
+$(TARGET_EXE): $(OBJS) $(OUTDIR) $(INTDIR)\$(APPNAME).res
+	$(CC) $(CC_OUT_EXE)$@ $(OBJS) \
+		$(CC_OUT_PDB)$(TARGET_PDB)	\
+		$(CC_LINK) \
+		$(LD_SUBSYSTEM_CONSOLE) \
+		$(INTDIR)\$(APPNAME).res \
+		$(LDFLAGS) 
+	$(POSTLINK_EXE) $@
+
+$(INTDIR)\$(APPNAME).obj: ..\src\$(APPNAME).c $(INTDIR)
+	$(CC) /c $(PARTOPTS) $(CC_OUT_OBJ)$@ ..\src\$(APPNAME).c
+
+$(INTDIR)\link386.obj: ..\win32\link386.c $(INTDIR)
+	$(CC) /c $(PARTOPTS) $(CC_OUT_OBJ)$@ ..\win32\link386.c
+
+$(INTDIR):
+	mkdir $@
+
+$(INTDIR)\$(APPNAME).res: ..\win32\$(APPNAME).rc
+	rc /nologo /r /I.. /I..\..\include\$(PLATFORM) /fo$@ ..\win32\$(APPNAME).rc
+
+dist:
+
+
+
+
+test:
+
diff -urN somfree\somdsrv\win32\somdsvr.rc newsomfree3\somdsrv\win32\somdsvr.rc
--- somfree\somdsrv\win32\somdsvr.rc	Thu Jan 01 07:00:00 1970
+++ newsomfree3\somdsrv\win32\somdsvr.rc	Sat Mar 16 14:09:26 2024
@@ -0,0 +1,54 @@
+/**************************************************************************
+ *
+ *  Copyright 2008, Roger Brown
+ *
+ *  This file is part of Roger Brown's Toolkit.
+ *
+ *  This program is free software: you can redistribute it and/or modify it
+ *  under the terms of the GNU Lesser General Public License as published by the
+ *  Free Software Foundation, either version 3 of the License, or (at your
+ *  option) any later version.
+ * 
+ *  This program is distributed in the hope that it will be useful, but WITHOUT
+ *  ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ *  FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for
+ *  more details.
+ *
+ *  You should have received a copy of the GNU Lesser General Public License
+ *  along with this program.  If not, see <http://www.gnu.org/licenses/>
+ *
+ */
+
+/*
+ * $Id: somdsvr.rc 35 2020-06-07 02:05:42Z somtoolkit $
+ */
+
+#include <windows.h>
+#include <depvers.h>
+
+1 VERSIONINFO
+	PRODUCTVERSION DEPVERS_somtkpkg_INT4
+	FILEOS VOS__WINDOWS32
+	FILEVERSION DEPVERS_somdsvr_INT4
+	FILETYPE VFT_APP
+BEGIN
+	BLOCK "StringFileInfo"
+	BEGIN
+		BLOCK "140904E4"
+		BEGIN
+			VALUE "CompanyName","Roger Brown\000\000"
+			VALUE "LegalCopyright","Copyright й Roger Brown 2001\000\000"
+			VALUE "ProductName",DEPVERS_somtkpkg_PRODUCTNAME
+			VALUE "ProductVersion",DEPVERS_somtkpkg_STR4
+			VALUE "Comments","Uncontrolled Release\000\000"
+			VALUE "FileDescription","dsom server\000\000"
+			VALUE "FileVersion",DEPVERS_somdsvr_STR4
+			VALUE "InternalName","somdsvr\000\000"
+			VALUE "OriginalFilename","SOMDSVR.EXE\000\000"
+		END
+	END
+	BLOCK "VarFileInfo"
+	BEGIN	
+		VALUE "Translation", 0x1409, 1252
+	END
+END
diff -urN somfree\some\makedefs.cf newsomfree3\some\makedefs.cf
--- somfree\some\makedefs.cf	Thu Jan 01 07:00:00 1970
+++ newsomfree3\some\makedefs.cf	Sat Mar 16 14:09:26 2024
@@ -0,0 +1,3 @@
+NAME some
+DEPENDS somc
+PROVIDES some
diff -urN somfree\some\scattrib.idl newsomfree3\some\scattrib.idl
--- somfree\some\scattrib.idl	Thu Jan 01 07:00:00 1970
+++ newsomfree3\some\scattrib.idl	Sat Mar 16 14:09:26 2024
@@ -0,0 +1,90 @@
+/**************************************************************************
+ *
+ *  Copyright 2015, 2017, 2018, Yuri Prokushev
+ *
+ *  This file is part of osFree project
+ *
+ *  This program is free software: you can redistribute it and/or modify it
+ *  under the terms of the GNU Lesser General Public License as published by the
+ *  Free Software Foundation, either version 3 of the License, or (at your
+ *  option) any later version.
+ * 
+ *  This program is distributed in the hope that it will be useful, but WITHOUT
+ *  ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ *  FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for
+ *  more details.
+ *
+ *  You should have received a copy of the GNU Lesser General Public License
+ *  along with this program.  If not, see <http://www.gnu.org/licenses/>
+ *
+ */
+
+
+#ifndef scattrib_idl
+#define scattrib_idl
+
+interface SOMTDataEntryC;
+interface SOMTMethodEntryC;
+
+#include <scentry.idl>
+interface SOMTAttributeEntryC : SOMTEntryC
+{
+readonly attribute boolean somtIsReadonly;
+// Whether the attribute is readonly.
+
+readonly attribute SOMTEntryC somtAttribType;
+// The type of the attribute.  This does not include pointer stars
+// or array declarators.  To get the "full" type, get each attribute
+// declarator and get the somtType attribute.
+
+SOMTDataEntryC somtGetFirstAttributeDeclarator();
+// The first attribute declarator for this attribute declaration.
+SOMTDataEntryC somtGetNextAttributeDeclarator();
+// The next attribute declarator for this attribute declaration,
+// relative to the previous call to this method or 
+// somtGetFirstAttributeDeclarator.
+
+SOMTMethodEntryC somtGetFirstGetMethod();
+// The first get method for this attribute declaration.
+SOMTMethodEntryC somtGetNextGetMethod();
+// The next get method for this attribute declaration,
+// relative to the previous call to this method or 
+// somtGetFirstGetMethod.
+
+SOMTMethodEntryC somtGetFirstSetMethod();
+// The first set method for this attribute declaration.
+SOMTMethodEntryC somtGetNextSetMethod();
+// The next set method for this attribute declaration,
+// relative to the previous call to this method or 
+// somtGetFirstSetMethod.
+
+#ifdef __SOMIDL__
+  implementation {
+    releaseorder: _get_somtIsReadonly, _get_somtAttribType, 
+                  somtGetFirstAttributeDeclarator, 
+		  somtGetNextAttributeDeclarator, 
+                  somtGetFirstGetMethod, somtGetNextGetMethod, 
+                  somtGetFirstSetMethod, somtGetNextSetMethod;
+
+
+    //# Class Modifiers
+    filestem = scattrib;
+    dllname = "some.dll";
+    callstyle = oidl;
+    majorversion = 2;
+    minorversion = 1;
+  
+    //# Method Modifiers
+    somtSetSymbolsOnEntry: override;
+    //somDumpSelfInt: override;
+  
+    //# Attribute Modifiers
+    somtIsReadonly: nodata;
+    somtAttribType: nodata;
+
+  };
+#endif /* __SOMIDL__ */
+};
+
+
+#endif  /* scattrib_idl */
diff -urN somfree\some\scbase.idl newsomfree3\some\scbase.idl
--- somfree\some\scbase.idl	Thu Jan 01 07:00:00 1970
+++ newsomfree3\some\scbase.idl	Sat Mar 16 14:09:26 2024
@@ -0,0 +1,56 @@
+/**************************************************************************
+ *
+ *  Copyright 2015, 2017, 2018, Yuri Prokushev
+ *
+ *  This file is part of osFree project
+ *
+ *  This program is free software: you can redistribute it and/or modify it
+ *  under the terms of the GNU Lesser General Public License as published by the
+ *  Free Software Foundation, either version 3 of the License, or (at your
+ *  option) any later version.
+ * 
+ *  This program is distributed in the hope that it will be useful, but WITHOUT
+ *  ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ *  FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for
+ *  more details.
+ *
+ *  You should have received a copy of the GNU Lesser General Public License
+ *  along with this program.  If not, see <http://www.gnu.org/licenses/>
+ *
+ */
+
+
+#ifndef scbase_idl
+#define scbase_idl
+
+#include <scentry.idl>
+interface SOMTClassEntryC;
+
+interface SOMTBaseClassEntryC : SOMTEntryC
+{
+  readonly attribute SOMTClassEntryC somtBaseClassDef;
+  // Returns the class definition entry for the Base class named in
+  // this entry.
+#ifdef __SOMIDL__
+  implementation {
+    releaseorder: _get_somtBaseClassDef;
+  
+    //# Class Modifiers
+    majorversion = 2;
+    minorversion = 1;
+    filestem = scbase;
+    dllname = "some.dll";
+    callstyle = oidl;
+  
+    //# Method Modifiers
+    //somDumpSelfInt: override;
+    //somtSetSymbolsOnEntry: override;
+  
+    //# Attribute Modifiers
+    somtBaseClassDef: nodata;
+  };
+#endif /* __SOMIDL__ */
+};
+
+
+#endif  /* scbase_idl */
diff -urN somfree\some\scclass.idl newsomfree3\some\scclass.idl
--- somfree\some\scclass.idl	Thu Jan 01 07:00:00 1970
+++ newsomfree3\some\scclass.idl	Sat Mar 16 14:09:26 2024
@@ -0,0 +1,318 @@
+/**************************************************************************
+ *
+ *  Copyright 2015, 2017, 2018, Yuri Prokushev
+ *
+ *  This file is part of osFree project
+ *
+ *  This program is free software: you can redistribute it and/or modify it
+ *  under the terms of the GNU Lesser General Public License as published by the
+ *  Free Software Foundation, either version 3 of the License, or (at your
+ *  option) any later version.
+ * 
+ *  This program is distributed in the hope that it will be useful, but WITHOUT
+ *  ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ *  FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for
+ *  more details.
+ *
+ *  You should have received a copy of the GNU Lesser General Public License
+ *  along with this program.  If not, see <http://www.gnu.org/licenses/>
+ *
+ */
+
+
+#ifndef scclass_idl
+#define scclass_idl
+
+#include <scentry.idl>
+interface SOMTPassthruEntryC;
+interface SOMTBaseClassEntryC;
+interface SOMTMetaClassEntryC;
+interface SOMTCommonEntryC;
+interface SOMTMethodEntryC;
+interface SOMTModuleEntryC;
+interface SOMTDataEntryC;
+interface SOMTAttributeEntryC;
+interface SOMTStructEntryC;
+interface SOMTTypedefEntryC;
+interface SOMTUnionEntryC;
+interface SOMTEnumEntryC;
+interface SOMTConstEntryC;
+interface SOMTSequenceEntryC;
+
+interface SOMTClassEntryC : SOMTEntryC
+
+// This entry is the anchor for all information about a class
+// definition. The part it inherits from <SOMTEntryC> concerns
+// the actual class statement in the interface definition.  The new
+// methods and attributes provided by the class concern the class
+// definition as a whole.
+// A number of the possible statements in a class definition are
+// optional, when they are missing from the class definition then
+// methods that would return an entry for this kind of statement, will
+// return NULL.
+
+{
+  readonly attribute string somtSourceFileName;
+  
+  // Returns the name of file containing the definition of this class.
+
+  readonly attribute SOMTMetaClassEntryC somtMetaClassEntry;
+  
+  // Returns the entry for the meta class statement in class
+  // definition or NULL if there is no meta class statement.
+  // Note: the SOM architecture requires that all classes have a meta
+  // class, however <SOMClass> is its own metaclass. Thus, any attempt
+  // to walk up the metaclass chain must terminate when it finds a
+  // class that is its own meta class, otherwise an infinite loop is
+  // possible.
+
+  readonly attribute SOMTModuleEntryC somtClassModule;
+  // The module that contains this class, or NULL if there is not one.
+
+  readonly attribute long somtNewMethodCount;
+  
+  // Returns the number of new methods introduced in this class
+  // definition.
+
+  readonly attribute boolean somtLocalInclude;
+  
+  // Returns true if the header files associated with this class
+  // definition should be included using local search, eg, "name.h"
+  // instead of <name.h>
+
+  readonly attribute long somtPrivateMethodCount;
+  
+  // Returns number of new private methods in class.
+
+  readonly attribute long somtStaticMethodCount;
+  
+  // Returns number of new static methods in class.
+
+  readonly attribute long somtOverrideMethodCount;
+  
+  // Returns number of new override methods in class.
+
+  readonly attribute long somtProcMethodCount;
+  
+  // Returns number of procedure methods for class.
+
+  readonly attribute long somtVAMethodCount;
+  
+  // Returns number of VarArg methods for class.
+
+  readonly attribute long somtBaseCount;
+  
+  // Returns number of base classes for class.
+
+  readonly attribute long somtExternalDataCount;
+  
+  // Returns number of external (public or private) data members for class.
+
+  readonly attribute long somtPublicDataCount;
+  
+  // Returns number of public data members for class.
+
+  readonly attribute long somtPrivateDataCount;
+  
+  // Returns number of private data members for class.
+
+  readonly attribute SOMTClassEntryC somtMetaclassFor;
+
+  // If this is a metaclass, the class for which it is a metaclass, else NULL.
+
+  readonly attribute boolean somtForwardRef;
+
+  // Whether this is a forward reference or not.
+
+  SOMTBaseClassEntryC somtGetFirstBaseClass();
+  
+  // Returns the entry for the "left most" direct base class form for
+  // this class, if it has one and NULL otherwise.  Note: <SOMObject>
+  // does not have any base classes and therefore will terminate an
+  // attempt to walk up the base class chain.
+
+  SOMTBaseClassEntryC somtGetNextBaseClass();
+  
+  // Returns the entry for the next direct base class form of this
+  // class, if it has one and NULL otherwise.  The direct base classes
+  // of a derived class are ordered from "left to right".
+
+  string somtGetFirstReleaseName();
+  
+  // Returns the first name in the release order statement for this
+  // entry if it has one and NULL otherwise.
+
+  string somtGetNextReleaseName();
+  
+  // Returns the next name in the release order statement for this
+  // entry if it has one and NULL otherwise.
+
+  long somtGetReleaseNameList(in string buffer);
+  
+  // Puts all the release names in <buffer> in template output form,
+  // buffer must be large enough, no tests are made.  The number of
+  // release names is returned.
+
+  SOMTPassthruEntryC somtGetFirstPassthru();
+  
+  // Returns the first passthru entry for this class definition if it
+  // has one and NULL otherwise.
+
+  SOMTPassthruEntryC somtGetNextPassthru();
+  
+  // Returns the next passthru entry for this class definition if it
+  // has one and NULL otherwise.  The passthru entry will be returned
+  // in an order based on the appearence of passthru statements in the
+  // class definition.
+
+  SOMTDataEntryC somtGetFirstData();
+  
+  // Returns the first data entry for this class definition if it has
+  // one and NULL otherwise.
+
+  SOMTDataEntryC somtGetNextData();
+  
+  // Returns the next data entry for this class definition if it has
+  // one and NULL otherwise.  The data entries will be returned in an
+  // order based on the appearence data member declarations in the
+  // class definition.
+
+  SOMTDataEntryC somtGetFirstStaticData();
+  
+  // Returns the first static data entry for this class definition if it has
+  // one and NULL otherwise. Static data is handled specialy in SOM so a
+  // different accessor method is provided.
+
+  SOMTDataEntryC somtGetNextStaticData();
+  
+  // Returns the next static data entry for this class definition if it has
+  // one and NULL otherwise.  The data entries will be returned in an
+  // order based on the release order
+
+  SOMTMethodEntryC somtGetFirstMethod();
+  
+  // Returns the first method entry for this class definition if it
+  // has one and NULL otherwise.  Method entries may be for new or
+  // overridden methods.
+
+  SOMTMethodEntryC somtGetNextMethod();
+  
+  // Returns the next method entry for this class definition if it has
+  // one and NULL otherwise.  The method entries will be returned in an
+  // order based on the appearence method declarations in the
+  // class definition.  Method entries may be for new or overridden methods.
+
+  SOMTMethodEntryC somtGetFirstInheritedMethod();
+  
+  // Returns the first inherited and not overridden method entry for
+  // this class definition if it has one and NULL otherwise.
+
+  SOMTMethodEntryC somtGetNextInheritedMethod();
+  
+  // Returns the next inherited and not overridden method entry for
+  // this class definition if it has one and NULL otherwise.  The
+  // method entries will be returned in an unspecified, but constant
+  // order.
+
+  SOMTAttributeEntryC somtGetFirstAttribute();
+  SOMTAttributeEntryC somtGetNextAttribute();
+  SOMTStructEntryC somtGetFirstStruct ();
+  SOMTStructEntryC somtGetNextStruct ();
+  SOMTTypedefEntryC somtGetFirstTypedef ();
+  SOMTTypedefEntryC somtGetNextTypedef ();
+  SOMTUnionEntryC somtGetFirstUnion ();
+  SOMTUnionEntryC somtGetNextUnion ();
+  SOMTEnumEntryC somtGetFirstEnum ();
+  SOMTEnumEntryC somtGetNextEnum ();
+  SOMTConstEntryC somtGetFirstConstant ();
+  SOMTConstEntryC somtGetNextConstant ();
+  SOMTSequenceEntryC somtGetFirstSequence ();
+  SOMTSequenceEntryC somtGetNextSequence ();
+  SOMTEntryC somtGetFirstPubdef ();
+  SOMTEntryC somtGetNextPubdef ();
+
+  boolean somtFilterNew(in SOMTMethodEntryC entry);
+  
+  // Returns 1 if entry is new in the class.
+
+  boolean somtFilterOverridden(in SOMTMethodEntryC entry);
+  
+  // Returns 1 if entry is an overriding method of the class.
+
+  boolean somtFilterPrivOrPub(in SOMTCommonEntryC entry);
+  
+  // Returns TRUE if entry is Private or Public.
+
+#ifdef __SOMIDL__
+  implementation {
+    releaseorder: _get_somtSourceFileName, _get_somtMetaClassEntry, 
+                  _get_somtNewMethodCount, _get_somtLocalInclude, 
+                  _get_somtPrivateMethodCount, _get_somtStaticMethodCount, 
+                  _get_somtOverrideMethodCount, _get_somtProcMethodCount, 
+                  _get_somtVAMethodCount, _get_somtBaseCount, 
+                  _get_somtExternalDataCount, _get_somtPublicDataCount, 
+                  _get_somtPrivateDataCount, somtGetFirstBaseClass, 
+                  somtGetNextBaseClass, somtGetFirstReleaseName, 
+                  somtGetNextReleaseName, somtGetReleaseNameList, 
+                  somtGetFirstPassthru, somtGetNextPassthru, 
+                  somtGetFirstData, somtGetNextData, 
+                  somtGetFirstMethod, somtGetNextMethod, 
+                  somtGetFirstInheritedMethod, somtGetNextInheritedMethod, 
+                  somtFilterNew, somtFilterOverridden, 
+                  somtFilterPrivOrPub, _get_somtMetaclassFor, 
+                  _get_somtForwardRef, somtGetFirstAttribute, 
+                  somtGetNextAttribute, somtGetFirstStruct, 
+                  somtGetNextStruct, somtGetFirstTypedef, 
+                  somtGetNextTypedef, somtGetFirstUnion, 
+                  somtGetNextUnion, somtGetFirstEnum, 
+                  somtGetNextEnum, somtGetFirstConstant, 
+                  somtGetNextConstant, somtGetFirstSequence, 
+                  somtGetNextSequence, _get_somtClassModule,
+		  somtGetFirstPubdef, somtGetNextPubdef,
+		  somtGetFirstStaticData, somtGetNextStaticData;
+
+
+    //# Class Modifiers
+    filestem = scclass;
+    dllname = "some.dll";
+    callstyle = oidl;
+    majorversion = 2;
+    minorversion = 1;
+  
+    //# Instance variable
+#ifdef __PRIVATE__
+    SOMTConstEntryC cons;
+    SOMTAttributeEntryC attrs;
+#endif
+    //# Method Modifiers
+    somDefaultInit: override;
+    somDumpSelfInt: override;
+    somtSetSymbolsOnEntry: override;
+    somtSetEntryStruct: override;
+    _get_somtCScopedName: override;
+    _get_somtIDLScopedName: override;
+  
+    //# Attribute Modifiers
+    somtSourceFileName: nodata;
+    somtMetaClassEntry: nodata;
+    somtNewMethodCount: nodata;
+    somtLocalInclude: nodata;
+    somtPrivateMethodCount: nodata;
+    somtStaticMethodCount: nodata;
+    somtOverrideMethodCount: nodata;
+    somtProcMethodCount: nodata;
+    somtVAMethodCount: nodata;
+    somtBaseCount: nodata;
+    somtPublicDataCount: nodata;
+    somtPrivateDataCount: nodata;
+    somtExternalDataCount: nodata;
+    somtMetaclassFor: nodata;
+    somtForwardRef: nodata;
+    somtClassModule: nodata;
+  
+  };
+#endif /* __SOMIDL__ */
+};
+
+
+#endif  /* scclass_idl */
diff -urN somfree\some\sccommon.idl newsomfree3\some\sccommon.idl
--- somfree\some\sccommon.idl	Thu Jan 01 07:00:00 1970
+++ newsomfree3\some\sccommon.idl	Sat Mar 16 14:09:26 2024
@@ -0,0 +1,136 @@
+/**************************************************************************
+ *
+ *  Copyright 2015, 2017, 2018, Yuri Prokushev
+ *
+ *  This file is part of osFree project
+ *
+ *  This program is free software: you can redistribute it and/or modify it
+ *  under the terms of the GNU Lesser General Public License as published by the
+ *  Free Software Foundation, either version 3 of the License, or (at your
+ *  option) any later version.
+ * 
+ *  This program is distributed in the hope that it will be useful, but WITHOUT
+ *  ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ *  FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for
+ *  more details.
+ *
+ *  You should have received a copy of the GNU Lesser General Public License
+ *  along with this program.  If not, see <http://www.gnu.org/licenses/>
+ *
+ */
+
+#ifndef sccommon_idl
+#define sccommon_idl
+
+#include <scentry.idl>
+interface SOMTTypedefEntryC;
+
+enum somtVisibilityT { somtInternalVE, somtPublicVE, somtPrivateVE };
+interface SOMTCommonEntryC : SOMTEntryC
+
+// This class defines a number of methods and attributes that are
+// common to <SOMTMethodEntry>, <SOMTDataEntry>, and
+// <SOMTParameterEntry>.  No entries of this type will actually
+// be found in the entry graph, instead they will all be one of
+// the types mentioned above.
+// Exception: entries whose somtElementType is SOMTTypedefBE, which
+// represent a reference to a user-defined type, are instance of this class.
+
+{
+
+  readonly attribute SOMTEntryC somtTypeObj;
+
+  // The object representing the base type of the entry.
+  // This does not include pointer stars or array declarators.
+
+  readonly attribute string somtPtrs;
+
+  // The string of stars associated with the entry's type.
+  // For example, an object of type "foo" would have somtPtrs = NULL,
+  // type "foo *" would have somtPtrs = "*", type
+  // "foo **" would have somtPtrs = "**", etc.
+
+  readonly attribute string somtArrayDimsString;
+
+  // Array dimensions in string form.
+
+  unsigned long somtGetFirstArrayDimension();
+  // The first array dimension, for items of type array.
+  // Zero indicates that the item is not an array.
+
+  unsigned long somtGetNextArrayDimension();
+  // The next array dimension, for items of type array,
+  // relative to the previous call to this method or to
+  // somtGetFirstArrayDimension.  Zero indicates no more dimensions.
+
+  readonly attribute string somtSourceText;
+  
+  // The un-parsed source text for this entry, with leading and
+  // trailing white space removed.  For attribute/typedef declarators
+  // and for user-defined types, this attribute only provides the
+  // source text for the entry's name.  For methods, arguments, 
+  // and instance variables, however, this attribute provides the 
+  // full definition.
+
+  readonly attribute string somtType;
+  
+  // The IDL type for this entry in string form. For methods this is the
+  // return type.  For data or parameters this is the type of the data
+  // item or parameter. For user-defined types, this is the type specification.
+  // It is of the form:   <typename><pointer-stars> <array-declarators>
+
+  readonly attribute somtVisibilityT somtVisibility;
+  
+  // The visibility of this entry.  Note: the visibility of
+  // parameter entries will always be public, and methods can never be
+  // internal.
+
+  boolean somtIsArray(out long size);
+  
+  // Returns 1 (true) if the type involves an array.  When the type
+  // involves an array then <size> is set to be the size of the
+  // array.
+
+  boolean somtIsPointer();
+  
+  // Returns 1 (true) if the type involves a pointer, and 0 (false)
+  // otherwise
+
+ 
+
+#ifdef __SOMIDL__
+  implementation {
+    releaseorder: _get_somtSourceText, _get_somtType, 
+                  _get_somtVisibility, somtIsArray, 
+                  somtIsPointer, somtIsArrayDominant, 
+                  _get_somtTypeObj, _get_somtPtrs, 
+                  _get_somtArrayDimsString, somtGetFirstArrayDimension, 
+                  somtGetNextArrayDimension;
+
+
+    //# Class Modifiers
+    majorversion = 2;
+    minorversion = 1;
+    filestem = sccommon;
+    dllname = "some.dll";
+    callstyle = oidl;
+
+    passthru C_h = "typedef enum somtVisibilityT { somtInternalVE, somtPublicVE, somtPrivateVE } somtVisibilityT;";
+    passthru C_xh = "typedef enum somtVisibilityT { somtInternalVE, somtPublicVE, somtPrivateVE } somtVisibilityT;";
+  
+    //# Method Modifiers
+    //somDumpSelfInt: override;
+    //somtSetSymbolsOnEntry: override;
+  
+    //# Attribute Modifiers
+    somtTypeObj: nodata;
+    somtPtrs: nodata;
+    somtArrayDimsString: nodata;
+    somtType: nodata;
+    somtVisibility: nodata;
+
+
+  };
+#endif /* __SOMIDL__ */
+};
+#endif  /* sccommon_idl */
diff -urN somfree\some\scconst.idl newsomfree3\some\scconst.idl
--- somfree\some\scconst.idl	Thu Jan 01 07:00:00 1970
+++ newsomfree3\some\scconst.idl	Sat Mar 16 14:09:26 2024
@@ -0,0 +1,91 @@
+/**************************************************************************
+ *
+ *  Copyright 2015, 2017, 2018, Yuri Prokushev
+ *
+ *  This file is part of osFree project
+ *
+ *  This program is free software: you can redistribute it and/or modify it
+ *  under the terms of the GNU Lesser General Public License as published by the
+ *  Free Software Foundation, either version 3 of the License, or (at your
+ *  option) any later version.
+ * 
+ *  This program is distributed in the hope that it will be useful, but WITHOUT
+ *  ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ *  FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for
+ *  more details.
+ *
+ *  You should have received a copy of the GNU Lesser General Public License
+ *  along with this program.  If not, see <http://www.gnu.org/licenses/>
+ *
+ */
+
+
+#ifndef scconst_idl
+#define scconst_idl
+
+#include <scentry.idl>
+
+interface SOMTConstEntryC : SOMTEntryC
+{
+  readonly attribute SOMTEntryC somtConstTypeObj;
+  // A pointer to an object representing 
+  // the type of the const.
+
+  readonly attribute string somtConstType;
+  // The type of the constant's value.
+
+  readonly attribute string somtConstStringVal;
+  // The string value of the constant (unevaluated).
+
+  readonly attribute unsigned long somtConstNumVal;
+  // The number value of the constant.
+  // This attribute is not valid if the value cannot
+  // be stored in an unsigned long (string, float, double, negative).
+  // The somtConstIsNegative attribute can be used to determine
+  // if the value is negative.  The somtConstType attribute can
+  // be used to determine whether the value is a float or double.
+
+  readonly attribute long somtConstNumNegVal;
+  // The number value of the constant, if negative.
+
+  readonly attribute boolean somtConstIsNegative;
+  // Whether the constant's value is a negative integer and
+  // must be obtained using somtConstNumNegVal rather than somtConstNumVal.
+
+  readonly attribute string somtConstVal;
+  // The string value of the constant (evaluated).
+  // The "get" method for this attribute returns a string whose
+  // ownership is transferred to the caller.
+
+#ifdef __SOMIDL__
+  implementation {
+    releaseorder: _get_somtConstStringVal, _get_somtConstNumVal, 
+                  _get_somtConstType, _get_somtConstTypeObj, 
+                  _get_somtConstVal, _get_somtConstNumNegVal,
+  		  _get_somtConstIsNegative;
+
+    //# Class Modifiers
+    majorversion = 2;
+    minorversion = 1;
+    filestem = scconst;
+    dllname = "some.dll";
+    callstyle = oidl;
+  
+    //# Method Modifiers
+    //somDumpSelfInt: override;
+    somtSetSymbolsOnEntry: override;
+  
+    //# Attribute Modifiers
+    somtConstStringVal: nodata;
+    somtConstNumVal: nodata;
+    somtConstVal: nodata;
+    somtConstNumNegVal: nodata;
+    somtConstType: nodata;
+    somtConstTypeObj: nodata;
+    somtConstIsNegative: nodata;
+  };
+#endif /* __SOMIDL__ */
+};
+
+
+#endif  /* scconst*/
diff -urN somfree\some\scdata.idl newsomfree3\some\scdata.idl
--- somfree\some\scdata.idl	Thu Jan 01 07:00:00 1970
+++ newsomfree3\some\scdata.idl	Sat Mar 16 14:09:26 2024
@@ -0,0 +1,56 @@
+/**************************************************************************
+ *
+ *  Copyright 2015, 2017, 2018, Yuri Prokushev
+ *
+ *  This file is part of osFree project
+ *
+ *  This program is free software: you can redistribute it and/or modify it
+ *  under the terms of the GNU Lesser General Public License as published by the
+ *  Free Software Foundation, either version 3 of the License, or (at your
+ *  option) any later version.
+ * 
+ *  This program is distributed in the hope that it will be useful, but WITHOUT
+ *  ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ *  FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for
+ *  more details.
+ *
+ *  You should have received a copy of the GNU Lesser General Public License
+ *  along with this program.  If not, see <http://www.gnu.org/licenses/>
+ *
+ */
+
+
+#ifndef scdata_idl
+#define scdata_idl
+
+#include <sccommon.idl>
+interface SOMTDataEntryC : SOMTCommonEntryC
+{
+  readonly attribute boolean somtIsSelfRef;
+  // Whether a declarator of a struct is self-referential.
+
+#ifdef __SOMIDL__
+
+  implementation {
+
+    releaseorder: _get_somtIsSelfRef;
+
+    //# Class Modifiers
+    majorversion = 2;
+    minorversion = 1;
+    filestem = scdata;
+    dllname = "some.dll";
+    callstyle = oidl;
+  
+    //# Method Modifiers
+    //somtSetSymbolsOnEntry: override;
+    //somDumpSelfInt: override;
+  
+    //# attribute modifiers
+    somtIsSelfRef: nodata;
+  };
+#endif /* __SOMIDL__ */
+};
+
+
+#endif  /* scdata_idl */
diff -urN somfree\some\scemit.idl newsomfree3\some\scemit.idl
--- somfree\some\scemit.idl	Thu Jan 01 07:00:00 1970
+++ newsomfree3\some\scemit.idl	Sat Mar 16 14:09:26 2024
@@ -0,0 +1,455 @@
+/**************************************************************************
+ *
+ *  Copyright 2015, 2017, 2018, Yuri Prokushev
+ *
+ *  This file is part of osFree project
+ *
+ *  This program is free software: you can redistribute it and/or modify it
+ *  under the terms of the GNU Lesser General Public License as published by the
+ *  Free Software Foundation, either version 3 of the License, or (at your
+ *  option) any later version.
+ * 
+ *  This program is distributed in the hope that it will be useful, but WITHOUT
+ *  ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ *  FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for
+ *  more details.
+ *
+ *  You should have received a copy of the GNU Lesser General Public License
+ *  along with this program.  If not, see <http://www.gnu.org/licenses/>
+ *
+ */
+
+
+#ifndef scemit_idl
+#define scemit_idl
+
+#include <somobj.idl>
+#include <sctmplt.idl>
+#include "sm.h"
+
+interface SOMTClassEntryC;
+interface SOMTModuleEntryC;
+interface SOMTBaseClassEntryC;
+interface SOMTPassthruEntryC;
+interface SOMTDataEntryC;
+interface SOMTStructEntryC;
+interface SOMTTypedefEntryC;
+interface SOMTUnionEntryC;
+interface SOMTEnumEntryC;
+interface SOMTConstEntryC;
+interface SOMTAttributeEntryC;
+interface SOMTSequenceEntryC;
+interface SOMTMethodEntryC;
+interface SOMTEntryC;
+
+interface SOMTEmitC : SOMObject
+
+// This is the pluggable unit in the SOM emitter framework. An emitter
+// is constructed by subclassing this class and then running the
+// master emitter program providing the name of the subclass as one of
+// its command line arguments.
+// The concepts of this class are simple:
+//
+//   Emitters always consist of a set of sections
+//   The sections are in a particular order for any particular
+//   emitter, and the order does not vary with the data processed by
+//   the emitter.
+//   A number of the sections of an emitter are common (maybe with
+//   slight variation) across several (or even most) emitters.
+//   There are a number of constructs that occur in varying numbers,
+//   eg, method declarations, data declarations, and attribute
+//   declarations.
+// Consequently, this class provides methods for:
+//   Methods for many common sections, including several that may be
+//   useful without overridding in several different emitters
+//   Sequencing through the sections of the emitter
+//   Iterating through the constructs that occur in varying numbers
+
+{
+  attribute SOMTTemplateOutputC somtTemplate;
+  // The template is to provide template output and maintains a symbol
+  // table that provides a sort of global context for the emitter.
+
+  attribute FILE *somtTargetFile;
+  // The target file is the one to which all emitter output is to be
+  // directed.
+
+  attribute SOMTClassEntryC somtTargetClass;
+  // The target class is the class definition for which code is to be
+  // emitted.
+
+  attribute SOMTModuleEntryC somtTargetModule;
+  // The target module is the module definition for which code is to be
+  // emitted.
+
+  attribute SOMTTargetTypeT somtTargetType;
+  // The target type indicates what type of output file is being
+  // produced, public, private, or implementation.  This allows the
+  // same emitter subclass to produce several different output files
+  // that generally differ only in how much of the class definition
+  // they cover. Eg, .csc, .sc, and .psc.
+  // This is attribute is for OIDL compatibility only.
+
+  attribute string somtEmitterName;
+  // The short name of the emitter (the name used to invoke it via the
+  // SOM Compiler.  Typically this is the file stem of the subclass
+  // of SOMTEmitC. This attribute should be set in the driver program
+  // that runs the emitter.  It is used to filter passthrus so that only
+  // passthrus directed to a particular emitter are seen by it.
+
+  boolean somtGenerateSections();
+  // Calls each of the section methods in order.  The order is:
+  //
+  //   somtEmitProlog
+  //   when emitting a class:
+  //   	  somtEmitClass
+  //   	  somtEmitBase
+  //   	  somtEmitMeta
+  //   somtEmitConstant
+  //   somtEmitTypedef
+  //   somtEmitStruct
+  //   somtEmitUnion
+  //   somtEmitEnum
+  //   when emitting a class:
+  //      somtEmitAttribute
+  //      somtEmitMethod
+  //      somtEmitRelease
+  //      somtEmitPassthru
+  //      somtEmitData
+  //   when emitting a module:
+  //       somtEmitInterface
+  //       somtEmitModule
+  //   somtEmitEpilog
+  //
+  // This method will need to be overridden by many emitters in order
+  // to rearange the order of the sections and to add or delete
+  // sections.
+  // Note: repeating sections such as methods, data, and passthru,
+  // have a prolog and epilog method as well. The prolog method is
+  // called before the first sections is processed and the epilog method
+  // is called after the last section is processed.
+
+  FILE* somtOpenSymbolsFile(in string file, 
+                           in string mode);
+  
+  // This method attempts to open the symbols file.
+  // If file doesn't exist then it will attempt to find it in the
+  // directories specified in the SMINCLUDE environment variable.
+  // If the file can be found a FILE * pointer is returned, otherwise
+  // NULL is returned.
+
+  void somtSetPredefinedSymbols();
+  
+  // Set predefined symbols that are used for such things as section
+  // names etc.
+
+  void somtFileSymbols();
+  
+  // Symbols that are common to the file.  This includes the target
+  // class symbols, and the metaclass symbols, and special symbols
+  // like <timeStamp>.  IE, all symbols that have a single definition.
+
+  void somtEmitProlog();
+  void somtEmitBaseIncludesProlog();
+  void somtEmitBaseIncludes(in SOMTBaseClassEntryC base);
+  void somtEmitBaseIncludesEpilog();
+  void somtEmitMetaInclude();
+  void somtEmitClass();
+  void somtEmitMeta();
+  void somtEmitBaseProlog();
+  void somtEmitBase(in SOMTBaseClassEntryC base);
+  void somtEmitBaseEpilog();
+  void somtEmitPassthruProlog();
+  void somtEmitPassthru(in SOMTPassthruEntryC entry);
+  void somtEmitPassthruEpilog();
+  void somtEmitRelease();
+  void somtEmitDataProlog();
+  void somtEmitData(in SOMTDataEntryC entry);
+  void somtEmitDataEpilog();
+  void somtEmitAttributeProlog();
+  void somtEmitAttribute(in SOMTAttributeEntryC att);
+  void somtEmitAttributeEpilog();
+  void somtEmitConstantProlog();
+  void somtEmitConstant(in SOMTConstEntryC con);
+  void somtEmitConstantEpilog();
+  void somtEmitTypedefProlog();
+  void somtEmitTypedef(in SOMTTypedefEntryC td);
+  void somtEmitTypedefEpilog();
+  void somtEmitStructProlog();
+  void somtEmitStruct(in SOMTStructEntryC struc);
+  void somtEmitStructEpilog();
+  void somtEmitUnionProlog();
+  void somtEmitUnion(in SOMTUnionEntryC un);
+  void somtEmitUnionEpilog();
+  void somtEmitEnumProlog();
+  void somtEmitEnum(in SOMTEnumEntryC en);
+  void somtEmitEnumEpilog();
+  void somtEmitInterfaceProlog();
+  void somtEmitInterface(in SOMTClassEntryC intfc);
+  void somtEmitInterfaceEpilog();
+  void somtEmitModuleProlog();
+  void somtEmitModule(in SOMTModuleEntryC mod);
+  void somtEmitModuleEpilog();
+  void somtEmitMethodsProlog();
+  void somtEmitMethods(in SOMTMethodEntryC method);
+  void somtEmitMethodsEpilog();
+  void somtEmitMethod(in SOMTMethodEntryC entry);
+  void somtEmitEpilog();
+  boolean somtScanBases(in string prolog, 
+                   in string each, 
+                   in string epilog);
+  boolean somtScanBaseIncludes(in string prolog, 
+                   in string each, 
+                   in string epilog);
+
+  boolean somtCheckVisibility(in SOMTMethodEntryC entry);
+  // Return 1 (true) if <entry> should be visible in the current
+  // target file.  This method is used by each of the following filter
+  // methods that are concerned with visibility.
+  // The default rule for visibility is:
+  //   only private methods are visible in private target files,
+  //   only public methods are visibile in public target files,
+  //   all methods are visibile in implementation or <somtAllE> target
+  //   files.
+
+  boolean somtNew(in SOMTMethodEntryC entry);
+  // Returns 1 (true) if <entry> is a method introduced by the target
+  // class and its visibility matches <somtTargetType> (somtImplementationE
+  // matches both private and public)
+
+  boolean somtImplemented(in SOMTMethodEntryC entry);
+  // Returns 1 (true) if <entry> is a method introduced or overridden
+  // by the target class and its visibility matches <somtTargetType>
+  // (somtImplementationE matches both private and public)
+
+  boolean somtOverridden(in SOMTMethodEntryC entry);
+  // Returns 1 (true) if <entry> is an overridding method of the target class 
+  // and its visibility matches <somtTargetType> (somtImplementationE
+  // matches both private and public)
+
+  boolean somtInherited(in SOMTMethodEntryC entry);
+  // Returns 1 (true) if <entry> is inherited 
+  // by the target class and its visibility matches <somtTargetType>
+  // (somtImplementationE matches both private and public)
+
+  boolean somtAllVisible(in SOMTMethodEntryC entry);
+  // Returns 1 (true) if <entry> is supported by the target class and
+  // its visibility matches <somtTargetType> (somtImplementationE
+  // matches both private and public)
+
+  boolean somtAll(in SOMTMethodEntryC entry);
+  // Returns 1 (true) if <entry> is supported by the target class.
+
+  boolean somtNewNoProc(in SOMTEntryC entry);
+  // Returns 1 (true) if somtNew does and the method
+  // IS NOT a direct call Procedure.
+
+  boolean somtPrivOrPub(in SOMTEntryC entry);
+  // Returns 1 (true) if entry is Private or Public.
+
+  boolean somtNewProc(in SOMTEntryC entry);
+  // Returns 1 (true) if somtNew does and the method
+  // IS a direct call Procedure.
+
+  boolean somtLink(in SOMTEntryC entry);
+  // Returns 1 (true) if "nolink" is not set.
+
+  boolean somtVA(in SOMTEntryC entry);
+  // Returns 1 (true) if entry is a VarArgs method.
+
+  boolean somtScanMethods(in string filter, 
+                     in string prolog, 
+                     in string each, 
+                     in string epilog, 
+                     in boolean forceProlog);
+  
+  // Will only call <each> on methods accepted by <filter>.
+  // If <forceProlog> is not true then the prolog and epilog emiters
+  // will be called only if there is at least one method that passes
+  // the filter.
+
+  boolean somtScanConstants(in string prolog, 
+                  in string each, 
+                  in string epilog);
+
+  boolean somtScanTypedefs(in string prolog, 
+                  in string each, 
+                  in string epilog);
+
+  boolean somtScanStructs(in string prolog, 
+                  in string each, 
+                  in string epilog);
+
+  boolean somtScanUnions(in string prolog, 
+                  in string each, 
+                  in string epilog);
+
+  boolean somtScanEnums(in string prolog, 
+                  in string each, 
+                  in string epilog);
+
+  boolean somtScanData(in string prolog, 
+                  in string each, 
+                  in string epilog);
+
+  boolean somtScanAttributes(in string prolog, 
+                  in string each, 
+                  in string epilog);
+
+  boolean somtScanInterfaces(in string prolog, 
+                  in string each, 
+                  in string epilog);
+
+  boolean somtScanModules(in string prolog, 
+                  in string each, 
+                  in string epilog);
+
+  boolean somtScanPassthru(in boolean before, 
+                      in string prolog, 
+                      in string each, 
+                      in string epilog);
+
+  void somtEmitFullPassthru(in boolean before, in string language);
+  
+  // Emits each passthru section defined for the language and targetType,
+  // and the result of the somtIsBeforePassthru method is equal to the
+  // before parameter.  (before = 1(true), or before = 0(false), i.e. after.)
+
+  boolean somtScanDataF(in string filter, 
+                   in string prolog, 
+                   in string each, 
+                   in string epilog, 
+                   in boolean forceProlog);
+  
+  // This method is like somtScanData but it also provides a paramater
+  // for a filter method.
+
+  boolean somtScanBasesF(in string filter, 
+                    in string prolog, 
+                    in string each, 
+                    in string epilog, 
+                    in boolean forceProlog);
+  
+  // This method is like somtScanBases but it also provides a paramater
+  // for a filter method.
+
+  string somtGetGlobalModifierValue(in string modifierName);
+  // Returns the value of the specified global modifier.
+  // Global modifiers are specified when the SOM Compiler is invoked,
+  // via the "-m" option.  For example, 
+  //                       sc -m"foo=bar"  file.idl
+  // specifies to the SOM Compiler and the emitters being run that
+  // the global modifier "foo" has the value "bar."
+  // Values of global modifiers are transient; they last only for the
+  // duration of the compile for which they were specified.
+  // If a modifier is specified in the "sc" command with no value,
+  // as in 
+  //                       sc -mfoo file.idl
+  // then the result of this method will be non-NULL.
+  // If no such modifier is specified, then the result is NULL.
+  // Older SOM compiler version uses "-a" option which is same as "-m" option.
+
+  SOMTEntryC somtGetFirstGlobalDefinition();
+  // Returns the first type or constant definition that is not
+  // associated with any interface or module.
+  // These global definitions must be surrounded by the somemittypes
+  // pragmas for them to be visible via this method.
+  // E.g., #pragma somemittypes on
+  //       ....
+  //       #pragma someemittypes off
+  // The list of global definitions returned by this method and
+  // the somtGetNextGlobalDefinition method may include entries
+  // for forward declarations as well as typedefs and constants.
+  // Global structs and unions are also included in the list.
+
+  SOMTEntryC somtGetNextGlobalDefinition();
+  // Returns the next type or constant definition that is not
+  // associated with any interface or module, relative to a
+  // previous call to somtGetFirstGlobalDefinition or
+  // somtGetNextGlobalDefinition.
+
+#ifdef __SOMIDL__
+  implementation {
+  
+    releaseorder: _get_somtTemplate, _get_somtTargetFile, 
+                  _set_somtTargetFile, _get_somtTargetClass, 
+                  _set_somtTargetClass, _get_somtTargetModule, 
+                  _set_somtTargetModule, _get_somtTargetType, 
+                  _set_somtTargetType, somtGenerateSections, 
+                  somtOpenSymbolsFile, somtSetPredefinedSymbols, 
+                  somtFileSymbols, somtEmitProlog, 
+                  somtEmitBaseIncludesProlog, somtEmitBaseIncludes, 
+                  somtEmitBaseIncludesEpilog, somtEmitMetaInclude, 
+                  somtEmitClass, somtEmitMeta, 
+                  somtEmitBaseProlog, somtEmitBase, 
+                  somtEmitBaseEpilog, somtEmitPassthruProlog, 
+                  somtEmitPassthru, somtEmitPassthruEpilog, 
+                  somtEmitRelease, somtEmitDataProlog, 
+                  somtEmitData, somtEmitDataEpilog, 
+                  somtEmitMethodsProlog, somtEmitMethods, 
+                  somtEmitMethodsEpilog, somtEmitMethod, 
+                  somtEmitEpilog, somtScanBases, somtScanConstants,
+                  somtCheckVisibility, somtNew, 
+                  somtImplemented, somtOverridden, 
+                  somtInherited, somtAllVisible, 
+                  somtAll, somtNewNoProc, 
+                  somtPrivOrPub, somtNewProc, 
+                  somtLink, somtVA, 
+                  somtScanMethods, somtScanData, 
+                  somtScanPassthru, somtEmitFullPassthru, 
+                  somtScanDataF, somtScanBasesF, 
+                  _set_somtTemplate, _set_somtEmitterName, 
+                  _get_somtEmitterName, somtEmitAttributeProlog, 
+                  somtEmitAttribute, somtEmitAttributeEpilog, 
+                  somtEmitConstantProlog, somtEmitConstant, 
+                  somtEmitConstantEpilog, somtEmitTypedefProlog, 
+                  somtEmitTypedef, somtEmitTypedefEpilog, 
+                  somtEmitStructProlog, somtEmitStruct, 
+                  somtEmitStructEpilog, somtEmitUnionProlog, 
+                  somtEmitUnion, somtEmitUnionEpilog, 
+                  somtEmitEnumProlog, somtEmitEnum, 
+                  somtEmitEnumEpilog, somtEmitInterfaceProlog, 
+                  somtEmitInterface, somtEmitInterfaceEpilog, 
+                  somtEmitModuleProlog, somtEmitModule, 
+                  somtEmitModuleEpilog, somtScanAttributes, 
+                  somtScanTypedefs, somtScanStructs, 
+                  somtScanUnions, somtScanEnums, 
+                  somtScanInterfaces, somtScanModules, 
+                  somtGetGlobalModifierValue,
+		  somtGetFirstGlobalDefinition, somtGetNextGlobalDefinition;
+
+    //# Class Modifiers
+    majorversion = 2;
+    minorversion = 1;
+    filestem = scemit;
+    dllname = "some.dll";
+    callstyle = oidl; 
+  
+    passthru C_h_after = "#include <sm.h>"
+  "#include <sctmplt.h>"
+  "#include <scclass.h>"
+/*  "#include <scmeta.h>"
+  "#include <scmethod.h>"
+  "#include <scpass.h>"*/;
+    passthru C_xh_after = "#include <sm.h>"
+  "#include <sctmplt.xh>"
+  "#include <scclass.xh>"
+/*  "#include <scmeta.xh>"
+  "#include <scmethod.xh>"
+  "#include <scpass.xh>"*/;
+  
+    //# Method Modifiers
+    somDefaultInit: override;
+//    somDestruct: override;
+    somDumpSelfInt: override;
+    //somtTargetFile: noset;
+    //_get_somtTargetFile: mplan=none;
+    //_set_somtTargetFile: mplan=none;
+    somtOpenSymbolsFile: mplan=none;
+
+  };
+#endif /* __SOMIDL__ */
+};
+
+
+#endif  /* scemit_idl */
diff -urN somfree\some\scentry.idl newsomfree3\some\scentry.idl
--- somfree\some\scentry.idl	Thu Jan 01 07:00:00 1970
+++ newsomfree3\some\scentry.idl	Sat Mar 16 14:09:26 2024
@@ -0,0 +1,205 @@
+/**************************************************************************
+ *
+ *  Copyright 2015, 2017, 2018, Yuri Prokushev
+ *
+ *  This file is part of osFree project
+ *
+ *  This program is free software: you can redistribute it and/or modify it
+ *  under the terms of the GNU Lesser General Public License as published by the
+ *  Free Software Foundation, either version 3 of the License, or (at your
+ *  option) any later version.
+ * 
+ *  This program is distributed in the hope that it will be useful, but WITHOUT
+ *  ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ *  FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for
+ *  more details.
+ *
+ *  You should have received a copy of the GNU Lesser General Public License
+ *  along with this program.  If not, see <http://www.gnu.org/licenses/>
+ *
+ */
+
+
+#ifndef scentry_idl
+#define scentry_idl
+
+#include <somobj.idl>
+#include "sm.h"
+
+#ifdef __PRIVATE__
+#include <somstrt.idl>
+#endif
+
+interface SOMTEmitC;
+
+interface SOMTEntryC : SOMObject
+
+// A SOM class interface definition is compiled to produce a graph
+// structure whose nodes are instances of <SOMTEntry> or its
+// sub-classes.  Each entry is derived from some syntactic element of
+// the definition source. The attributes defined in <SOMTEntryC>
+// refer to this syntactic element in a fairly obvious way.
+//
+
+{
+#ifdef __PRIVATE__
+  readonly attribute Entry * somtEntryStruct;
+  // Entry structure which represent abstract syntax graph
+#endif
+
+  attribute string somtEntryName;
+  // The name associated with this entry.  Eg, the name of
+  // the data item, the class, the method, the type, etc.
+
+  attribute SOMTTypes somtElementType;
+  // Returns the type of this entry.
+  // This is not datatype, but entry type (method, class, 
+  // passthru, etc.). The value is defined by SOMTTypes.
+
+  readonly attribute string somtElementTypeName;
+  // String version of somtElementType.
+
+  readonly attribute string somtEntryComment;
+  // Returns the comment associated with this entry, or NULL is this
+  // entry has no associated comment.  Comments will have comment
+  // delimitors removed, but will retain newline characters as
+  // specified in the source file. (use smLookupComment)
+
+  readonly attribute unsigned long somtSourceLineNumber;
+  // Returns the line number in the source file where this entry's
+  // syntactic form ended.
+
+  readonly attribute TypeCode somtTypeCode;
+  // The typecode, if appropriate, or NULL.
+
+  readonly attribute boolean somtIsReference;
+  // Whether the entry is just a reference to the real type (TRUE) 
+  // rather than a declaration of it (FALSE).
+
+  readonly attribute string somtIDLScopedName;
+  // The IDL scoped name of the entry (using double colon as delimiter).
+
+  readonly attribute string somtCScopedName;
+  // The C scoped name of the entry (using underscore as delimiter).
+
+  string somtGetModifierValue(in string modifierName);
+  
+  // Returns the value of the named modifier if this entry has the
+  // named modifier and NULL otherwise. Note: if the modifier is
+  // present but does not have a value then a value of <'\1'> is
+  // returned.
+
+  boolean somtGetFirstModifier(inout string modifierName, 
+                         inout string modifierValue);
+  
+  // Returns the first modifier associated with this entry.  1 (true)
+  // is returned if the entry has at least one modifier and 0 (false)
+  // otherwise.
+
+  boolean somtGetNextModifier(inout string modifierName, 
+                        inout string modifierValue);
+  
+  // Returns the next modifier (with respect to the last call to
+  // <somtGetNextModifier> or <somtGetFirstModifier>)
+  // associated with this entry.  1 (true) is returned if the entry
+  // had another modifier and 0 (false) otherwise.
+
+  long somtFormatModifier(in string buffer, 
+                       in string name, 
+                       in string value);
+  
+  // Formats the indicated name/value pair into buffer.  Buffer must
+  // be big enough to hold all the formatted pair, no checks are made.
+  // The number of characters added to buffer are returned (not
+  // including the trailing null character).
+  // Note: value may be null
+  // You will probably never call this method, it is provided so that
+  // you can override it to control the format returned in
+  // <somtGetModifierList>.
+
+  long somtGetModifierList(in string buffer);
+  
+  // The modifiers for this entry are placed in <buffer> in template
+  // list form (newline separated).  Buffer must be big enough to
+  // hold all the modifiers, no checks are made. The number of
+  // modifiers is returned.
+
+  long somtSetSymbolsOnEntry(in SOMTEmitC emitter, 
+                          in string prefix);
+  
+  // Places a number of symbol/value pairs in <t>.  All the symbols
+  // will begin with <prefix>.
+
+  void somtSetEntryStruct(inout Entry es);
+  
+  // Sets the entry struct data member.
+  // Note, when overridding this method, it is important to call the
+  // parent version of the method first and then do your processing.
+
+
+#ifdef __SOMIDL__
+  implementation {
+  
+    releaseorder: _get_somtEntryName, _set_somtEntryName, 
+                  _get_somtElementType, _set_somtElementType, 
+                  _get_somtEntryComment, _get_somtSourceLineNumber, 
+                  _get_somtTypeCode, _get_somtIsReference, 
+                  somtGetModifierValue, somtGetFirstModifier, 
+                  somtGetNextModifier, somtFormatModifier, 
+                  somtGetModifierList, somtSetSymbolsOnEntry, 
+                  somtSetEntryStruct, _get_somtEntryStruct, 
+                  somtShowAssocEntry, _get_somtCScopedName, 
+                  _get_somtIDLScopedName, _get_somtElementTypeName;
+
+
+    //# Class Modifiers
+    majorversion = 2;
+    minorversion = 1;
+    filestem = scentry;
+    dllname = "some.dll";
+    callstyle = oidl;
+  
+    passthru C_h_after =        "#include <sm.h>"
+  "#include <scemit.h>"
+  "#include <sctmplt.h>";
+    passthru C_xh_after =        "#include <sm.h>"
+  "#include <scemit.xh>"
+  "#include <sctmplt.xh>";
+  
+  
+    //# Internal Instance Variables
+#ifdef __PRIVATE__
+   Entry * es;
+   // Entry structure which represent abstract syntax graph. Seems it was moved
+   // from attributes to instance var by historical reason.
+   
+   string CScopedName;
+   string IDLScopedName;
+   SOMStringTableC Stab;
+   unsigned long iterator;
+#endif
+  
+    //# Method Modifiers
+    somDefaultInit: override;
+    somDestruct: override;
+    //somPrintSelf: override;
+    //somDumpSelfInt: override;
+    //somDumpSelf: override;
+  
+    //# Attribute Modifiers
+    somtEntryComment: nodata;
+    somtCScopedName: nodata;
+    somtIDLScopedName: nodata;
+    somtSourceLineNumber: nodata;
+    somtTypeCode: nodata;
+    somtIsReference: nodata;
+    somtEntryStruct: nodata;
+    somtElementTypeName: nodata;
+    somtEntryName: noget;
+  
+  };
+#endif /* __SOMIDL__ */
+};
+
+
+#endif  /* scentry_idl */
diff -urN somfree\some\scenum.idl newsomfree3\some\scenum.idl
--- somfree\some\scenum.idl	Thu Jan 01 07:00:00 1970
+++ newsomfree3\some\scenum.idl	Sat Mar 16 14:09:26 2024
@@ -0,0 +1,58 @@
+/**************************************************************************
+ *
+ *  Copyright 2015, 2017, 2018, Yuri Prokushev
+ *
+ *  This file is part of osFree project
+ *
+ *  This program is free software: you can redistribute it and/or modify it
+ *  under the terms of the GNU Lesser General Public License as published by the
+ *  Free Software Foundation, either version 3 of the License, or (at your
+ *  option) any later version.
+ * 
+ *  This program is distributed in the hope that it will be useful, but WITHOUT
+ *  ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ *  FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for
+ *  more details.
+ *
+ *  You should have received a copy of the GNU Lesser General Public License
+ *  along with this program.  If not, see <http://www.gnu.org/licenses/>
+ *
+ */
+
+
+#ifndef scenum_idl
+#define scenum_idl
+
+#include <scentry.idl>
+
+interface SOMTEnumNameEntryC;
+
+interface SOMTEnumEntryC : SOMTEntryC
+{
+SOMTEnumNameEntryC somtGetFirstEnumName();
+SOMTEnumNameEntryC somtGetNextEnumName();
+
+#ifdef __SOMIDL__
+  implementation {
+    releaseorder: somtGetFirstEnumName, somtGetNextEnumName;
+  
+
+    //# Class Modifiers
+    majorversion = 2;
+    minorversion = 1;
+    filestem = scenum;
+    dllname = "some.dll";
+    callstyle = oidl;
+  
+    //# Method Modifiers
+    //somDumpSelfInt: override;
+    //somtSetSymbolsOnEntry: override;
+  
+    //# Attribute Modifiers
+    somtEnumNames: nodata;
+  };
+#endif /* __SOMIDL__ */
+};
+
+
+#endif  /* scenum*/
diff -urN somfree\some\scenumnm.idl newsomfree3\some\scenumnm.idl
--- somfree\some\scenumnm.idl	Thu Jan 01 07:00:00 1970
+++ newsomfree3\some\scenumnm.idl	Sat Mar 16 14:09:26 2024
@@ -0,0 +1,60 @@
+/**************************************************************************
+ *
+ *  Copyright 2015, 2017, 2018, Yuri Prokushev
+ *
+ *  This file is part of osFree project
+ *
+ *  This program is free software: you can redistribute it and/or modify it
+ *  under the terms of the GNU Lesser General Public License as published by the
+ *  Free Software Foundation, either version 3 of the License, or (at your
+ *  option) any later version.
+ * 
+ *  This program is distributed in the hope that it will be useful, but WITHOUT
+ *  ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ *  FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for
+ *  more details.
+ *
+ *  You should have received a copy of the GNU Lesser General Public License
+ *  along with this program.  If not, see <http://www.gnu.org/licenses/>
+ *
+ */
+
+
+#ifndef scenumnm_idl
+#define scenumnm_idl
+
+#include <scentry.idl>
+
+interface SOMTEnumEntryC;
+
+interface SOMTEnumNameEntryC : SOMTEntryC
+{
+  readonly attribute SOMTEnumEntryC somtEnumPtr;
+  // A pointer to the enumerator.
+
+  readonly attribute unsigned long somtEnumVal;
+  // The value of the enumeration.
+#ifdef __SOMIDL__
+  implementation {
+    releaseorder: _get_somtEnumPtr, _get_somtEnumVal;
+  
+    //# Class Modifiers
+    majorversion = 2;
+    minorversion = 1;
+    filestem = scenumnm;
+    dllname = "some.dll";
+    callstyle = oidl;
+  
+    //# Method Modifiers
+    //somDumpSelfInt: override;
+    //somtSetSymbolsOnEntry: override;
+  
+    //# Attribute Modifiers
+    somtEnumPtr: nodata;
+    somtEnumVal: nodata;
+  };
+#endif /* __SOMIDL__ */
+};
+
+
+#endif  /* scenumnm */
diff -urN somfree\some\scmeta.idl newsomfree3\some\scmeta.idl
--- somfree\some\scmeta.idl	Thu Jan 01 07:00:00 1970
+++ newsomfree3\some\scmeta.idl	Sat Mar 16 14:09:26 2024
@@ -0,0 +1,63 @@
+/**************************************************************************
+ *
+ *  Copyright 2015, 2017, 2018, Yuri Prokushev
+ *
+ *  This file is part of osFree project
+ *
+ *  This program is free software: you can redistribute it and/or modify it
+ *  under the terms of the GNU Lesser General Public License as published by the
+ *  Free Software Foundation, either version 3 of the License, or (at your
+ *  option) any later version.
+ * 
+ *  This program is distributed in the hope that it will be useful, but WITHOUT
+ *  ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ *  FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for
+ *  more details.
+ *
+ *  You should have received a copy of the GNU Lesser General Public License
+ *  along with this program.  If not, see <http://www.gnu.org/licenses/>
+ *
+ */
+
+
+#ifndef scmeta_idl
+#define scmeta_idl
+
+#include <scentry.idl>
+interface SOMTClassEntryC;
+
+interface SOMTMetaClassEntryC : SOMTEntryC
+{
+  readonly attribute string somtMetaFile;
+  // Returns the name of the file containing the definition of the
+  // meta class named in this entry.
+
+  readonly attribute SOMTClassEntryC somtMetaClassDef;
+  // Returns the class definition entry for the meta class named in
+  // this entry.
+
+#ifdef __SOMIDL__
+  implementation {
+    releaseorder: _get_somtMetaFile,_get_somtMetaClassDef;
+  
+    //# Class Modifiers
+    majorversion = 2;
+    minorversion = 1;
+    filestem = scmeta;
+    dllname = "some.dll";
+    callstyle = oidl;
+  
+    //# Method Modifiers
+    //somtSetSymbolsOnEntry: override;
+    //somDumpSelfInt: override;
+  
+    //# Attribute Modifiers
+    somtMetaFile: nodata;
+    somtMetaClassDef: nodata;
+  
+  };
+#endif /* __SOMIDL__ */
+};
+
+
+#endif  /* scmeta_idl */
diff -urN somfree\some\scmethod.idl newsomfree3\some\scmethod.idl
--- somfree\some\scmethod.idl	Thu Jan 01 07:00:00 1970
+++ newsomfree3\some\scmethod.idl	Sat Mar 16 14:09:26 2024
@@ -0,0 +1,189 @@
+/**************************************************************************
+ *
+ *  Copyright 2015, 2017, 2018, Yuri Prokushev
+ *
+ *  This file is part of osFree project
+ *
+ *  This program is free software: you can redistribute it and/or modify it
+ *  under the terms of the GNU Lesser General Public License as published by the
+ *  Free Software Foundation, either version 3 of the License, or (at your
+ *  option) any later version.
+ * 
+ *  This program is distributed in the hope that it will be useful, but WITHOUT
+ *  ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ *  FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for
+ *  more details.
+ *
+ *  You should have received a copy of the GNU Lesser General Public License
+ *  along with this program.  If not, see <http://www.gnu.org/licenses/>
+ *
+ */
+
+#ifndef scmethod_idl
+#define scmethod_idl
+
+#include <sccommon.idl>
+interface SOMTClassEntryC;
+interface SOMTParameterEntryC;
+interface SOMTDataEntryC;
+interface SOMTStructEntryC;
+
+interface SOMTMethodEntryC : SOMTCommonEntryC
+{
+  readonly attribute boolean somtIsVarargs;
+  // Returns 1 (true) if this method definition has a variable length
+  // parameter list.
+
+  readonly attribute SOMTMethodEntryC somtOriginalMethod;
+  // If this is an override method definition (<SOMTOverrideMethodE>)
+  // then this is the method definition entry that orginially
+  // introduced the method.
+
+  readonly attribute SOMTClassEntryC somtOriginalClass;
+  // If this is an override method definition (<SOMTOverrideMethodE>)
+  // then this is the class definition entry that orginially
+  // introduced the method.
+
+  readonly attribute SOMTEntryC somtMethodGroup;
+  // The group this method is defined in within a class definition.
+
+  readonly attribute boolean somtIsPrivateMethod;
+  // Whether or not the method is private.
+
+  readonly attribute boolean somtIsOneway;
+  // Whether or not the method is oneway.
+
+  readonly attribute short somtArgCount;
+  // The number of arguments for the method.
+
+  SOMTParameterEntryC somtGetFirstParameter();
+  
+  // Returns the first formal parameter entry for this method if it
+  // has one and NULL otherwise.  Note: the target object parameter is
+  // not included, therefore the first parameter is really the second
+  // parameter from a SOM runtime perspective.
+
+  SOMTParameterEntryC somtGetNextParameter();
+  
+  // Returns the next formal parameter entry for this method if it has
+  // one and NULL otherwise.
+
+  string somtGetIDLParamList(in string buffer);
+  // Returns the formal parameter list (in IDL syntax) for this method.
+  // The parameter list is built in <buffer> and the address of <buffer>
+  // is returned.
+  // Parameters are delimited with newlines.
+  // The method receiver and any implicit method arguments are NOT included.
+
+  string somtGetShortCParamList(in string buffer, 
+                      in string selfParm, 
+                      in string varargsParm);
+  
+  // Returns the formal parameter list (in ANSI C function prototype
+  // form, with types) for this method. The parameter list is built in 
+  // <buffer> and the address of <buffer> is returned.
+  // Parameters are delimited with newlines.
+  // If this method takes a variable number of arguments then the
+  // final parameter substring is replaced by <varargsParm>, unless
+  // <varargsParm> is NULL in which case the final parameter is
+  // removed.
+  // If <selfParm> is not null then it is added as an initial
+  // parameter. (The <selfParm> string may actually contain multiple
+  // parameters, delimited by newline characters.)
+  // The method receiver and any implicit method arguments are NOT
+  // included.
+  // The types of the method parameters are given in C form (with pointer
+  // stars, where needed) rather than in the IDL form.
+
+  string somtGetFullCParamList(in string buffer, in string varargsParm);
+  // Same as somtGetShortCParamList except that the method receiver and
+  // any implicit method arguments (Environment and Context) are included.
+  // The types of the method parameters are given in C form (with pointer
+  // stars, where needed) rather than in the IDL form.
+
+  string somtGetShortParamNameList(in string buffer, 
+                       in string selfParm, 
+                       in string varargsParm);
+  
+  // Returns the parameter list for this method in call form (without
+  // types). The argument list is built in <buffer> and the address of 
+  // <buffer> is returned. Parameters are delimited with newlines.
+  // If this method takes a variable number of arguments then the
+  // final parameter is replaced by <varargsParm>, unless
+  // <varargsParm> is NULL in which case the final parameter is removed.
+  // If <selfParm> is not null then it is added as an initial
+  // parameter. (The <selfParm> string may actually contain multiple
+  // parameters, delimited by newline characters.)
+  // The method receiver and any implicit method arguments are NOT
+  // included.
+
+  string somtGetFullParamNameList(in string buffer, in string varargsParm);
+  // Same as somtGetParamNameList except that the method receiver and
+  // any implicit method arguments (Environment and Context) are included.
+
+  SOMTParameterEntryC somtGetNthParameter(in short n);
+  // Returns the object representing the nth explicit method parameter.
+
+  SOMTStructEntryC somtGetFirstException();
+  // The first exception this method raises.
+  SOMTStructEntryC somtGetNextException();
+ // The next exception this method raises,
+ // relative to the previous call to this method or to
+ // somtGetFirstException.
+
+  readonly attribute string *somtContextArray;
+  // An array of the context string-literals for the method.
+
+  readonly attribute string somtCReturnType;
+  // The C datatype the method returns. This may not correspond to the
+  // IDL data type (in particular, pointer stars may be added).
+
+#ifdef __SOMIDL__
+  implementation {
+
+    releaseorder: _get_somtIsVarargs, _get_somtOriginalMethod, 
+                  _get_somtOriginalClass, _get_somtMethodGroup, 
+                  somtGetFirstParameter, somtGetNextParameter, 
+                  somtGetArgList, somtGetParmList, 
+                  _get_somtIsPrivateMethod, _get_somtIsOneway, 
+                  _get_somtArgCount, somtGetFirstException, 
+                  somtGetNextException, _get_somtContextArray, 
+                  somtGetShortCPrototype, somtGetFullCPrototype, 
+                  somtGetShortParmList, somtGetFullParmList, 
+                  somtGetNthParameter, _get_somtCReturnType, 
+                  somtGetIDLParamList, somtGetShortCParamList, 
+                  somtGetFullCParamList, somtGetShortParamNameList, 
+                  somtGetFullParamNameList;
+
+
+    //# Class Modifiers
+    majorversion = 2;
+    minorversion = 1;
+    filestem = scmethod;
+    dllname = "some.dll";
+    callstyle = oidl; 
+  
+    //# Internal Instance Variables
+    SOMTParameterEntryC nextParameter;     
+  
+    //# Method Modifiers
+    somtSetSymbolsOnEntry: override;
+    somDumpSelfInt: override;
+  
+    //# Attribute Modifiers
+    somtIsVarargs: nodata;
+    somtOriginalClass: nodata;
+    somtOriginalMethod: nodata;
+    somtMethodGroup: nodata;
+    somtIsPrivateMethod: nodata;
+    somtIsOneway: nodata;
+    somtArgCount: nodata;
+    somtContextArray: nodata;
+    somtCReturnType: nodata;
+  
+  };
+#endif /* __SOMIDL__ */
+};
+
+
+#endif  /* scmethod_idl */
diff -urN somfree\some\scmodule.idl newsomfree3\some\scmodule.idl
--- somfree\some\scmodule.idl	Thu Jan 01 07:00:00 1970
+++ newsomfree3\some\scmodule.idl	Sat Mar 16 14:09:26 2024
@@ -0,0 +1,95 @@
+/**************************************************************************
+ *
+ *  Copyright 2015, 2017, 2018, Yuri Prokushev
+ *
+ *  This file is part of osFree project
+ *
+ *  This program is free software: you can redistribute it and/or modify it
+ *  under the terms of the GNU Lesser General Public License as published by the
+ *  Free Software Foundation, either version 3 of the License, or (at your
+ *  option) any later version.
+ * 
+ *  This program is distributed in the hope that it will be useful, but WITHOUT
+ *  ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ *  FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for
+ *  more details.
+ *
+ *  You should have received a copy of the GNU Lesser General Public License
+ *  along with this program.  If not, see <http://www.gnu.org/licenses/>
+ *
+ */
+
+#ifndef scmodule_idl
+#define scmodule_idl
+
+#include <scentry.idl>
+
+interface SOMTStructEntryC;
+interface SOMTTypedefEntryC;
+interface SOMTUnionEntryC;
+interface SOMTEnumEntryC;
+interface SOMTConstEntryC;
+interface SOMTSequenceEntryC;
+interface SOMTClassEntryC;
+
+interface SOMTModuleEntryC : SOMTEntryC
+{
+  readonly attribute SOMTModuleEntryC somtOuterModule;
+  /* The module enclosing this module, or NULL if there is none. */
+
+  readonly attribute string somtModuleFile;
+  /* The name of the file in which the module appears. */
+
+  SOMTStructEntryC somtGetFirstModuleStruct ();
+  SOMTStructEntryC somtGetNextModuleStruct ();
+  SOMTTypedefEntryC somtGetFirstModuleTypedef ();
+  SOMTTypedefEntryC somtGetNextModuleTypedef ();
+  SOMTUnionEntryC somtGetFirstModuleUnion ();
+  SOMTUnionEntryC somtGetNextModuleUnion ();
+  SOMTEnumEntryC somtGetFirstModuleEnum ();
+  SOMTEnumEntryC somtGetNextModuleEnum ();
+  SOMTConstEntryC somtGetFirstModuleConstant ();
+  SOMTConstEntryC somtGetNextModuleConstant ();
+  SOMTSequenceEntryC somtGetFirstModuleSequence ();
+  SOMTSequenceEntryC somtGetNextModuleSequence ();
+  SOMTClassEntryC somtGetFirstInterface ();
+  SOMTClassEntryC somtGetNextInterface ();
+  SOMTModuleEntryC somtGetFirstModule ();
+  SOMTModuleEntryC somtGetNextModule ();
+  SOMTEntryC somtGetFirstModuleDef ();
+  SOMTEntryC somtGetNextModuleDef ();
+
+#ifdef __SOMIDL__
+  implementation {
+    releaseorder: _get_somtOuterModule, somtGetFirstModuleStruct, 
+                  somtGetNextModuleStruct, somtGetFirstModuleTypedef, 
+                  somtGetNextModuleTypedef, somtGetFirstModuleUnion, 
+                  somtGetNextModuleUnion, somtGetFirstModuleEnum, 
+                  somtGetNextModuleEnum, somtGetFirstModuleConstant, 
+                  somtGetNextModuleConstant, somtGetFirstModuleSequence, 
+                  somtGetNextModuleSequence, somtGetFirstInterface, 
+                  somtGetNextInterface, somtGetFirstModule, 
+                  somtGetNextModule, somtGetFirstModuleDef, 
+		  somtGetNextModuleDef, _get_somtModuleFile;
+
+    //# Class Modifiers
+    majorversion = 2;
+    minorversion = 1;
+    filestem = scmodule;
+    dllname = "some.dll";
+    callstyle = oidl;
+  
+    //# Method Modifiers
+    //somDumpSelfInt: override;
+    //somtSetSymbolsOnEntry: override;
+  
+    //# Attribute Modifiers
+    somtOuterModule: nodata;
+    somtModuleFile: nodata;
+
+  };
+#endif /* __SOMIDL__ */
+};
+
+
+#endif  /* scmodule_idl */
diff -urN somfree\some\scparm.idl newsomfree3\some\scparm.idl
--- somfree\some\scparm.idl	Thu Jan 01 07:00:00 1970
+++ newsomfree3\some\scparm.idl	Sat Mar 16 14:09:26 2024
@@ -0,0 +1,76 @@
+/**************************************************************************
+ *
+ *  Copyright 2015, 2017, 2018, Yuri Prokushev
+ *
+ *  This file is part of osFree project
+ *
+ *  This program is free software: you can redistribute it and/or modify it
+ *  under the terms of the GNU Lesser General Public License as published by the
+ *  Free Software Foundation, either version 3 of the License, or (at your
+ *  option) any later version.
+ * 
+ *  This program is distributed in the hope that it will be useful, but WITHOUT
+ *  ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ *  FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for
+ *  more details.
+ *
+ *  You should have received a copy of the GNU Lesser General Public License
+ *  along with this program.  If not, see <http://www.gnu.org/licenses/>
+ *
+ */
+
+#ifndef scparm_idl
+#define scparm_idl
+
+#include <sccommon.idl>
+enum somtParameterDirectionT {somtInE, somtOutE,somtInOutE};
+interface SOMTParameterEntryC : SOMTCommonEntryC
+{
+  readonly attribute somtParameterDirectionT somtParameterDirection;
+  // The direction for this parameter. (somtInE, somtOutE, or somtInOutE).
+
+  readonly attribute string somtIDLParameterDeclaration;
+  // The IDL declaration of the parameter, including the type and name.
+
+  readonly attribute string somtCParameterDeclaration;
+  // The declaration for the parameter within a C method procedure prototype.
+  // It includes the parameter's type and name.
+  // This may differ from the parameter's IDL declaration.
+  // In particular, pointer stars may be added.
+
+  readonly attribute string somtPascalParameterDeclaration;
+  // The declaration for the parameter within a Pascal method procedure prototype.
+  // It includes the parameter's type and name.
+  // This may differ from the parameter's IDL declaration.
+  // In particular, pointer stars may be added.
+
+#ifdef __SOMIDL__
+  implementation {
+    releaseorder: _get_somtParameterDirection, _get_somtCParameterDeclaration,
+		_get_somtIDLParameterDeclaration, _get_somtPascalParameterDeclaration;
+  
+    passthru C_h = "typedef enum somtParameterDirectionT {somtInE,somtOutE,somtInOutE} somtParameterDirectionT;";
+    passthru C_xh = "typedef enum somtParameterDirectionT {somtInE,somtOutE,somtInOutE} somtParameterDirectionT;";
+
+    //# Class Modifiers
+    majorversion = 2;
+    minorversion = 1;
+    filestem = scparm;
+    dllname = "some.dll";
+    callstyle = oidl;
+  
+    //# Method Modifiers
+    somtSetSymbolsOnEntry: override;
+    somDumpSelfInt: override;
+  
+    //# Attribute modifiers
+    somtParameterDirection: nodata;
+    somtCParameterDeclaration: nodata;
+    somtIDLParameterDeclaration: nodata;
+    somtPascalParameterDeclaration: nodata;
+  };
+#endif /* __SOMIDL__ */
+};
+
+
+#endif  /* scparm_idl */
diff -urN somfree\some\scpass.idl newsomfree3\some\scpass.idl
--- somfree\some\scpass.idl	Thu Jan 01 07:00:00 1970
+++ newsomfree3\some\scpass.idl	Sat Mar 16 14:09:26 2024
@@ -0,0 +1,71 @@
+/**************************************************************************
+ *
+ *  Copyright 2015, 2017, 2018, Yuri Prokushev
+ *
+ *  This file is part of osFree project
+ *
+ *  This program is free software: you can redistribute it and/or modify it
+ *  under the terms of the GNU Lesser General Public License as published by the
+ *  Free Software Foundation, either version 3 of the License, or (at your
+ *  option) any later version.
+ * 
+ *  This program is distributed in the hope that it will be useful, but WITHOUT
+ *  ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ *  FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for
+ *  more details.
+ *
+ *  You should have received a copy of the GNU Lesser General Public License
+ *  along with this program.  If not, see <http://www.gnu.org/licenses/>
+ *
+ */
+
+
+#ifndef scpass_idl
+#define scpass_idl
+
+#include <scentry.idl>
+interface SOMTPassthruEntryC : SOMTEntryC
+{
+  readonly attribute string somtPassthruBody;
+  // The source content text of this passthru entry without
+  // any modification. Newlines that were present in the source will
+  // still be present.
+
+  readonly attribute string somtPassthruLanguage;
+  // Returns the name of the language for which this passthru entry
+  // is intended. Language names are always all upper case.
+
+  readonly attribute string somtPassthruTarget;
+  // Returns the target for this passthru entry.
+
+  boolean somtIsBeforePassthru();
+  // Returns 1 (true) if this passthru entry is to be put at the
+  // beginning of the file or 0 (false) if this passthru entry is to
+  // go later in the file.
+
+#ifdef __SOMIDL__
+  implementation {
+    releaseorder: _get_somtPassthruBody,_get_somtPassthruTarget,
+		_get_somtPassthruLanguage, somtIsBeforePassthru;
+  
+    //# Class Modifiers
+    majorversion = 2;
+    minorversion = 1;
+    filestem = scpass;
+    dllname = "some.dll";
+    callstyle = oidl;
+  
+    //# Method Modifiers
+    //somtSetSymbolsOnEntry: override;
+    //somDumpSelfInt: override;
+  
+    //# Attribute Modifiers
+    somtPassthruTarget: nodata;
+    somtPassthruLanguage: nodata;
+    somtPassthruBody: nodata;
+  };
+#endif /* __SOMIDL__ */
+};
+
+
+#endif  /* scpass_idl */
diff -urN somfree\some\scseqnce.idl newsomfree3\some\scseqnce.idl
--- somfree\some\scseqnce.idl	Thu Jan 01 07:00:00 1970
+++ newsomfree3\some\scseqnce.idl	Sat Mar 16 14:09:26 2024
@@ -0,0 +1,59 @@
+/**************************************************************************
+ *
+ *  Copyright 2015, 2017, 2018, Yuri Prokushev
+ *
+ *  This file is part of osFree project
+ *
+ *  This program is free software: you can redistribute it and/or modify it
+ *  under the terms of the GNU Lesser General Public License as published by the
+ *  Free Software Foundation, either version 3 of the License, or (at your
+ *  option) any later version.
+ * 
+ *  This program is distributed in the hope that it will be useful, but WITHOUT
+ *  ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ *  FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for
+ *  more details.
+ *
+ *  You should have received a copy of the GNU Lesser General Public License
+ *  along with this program.  If not, see <http://www.gnu.org/licenses/>
+ *
+ */
+
+#ifndef scseqnce_idl
+#define scseqnce_idl
+
+#include <scentry.idl>
+
+interface SOMTSequenceEntryC : SOMTEntryC
+{
+  readonly attribute long somtSeqLength;
+  // The length of the sequence.
+
+  readonly attribute SOMTEntryC somtSeqType;
+  // The type of the sequence.
+
+#ifdef __SOMIDL__
+  implementation {
+    releaseorder: _get_somtSeqLength, _get_somtSeqType, _get_somtSeqTypedef;
+  
+    //# Class Modifiers
+    majorversion = 2;
+    minorversion = 1;
+    filestem = scseqnce;
+    dllname = "some.dll";
+    callstyle = oidl;
+  
+    //# Method Modifiers
+    somDumpSelfInt: override;
+    somtSetSymbolsOnEntry: override;
+  
+    //# Attribute Modifiers
+    somtSeqLength: nodata;
+    somtSeqType: nodata;
+    somtSeqTypedef: nodata;
+  };
+#endif /* __SOMIDL__ */
+};
+
+
+#endif  /* scseqnce*/
diff -urN somfree\some\scstring.idl newsomfree3\some\scstring.idl
--- somfree\some\scstring.idl	Thu Jan 01 07:00:00 1970
+++ newsomfree3\some\scstring.idl	Sat Mar 16 14:09:26 2024
@@ -0,0 +1,53 @@
+/**************************************************************************
+ *
+ *  Copyright 2015, 2017, 2018, Yuri Prokushev
+ *
+ *  This file is part of osFree project
+ *
+ *  This program is free software: you can redistribute it and/or modify it
+ *  under the terms of the GNU Lesser General Public License as published by the
+ *  Free Software Foundation, either version 3 of the License, or (at your
+ *  option) any later version.
+ * 
+ *  This program is distributed in the hope that it will be useful, but WITHOUT
+ *  ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ *  FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for
+ *  more details.
+ *
+ *  You should have received a copy of the GNU Lesser General Public License
+ *  along with this program.  If not, see <http://www.gnu.org/licenses/>
+ *
+ */
+
+#ifndef scstring_idl
+#define scstring_idl
+
+#include <scentry.idl>
+
+interface SOMTStringEntryC : SOMTEntryC
+{
+  readonly attribute long somtStringLength;
+  // The length of the string.
+#ifdef __SOMIDL__
+  implementation {
+    releaseorder: _get_somtStringLength;
+  
+    //# Class Modifiers
+    majorversion = 2;
+    minorversion = 1;
+    filestem = scstring;
+    dllname = "some.dll";
+    callstyle = oidl;
+  
+    //# Method Modifiers
+    somDumpSelfInt: override;
+    somtSetSymbolsOnEntry: override;
+  
+    //# Attribute Modifiers
+    somtStringLength: nodata;
+  };
+#endif /* __SOMIDL__ */
+};
+
+
+#endif  /* scstring*/
diff -urN somfree\some\scstruct.idl newsomfree3\some\scstruct.idl
--- somfree\some\scstruct.idl	Thu Jan 01 07:00:00 1970
+++ newsomfree3\some\scstruct.idl	Sat Mar 16 14:09:26 2024
@@ -0,0 +1,68 @@
+/**************************************************************************
+ *
+ *  Copyright 2015, 2017, 2018, Yuri Prokushev
+ *
+ *  This file is part of osFree project
+ *
+ *  This program is free software: you can redistribute it and/or modify it
+ *  under the terms of the GNU Lesser General Public License as published by the
+ *  Free Software Foundation, either version 3 of the License, or (at your
+ *  option) any later version.
+ * 
+ *  This program is distributed in the hope that it will be useful, but WITHOUT
+ *  ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ *  FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for
+ *  more details.
+ *
+ *  You should have received a copy of the GNU Lesser General Public License
+ *  along with this program.  If not, see <http://www.gnu.org/licenses/>
+ *
+ */
+
+#ifndef scstruct_idl
+#define scstruct_idl
+
+#include <scentry.idl>
+
+interface SOMTTypedefEntryC;
+interface SOMTClassEntryC;
+
+interface SOMTStructEntryC : SOMTEntryC
+{
+  SOMTTypedefEntryC somtGetFirstMember();
+  // The first member of the struct.
+  SOMTTypedefEntryC somtGetNextMember();
+  // The next member of the struct, relative to the previous call
+  // to this method or somtGetFirstMember.
+
+  readonly attribute SOMTClassEntryC somtStructClass;
+  // The class in which the structure was defined.
+
+  readonly attribute boolean somtIsException;
+  // Whether the structure is really an exception.
+#ifdef __SOMIDL__
+  implementation {
+    releaseorder: _get_somtStructClass, _get_somtIsException,
+		somtGetFirstMember, somtGetNextMember;
+  
+    //# Class Modifiers
+    majorversion = 2;
+    minorversion = 1;
+    filestem = scstruct;
+    dllname = "some.dll";
+    callstyle = oidl;
+  
+    //# Method Modifiers
+    //somDumpSelfInt: override;
+    //somtSetSymbolsOnEntry: override;
+  
+    //# Attribute Modifiers
+    somtIsException: nodata;
+    somtStructClass: nodata;
+
+  };
+#endif /* __SOMIDL__ */
+};
+
+
+#endif  /* scstruct_idl */
diff -urN somfree\some\sctdef.idl newsomfree3\some\sctdef.idl
--- somfree\some\sctdef.idl	Thu Jan 01 07:00:00 1970
+++ newsomfree3\some\sctdef.idl	Sat Mar 16 14:09:26 2024
@@ -0,0 +1,69 @@
+/**************************************************************************
+ *
+ *  Copyright 2015, 2017, 2018, Yuri Prokushev
+ *
+ *  This file is part of osFree project
+ *
+ *  This program is free software: you can redistribute it and/or modify it
+ *  under the terms of the GNU Lesser General Public License as published by the
+ *  Free Software Foundation, either version 3 of the License, or (at your
+ *  option) any later version.
+ * 
+ *  This program is distributed in the hope that it will be useful, but WITHOUT
+ *  ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ *  FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for
+ *  more details.
+ *
+ *  You should have received a copy of the GNU Lesser General Public License
+ *  along with this program.  If not, see <http://www.gnu.org/licenses/>
+ *
+ */
+
+#ifndef sctdef_idl
+#define sctdef_idl
+
+#include <sccommon.idl>
+interface SOMTTypedefEntryC : SOMTEntryC
+{
+readonly attribute SOMTEntryC somtTypedefType;
+// The type of the typedef. This does not include pointer stars or
+// array declarators.   These must be obtained by examining each
+// of the declarators.
+
+SOMTCommonEntryC somtGetFirstDeclarator();
+// The first declarator for this typedef.
+// Declarators of struct members will be instances of SOMTDataEntryC, 
+// while declarators of typedefs will be instances of SOMTUserDefinedTypeEntryC.
+
+SOMTCommonEntryC somtGetNextDeclarator();
+// The next declarator for this typedef, relative to the previous 
+// call to this method or somtGetFirstDeclarator.
+// Declarators of struct members will be instances of SOMTDataEntryC, 
+// while declarators of typedefs will be instances of SOMTUserDefinedTypeEntryC.
+
+#ifdef __SOMIDL__
+  implementation {
+    releaseorder: _get_somtTypedefType, 
+		  somtGetFirstDeclarator, somtGetNextDeclarator;
+  
+    //# Class Modifiers
+    majorversion = 2;
+    minorversion = 2; // 1->2 when override _get_somtTypeCode
+    filestem = sctdef;
+    dllname = "some.dll";
+    callstyle = oidl;
+  
+    //# Method Modifiers
+    //somtSetSymbolsOnEntry: override;
+    //somDumpSelfInt: override;
+  
+    //# Attribute Modifiers
+    somtTypedefType: nodata;
+    _get_somtTypeCode: override;
+
+  };
+#endif /* __SOMIDL__ */
+};
+
+
+#endif  /* sctdef_idl */
diff -urN somfree\some\sctmplt.idl newsomfree3\some\sctmplt.idl
--- somfree\some\sctmplt.idl	Thu Jan 01 07:00:00 1970
+++ newsomfree3\some\sctmplt.idl	Sat Mar 16 14:09:26 2024
@@ -0,0 +1,233 @@
+/**************************************************************************
+ *
+ *  Copyright 2015, 2017, 2018, Yuri Prokushev
+ *
+ *  This file is part of osFree project
+ *
+ *  This program is free software: you can redistribute it and/or modify it
+ *  under the terms of the GNU Lesser General Public License as published by the
+ *  Free Software Foundation, either version 3 of the License, or (at your
+ *  option) any later version.
+ * 
+ *  This program is distributed in the hope that it will be useful, but WITHOUT
+ *  ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ *  FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for
+ *  more details.
+ *
+ *  You should have received a copy of the GNU Lesser General Public License
+ *  along with this program.  If not, see <http://www.gnu.org/licenses/>
+ *
+ */
+
+
+#ifndef sctmplt_idl
+#define sctmplt_idl
+
+#include <somobj.idl>
+interface SOMStringTableC;
+
+enum somtCommentStyleT { somtDashesE, somtCPPE, somtCSimpleE, somtCBlockE, somtPSimpleE, somtPBlockE, somtPBorlandE };
+
+interface SOMTTemplateOutputC : SOMObject
+{
+  const long MAX_INPUT_LINE_LENGTH = 1024;
+  const long MAX_OUTPUT_LINE_LENGTH = 4096;
+  attribute somtCommentStyleT somtCommentStyle;
+  
+  // Controls the style in which comments are wrtten as follows:
+  //   somtDashesE: "--" at the start of each line
+  //   somtCPPE: C++ style, "//" at the start of each line
+  //   somtCSimpleE: simple C style, each line wrapped in / * and * /
+  //   somtCBlockE: block C style, block style, ie leading / * then a * on each
+  //              line and then a final * /
+  //   somtPSimpleE: simple Pascal style, each line wrapped in (* and *)
+  //   somtPBlockE: block Pascal style, block style, ie leading (* then a * on each
+  //              line and then a final *)
+  //   somtPBorlandE: block Borland Pascal style, block style, ie leading { 
+  //              and then a final }
+
+  attribute long somtLineLength;
+  
+  // Controls list output only.  Default is 72.
+  // At least one list item will be output on each line, so making
+  // this value very short will cause list items to be placed on
+  // separate lines.
+
+  attribute boolean somtCommentNewline;
+
+  string somtGetSymbol(in string name);
+  
+  // Returns the value associated with <name>.  If no value is
+  // associated with <name> then NULL is returned
+
+  void somtSetSymbol(in string name, 
+                    in string value);
+  
+  // Makes the symbol with name <name> have value <value>.  This will
+  // overwrite any previous value the symbol had, and add the symbol
+  // if necessary.
+  // Takes over ownership of both name and value.
+
+  void somtSetSymbolCopyName(in string name, 
+                            in string value);
+  
+  // See somtSetSymbol
+  // Only takes over ownership of value.
+
+  void somtSetSymbolCopyValue(in string name, 
+                             in string value);
+  
+  // See somtSetSymbol
+  // Only takes over ownership of name.
+
+  void somtSetSymbolCopyBoth(in string name, 
+                            in string value);
+  
+  // See somtSetSymbol
+  // Does not take over ownership of either <name> or <value>
+
+  boolean somtCheckSymbol(in string name);
+  
+  // Returns 1 (true) if the indicated symbol has non-null, non-zero
+  // length value, and 0 (false) otherwise.
+
+  void somtSetOutputFile(inout FILE fp);
+  
+  // All template output will be directed to <fp>. Default is <stdout>.
+
+  void somto(in string tmplt);
+  
+  // Outputs a template, <tmplt>, after substitution for any symbols
+  // that occur in it.  Five substitutions are supported: simple,
+  // list, comment, tab, and conditional.
+  // Substitutable items in the template are bracketed with angle
+  // brackets. (Backslash can be used to escape an angle bracket.)
+  // Simple substitutions just replace a symbol with its value. If
+  // the symbol has no value in this template object then the symbol
+  // is replaced error string but no error is raised.
+  // List substitution assumes that the symbol has a value in output
+  // template list form. This is a newline separated string of
+  // values. The list substitution specification consists of four
+  // parts, a prefix, a symbol, a separator, and a list indicator.
+  // prefixes and separators can only be composed of blanks, comma,
+  // colons, and semi-colons.  The list indicator is "..." (three
+  // periods).  For example, the list substitution
+  // specification "<, name, ...> has a prefix of ", ", a symbol of
+  // "name" and a separator of ", ".  The prefix will be used
+  // whenever there is at least one item in the list and the separator
+  // will be used between any two list items.  After the first items
+  // of a list is placed each additional item is evaluated to see if
+  // it would begin after the line length limit (set by
+  // _set_somtLineLength), if it would then a new line is begun and the
+  // value is placed directly under the first item.
+  // Comment substitution assumes that the symbol has a value in
+  // output template list form.  A comment specification consists of
+  // a comment indicator followed by a symbol name. The comment
+  // indicator is "--".  Eg, <-- classComment> is a valid comment
+  // substitution specification.  The lines of the comment are output
+  // according to the current comment style (see <somtCommentStyle>)
+  // and alined with the starting column of the comment
+  // specification.
+  // Tab substitution is specified by <@dd> where "dd" is a valid
+  // positive integer. Blanks will be inserted into the output stream
+  // if necessary to position the next character of output at the
+  // column indicated by "dd".
+  // Conditional substitution is specified by puting a question mark,
+  // "?", in column one of the template line.  The line will not be
+  // output at all unless at least one valid, non-blank,  symbol
+  // substitution  occurs on the line.
+
+  void somtOutputComment(in string comment);
+  
+  // Inserts a comment into the output stream.  <comment> must be a
+  // string containing the comment with lines in the comment
+  // seperated by newlines.
+  // The style of output is controlled by <somtCommentStyle>
+
+  void somtOutputSection(in string sectionName);
+  
+  // Just like <somto> above, except <sectionName> must be a symbol
+  // whose value will be used as the template.
+
+  void somtAddSectionDefinitions(in string defString);
+  
+  // <defString> must be a string of the form:
+  // :section1
+  // value 1 line 1
+  // value 1 line 2
+  // :section2
+  // value 2 line 1
+  // :section3
+  // value 3 line 1
+  // Where the lines that contain a ":" in column 1 immediately followed
+  // by a single name are used to intro the start of a new section.
+  // The section is named by the name on the colon line.  A backslash
+  // can be used to escape a colon in column one that is not supposed
+  // to start a new section.
+  // Adds the indicated section definitions to this template.
+
+  void somtReadSectionDefinitions(inout FILE fp);
+  
+  // Reads section definitions from the indicated file.  The section
+  // definitions must be in the form defined above in
+  // <somtAddSectionDefinitions>.
+
+  string somtExpandSymbol(in string s, 
+                         in string buf);
+  
+  // Expands simple symbols in an already expanded string.  Thus if you
+  // have a symbol which is itself a Section in a template file, and this
+  // section could have other sections in it then you should call this
+  // method.
+
+#ifdef __SOMIDL__
+  implementation {
+    releaseorder: _get_somtCommentStyle,_set_somtCommentStyle,_get_somtLineLength, 
+                  _set_somtLineLength,_set_somtCommentNewline,_get_somtCommentNewline, 
+                  somtGetSymbol,somtSetSymbol,somtSetSymbolCopyName,somtSetSymbolCopyValue, 
+                  somtSetSymbolCopyBoth,somtCheckSymbol,somtSetOutputFile, 
+                  somto,somtOutputComment,somtOutputSection, 
+                  somtAddSectionDefinitions,somtReadSectionDefinitions, 
+                  somtExpandSymbol;
+  
+    //# Class Modifiers
+    majorversion = 2;
+    minorversion = 2;
+    filestem = sctmplt;
+    dllname = "some.dll";
+    callstyle = oidl;
+  
+    passthru C_h =        "#include <stdio.h>"
+"typedef enum somtCommentStyleT { somtDashesE, somtCPPE, somtCSimpleE, somtCBlockE, somtPSimpleE, somtPBlockE, somtPBorlandE } somtCommentStyleT;";
+    passthru C_xh =        "#include <stdio.h>"
+"typedef enum somtCommentStyleT { somtDashesE, somtCPPE, somtCSimpleE, somtCBlockE, somtPSimpleE, somtPBlockE, somtPBorlandE } somtCommentStyleT;";
+  
+    //# Internal Instance Variables
+    SOMStringTableC stab;
+    FILE *fp;
+    long currentColumn;
+    boolean conditionalLine;
+    boolean anyExpansions;
+    char oBuf[MAX_OUTPUT_LINE_LENGTH];
+    long oBufPos;
+  
+    //# Method Modifiers
+    somDefaultInit: override;
+    somDestruct: override;
+    //somPrintSelf: override;
+    //somDumpSelfInt: override;
+    //somtSetOutputFile: mplan=none;
+    //somtReadSectionDefinitions: mplan=none;
+  };
+#endif /* __SOMIDL__ */
+};
+
+
+/*
+  Version changes:
+  2.1 - original IBM SOM 3.0 interface
+  2.2 - added 3 new types of comments
+
+*/
+
+#endif  /* sctmplt_idl */
diff -urN somfree\some\scunion.idl newsomfree3\some\scunion.idl
--- somfree\some\scunion.idl	Thu Jan 01 07:00:00 1970
+++ newsomfree3\some\scunion.idl	Sat Mar 16 14:09:26 2024
@@ -0,0 +1,81 @@
+/**************************************************************************
+ *
+ *  Copyright 2015, 2017, 2018, Yuri Prokushev
+ *
+ *  This file is part of osFree project
+ *
+ *  This program is free software: you can redistribute it and/or modify it
+ *  under the terms of the GNU Lesser General Public License as published by the
+ *  Free Software Foundation, either version 3 of the License, or (at your
+ *  option) any later version.
+ * 
+ *  This program is distributed in the hope that it will be useful, but WITHOUT
+ *  ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ *  FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for
+ *  more details.
+ *
+ *  You should have received a copy of the GNU Lesser General Public License
+ *  along with this program.  If not, see <http://www.gnu.org/licenses/>
+ *
+ */
+
+#ifndef scunion_idl
+#define scunion_idl
+
+#include <scentry.idl>
+
+interface SOMTDataEntryC;
+
+interface SOMTUnionEntryC : SOMTEntryC
+{
+#if 0
+  struct somtLabelList {
+    string label;
+    somtLabelList *nextLabel;
+  };
+  // Linked list of case labels.
+
+  struct somtCaseEntry {
+    somtLabelList *caseLabels;  // The labels for this case.
+    SOMTEntryC memberType;       // The type of the member.
+    SOMTDataEntryC memberDeclarator; // The declarator for the member.
+  };
+  // A case for the union.
+#endif
+  readonly attribute SOMTEntryC somtSwitchType;
+  // The switch type of the union.
+
+//  somtCaseEntry *somtGetFirstCaseEntry();
+  // The first case for the union.
+
+//  somtCaseEntry *somtGetNextCaseEntry();
+  // The next case for the union, relative to the previous
+  // call to this method or to somtGetFirstCaseEntry.
+
+#ifdef __SOMIDL__
+  implementation {
+    releaseorder: _get_somtSwitchType, somtGetFirstCaseEntry, somtGetNextCaseEntry;
+  
+    //# Class Modifiers
+    majorversion = 2;
+    minorversion = 1;
+    filestem = scunion;
+    dllname = "some.dll";
+    callstyle = oidl;
+  
+    //# Method Modifiers
+//    somDumpSelfInt: override;
+    //somtSetSymbolsOnEntry: override;
+  
+    //# Attribute Modifiers
+    somtSwitchType: nodata;
+
+    /* passthru C_h_before = "#include <scentry.h>"; */
+
+
+  };
+#endif /* __SOMIDL__ */
+};
+
+
+#endif  /* scunion*/
diff -urN somfree\some\scusrtyp.idl newsomfree3\some\scusrtyp.idl
--- somfree\some\scusrtyp.idl	Thu Jan 01 07:00:00 1970
+++ newsomfree3\some\scusrtyp.idl	Sat Mar 16 14:09:26 2024
@@ -0,0 +1,62 @@
+/**************************************************************************
+ *
+ *  Copyright 2015, 2017, 2018, Yuri Prokushev
+ *
+ *  This file is part of osFree project
+ *
+ *  This program is free software: you can redistribute it and/or modify it
+ *  under the terms of the GNU Lesser General Public License as published by the
+ *  Free Software Foundation, either version 3 of the License, or (at your
+ *  option) any later version.
+ * 
+ *  This program is distributed in the hope that it will be useful, but WITHOUT
+ *  ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ *  FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for
+ *  more details.
+ *
+ *  You should have received a copy of the GNU Lesser General Public License
+ *  along with this program.  If not, see <http://www.gnu.org/licenses/>
+ *
+ */
+
+
+#ifndef scusrtyp_idl
+#define scusrtyp_idl
+
+#include <sccommon.idl>
+interface SOMTUserDefinedTypeEntryC : SOMTCommonEntryC
+{
+
+  readonly attribute SOMTTypedefEntryC somtOriginalTypedef;
+  // The typedef that defined the user-defined type.
+
+  readonly attribute SOMTEntryC somtBaseTypeObj;
+  // The object representing the base type 
+  // (eg. short, float, unsigned long) of a user-defined type, 
+  // skipping over any intermediate user-defined types.
+
+#ifdef __SOMIDL__
+  implementation {
+    releaseorder: _get_somtOriginalTypedef, _get_somtBaseTypeObj;
+  
+    //# Class Modifiers
+    majorversion = 2;
+    minorversion = 1;
+    filestem = scusrtyp;
+    dllname = "some.dll";
+    callstyle = oidl;
+  
+    //# Method Modifiers
+    somtSetSymbolsOnEntry: override;
+    somDumpSelfInt: override;
+    _get_somtTypeObj: override;
+  
+    //# attribute modifiers
+    somtOriginalTypedef: nodata;
+    somtBaseTypeObj: nodata;
+  };
+#endif /* __SOMIDL__ */
+};
+
+
+#endif  /* scusrtyp_idl */
diff -urN somfree\some\somstrt.idl newsomfree3\some\somstrt.idl
--- somfree\some\somstrt.idl	Thu Jan 01 07:00:00 1970
+++ newsomfree3\some\somstrt.idl	Sat Mar 16 14:09:26 2024
@@ -0,0 +1,138 @@
+/**************************************************************************
+ *
+ *  Copyright 2015, Yuri Prokushev
+ *
+ *  This file is part of osFree project
+ *
+ *  This program is free software: you can redistribute it and/or modify it
+ *  under the terms of the GNU Lesser General Public License as published by the
+ *  Free Software Foundation, either version 3 of the License, or (at your
+ *  option) any later version.
+ * 
+ *  This program is distributed in the hope that it will be useful, but WITHOUT
+ *  ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ *  FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for
+ *  more details.
+ *
+ *  You should have received a copy of the GNU Lesser General Public License
+ *  along with this program.  If not, see <http://www.gnu.org/licenses/>
+ *
+ */
+
+
+#ifndef somstrt_idl
+#define somstrt_idl
+
+#include <somobj.idl>
+
+typedef struct entryT {
+    string key;
+    string value;
+    entryT *next;
+} *tablePT;
+
+interface SOMStringTableC : SOMObject
+// ╬с·хъЄрьш ъырёёр SOMStringTableC  ты ■Єё  ёшьтюы№э√х ЄрсышЎ√, ъюЄюЁ√х юЄюсЁрцр■Є
+// ёЄЁюъш эр ёЄЁюъш (ъы■ў-чэрўхэшх, рёёюЎшрЄштэ√х ьрёёшт√). ╦■сющ ¤ъчхьяы Ё ъырёёр 
+// ьюцхЄ їЁрэшЄ№ эхюуЁрэшўхээюх ўшёыю ¤ыхьхэЄют. ╧Ёш єтхышўхэшш ъюышўхёЄтр ёЄЁюъ
+// тЁхь  яюшёър ёЄЁюъш єтхышўштрхЄё .
+
+{
+
+  attribute unsigned long somstTargetCapacity;
+  // ┼ьъюёЄ№ рёёюЎшрЄштэюую ьрёёштр.
+  // ╟эрўхэшх эх тыш хЄ эр ЁрсюЄє ш ёюїЁрэхэю фы  ёютьхёЄшьюёЄш.
+
+  readonly attribute unsigned long somstAssociationsCount;
+  // ╥хъє∙хх ўшёыю рёёюЎшрЎшщ т ьрёёштх
+
+  short somstAssociate(in string key, in string value);
+  // ╙ёЄрэртыштрхЄ ёт ч№ <key> ш <value>.  
+  // ┬ючтЁр∙рхЄ 0, хёыш ёт ч№ эх ьюцхЄ с√Є№ єёЄрэютыхэр
+  // (<key> эєыхтющ шыш эхфюёЄрЄюўэю ярь Єш); -1 - рёёюЎшрЎш  єёях°эр т√яюыэхэр,
+  // эю <key> єцх шьхы чэрўхэшх фю т√чютр ьхЄюфр,
+  // 1 - рёёюЎшрЎш  єёях°эю т√яюыэхэр ш <key> эх ёє∙хёЄтютры.
+  // ╟рьхўрэшх: ьрёёшт ёюїЁрэ хЄ ёё√ыъш эр <key> ш <value>, яхЁхфртрхь√х т рЁуєьхэЄрї.
+  // ╩юяш  чэрўхэшщ эх <key> ш <value> ёючфрхЄё .
+  // ╧Ёш єэшўЄюцхэшш юс·хъЄр ярь Є№, чрэшьрхьр  <key> ш <value> юётюсюцфрхЄё 
+  // ё яюью∙№■ SOMFree, Є.х. ярь Є№ яюф <key> ш <value> фюыцэр с√Є№ т√фхыхэр ё яюью∙№■ 
+  // SOMMalloc ш рэрыюушўэ√ї ЇєэъЎшщ.
+  // ╟рьхўрэшх: ╧Ёш чрьхэх <value> яЁш шьх■∙хьё  <key> ёЄрЁюх <value> чрьхэр хЄё , 
+  // ярь Є№ эх юётюсюцфрхЄё 
+
+  short somstAssociateCopyKey(in string key, in string value);
+  // ╥ю цх, ўЄю ш <somstAssociate>, эю ьрёёшт ёюфхЁцшЄ ъюяшш чэрўхэшщ <key>.
+  // ╟эрўхэшх <key> ъюяшЁєхЄё  т т√фхы хьє■ ё яюью∙№■ SOMMalloc ярь Є№.
+
+  short somstAssociateCopyValue(in string key, in string value);
+  // ╥ю цх, ўЄю ш <somstAssociate>, эю ьрёёшт ёюфхЁцшЄ ъюяшш чэрўхэшщ <value>.
+  // ╟эрўхэшх <value> ъюяшЁєхЄё  т т√фхы хьє■ ё яюью∙№■ SOMMalloc ярь Є№.
+
+  short somstAssociateCopyBoth(in string key, in string value);
+  // ╥ю цх, ўЄю ш <somstAssociate>, эю ьрёёшт ёюфхЁцшЄ ъюяшш чэрўхэшщ <key> ш <value>.
+  // ╟эрўхэш  <key> ш <value> ъюяшЁє■Єё  т т√фхы хьє■ ё яюью∙№■ SOMMalloc ярь Є№.
+
+  string somstGetAssociation(in string key);
+  // ┬ючтЁр∙рхЄё  ёЄЁюър, рёёюЎшшЁютрээр  ё <key>, шыш NULL, хёыш эхЄ рёёюЎшрЎшш.
+  // ╠рёёшт яЁюфюыцрхЄ їЁрэшЄ№ єърчрЄхы№ эр чэрўхэшх.
+
+  boolean somstClearAssociation(in string key);
+  // ┬ фрээющ тхЁёшш эх Ёхрышчютрэ.
+  // The association for <key>, if any, is removed.
+  // 1 is returned if <key> had an association, and 0 is returned if
+  // it did not.
+
+  string somstGetIthKey(in unsigned long i);
+  // ┬ючтЁр∙рхЄ ъы■ўхтє■ ўрёЄ№ <i>-щ яю ёўхЄє рёёюЎшрЎшш.
+  // ┼ёыш эхЄ рёёюЎшрЎшш, Єю трчтЁр∙рхЄ NULL.
+  // ╧юЁ фюъ рёёюЎшрЎшш т ьрёёштх эх юяЁхфхыхэ, эю юёЄрхЄё  яюёЄю ээ√ь фю ёыхфє■∙хщ ьюфшЇшърЎшш.
+
+  string somstGetIthValue(in unsigned long i);
+  // ┬ючтЁр∙рхЄ чэрўшьє■ ўрёЄ№ <i>-щ яю ёўхЄє рёёюЎшрЎшш.
+  // ┼ёыш эхЄ рёёюЎшрЎшш, Єю трчтЁр∙рхЄ NULL.
+  // ╧юЁ фюъ рёёюЎшрЎшш т ьрёёштх эх юяЁхфхыхэ, эю юёЄрхЄё  яюёЄю ээ√ь фю ёыхфє■∙хщ ьюфшЇшърЎшш.
+
+#ifdef __SOMIDL__
+  implementation {
+    releaseorder: _get_somstTargetCapacity, _set_somstTargetCapacity,
+                  _get_somstAssociationsCount, 
+                  somstAssociate,somstAssociateCopyKey,somstAssociateCopyValue, 
+                  somstAssociateCopyBoth,somstGetAssociation,
+                  somstClearAssociation,somstGetIthKey,somstGetIthValue;
+  
+    //# Class Modifiers
+    majorversion = 2;
+    minorversion = 1;
+    filestem = somstrt;
+    dllname = "some.dll";
+    callstyle = oidl;
+  
+    //# Internal Instance Variables
+    unsigned long tableSize;
+    // ╨рчьхЁ ьрёёштр. 
+    struct entryT * table;
+    // ╙ърчрЄхы№ эр эрўрыю ьрёёштр. 
+    unsigned long numberOfEntries;
+    // ╫шёыю чряшёхщ т ьрёёштх
+  
+    //# Method Modifiers
+    somDefaultInit: override, init;
+    // ╩юэёЄЁєъЄюЁ
+    somDestruct: override;
+    // ─хёЄЁєъЄюЁ
+    somDumpSelfInt: override;
+    // ─рья чэрўхэшщ ьрёёштр
+    
+    somstTargetCapacity: nodata;
+    somstAssociationsCount: noget;
+  };
+#endif /* __SOMIDL__ */
+};
+
+/*
+  Version changes:
+  2.1 - original IBM SOM 3.0 interface
+
+*/
+
+#endif  /* somstrt_idl */
diff -urN somfree\some\src\scattrib.cpp newsomfree3\some\src\scattrib.cpp
--- somfree\some\src\scattrib.cpp	Thu Jan 01 07:00:00 1970
+++ newsomfree3\some\src\scattrib.cpp	Sat Mar 16 14:09:26 2024
@@ -0,0 +1,126 @@
+/**************************************************************************
+ *
+ *  Copyright 2015, 2017 Yuri Prokushev
+ *
+ *  This file is part of osFree project
+ *
+ *  This program is free software: you can redistribute it and/or modify it
+ *  under the terms of the GNU Lesser General Public License as published by the
+ *  Free Software Foundation, either version 3 of the License, or (at your
+ *  option) any later version.
+ * 
+ *  This program is distributed in the hope that it will be useful, but WITHOUT
+ *  ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ *  FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for
+ *  more details.
+ *
+ *  You should have received a copy of the GNU Lesser General Public License
+ *  along with this program.  If not, see <http://www.gnu.org/licenses/>
+ *
+ */
+
+#ifndef SOM_Module_scattrib_Source
+#define SOM_Module_scattrib_Source
+#endif
+
+#define SOMTAttributeEntryC_Class_Source
+
+#define __PRIVATE__
+#include <rhbopt.h>
+#include <stdio.h>
+#include <string.h>
+#include <stdlib.h>
+#include "rhbsc.h"
+
+#include "scattrib.xih"
+
+SOM_Scope long SOMLINK somtSetSymbolsOnEntry(SOMTAttributeEntryC SOMSTAR somSelf,
+	                                           /* in */ SOMTEmitC SOMSTAR emitter,
+	                                           /* in */ string prefix)
+{
+  char buf[250];
+  
+  SOMTAttributeEntryCData *somThis = SOMTAttributeEntryCGetData(somSelf);
+  SOMTAttributeEntryCMethodDebug("SOMTAttributeEntryC","somtSetSymbolsOnEntry");
+  
+
+  SOMTTemplateOutputC *templ = emitter->_get_somtTemplate();
+
+  SOMTAttributeEntryC_parent_SOMTEntryC_somtSetSymbolsOnEntry(somSelf, emitter, prefix);
+  RHBattribute *c=somSelf->_get_somtEntryStruct()->data->is_attribute();
+  
+  RHBtype *t=c->attribute_type->is_base_type();
+
+  buf[0]=0;
+  strcat(buf, prefix);
+  templ->somtSetSymbolCopyBoth(strcat(buf, "BaseType"), c->attribute_type->id);
+
+// чфхё№ эрфю юЄЁрсюЄрЄ№ фхъырЁрЄюЁ√  
+  return 1;
+}
+
+SOM_Scope SOMTMethodEntryC SOMSTAR SOMLINK somtGetFirstSetMethod(SOMTAttributeEntryC SOMSTAR somSelf)
+{
+  SOMTAttributeEntryCData *somThis = SOMTAttributeEntryCGetData(somSelf);
+  SOMTAttributeEntryCMethodDebug("SOMTAttributeEntryC","somtGetFirstSetMethod");
+  
+  return NULL;
+}
+
+SOM_Scope SOMTEntryC SOMSTAR SOMLINK _get_somtAttribType(SOMTAttributeEntryC SOMSTAR somSelf)
+{
+  SOMTAttributeEntryCData *somThis = SOMTAttributeEntryCGetData(somSelf);
+  SOMTAttributeEntryCMethodDebug("SOMTAttributeEntryC","_get_somtAttribType");
+
+  return NULL;
+}
+
+SOM_Scope SOMTMethodEntryC SOMSTAR SOMLINK somtGetFirstGetMethod(SOMTAttributeEntryC SOMSTAR somSelf)
+{
+  SOMTAttributeEntryCData *somThis = SOMTAttributeEntryCGetData(somSelf);
+  SOMTAttributeEntryCMethodDebug("SOMTAttributeEntryC","somtGetFirstGetMethod");
+  
+  return NULL;
+}
+
+SOM_Scope SOMTDataEntryC SOMSTAR SOMLINK somtGetFirstAttributeDeclarator(SOMTAttributeEntryC SOMSTAR somSelf)
+{
+  SOMTAttributeEntryCData *somThis = SOMTAttributeEntryCGetData(somSelf);
+  SOMTAttributeEntryCMethodDebug("SOMTAttributeEntryC","somtGetFirstAttributeDeclarator");
+  
+  return NULL;
+}
+
+SOM_Scope SOMTMethodEntryC SOMSTAR SOMLINK somtGetNextGetMethod(SOMTAttributeEntryC SOMSTAR somSelf)
+{
+  SOMTAttributeEntryCData *somThis = SOMTAttributeEntryCGetData(somSelf);
+  SOMTAttributeEntryCMethodDebug("SOMTAttributeEntryC","somtGetNextGetMethod");
+  
+  return NULL;
+}
+
+SOM_Scope SOMTDataEntryC SOMSTAR SOMLINK somtGetNextAttributeDeclarator(SOMTAttributeEntryC SOMSTAR somSelf)
+{
+  SOMTAttributeEntryCData *somThis = SOMTAttributeEntryCGetData(somSelf);
+  SOMTAttributeEntryCMethodDebug("SOMTAttributeEntryC","somtGetNextAttributeDeclarator");
+  
+  return NULL;
+}
+
+SOM_Scope boolean SOMLINK _get_somtIsReadonly(SOMTAttributeEntryC SOMSTAR somSelf)
+{
+  SOMTAttributeEntryCData *somThis = SOMTAttributeEntryCGetData(somSelf);
+  SOMTAttributeEntryCMethodDebug("SOMTAttributeEntryC","_get_somtIsReadonly");
+  
+  RHBattribute *c=somSelf->_get_somtEntryStruct()->data->is_attribute();
+  
+  return c->readonly;
+}
+
+SOM_Scope SOMTMethodEntryC SOMSTAR SOMLINK somtGetNextSetMethod(SOMTAttributeEntryC SOMSTAR somSelf)
+{
+  SOMTAttributeEntryCData *somThis = SOMTAttributeEntryCGetData(somSelf);
+  SOMTAttributeEntryCMethodDebug("SOMTAttributeEntryC","somtGetNextSetMethod");
+  
+  return NULL;
+}
diff -urN somfree\some\src\scbase.cpp newsomfree3\some\src\scbase.cpp
--- somfree\some\src\scbase.cpp	Thu Jan 01 07:00:00 1970
+++ newsomfree3\some\src\scbase.cpp	Sat Mar 16 14:09:26 2024
@@ -0,0 +1,46 @@
+/**************************************************************************
+ *
+ *  Copyright 2015, 2017 Yuri Prokushev
+ *
+ *  This file is part of osFree project
+ *
+ *  This program is free software: you can redistribute it and/or modify it
+ *  under the terms of the GNU Lesser General Public License as published by the
+ *  Free Software Foundation, either version 3 of the License, or (at your
+ *  option) any later version.
+ * 
+ *  This program is distributed in the hope that it will be useful, but WITHOUT
+ *  ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ *  FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for
+ *  more details.
+ *
+ *  You should have received a copy of the GNU Lesser General Public License
+ *  along with this program.  If not, see <http://www.gnu.org/licenses/>
+ *
+ */
+
+#ifndef SOM_Module_scbase_Source
+#define SOM_Module_scbase_Source
+#endif
+
+#define SOMTBaseClassEntryC_Class_Source
+
+#include "scbase.xih"
+
+SOM_Scope SOMTClassEntryC SOMSTAR SOMLINK _get_somtBaseClassDef(SOMTBaseClassEntryC SOMSTAR somSelf)
+{
+  SOMTBaseClassEntryCData *somThis = SOMTBaseClassEntryCGetData(somSelf);
+  SOMTBaseClassEntryCMethodDebug("SOMTBaseClassEntryC","_get_somtBaseClassDef");
+
+  return NULL;
+}
+
+SOM_Scope long SOMLINK somtSetSymbolsOnEntry(SOMTBaseClassEntryC SOMSTAR somSelf,
+	                                           /* in */ SOMTEmitC SOMSTAR emitter,
+	                                           /* in */ string prefix)
+{
+  SOMTBaseClassEntryCData *somThis = SOMTBaseClassEntryCGetData(somSelf);
+  SOMTBaseClassEntryCMethodDebug("SOMTBaseClassEntryC","somtSetSymbolsOnEntry");
+
+  return 0;
+}
diff -urN somfree\some\src\scclass.cpp newsomfree3\some\src\scclass.cpp
--- somfree\some\src\scclass.cpp	Thu Jan 01 07:00:00 1970
+++ newsomfree3\some\src\scclass.cpp	Sat Mar 16 14:09:26 2024
@@ -0,0 +1,649 @@
+/**************************************************************************
+ *
+ *  Copyright 2015, 2017 Yuri Prokushev
+ *
+ *  This file is part of osFree project
+ *
+ *  This program is free software: you can redistribute it and/or modify it
+ *  under the terms of the GNU Lesser General Public License as published by the
+ *  Free Software Foundation, either version 3 of the License, or (at your
+ *  option) any later version.
+ * 
+ *  This program is distributed in the hope that it will be useful, but WITHOUT
+ *  ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ *  FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for
+ *  more details.
+ *
+ *  You should have received a copy of the GNU Lesser General Public License
+ *  along with this program.  If not, see <http://www.gnu.org/licenses/>
+ *
+ */
+
+#ifndef SOM_Module_scclass_Source
+#define SOM_Module_scclass_Source
+#endif
+
+#define SOMTClassEntryC_Class_Source
+
+#define __PRIVATE__
+#include <rhbopt.h>
+#include <stdio.h>
+#include <string.h>
+#include <stdlib.h>
+#include "rhbsc.h"
+#include "scclass.xih"
+
+#include "scconst.xh"
+#include "scattrib.xh"
+
+SOM_Scope SOMTTypedefEntryC * SOMLINK somtGetFirstTypedef(SOMTClassEntryC * somSelf)
+{
+  SOMTClassEntryCData *somThis = SOMTClassEntryCGetData(somSelf);
+  SOMTClassEntryCMethodDebug("SOMTClassEntryC","somtGetFirstTypedef");
+  
+  return NULL;
+}
+
+SOM_Scope SOMTTypedefEntryC * SOMLINK somtGetNextTypedef(SOMTClassEntryC * somSelf)
+{
+  SOMTClassEntryCData *somThis = SOMTClassEntryCGetData(somSelf);
+  SOMTClassEntryCMethodDebug("SOMTClassEntryC","somtGetNextTypedef");
+  
+  return NULL;
+}
+
+SOM_Scope SOMTEnumEntryC * SOMLINK somtGetNextEnum(SOMTClassEntryC * somSelf)
+{
+  SOMTClassEntryCData *somThis = SOMTClassEntryCGetData(somSelf);
+  SOMTClassEntryCMethodDebug("SOMTClassEntryC","somtGetNextEnum");
+  
+  return NULL;
+}
+
+SOM_Scope SOMTPassthruEntryC * SOMLINK somtGetNextPassthru(SOMTClassEntryC * somSelf)
+{
+  SOMTClassEntryCData *somThis = SOMTClassEntryCGetData(somSelf);
+  SOMTClassEntryCMethodDebug("SOMTClassEntryC","somtGetNextPassthru");
+  
+  return NULL;
+}
+
+SOM_Scope boolean SOMLINK _get_somtForwardRef(SOMTClassEntryC * somSelf)
+{
+  SOMTClassEntryCData *somThis = SOMTClassEntryCGetData(somSelf);
+  SOMTClassEntryCMethodDebug("SOMTClassEntryC","_get_somtForwardRef");
+  
+  return FALSE;
+}
+
+SOM_Scope long SOMLINK _get_somtPrivateMethodCount(SOMTClassEntryC * somSelf)
+{
+  SOMTClassEntryCData *somThis = SOMTClassEntryCGetData(somSelf);
+  SOMTClassEntryCMethodDebug("SOMTClassEntryC","_get_somtPrivateMethodCount");
+  
+  return 0;
+}
+
+SOM_Scope SOMTSequenceEntryC * SOMLINK somtGetFirstSequence(SOMTClassEntryC * somSelf)
+{
+  SOMTClassEntryCData *somThis = SOMTClassEntryCGetData(somSelf);
+  SOMTClassEntryCMethodDebug("SOMTClassEntryC","somtGetFirstSequence");
+  
+  return NULL;
+}
+
+SOM_Scope boolean SOMLINK somtFilterOverridden(SOMTClassEntryC * somSelf,
+                                               /* in */ SOMTMethodEntryC * entry)
+{
+  SOMTClassEntryCData *somThis = SOMTClassEntryCGetData(somSelf);
+  SOMTClassEntryCMethodDebug("SOMTClassEntryC","somtFilterOverridden");
+  
+  return FALSE;
+}
+
+SOM_Scope SOMTStructEntryC * SOMLINK somtGetNextStruct(SOMTClassEntryC * somSelf)
+{
+  SOMTClassEntryCData *somThis = SOMTClassEntryCGetData(somSelf);
+  SOMTClassEntryCMethodDebug("SOMTClassEntryC","somtGetNextStruct");
+  
+  return NULL;
+}
+
+SOM_Scope SOMTModuleEntryC * SOMLINK _get_somtClassModule(SOMTClassEntryC * somSelf)
+{
+  SOMTClassEntryCData *somThis = SOMTClassEntryCGetData(somSelf);
+  SOMTClassEntryCMethodDebug("SOMTClassEntryC","_get_somtClassModule");
+  
+  return NULL;
+}
+
+SOM_Scope SOMTBaseClassEntryC * SOMLINK somtGetNextBaseClass(SOMTClassEntryC * somSelf)
+{
+  SOMTClassEntryCData *somThis = SOMTClassEntryCGetData(somSelf);
+  SOMTClassEntryCMethodDebug("SOMTClassEntryC","somtGetNextBaseClass");
+  
+  return NULL;
+}
+
+SOM_Scope SOMTDataEntryC * SOMLINK somtGetFirstData(SOMTClassEntryC * somSelf)
+{
+  SOMTClassEntryCData *somThis = SOMTClassEntryCGetData(somSelf);
+  SOMTClassEntryCMethodDebug("SOMTClassEntryC","somtGetFirstData");
+  
+  return NULL;
+}
+
+SOM_Scope long SOMLINK _get_somtPrivateDataCount(SOMTClassEntryC * somSelf)
+{
+  SOMTClassEntryCData *somThis = SOMTClassEntryCGetData(somSelf);
+  SOMTClassEntryCMethodDebug("SOMTClassEntryC","_get_somtPrivateDataCount");
+  
+  return 0;
+}
+
+SOM_Scope long SOMLINK _get_somtVAMethodCount(SOMTClassEntryC * somSelf)
+{
+  SOMTClassEntryCData *somThis = SOMTClassEntryCGetData(somSelf);
+  SOMTClassEntryCMethodDebug("SOMTClassEntryC","_get_somtVAMethodCount");
+  
+  return 0;
+}
+
+SOM_Scope string SOMLINK _get_somtCScopedName(SOMTClassEntryC * somSelf)
+{
+  SOMTClassEntryCData *somThis = SOMTClassEntryCGetData(somSelf);
+  SOMTClassEntryCMethodDebug("SOMTClassEntryC","_get_somtCScopedName");
+  
+  return SOMTClassEntryC_parent_SOMTEntryC__get_somtCScopedName(somSelf);
+}
+
+SOM_Scope void SOMLINK somtSetEntryStruct(SOMTClassEntryC * somSelf,
+                                          /* inout */ Entry *es)
+{
+  SOMTClassEntryCData *somThis = SOMTClassEntryCGetData(somSelf);
+  SOMTClassEntryCMethodDebug("SOMTClassEntryC","somtSetEntryStruct");
+  
+  //SOMTClassEntryC_parent_SOMTEntryC_somtSetEntryStruct(somSelf, es);
+  parent_somtSetEntryStruct(somSelf, es);
+}
+
+SOM_Scope SOMTUnionEntryC * SOMLINK somtGetNextUnion(SOMTClassEntryC * somSelf)
+{
+  SOMTClassEntryCData *somThis = SOMTClassEntryCGetData(somSelf);
+  SOMTClassEntryCMethodDebug("SOMTClassEntryC","somtGetNextUnion");
+  
+  return NULL;
+}
+
+SOM_Scope SOMTStructEntryC * SOMLINK somtGetFirstStruct(SOMTClassEntryC * somSelf)
+{
+  SOMTClassEntryCData *somThis = SOMTClassEntryCGetData(somSelf);
+  SOMTClassEntryCMethodDebug("SOMTClassEntryC","somtGetFirstStruct");
+  
+  return NULL;
+}
+
+SOM_Scope SOMTPassthruEntryC * SOMLINK somtGetFirstPassthru(SOMTClassEntryC * somSelf)
+{
+  SOMTClassEntryCData *somThis = SOMTClassEntryCGetData(somSelf);
+  SOMTClassEntryCMethodDebug("SOMTClassEntryC","somtGetFirstPassthru");
+  
+  return NULL;
+}
+
+SOM_Scope SOMTEnumEntryC * SOMLINK somtGetFirstEnum(SOMTClassEntryC * somSelf)
+{
+  SOMTClassEntryCData *somThis = SOMTClassEntryCGetData(somSelf);
+  SOMTClassEntryCMethodDebug("SOMTClassEntryC","somtGetFirstEnum");
+  
+  return NULL;
+}
+
+SOM_Scope SOMTClassEntryC * SOMLINK _get_somtMetaclassFor(SOMTClassEntryC * somSelf)
+{
+  SOMTClassEntryCData *somThis = SOMTClassEntryCGetData(somSelf);
+  SOMTClassEntryCMethodDebug("SOMTClassEntryC","_get_somtMetaclassFor");
+  
+  return NULL;
+}
+
+SOM_Scope boolean SOMLINK _get_somtLocalInclude(SOMTClassEntryC * somSelf)
+{
+  SOMTClassEntryCData *somThis = SOMTClassEntryCGetData(somSelf);
+  SOMTClassEntryCMethodDebug("SOMTClassEntryC","_get_somtLocalInclude");
+  
+  return NULL;
+}
+
+SOM_Scope long SOMLINK somtSetSymbolsOnEntry(SOMTClassEntryC * somSelf,
+                                             /* in */ SOMTEmitC * emitter,
+                                             /* in */ string prefix)
+{
+  string filestem;
+  char buf[250];
+
+  SOMTClassEntryCData *somThis = SOMTClassEntryCGetData(somSelf);
+  SOMTClassEntryCMethodDebug("SOMTClassEntryC","somtSetSymbolsOnEntry");
+
+  SOMTClassEntryC_parent_SOMTEntryC_somtSetSymbolsOnEntry(somSelf, emitter, prefix);
+
+  SOMTTemplateOutputC *templ = emitter->_get_somtTemplate();
+  
+  buf[0]=0;
+  strcat(buf, prefix);
+  templ->somtSetSymbolCopyBoth(strcat(buf, "SourceFile"), somSelf->_get_somtEntryStruct()->data->defined_in->id);
+  
+  buf[0]=0;
+  strcat(buf, prefix);
+  if (somSelf->somtGetModifierValue("filestem"))
+  {
+    filestem=somSelf->somtGetModifierValue("filestem");
+  } 
+  else
+  {
+    filestem=somSelf->_get_somtEntryStruct()->filestem;
+  };
+  
+  templ->somtSetSymbolCopyBoth(strcat(buf, "SourceFileStem"), filestem);
+
+  buf[0]=0;
+  strcat(buf, prefix);
+  templ->somtSetSymbolCopyBoth(strcat(buf, "ReleaseOrder"), somSelf->somtGetModifierValue("releaseorder"));
+
+  buf[0]=0;
+  strcat(buf, prefix);
+  templ->somtSetSymbolCopyBoth(strcat(buf, "MajorVersion"), somSelf->somtGetModifierValue("majorversion"));
+
+  buf[0]=0;
+  strcat(buf, prefix);
+  templ->somtSetSymbolCopyBoth(strcat(buf, "MinorVersion"), somSelf->somtGetModifierValue("minorversion"));
+
+  buf[0]=0;
+  strcat(buf, prefix);
+  templ->somtSetSymbolCopyBoth(strcat(buf, "Include"), somSelf->_get_somtEntryStruct()->data->defined_in->id);
+
+  return 1;
+}
+
+SOM_Scope SOMTDataEntryC * SOMLINK somtGetNextData(SOMTClassEntryC * somSelf)
+{
+  SOMTClassEntryCData *somThis = SOMTClassEntryCGetData(somSelf);
+  SOMTClassEntryCMethodDebug("SOMTClassEntryC","somtGetNextData");
+  
+  return NULL;
+}
+
+SOM_Scope SOMTConstEntryC * SOMLINK somtGetFirstConstant(SOMTClassEntryC * somSelf)
+{
+  SOMTClassEntryCData *somThis = SOMTClassEntryCGetData(somSelf);
+  SOMTClassEntryCMethodDebug("SOMTClassEntryC","somtGetFirstConstant");
+  RHBelement * e=somSelf->_get_somtEntryStruct()->data->children();
+	while (e)
+	{
+    RHBconstant *m=e->is_constant();
+    if (m) 
+    {
+      if (_cons)
+      {
+        SOMFree(_cons->_get_somtEntryStruct());
+        delete _cons;
+      }
+      _cons=new SOMTConstEntryC();
+      Entry *es=(Entry *)SOMMalloc(sizeof(Entry));
+      es->name=m->id;
+      es->type=SOMTConstE;
+      es->data=m;
+      es->filestem=somSelf->_get_somtEntryStruct()->filestem;
+      _cons->somtSetEntryStruct(es);
+      return _cons;
+    }
+		e=e->next();
+	}
+  return NULL;
+}
+
+SOM_Scope SOMTConstEntryC * SOMLINK somtGetNextConstant(SOMTClassEntryC * somSelf)
+{
+  SOMTClassEntryCData *somThis = SOMTClassEntryCGetData(somSelf);
+  SOMTClassEntryCMethodDebug("SOMTClassEntryC","somtGetNextConstant");
+  RHBelement * e=_cons->_get_somtEntryStruct()->data;
+  e=e->next();
+	while (e)
+	{
+    RHBconstant *m=e->is_constant();
+    if (m) 
+    {
+      Entry *es=(Entry *)SOMMalloc(sizeof(Entry));
+      es->name=m->id;
+      es->type=SOMTConstE;
+      es->data=m;
+      es->filestem=somSelf->_get_somtEntryStruct()->filestem;
+      
+      //SOMFree(_cons->_get_somtEntryStruct());
+      //delete _cons;
+      _cons=new SOMTConstEntryC();
+      _cons->somtSetEntryStruct(es);
+      return _cons;
+    }
+		e=e->next();
+	}
+  return NULL;
+}
+
+SOM_Scope SOMTAttributeEntryC * SOMLINK somtGetFirstAttribute(SOMTClassEntryC * somSelf)
+{
+  SOMTClassEntryCData *somThis = SOMTClassEntryCGetData(somSelf);
+  SOMTClassEntryCMethodDebug("SOMTClassEntryC","somtGetFirstAttribute");
+  RHBelement * e=somSelf->_get_somtEntryStruct()->data->children();
+	while (e)
+	{
+    RHBattribute *m=e->is_attribute();
+    if (m) 
+    {
+      if (_attrs)
+      {
+        SOMFree(_attrs->_get_somtEntryStruct());
+        delete _attrs;
+      }
+      _attrs=new SOMTAttributeEntryC();
+      Entry *es=(Entry *)SOMMalloc(sizeof(Entry));
+      es->name=m->id;
+      es->type=SOMTAttE;
+      es->data=m;
+      es->filestem=somSelf->_get_somtEntryStruct()->filestem;
+      _attrs->somtSetEntryStruct(es);
+
+      return _attrs;
+    }
+		e=e->next();
+	}
+  return NULL;
+}
+
+SOM_Scope SOMTAttributeEntryC * SOMLINK somtGetNextAttribute(SOMTClassEntryC * somSelf)
+{
+  SOMTClassEntryCData *somThis = SOMTClassEntryCGetData(somSelf);
+  SOMTClassEntryCMethodDebug("SOMTClassEntryC","somtGetNextAttribute");
+  RHBelement * e=_attrs->_get_somtEntryStruct()->data;
+  e=e->next();
+	while (e)
+	{
+    RHBattribute *m=e->is_attribute();
+    if (m) 
+    {
+      Entry *es=(Entry *)SOMMalloc(sizeof(Entry));
+      es->name=m->id;
+      es->type=SOMTAttE;
+      es->data=m;
+      es->filestem=somSelf->_get_somtEntryStruct()->filestem;
+      _attrs=new SOMTAttributeEntryC();
+      _attrs->somtSetEntryStruct(es);
+      return _attrs;
+    }
+		e=e->next();
+	}
+  return NULL;
+}
+
+SOM_Scope SOMTMethodEntryC * SOMLINK somtGetNextMethod(SOMTClassEntryC * somSelf)
+{
+  SOMTClassEntryCData *somThis = SOMTClassEntryCGetData(somSelf);
+  SOMTClassEntryCMethodDebug("SOMTClassEntryC","somtGetNextMethod");
+  
+  return NULL;
+}
+
+SOM_Scope void SOMLINK somDumpSelfInt(SOMTClassEntryC * somSelf,
+                                      /* in */ long level)
+{
+  SOMTClassEntryCData *somThis = SOMTClassEntryCGetData(somSelf);
+  SOMTClassEntryCMethodDebug("SOMTClassEntryC","somDumpSelfInt");
+  
+}
+
+
+SOM_Scope SOMTMetaClassEntryC * SOMLINK _get_somtMetaClassEntry(SOMTClassEntryC * somSelf)
+{
+  SOMTClassEntryCData *somThis = SOMTClassEntryCGetData(somSelf);
+  SOMTClassEntryCMethodDebug("SOMTClassEntryC","_get_somtMetaClassEntry");
+  
+  return NULL;
+}
+
+SOM_Scope long SOMLINK _get_somtStaticMethodCount(SOMTClassEntryC * somSelf)
+{
+  SOMTClassEntryCData *somThis = SOMTClassEntryCGetData(somSelf);
+  SOMTClassEntryCMethodDebug("SOMTClassEntryC","_get_somtStaticMethodCount");
+  
+  return NULL;
+}
+
+SOM_Scope SOMTDataEntryC * SOMLINK somtGetNextStaticData(SOMTClassEntryC * somSelf)
+{
+  SOMTClassEntryCData *somThis = SOMTClassEntryCGetData(somSelf);
+  SOMTClassEntryCMethodDebug("SOMTClassEntryC","somtGetNextStaticData");
+  
+  return NULL;
+}
+
+SOM_Scope long SOMLINK _get_somtNewMethodCount(SOMTClassEntryC * somSelf)
+{
+  SOMTClassEntryCData *somThis = SOMTClassEntryCGetData(somSelf);
+  SOMTClassEntryCMethodDebug("SOMTClassEntryC","_get_somtNewMethodCount");
+  
+  return 0;
+}
+
+SOM_Scope SOMTBaseClassEntryC * SOMLINK somtGetFirstBaseClass(SOMTClassEntryC * somSelf)
+{
+  SOMTClassEntryCData *somThis = SOMTClassEntryCGetData(somSelf);
+  SOMTClassEntryCMethodDebug("SOMTClassEntryC","somtGetFirstBaseClass");
+
+  RHBelement * e=somSelf->_get_somtEntryStruct()->data;
+	while (e)
+	{
+    RHBinterface *m=e->is_interface();
+    if (m) 
+    {
+      
+/*
+      if (_cons)
+      {
+        SOMFree(_cons->_get_somtEntryStruct());
+        delete _cons;
+      }
+      _cons=new SOMTConstEntryC();
+      Entry *es=(Entry *)SOMMalloc(sizeof(Entry));
+      es->name=m->id;
+      es->type=SOMTConstE;
+      es->data=m;
+      es->filestem=somSelf->_get_somtEntryStruct()->filestem;
+      _cons->somtSetEntryStruct(es);
+      return _cons;*/
+    }
+		e=e->next();
+	}
+  return NULL;
+}
+
+SOM_Scope long SOMLINK _get_somtOverrideMethodCount(SOMTClassEntryC * somSelf)
+{
+  SOMTClassEntryCData *somThis = SOMTClassEntryCGetData(somSelf);
+  SOMTClassEntryCMethodDebug("SOMTClassEntryC","_get_somtOverrideMethodCount");
+  
+  return 0;
+}
+
+SOM_Scope SOMTMethodEntryC * SOMLINK somtGetFirstMethod(SOMTClassEntryC * somSelf)
+{
+  SOMTClassEntryCData *somThis = SOMTClassEntryCGetData(somSelf);
+  SOMTClassEntryCMethodDebug("SOMTClassEntryC","somtGetFirstMethod");
+  
+  return NULL;
+}
+
+SOM_Scope SOMTEntryC * SOMLINK somtGetNextPubdef(SOMTClassEntryC * somSelf)
+{
+  SOMTClassEntryCData *somThis = SOMTClassEntryCGetData(somSelf);
+  SOMTClassEntryCMethodDebug("SOMTClassEntryC","somtGetNextPubdef");
+  
+  return NULL;
+}
+
+SOM_Scope SOMTMethodEntryC * SOMLINK somtGetNextInheritedMethod(SOMTClassEntryC * somSelf)
+{
+  SOMTClassEntryCData *somThis = SOMTClassEntryCGetData(somSelf);
+  SOMTClassEntryCMethodDebug("SOMTClassEntryC","somtGetNextInheritedMethod");
+  
+  return NULL;
+}
+
+SOM_Scope boolean SOMLINK somtFilterPrivOrPub(SOMTClassEntryC * somSelf,
+                                              /* in */ SOMTCommonEntryC * entry)
+{
+  SOMTClassEntryCData *somThis = SOMTClassEntryCGetData(somSelf);
+  SOMTClassEntryCMethodDebug("SOMTClassEntryC","somtFilterPrivOrPub");
+  
+  return FALSE;
+}
+
+SOM_Scope SOMTUnionEntryC * SOMLINK somtGetFirstUnion(SOMTClassEntryC * somSelf)
+{
+  SOMTClassEntryCData *somThis = SOMTClassEntryCGetData(somSelf);
+  SOMTClassEntryCMethodDebug("SOMTClassEntryC","somtGetFirstUnion");
+  
+  return NULL;
+}
+
+SOM_Scope SOMTSequenceEntryC * SOMLINK somtGetNextSequence(SOMTClassEntryC * somSelf)
+{
+  SOMTClassEntryCData *somThis = SOMTClassEntryCGetData(somSelf);
+  SOMTClassEntryCMethodDebug("SOMTClassEntryC","somtGetNextSequence");
+  
+  return NULL;
+}
+
+SOM_Scope long SOMLINK somtGetReleaseNameList(SOMTClassEntryC * somSelf,
+                                              /* in */ string buffer)
+{
+  SOMTClassEntryCData *somThis = SOMTClassEntryCGetData(somSelf);
+  SOMTClassEntryCMethodDebug("SOMTClassEntryC","somtGetReleaseNameList");
+  
+  return 0;
+}
+
+SOM_Scope long SOMLINK _get_somtBaseCount(SOMTClassEntryC * somSelf)
+{
+  SOMTClassEntryCData *somThis = SOMTClassEntryCGetData(somSelf);
+  SOMTClassEntryCMethodDebug("SOMTClassEntryC","_get_somtBaseCount");
+  
+  return 0;
+}
+
+SOM_Scope boolean SOMLINK somtFilterNew(SOMTClassEntryC * somSelf,
+                                        /* in */ SOMTMethodEntryC * entry)
+{
+  SOMTClassEntryCData *somThis = SOMTClassEntryCGetData(somSelf);
+  SOMTClassEntryCMethodDebug("SOMTClassEntryC","somtFilterNew");
+  
+  return FALSE;
+}
+
+SOM_Scope string SOMLINK _get_somtIDLScopedName(SOMTClassEntryC * somSelf)
+{
+  SOMTClassEntryCData *somThis = SOMTClassEntryCGetData(somSelf);
+  SOMTClassEntryCMethodDebug("SOMTClassEntryC","_get_somtIDLScopedName");
+  
+  return SOMTClassEntryC_parent_SOMTEntryC__get_somtIDLScopedName(somSelf);
+}
+
+SOM_Scope long SOMLINK _get_somtPublicDataCount(SOMTClassEntryC * somSelf)
+{
+  SOMTClassEntryCData *somThis = SOMTClassEntryCGetData(somSelf);
+  SOMTClassEntryCMethodDebug("SOMTClassEntryC","_get_somtPublicDataCount");
+
+  return 0;
+}
+
+SOM_Scope string SOMLINK _get_somtSourceFileName(SOMTClassEntryC * somSelf)
+{
+  SOMTClassEntryCData *somThis = SOMTClassEntryCGetData(somSelf);
+  SOMTClassEntryCMethodDebug("SOMTClassEntryC","_get_somtSourceFileName");
+  
+  //Entry *es=SOMTClassEntryC_parent_SOMTEntryC__get_somtEntryStruct(somSelf);
+  //Entry *es=SOMTClassEntryC_parent_SOMTEntryC__get_somtEntryStruct(somSelf);
+  Entry *es=somSelf->_get_somtEntryStruct();
+  
+  return es->data->defined_in->id;
+}
+
+SOM_Scope long SOMLINK _get_somtProcMethodCount(SOMTClassEntryC * somSelf)
+{
+  SOMTClassEntryCData *somThis = SOMTClassEntryCGetData(somSelf);
+  SOMTClassEntryCMethodDebug("SOMTClassEntryC","_get_somtProcMethodCount");
+
+  return 0;
+}
+
+SOM_Scope SOMTMethodEntryC * SOMLINK somtGetFirstInheritedMethod(SOMTClassEntryC * somSelf)
+{
+  SOMTClassEntryCData *somThis = SOMTClassEntryCGetData(somSelf);
+  SOMTClassEntryCMethodDebug("SOMTClassEntryC","somtGetFirstInheritedMethod");
+
+  return NULL;
+}
+
+SOM_Scope SOMTEntryC * SOMLINK somtGetFirstPubdef(SOMTClassEntryC * somSelf)
+{
+  SOMTClassEntryCData *somThis = SOMTClassEntryCGetData(somSelf);
+  SOMTClassEntryCMethodDebug("SOMTClassEntryC","somtGetFirstPubdef");
+
+  return NULL;
+}
+
+SOM_Scope SOMTDataEntryC * SOMLINK somtGetFirstStaticData(SOMTClassEntryC * somSelf)
+{
+  SOMTClassEntryCData *somThis = SOMTClassEntryCGetData(somSelf);
+  SOMTClassEntryCMethodDebug("SOMTClassEntryC","somtGetFirstStaticData");
+
+  return NULL;
+}
+
+SOM_Scope string SOMLINK somtGetFirstReleaseName(SOMTClassEntryC * somSelf)
+{
+  SOMTClassEntryCData *somThis = SOMTClassEntryCGetData(somSelf);
+  SOMTClassEntryCMethodDebug("SOMTClassEntryC","somtGetFirstReleaseName");
+
+  return NULL;
+}
+
+SOM_Scope string SOMLINK somtGetNextReleaseName(SOMTClassEntryC * somSelf)
+{
+  SOMTClassEntryCData *somThis = SOMTClassEntryCGetData(somSelf);
+  SOMTClassEntryCMethodDebug("SOMTClassEntryC","somtGetNextReleaseName");
+
+  return NULL;
+}
+
+SOM_Scope long SOMLINK _get_somtExternalDataCount(SOMTClassEntryC * somSelf)
+{
+  SOMTClassEntryCData *somThis = SOMTClassEntryCGetData(somSelf);
+  SOMTClassEntryCMethodDebug("SOMTClassEntryC","_get_somtExternalDataCount");
+
+  return 0;
+}
+
+
+SOM_Scope void SOMLINK somDefaultInit(SOMTClassEntryC SOMSTAR somSelf, somInitCtrl *ctrl)
+{
+  SOMTClassEntryCData *somThis; // set by BeginInitializer 
+  somInitCtrl globalCtrl;
+  somBooleanVector myMask;
+  SOMTClassEntryCMethodDebug("SOMTClassEntryC", "somDefaultInit");
+  
+  SOMTClassEntryC_BeginInitializer_somDefaultInit;
+  SOMTClassEntryC_Init_SOMTEntryC_somDefaultInit(somSelf, ctrl);
+
+  _cons=NULL;
+  _attrs=NULL;
+}
diff -urN somfree\some\src\sccommon.cpp newsomfree3\some\src\sccommon.cpp
--- somfree\some\src\sccommon.cpp	Thu Jan 01 07:00:00 1970
+++ newsomfree3\some\src\sccommon.cpp	Sat Mar 16 14:09:26 2024
@@ -0,0 +1,119 @@
+/**************************************************************************
+ *
+ *  Copyright 2015, 2017 Yuri Prokushev
+ *
+ *  This file is part of osFree project
+ *
+ *  This program is free software: you can redistribute it and/or modify it
+ *  under the terms of the GNU Lesser General Public License as published by the
+ *  Free Software Foundation, either version 3 of the License, or (at your
+ *  option) any later version.
+ * 
+ *  This program is distributed in the hope that it will be useful, but WITHOUT
+ *  ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ *  FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for
+ *  more details.
+ *
+ *  You should have received a copy of the GNU Lesser General Public License
+ *  along with this program.  If not, see <http://www.gnu.org/licenses/>
+ *
+ */
+
+#ifndef SOM_Module_sccommon_Source
+#define SOM_Module_sccommon_Source
+#endif
+
+#define SOMTCommonEntryC_Class_Source
+
+#define __PRIVATE__
+#include <rhbopt.h>
+#include <stdio.h>
+#include <string.h>
+#include <stdlib.h>
+#include "rhbsc.h"
+
+#include "sccommon.xih"
+
+SOM_Scope long SOMLINK somtSetSymbolsOnEntry(SOMTCommonEntryC SOMSTAR somSelf,
+	                                           /* in */ SOMTEmitC SOMSTAR emitter,
+	                                           /* in */ string prefix)
+{
+  SOMTCommonEntryCData *somThis = SOMTCommonEntryCGetData(somSelf);
+  SOMTCommonEntryCMethodDebug("SOMTCommonEntryC","somtSetSymbolsOnEntry");
+
+  return 0;
+}
+
+SOM_Scope string SOMLINK _get_somtArrayDimsString(SOMTCommonEntryC SOMSTAR somSelf)
+{
+  SOMTCommonEntryCData *somThis = SOMTCommonEntryCGetData(somSelf);
+  SOMTCommonEntryCMethodDebug("SOMTCommonEntryC","_get_somtArrayDimsString");
+
+  return NULL;
+}
+
+SOM_Scope SOMTEntryC SOMSTAR SOMLINK _get_somtTypeObj(SOMTCommonEntryC SOMSTAR somSelf)
+{
+  SOMTCommonEntryCData *somThis = SOMTCommonEntryCGetData(somSelf);
+  SOMTCommonEntryCMethodDebug("SOMTCommonEntryC","_get_somtTypeObj");
+
+  return NULL;
+}
+
+SOM_Scope somtVisibilityT SOMLINK _get_somtVisibility(SOMTCommonEntryC SOMSTAR somSelf)
+{
+  SOMTCommonEntryCData *somThis = SOMTCommonEntryCGetData(somSelf);
+  SOMTCommonEntryCMethodDebug("SOMTCommonEntryC","_get_somtVisibility");
+
+  return (somtVisibilityT)NULL;
+}
+
+SOM_Scope unsigned long SOMLINK somtGetFirstArrayDimension(SOMTCommonEntryC SOMSTAR somSelf)
+{
+  SOMTCommonEntryCData *somThis = SOMTCommonEntryCGetData(somSelf);
+  SOMTCommonEntryCMethodDebug("SOMTCommonEntryC","somtGetFirstArrayDimension");
+
+  return 0;
+}
+
+SOM_Scope string SOMLINK _get_somtType(SOMTCommonEntryC SOMSTAR somSelf)
+{
+  SOMTCommonEntryCData *somThis = SOMTCommonEntryCGetData(somSelf);
+  SOMTCommonEntryCMethodDebug("SOMTCommonEntryC","_get_somtType");
+
+  return NULL;
+}
+
+SOM_Scope string SOMLINK _get_somtPtrs(SOMTCommonEntryC SOMSTAR somSelf)
+{
+  SOMTCommonEntryCData *somThis = SOMTCommonEntryCGetData(somSelf);
+  SOMTCommonEntryCMethodDebug("SOMTCommonEntryC","_get_somtPtrs");
+
+  return NULL;
+}
+
+SOM_Scope boolean SOMLINK somtIsPointer(SOMTCommonEntryC SOMSTAR somSelf)
+{
+  SOMTCommonEntryCData *somThis = SOMTCommonEntryCGetData(somSelf);
+  SOMTCommonEntryCMethodDebug("SOMTCommonEntryC","somtIsPointer");
+
+  return FALSE;
+}
+
+SOM_Scope unsigned long SOMLINK somtGetNextArrayDimension(SOMTCommonEntryC SOMSTAR somSelf)
+{
+  SOMTCommonEntryCData *somThis = SOMTCommonEntryCGetData(somSelf);
+  SOMTCommonEntryCMethodDebug("SOMTCommonEntryC","somtGetNextArrayDimension");
+
+  return 0;
+}
+
+SOM_Scope boolean SOMLINK somtIsArray(SOMTCommonEntryC SOMSTAR somSelf,
+	                                    /* out */ long *size)
+{
+  SOMTCommonEntryCData *somThis = SOMTCommonEntryCGetData(somSelf);
+  SOMTCommonEntryCMethodDebug("SOMTCommonEntryC","somtIsArray");
+
+  return FALSE;
+}
+
diff -urN somfree\some\src\scconst.cpp newsomfree3\some\src\scconst.cpp
--- somfree\some\src\scconst.cpp	Thu Jan 01 07:00:00 1970
+++ newsomfree3\some\src\scconst.cpp	Sat Mar 16 14:09:26 2024
@@ -0,0 +1,120 @@
+/**************************************************************************
+ *
+ *  Copyright 2015, 2017 Yuri Prokushev
+ *
+ *  This file is part of osFree project
+ *
+ *  This program is free software: you can redistribute it and/or modify it
+ *  under the terms of the GNU Lesser General Public License as published by the
+ *  Free Software Foundation, either version 3 of the License, or (at your
+ *  option) any later version.
+ * 
+ *  This program is distributed in the hope that it will be useful, but WITHOUT
+ *  ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ *  FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for
+ *  more details.
+ *
+ *  You should have received a copy of the GNU Lesser General Public License
+ *  along with this program.  If not, see <http://www.gnu.org/licenses/>
+ *
+ */
+
+#ifndef SOM_Module_scconst_Source
+#define SOM_Module_scconst_Source
+#endif
+
+#define SOMTConstEntryC_Class_Source
+
+#define __PRIVATE__
+#include <rhbopt.h>
+#include <stdio.h>
+#include <string.h>
+#include <stdlib.h>
+#include "rhbsc.h"
+
+#include "scconst.xih"
+
+SOM_Scope long SOMLINK somtSetSymbolsOnEntry(SOMTConstEntryC SOMSTAR somSelf,
+	                                           /* in */ SOMTEmitC SOMSTAR emitter,
+	                                           /* in */ string prefix)
+{
+  char buf[250];
+  
+  SOMTConstEntryCData *somThis = SOMTConstEntryCGetData(somSelf);
+  SOMTConstEntryCMethodDebug("SOMTConstEntryC","somtSetSymbolsOnEntry");
+
+  SOMTTemplateOutputC *templ = emitter->_get_somtTemplate();
+
+  SOMTConstEntryC_parent_SOMTEntryC_somtSetSymbolsOnEntry(somSelf, emitter, prefix);
+  RHBconstant *c=somSelf->_get_somtEntryStruct()->data->is_constant();
+  
+  buf[0]=0;
+  strcat(buf, prefix);
+  templ->somtSetSymbolCopyBoth(strcat(buf, "Type"), c->constant_type->id);
+  
+  buf[0]=0;
+  strcat(buf, prefix);
+  if (!(c->value_string))
+  {
+    templ->somtSetSymbolCopyBoth(strcat(buf, "ValueEvaluated"), c->const_val->value_string);
+  } else {
+    templ->somtSetSymbolCopyBoth(strcat(buf, "ValueEvaluated"), c->value_string);
+  }
+  return 1;
+}
+
+SOM_Scope boolean SOMLINK _get_somtConstIsNegative(SOMTConstEntryC SOMSTAR somSelf)
+{
+  SOMTConstEntryCData *somThis = SOMTConstEntryCGetData(somSelf);
+  SOMTConstEntryCMethodDebug("SOMTConstEntryC","_get_somtConstIsNegative");
+
+  return FALSE;
+}
+
+SOM_Scope unsigned long SOMLINK _get_somtConstNumVal(SOMTConstEntryC SOMSTAR somSelf)
+{
+  SOMTConstEntryCData *somThis = SOMTConstEntryCGetData(somSelf);
+  SOMTConstEntryCMethodDebug("SOMTConstEntryC","_get_somtConstNumVal");
+
+  return 0;
+}
+
+SOM_Scope SOMTEntryC SOMSTAR SOMLINK _get_somtConstTypeObj(SOMTConstEntryC SOMSTAR somSelf)
+{
+  SOMTConstEntryCData *somThis = SOMTConstEntryCGetData(somSelf);
+  SOMTConstEntryCMethodDebug("SOMTConstEntryC","_get_somtConstTypeObj");
+
+  return FALSE;
+}
+
+SOM_Scope string SOMLINK _get_somtConstStringVal(SOMTConstEntryC SOMSTAR somSelf)
+{
+  SOMTConstEntryCData *somThis = SOMTConstEntryCGetData(somSelf);
+  SOMTConstEntryCMethodDebug("SOMTConstEntryC","_get_somtConstStringVal");
+
+  return NULL;
+}
+
+SOM_Scope long SOMLINK _get_somtConstNumNegVal(SOMTConstEntryC SOMSTAR somSelf)
+{
+  SOMTConstEntryCData *somThis = SOMTConstEntryCGetData(somSelf);
+  SOMTConstEntryCMethodDebug("SOMTConstEntryC","_get_somtConstNumNegVal");
+
+  return 0;
+}
+
+SOM_Scope string SOMLINK _get_somtConstVal(SOMTConstEntryC SOMSTAR somSelf)
+{
+  SOMTConstEntryCData *somThis = SOMTConstEntryCGetData(somSelf);
+  SOMTConstEntryCMethodDebug("SOMTConstEntryC","_get_somtConstVal");
+
+  return NULL;
+}
+
+SOM_Scope string SOMLINK _get_somtConstType(SOMTConstEntryC SOMSTAR somSelf)
+{
+  SOMTConstEntryCData *somThis = SOMTConstEntryCGetData(somSelf);
+  SOMTConstEntryCMethodDebug("SOMTConstEntryC","_get_somtConstType");
+
+  return NULL;
+}
diff -urN somfree\some\src\scdata.cpp newsomfree3\some\src\scdata.cpp
--- somfree\some\src\scdata.cpp	Thu Jan 01 07:00:00 1970
+++ newsomfree3\some\src\scdata.cpp	Sat Mar 16 14:09:26 2024
@@ -0,0 +1,53 @@
+/**************************************************************************
+ *
+ *  Copyright 2015, 2017 Yuri Prokushev
+ *
+ *  This file is part of osFree project
+ *
+ *  This program is free software: you can redistribute it and/or modify it
+ *  under the terms of the GNU Lesser General Public License as published by the
+ *  Free Software Foundation, either version 3 of the License, or (at your
+ *  option) any later version.
+ * 
+ *  This program is distributed in the hope that it will be useful, but WITHOUT
+ *  ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ *  FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for
+ *  more details.
+ *
+ *  You should have received a copy of the GNU Lesser General Public License
+ *  along with this program.  If not, see <http://www.gnu.org/licenses/>
+ *
+ */
+
+#ifndef SOM_Module_scdata_Source
+#define SOM_Module_scdata_Source
+#endif
+
+#define SOMTDataEntryC_Class_Source
+
+#define __PRIVATE__
+#include <rhbopt.h>
+#include <stdio.h>
+#include <string.h>
+#include <stdlib.h>
+#include "rhbsc.h"
+
+#include "scdata.xih"
+
+SOM_Scope long SOMLINK somtSetSymbolsOnEntry(SOMTDataEntryC SOMSTAR somSelf,
+	                                           /* in */ SOMTEmitC SOMSTAR emitter,
+	                                           /* in */ string prefix)
+{
+  SOMTDataEntryCData *somThis = SOMTDataEntryCGetData(somSelf);
+  SOMTDataEntryCMethodDebug("SOMTDataEntryC","somtSetSymbolsOnEntry");
+
+  return 0;
+}
+
+SOM_Scope boolean SOMLINK _get_somtIsSelfRef(SOMTDataEntryC SOMSTAR somSelf)
+{
+  SOMTDataEntryCData *somThis = SOMTDataEntryCGetData(somSelf);
+  SOMTDataEntryCMethodDebug("SOMTDataEntryC","_get_somtIsSelfRef");
+
+  return FALSE;
+}
diff -urN somfree\some\src\scemit.cpp newsomfree3\some\src\scemit.cpp
--- somfree\some\src\scemit.cpp	Thu Jan 01 07:00:00 1970
+++ newsomfree3\some\src\scemit.cpp	Sat Mar 16 14:09:26 2024
@@ -0,0 +1,1102 @@
+/**************************************************************************
+ *
+ *  Copyright 2015, 2017 Yuri Prokushev
+ *
+ *  This file is part of osFree project
+ *
+ *  This program is free software: you can redistribute it and/or modify it
+ *  under the terms of the GNU Lesser General Public License as published by the
+ *  Free Software Foundation, either version 3 of the License, or (at your
+ *  option) any later version.
+ * 
+ *  This program is distributed in the hope that it will be useful, but WITHOUT
+ *  ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ *  FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for
+ *  more details.
+ *
+ *  You should have received a copy of the GNU Lesser General Public License
+ *  along with this program.  If not, see <http://www.gnu.org/licenses/>
+ *
+ */
+
+#ifndef SOM_Module_scemit_Source
+#define SOM_Module_scemit_Source
+#endif
+
+#define SOMTEmitC_Class_Source
+
+#include <time.h>
+
+#include "scemit.xih"
+#include "scconst.xh"
+#include "scattrib.xh"
+#include "scbase.xh"
+#include "scmethod.xh"
+#include "scclass.xh"
+
+typedef void (SOMLINK * somtEmitProc)(SOMTEmitC SOMSTAR somSelf);
+typedef void (SOMLINK * somtEmitProcEach)(SOMTEmitC SOMSTAR somSelf, SOMTEntryC SOMSTAR base);
+
+SOM_Scope boolean SOMLINK somtGenerateSections(SOMTEmitC SOMSTAR somSelf)
+{
+  SOMTEmitCData *somThis = SOMTEmitCGetData(somSelf); 
+  SOMTClassEntryC *cls = _somtTargetClass;
+  SOMTEmitCMethodDebug("SOMTEmitC","somtGenerateSections");
+  
+  somSelf->somtFileSymbols();
+  
+  somSelf->somtEmitProlog();
+  
+  if (cls != (SOMTClassEntryC *) NULL) 
+  {
+    somSelf->somtScanBaseIncludes("somtEmitBaseIncludesProlog",
+                                  "somtEmitBaseIncludes",
+                                  "somtEmitBaseIncludesEpilog");
+                                   
+    somSelf->somtEmitMetaInclude();
+    
+    somSelf->somtEmitClass();
+    
+    somSelf->somtScanBases("somtEmitBaseProlog",
+                           "somtEmitBase",
+                           "somtEmitBaseEpilog");
+  
+    somSelf->somtEmitMeta();
+  }
+  
+  somSelf->somtScanConstants("somtEmitConstantProlog",
+                             "somtEmitConstant",
+                             "somtEmitConstantEpilog");
+
+  somSelf->somtScanTypedefs("somtEmitTypedefProlog",
+                            "somtEmitTypedef",
+                            "somtEmitTypedefEpilog");
+
+  somSelf->somtScanStructs("somtEmitStructProlog",
+                           "somtEmitStruct",
+                           "somtEmitStructEpilog");
+
+  somSelf->somtScanUnions("somtEmitUnionProlog",
+                          "somtEmitUnion",
+                          "somtEmitUnionEpilog");
+
+  somSelf->somtScanEnums("somtEmitEnumProlog",
+                         "somtEmitEnum",
+                         "somtEmitEnumEpilog");
+
+  if (cls != (SOMTClassEntryC *) NULL) 
+  {
+    somSelf->somtScanAttributes("somtEmitAttributeProlog",
+                                "somtEmitAttribute",
+                                "somtEmitAttributeEpilog");
+
+    somSelf->somtScanMethods(NULL,
+                             "somtEmitMethodsProlog",
+                             "somtEmitMethods",
+                             "somtEmitMethodsEpilog",
+                             TRUE);
+                            
+    somSelf->somtEmitRelease();
+  
+    somSelf->somtScanPassthru(TRUE,
+                              "somtEmitPassthruProlog",
+                              "somtEmitPassthru",
+                              "somtEmitPassthruEpilog");
+
+    somSelf->somtScanPassthru(FALSE,
+                              "somtEmitPassthruProlog",
+                              "somtEmitPassthru",
+                              "somtEmitPassthruEpilog");
+
+    somSelf->somtScanData("somtEmitDataProlog",
+                          "somtEmitData",
+                          "somtEmitDataEpilog");
+  }
+  
+  if (_somtTargetModule != (SOMTModuleEntryC *) NULL) 
+  {
+    somSelf->somtScanInterfaces("somtEmitInterfaceProlog",
+                                "somtEmitInterface", 
+                                "somtEmitInterfaceEpilog");
+
+    somSelf->somtScanModules("somtEmitModuleProlog",
+                             "somtEmitModule", 
+                             "somtEmitModuleEpilog");
+  }
+
+  somSelf->somtEmitEpilog();
+
+  return TRUE;
+}
+
+  /*
+For emitters having a target module:
+somtEmitProlog
+somtGenerateSections Method
+somtEmitConstantProlog
+somtEmitConstant (for each constant)
+somtEmitConstantEpilog
+somtEmitTypedefProlog
+somtEmitTypedef (for each typedef)
+somtEmitTypedefEpilog
+somtEmitStructProlog
+somtEmitStruct (for each struct)
+somtEmitStructEpilog
+somtEmitUnionProlog
+somtEmitUnion (for each union)
+somtEmitUnionEpilog
+somtEmitEnumProlog
+somtEmitEnum (for each enum)
+somtEmitEnumEpilog
+somtEmitInterfaceProlog
+somtEmitInterface (for each interface)
+somtEmitInterfaceEpilog
+somtEmitModuleProlog
+somtEmitModule (for each embedded module)
+somtEmitModuleEpilog
+somtEmitEpilog
+
+Repeating sections (such as somtEmitBase) are emitted using the corresponding
+somtScan<Section> Methods.
+To rearrange the order of sections, or to add or delete sections in your emitter, override the
+somtGenerateSections method.
+*/
+
+SOM_Scope FILE *SOMLINK somtOpenSymbolsFile(SOMTEmitC SOMSTAR somSelf,
+	                                                 /* in */ string fileName,
+	                                                 /* in */ string mode)
+{
+  SOMTEmitCData *somThis = SOMTEmitCGetData(somSelf); 
+  SOMTEmitCMethodDebug("SOMTEmitC","somtOpenSymbolsFile");
+  
+  return fopen(fileName, mode);
+}
+
+SOM_Scope string SOMLINK somtGetGlobalModifierValue(SOMTEmitC SOMSTAR somSelf,
+	                                                         /* in */ string modifierName)
+{
+  SOMTEmitCData *somThis = SOMTEmitCGetData(somSelf); 
+  SOMTEmitCMethodDebug("SOMTEmitC","somtGetGlobalModifierValue");
+  
+  return NULL;
+}
+
+SOM_Scope void SOMLINK somtFileSymbols(SOMTEmitC SOMSTAR somSelf)
+{
+  SOMTEmitCData *somThis = SOMTEmitCGetData(somSelf); 
+  time_t     now = time(0);
+  struct tm  tstruct;
+  char       buf[80];
+  SOMTClassEntryC *cls = _somtTargetClass;
+  SOMTTemplateOutputC *templ = _somtTemplate;
+  SOMTEmitCMethodDebug("SOMTEmitC","somtFileSymbols");
+
+  tstruct = *localtime(&now);
+  strftime(buf, sizeof(buf), "%Y-%m-%d %X", &tstruct);
+    
+  templ->somtSetSymbolCopyBoth("timeStamp", buf);
+  
+  if (cls != (SOMTClassEntryC *) NULL) 
+  {
+    cls->somtSetSymbolsOnEntry(somSelf, "class");
+  }
+}
+
+SOM_Scope void SOMLINK somtEmitProlog(SOMTEmitC SOMSTAR somSelf)
+{
+  SOMTEmitCData *somThis = SOMTEmitCGetData(somSelf);
+  SOMTEmitCMethodDebug("SOMTEmitC","somtEmitProlog");
+  //somPrintf(_somtTemplate->somtGetSymbol("prologSN"));
+  _somtTemplate->somtOutputSection(_somtTemplate->somtGetSymbol("prologSN"));
+}
+
+SOM_Scope void SOMLINK somtEmitClass(SOMTEmitC SOMSTAR somSelf)
+{
+  SOMTEmitCData *somThis = SOMTEmitCGetData(somSelf);
+  SOMTEmitCMethodDebug("SOMTEmitC","somtEmitClass");
+  
+  _somtTemplate->somtOutputSection(_somtTemplate->somtGetSymbol("classSN"));
+}
+
+SOM_Scope void SOMLINK somtEmitModule(SOMTEmitC SOMSTAR somSelf,
+	                                           /* in */ SOMTModuleEntryC SOMSTAR mod)
+{
+  SOMTEmitCData *somThis = SOMTEmitCGetData(somSelf); 
+  SOMTEmitCMethodDebug("SOMTEmitC","somtEmitModule");
+  
+  return;
+}
+
+SOM_Scope void SOMLINK somtEmitPassthruProlog(SOMTEmitC SOMSTAR somSelf)
+{
+  SOMTEmitCData *somThis = SOMTEmitCGetData(somSelf);
+  SOMTEmitCMethodDebug("SOMTEmitC","somtEmitPassthruProlog");
+  
+  _somtTemplate->somtOutputSection(_somtTemplate->somtGetSymbol("passthruPrologSN"));
+}
+
+SOM_Scope void SOMLINK somtEmitConstantEpilog(SOMTEmitC SOMSTAR somSelf)
+{
+  SOMTEmitCData *somThis = SOMTEmitCGetData(somSelf);
+  SOMTEmitCMethodDebug("SOMTEmitC","somtEmitConstantEpilog");
+  
+  _somtTemplate->somtOutputSection(_somtTemplate->somtGetSymbol("constantEpilogSN"));
+}
+
+SOM_Scope void SOMLINK somtEmitModuleEpilog(SOMTEmitC SOMSTAR somSelf)
+{
+  SOMTEmitCData *somThis = SOMTEmitCGetData(somSelf); 
+  SOMTEmitCMethodDebug("SOMTEmitC","somtEmitModuleEpilog");
+  
+  return;
+}
+
+SOM_Scope void SOMLINK somtEmitData(SOMTEmitC SOMSTAR somSelf,
+	                                         /* in */ SOMTDataEntryC SOMSTAR entry)
+{
+  SOMTEmitCData *somThis = SOMTEmitCGetData(somSelf);
+  SOMTEmitCMethodDebug("SOMTEmitC","somtEmitData");
+  
+  _somtTemplate->somtOutputSection(_somtTemplate->somtGetSymbol("dataSN"));
+}
+
+SOM_Scope void SOMLINK somtEmitInterface(SOMTEmitC SOMSTAR somSelf,
+	                                              /* in */ SOMTClassEntryC SOMSTAR intfc)
+{
+  SOMTEmitCData *somThis = SOMTEmitCGetData(somSelf); 
+  SOMTEmitCMethodDebug("SOMTEmitC","somtEmitInterface");
+  
+  return;
+}
+
+SOM_Scope void SOMLINK somtEmitTypedefEpilog(SOMTEmitC SOMSTAR somSelf)
+{
+  SOMTEmitCData *somThis = SOMTEmitCGetData(somSelf);
+  SOMTEmitCMethodDebug("SOMTEmitC","somtEmitTypedefEpilog");
+  
+  _somtTemplate->somtOutputSection(_somtTemplate->somtGetSymbol("typedefEpilogSN"));
+}
+
+SOM_Scope void SOMLINK somtEmitMethod(SOMTEmitC SOMSTAR somSelf,
+	                                           /* in */ SOMTMethodEntryC SOMSTAR entry)
+{
+  SOMTEmitCData *somThis = SOMTEmitCGetData(somSelf);
+  SOMTEmitCMethodDebug("SOMTEmitC","somtEmitMethod");
+  
+  entry->somtSetSymbolsOnEntry(somSelf, "method");
+  _somtTemplate->somtOutputSection(_somtTemplate->somtGetSymbol("methodSN"));
+}
+
+SOM_Scope void SOMLINK somtEmitAttribute(SOMTEmitC SOMSTAR somSelf,
+	                                              /* in */ SOMTAttributeEntryC SOMSTAR att)
+{
+  SOMTEmitCData *somThis = SOMTEmitCGetData(somSelf);
+  SOMTEmitCMethodDebug("SOMTEmitC","somtEmitAttribute");
+
+  att->somtSetSymbolsOnEntry(somSelf, "attribute");
+  _somtTemplate->somtOutputSection(_somtTemplate->somtGetSymbol("attributeSN"));
+}
+
+SOM_Scope void SOMLINK somtEmitEnumProlog(SOMTEmitC SOMSTAR somSelf)
+{
+  SOMTEmitCData *somThis = SOMTEmitCGetData(somSelf);
+  SOMTEmitCMethodDebug("SOMTEmitC","somtEmitEnumProlog");
+  
+  _somtTemplate->somtOutputSection(_somtTemplate->somtGetSymbol("enumPrologSN"));
+}
+
+SOM_Scope void SOMLINK somtEmitAttributeProlog(SOMTEmitC SOMSTAR somSelf)
+{
+  SOMTEmitCData *somThis = SOMTEmitCGetData(somSelf);
+  SOMTEmitCMethodDebug("SOMTEmitC","somtEmitAttributeProlog");
+  
+  _somtTemplate->somtOutputSection(_somtTemplate->somtGetSymbol("attributePrologSN"));
+}
+
+SOM_Scope void SOMLINK somtEmitBaseIncludesProlog(SOMTEmitC SOMSTAR somSelf)
+{
+  SOMTEmitCData *somThis = SOMTEmitCGetData(somSelf);
+  SOMTEmitCMethodDebug("SOMTEmitC","somtEmitBaseIncludesProlog");
+  
+  _somtTemplate->somtOutputSection(_somtTemplate->somtGetSymbol("baseIncludesPrologSN"));
+}
+
+SOM_Scope void SOMLINK somtEmitStructProlog(SOMTEmitC SOMSTAR somSelf)
+{
+  SOMTEmitCData *somThis = SOMTEmitCGetData(somSelf);
+  SOMTEmitCMethodDebug("SOMTEmitC","somtEmitStructProlog");
+  
+  _somtTemplate->somtOutputSection(_somtTemplate->somtGetSymbol("structPrologSN"));
+}
+
+SOM_Scope void SOMLINK somtEmitUnionProlog(SOMTEmitC SOMSTAR somSelf)
+{
+  SOMTEmitCData *somThis = SOMTEmitCGetData(somSelf);
+  SOMTEmitCMethodDebug("SOMTEmitC","somtEmitUnionProlog");
+  
+  _somtTemplate->somtOutputSection(_somtTemplate->somtGetSymbol("unionPrologSN"));
+}
+
+SOM_Scope void SOMLINK somtEmitDataEpilog(SOMTEmitC SOMSTAR somSelf)
+{
+  SOMTEmitCData *somThis = SOMTEmitCGetData(somSelf);
+  SOMTEmitCMethodDebug("SOMTEmitC","somtEmitDataEpilog");
+  
+  _somtTemplate->somtOutputSection(_somtTemplate->somtGetSymbol("dataEpilogSN"));
+}
+
+SOM_Scope void SOMLINK somtEmitPassthruEpilog(SOMTEmitC SOMSTAR somSelf)
+{
+  SOMTEmitCData *somThis = SOMTEmitCGetData(somSelf);
+  SOMTEmitCMethodDebug("SOMTEmitC","somtEmitPassthruEpilog");
+  
+  _somtTemplate->somtOutputSection(_somtTemplate->somtGetSymbol("passthruEpilogSN"));
+}
+
+SOM_Scope void SOMLINK somtEmitEpilog(SOMTEmitC SOMSTAR somSelf)
+{
+  SOMTEmitCData *somThis = SOMTEmitCGetData(somSelf);
+  SOMTEmitCMethodDebug("SOMTEmitC","somtEmitEpilog");
+  
+
+  _somtTemplate->somtOutputSection(_somtTemplate->somtGetSymbol("epilogSN"));
+
+}
+
+SOM_Scope void SOMLINK somtEmitEnum(SOMTEmitC SOMSTAR somSelf,
+	                                         /* in */ SOMTEnumEntryC SOMSTAR en)
+{
+  SOMTEmitCData *somThis = SOMTEmitCGetData(somSelf);
+  SOMTEmitCMethodDebug("SOMTEmitC","somtEmitEnum");
+  
+  _somtTemplate->somtOutputSection(_somtTemplate->somtGetSymbol("enumSN"));
+}
+
+SOM_Scope void SOMLINK somtEmitBaseIncludes(SOMTEmitC SOMSTAR somSelf,
+	                                                 /* in */ SOMTBaseClassEntryC SOMSTAR base)
+{
+  SOMTEmitCData *somThis = SOMTEmitCGetData(somSelf);
+  SOMTEmitCMethodDebug("SOMTEmitC","somtEmitBaseIncludes");
+
+  base->somtSetSymbolsOnEntry(somSelf, "base");
+  _somtTemplate->somtOutputSection(_somtTemplate->somtGetSymbol("baseIncludesSN"));
+}
+
+SOM_Scope void SOMLINK somtEmitAttributeEpilog(SOMTEmitC SOMSTAR somSelf)
+{
+  SOMTEmitCData *somThis = SOMTEmitCGetData(somSelf);
+  SOMTEmitCMethodDebug("SOMTEmitC","somtEmitAttributeEpilog");
+  
+  _somtTemplate->somtOutputSection(_somtTemplate->somtGetSymbol("attributeEpilogSN"));
+}
+
+SOM_Scope void SOMLINK somtEmitBaseEpilog(SOMTEmitC SOMSTAR somSelf)
+{
+  SOMTEmitCData *somThis = SOMTEmitCGetData(somSelf);
+  SOMTEmitCMethodDebug("SOMTEmitC","somtEmitBaseEpilog");
+  
+  _somtTemplate->somtOutputSection(_somtTemplate->somtGetSymbol("baseEpilogSN"));
+}
+
+SOM_Scope void SOMLINK somtEmitModuleProlog(SOMTEmitC SOMSTAR somSelf)
+{
+  SOMTEmitCData *somThis = SOMTEmitCGetData(somSelf); 
+  SOMTEmitCMethodDebug("SOMTEmitC","somtEmitModuleProlog");
+  
+  return;
+}
+
+SOM_Scope void SOMLINK somtEmitStruct(SOMTEmitC SOMSTAR somSelf,
+	                                           /* in */ SOMTStructEntryC SOMSTAR struc)
+{
+  SOMTEmitCData *somThis = SOMTEmitCGetData(somSelf);
+  SOMTEmitCMethodDebug("SOMTEmitC","somtEmitStruct");
+  
+  _somtTemplate->somtOutputSection(_somtTemplate->somtGetSymbol("structSN"));
+}
+
+SOM_Scope void SOMLINK somtEmitConstant(SOMTEmitC SOMSTAR somSelf,
+	                                             /* in */ SOMTConstEntryC SOMSTAR con)
+{
+  SOMTEmitCData *somThis = SOMTEmitCGetData(somSelf);
+  SOMTEmitCMethodDebug("SOMTEmitC","somtEmitConstant");
+
+  con->somtSetSymbolsOnEntry(somSelf, "constant");
+  _somtTemplate->somtOutputSection(_somtTemplate->somtGetSymbol("constantSN"));
+}                                               
+
+SOM_Scope void SOMLINK somtEmitConstantProlog(SOMTEmitC SOMSTAR somSelf)
+{
+  SOMTEmitCData *somThis = SOMTEmitCGetData(somSelf);
+  SOMTEmitCMethodDebug("SOMTEmitC","somtEmitConstantProlog");
+  
+  _somtTemplate->somtOutputSection(_somtTemplate->somtGetSymbol("constantPrologSN"));
+}
+
+SOM_Scope void SOMLINK somtEmitInterfaceProlog(SOMTEmitC SOMSTAR somSelf)
+{
+  SOMTEmitCData *somThis = SOMTEmitCGetData(somSelf); 
+  SOMTEmitCMethodDebug("SOMTEmitC","somtEmitInterfaceProlog");
+  
+  return;
+}
+
+SOM_Scope void SOMLINK somtEmitDataProlog(SOMTEmitC SOMSTAR somSelf)
+{
+  SOMTEmitCData *somThis = SOMTEmitCGetData(somSelf);
+  SOMTEmitCMethodDebug("SOMTEmitC","somtEmitDataProlog");
+  
+  _somtTemplate->somtOutputSection(_somtTemplate->somtGetSymbol("dataPrologSN"));
+}
+
+SOM_Scope void SOMLINK somtEmitPassthru(SOMTEmitC SOMSTAR somSelf,
+	                                             /* in */ SOMTPassthruEntryC SOMSTAR entry)
+{
+  SOMTEmitCData *somThis = SOMTEmitCGetData(somSelf);
+  SOMTEmitCMethodDebug("SOMTEmitC","somtEmitPassthru");
+  
+  _somtTemplate->somtOutputSection(_somtTemplate->somtGetSymbol("passthruSN"));
+}
+
+SOM_Scope void SOMLINK somtEmitUnion(SOMTEmitC SOMSTAR somSelf,
+	                                          /* in */ SOMTUnionEntryC SOMSTAR un)
+{
+  SOMTEmitCData *somThis = SOMTEmitCGetData(somSelf);
+  SOMTEmitCMethodDebug("SOMTEmitC","somtEmitUnion");
+  
+  _somtTemplate->somtOutputSection(_somtTemplate->somtGetSymbol("unionSN"));
+}
+
+SOM_Scope void SOMLINK somtEmitMeta(SOMTEmitC SOMSTAR somSelf)
+{
+  SOMTEmitCData *somThis = SOMTEmitCGetData(somSelf);
+  SOMTEmitCMethodDebug("SOMTEmitC","somtEmitMeta");
+  
+  _somtTemplate->somtOutputSection(_somtTemplate->somtGetSymbol("metaSN"));
+}
+
+SOM_Scope void SOMLINK somtEmitTypedefProlog(SOMTEmitC SOMSTAR somSelf)
+{
+  SOMTEmitCData *somThis = SOMTEmitCGetData(somSelf);
+  SOMTEmitCMethodDebug("SOMTEmitC","somtEmitTypedefProlog");
+  
+  _somtTemplate->somtOutputSection(_somtTemplate->somtGetSymbol("typedefPrologSN"));
+}
+
+SOM_Scope void SOMLINK somtEmitBaseIncludesEpilog(SOMTEmitC SOMSTAR somSelf)
+{
+  SOMTEmitCData *somThis = SOMTEmitCGetData(somSelf);
+  SOMTEmitCMethodDebug("SOMTEmitC","somtEmitBaseIncludesEpilog");
+  _somtTemplate->somtOutputSection(_somtTemplate->somtGetSymbol("baseIncludesEpilogSN"));
+}
+
+SOM_Scope void SOMLINK somtEmitEnumEpilog(SOMTEmitC SOMSTAR somSelf)
+{
+  SOMTEmitCData *somThis = SOMTEmitCGetData(somSelf);
+  SOMTEmitCMethodDebug("SOMTEmitC","somtEmitEnumEpilog");
+  
+  _somtTemplate->somtOutputSection(_somtTemplate->somtGetSymbol("enumEpilogSN"));
+}
+
+SOM_Scope void SOMLINK somtEmitBaseProlog(SOMTEmitC SOMSTAR somSelf)
+{
+  SOMTEmitCData *somThis = SOMTEmitCGetData(somSelf);
+  SOMTEmitCMethodDebug("SOMTEmitC","somtEmitBaseProlog");
+  
+  _somtTemplate->somtOutputSection(_somtTemplate->somtGetSymbol("basePrologSN"));
+}
+
+SOM_Scope void SOMLINK somtEmitMethodsProlog(SOMTEmitC SOMSTAR somSelf)
+{
+  SOMTEmitCData *somThis = SOMTEmitCGetData(somSelf);
+  SOMTEmitCMethodDebug("SOMTEmitC","somtEmitMethodsProlog");
+  
+  _somtTemplate->somtOutputSection(_somtTemplate->somtGetSymbol("methodsPrologSN"));
+}
+
+SOM_Scope void SOMLINK somtEmitBase(SOMTEmitC SOMSTAR somSelf,
+	                                         /* in */ SOMTBaseClassEntryC SOMSTAR base)
+{
+  SOMTEmitCData *somThis = SOMTEmitCGetData(somSelf);
+  SOMTEmitCMethodDebug("SOMTEmitC","somtEmitBase");
+
+  base->somtSetSymbolsOnEntry(somSelf, "base");
+  _somtTemplate->somtOutputSection(_somtTemplate->somtGetSymbol("baseSN"));
+}
+
+SOM_Scope void SOMLINK somtEmitRelease(SOMTEmitC SOMSTAR somSelf)
+{
+  SOMTEmitCData *somThis = SOMTEmitCGetData(somSelf);
+  SOMTEmitCMethodDebug("SOMTEmitC","somtEmitRelease");
+  
+  _somtTemplate->somtOutputSection(_somtTemplate->somtGetSymbol("releaseSN"));
+}
+
+SOM_Scope void SOMLINK somtEmitMetaInclude(SOMTEmitC SOMSTAR somSelf)
+{
+  SOMTEmitCData *somThis = SOMTEmitCGetData(somSelf);
+  SOMTEmitCMethodDebug("SOMTEmitC","somtEmitMetaInclude");
+  
+  _somtTemplate->somtOutputSection(_somtTemplate->somtGetSymbol("metaIncludeSN"));
+}
+
+SOM_Scope void SOMLINK somtEmitStructEpilog(SOMTEmitC SOMSTAR somSelf)
+{
+  SOMTEmitCData *somThis = SOMTEmitCGetData(somSelf);
+  SOMTEmitCMethodDebug("SOMTEmitC","somtEmitStructEpilog");
+  
+  _somtTemplate->somtOutputSection(_somtTemplate->somtGetSymbol("structEpilogSN"));
+}
+
+SOM_Scope void SOMLINK somtEmitMethods(SOMTEmitC SOMSTAR somSelf,
+	                                            /* in */ SOMTMethodEntryC SOMSTAR method)
+{
+  SOMTEmitCData *somThis = SOMTEmitCGetData(somSelf);
+  SOMTEmitCMethodDebug("SOMTEmitC","somtEmitMethods");
+  
+  _somtTemplate->somtOutputSection(_somtTemplate->somtGetSymbol("methodsSN"));
+}
+
+SOM_Scope void SOMLINK somtEmitUnionEpilog(SOMTEmitC SOMSTAR somSelf)
+{
+  SOMTEmitCData *somThis = SOMTEmitCGetData(somSelf);
+  SOMTEmitCMethodDebug("SOMTEmitC","somtEmitEpilog");
+  
+  _somtTemplate->somtOutputSection(_somtTemplate->somtGetSymbol("unionEpilogSN"));
+}
+
+SOM_Scope void SOMLINK somtEmitInterfaceEpilog(SOMTEmitC SOMSTAR somSelf)
+{
+  SOMTEmitCData *somThis = SOMTEmitCGetData(somSelf); 
+  SOMTEmitCMethodDebug("SOMTEmitC","somtEmitInterfaceEpilog");
+  
+  return;
+}
+
+SOM_Scope void SOMLINK somtEmitMethodsEpilog(SOMTEmitC SOMSTAR somSelf)
+{
+  SOMTEmitCData *somThis = SOMTEmitCGetData(somSelf);
+  SOMTEmitCMethodDebug("SOMTEmitC","somtEmitMethodsEpilog");
+  
+  _somtTemplate->somtOutputSection(_somtTemplate->somtGetSymbol("methodEpilogSN"));
+}
+
+SOM_Scope void SOMLINK somtEmitTypedef(SOMTEmitC SOMSTAR somSelf,
+	                                            /* in */ SOMTTypedefEntryC SOMSTAR td)
+{
+  SOMTEmitCData *somThis = SOMTEmitCGetData(somSelf);
+  SOMTEmitCMethodDebug("SOMTEmitC","somtEmitTypedef");
+  
+  _somtTemplate->somtOutputSection(_somtTemplate->somtGetSymbol("typedefSN"));
+}
+
+SOM_Scope void SOMLINK somDefaultInit(SOMTEmitC SOMSTAR somSelf, somInitCtrl *ctrl)
+{
+  SOMTEmitCData *somThis; // set by BeginInitializer 
+  somInitCtrl globalCtrl;
+  somBooleanVector myMask;
+  SOMTEmitCMethodDebug("SOMTEmitC", "somDefaultInit");
+  
+  SOMTEmitC_BeginInitializer_somDefaultInit;
+  SOMTEmitC_Init_SOMObject_somDefaultInit(somSelf, ctrl);
+  
+  _somtTemplate=new SOMTTemplateOutputC();
+  somSelf->somtSetPredefinedSymbols();
+}
+
+SOM_Scope void SOMLINK somtSetPredefinedSymbols(SOMTEmitC SOMSTAR somSelf)
+{
+  SOMTEmitCData *somThis = SOMTEmitCGetData(somSelf);
+  SOMTEmitCMethodDebug("SOMTEmitC","somtSetPredefinedSymbols");
+
+  _somtTemplate->somtSetSymbolCopyBoth("prologSN", "prologS"); //+
+  _somtTemplate->somtSetSymbolCopyBoth("baseIncludesPrologSN", "baseIncludesPrologS"); //+
+  _somtTemplate->somtSetSymbolCopyBoth("baseIncludesSN", "baseIncludesS");//+
+  _somtTemplate->somtSetSymbolCopyBoth("baseIncludesEpilogSN", "baseIncludesEpilogS"); //+
+  _somtTemplate->somtSetSymbolCopyBoth("metaIncludeSN", "metaIncludeS"); //+
+  _somtTemplate->somtSetSymbolCopyBoth("classSN", "classS"); //+
+  _somtTemplate->somtSetSymbolCopyBoth("metaSN", "metaS"); //+
+  _somtTemplate->somtSetSymbolCopyBoth("basePrologSN", "basePrologS"); //+
+  _somtTemplate->somtSetSymbolCopyBoth("baseSN", "baseS");//+
+  _somtTemplate->somtSetSymbolCopyBoth("baseEpilogSN", "baseEpilogS"); //+
+  _somtTemplate->somtSetSymbolCopyBoth("constantPrologSN", "constantPrologS"); //+
+  _somtTemplate->somtSetSymbolCopyBoth("constantSN", "constantS");//+
+  _somtTemplate->somtSetSymbolCopyBoth("constantEpilogSN", "constantEpilogS"); //+
+  _somtTemplate->somtSetSymbolCopyBoth("typedefPrologSN", "typedefPrologS");//+
+  _somtTemplate->somtSetSymbolCopyBoth("typedefSN", "typedefS");//+
+  _somtTemplate->somtSetSymbolCopyBoth("typedefEpilogSN", "typedefEpilogS");//+
+  _somtTemplate->somtSetSymbolCopyBoth("structPrologSN", "structPrologS");//+
+  _somtTemplate->somtSetSymbolCopyBoth("structSN", "structS");//+
+  _somtTemplate->somtSetSymbolCopyBoth("structEpilogSN", "structEpilogS");//+
+  _somtTemplate->somtSetSymbolCopyBoth("unionPrologSN", "unionPrologS");//+
+  _somtTemplate->somtSetSymbolCopyBoth("unionSN", "unionS");//+
+  _somtTemplate->somtSetSymbolCopyBoth("unionEpilogSN", "unionEpilogS");//+
+  _somtTemplate->somtSetSymbolCopyBoth("enumPrologSN", "enumPrologS");//+
+  _somtTemplate->somtSetSymbolCopyBoth("enumSN", "enumS");//+
+  _somtTemplate->somtSetSymbolCopyBoth("enumEpilogSN", "enumEpilogS");//+
+  _somtTemplate->somtSetSymbolCopyBoth("attributePrologSN", "attributePrologS");//++
+  _somtTemplate->somtSetSymbolCopyBoth("attributeSN", "attributeS");//+
+  _somtTemplate->somtSetSymbolCopyBoth("attributeEpilogSN", "attributeEpilogS");//++
+  _somtTemplate->somtSetSymbolCopyBoth("interfacePrologSN", "interfacePrologS");
+  _somtTemplate->somtSetSymbolCopyBoth("interfaceSN", "interfaceS");
+  _somtTemplate->somtSetSymbolCopyBoth("interfaceEpilogSN", "interfaceEpilogS");
+  _somtTemplate->somtSetSymbolCopyBoth("modulePrologSN", "modulePrologS");
+  _somtTemplate->somtSetSymbolCopyBoth("moduleSN", "moduleS");
+  _somtTemplate->somtSetSymbolCopyBoth("moduleEpilogSN", "moduleEpilogS");
+  _somtTemplate->somtSetSymbolCopyBoth("passthruPrologSN", "passthruPrologS");//+
+  _somtTemplate->somtSetSymbolCopyBoth("passthruSN", "passthruS");//+
+  _somtTemplate->somtSetSymbolCopyBoth("passthruEpilogSN", "passthruEpilogS");//+
+  _somtTemplate->somtSetSymbolCopyBoth("releaseSN", "releaseS");//+
+  _somtTemplate->somtSetSymbolCopyBoth("dataPrologSN", "dataPrologS");//+
+  _somtTemplate->somtSetSymbolCopyBoth("dataSN", "dataS");//+
+  _somtTemplate->somtSetSymbolCopyBoth("dataEpilogSN", "dataEpilogS");//+
+  _somtTemplate->somtSetSymbolCopyBoth("methodsPrologSN", "methodsPrologS");//+
+  _somtTemplate->somtSetSymbolCopyBoth("methodsSN", "methodsS");//+
+  _somtTemplate->somtSetSymbolCopyBoth("overrideMethodsSN", "overrideMethodsS");
+  _somtTemplate->somtSetSymbolCopyBoth("overriddenMethodsSN", "overriddenMethodsS");
+  _somtTemplate->somtSetSymbolCopyBoth("inheritedMethodsSN", "inheritedMethodsS");
+  _somtTemplate->somtSetSymbolCopyBoth("methodsEpilogSN", "methodsEpilogS");//+
+  _somtTemplate->somtSetSymbolCopyBoth("epilogSN", "epilogS"); //+
+}
+
+SOM_Scope boolean SOMLINK somtScanStructs(SOMTEmitC SOMSTAR somSelf,
+                                                 /* in */ string prolog,
+                                                 /* in */ string each,
+                                                 /* in */ string epilog)
+{
+  somtEmitProc Proc;
+  somtEmitProcEach ProcEach;
+  SOMTEmitCData *somThis = SOMTEmitCGetData(somSelf);
+  SOMTEmitCMethodDebug("SOMTEmitC","somtScanStructs");
+
+  Proc = (somtEmitProc) somResolveByName(somSelf, prolog);
+  Proc(somSelf);
+
+  ProcEach = (somtEmitProcEach) somResolveByName(somSelf, each);
+  ProcEach(somSelf, NULL);
+
+  Proc = (somtEmitProc) somResolveByName(somSelf, epilog);
+  Proc(somSelf);
+
+  return FALSE;
+}
+
+SOM_Scope boolean SOMLINK somtScanEnums(SOMTEmitC SOMSTAR somSelf,
+                                               /* in */ string prolog,
+                                               /* in */ string each,
+                                               /* in */ string epilog)
+{
+  somtEmitProc Proc;
+  somtEmitProcEach ProcEach;
+  SOMTEmitCData *somThis = SOMTEmitCGetData(somSelf);
+  SOMTEmitCMethodDebug("SOMTEmitC","somtScanEnums");
+
+  Proc = (somtEmitProc) somResolveByName(somSelf, prolog);
+  Proc(somSelf);
+
+  ProcEach = (somtEmitProcEach) somResolveByName(somSelf, each);
+  ProcEach(somSelf, NULL);
+
+  Proc = (somtEmitProc) somResolveByName(somSelf, epilog);
+  Proc(somSelf);
+
+  return FALSE;
+}
+
+SOM_Scope boolean SOMLINK somtScanData(SOMTEmitC SOMSTAR somSelf,
+                                              /* in */ string prolog,
+                                              /* in */ string each,
+                                              /* in */ string epilog)
+{
+  somtEmitProc Proc;
+  somtEmitProcEach ProcEach;
+  SOMTEmitCData *somThis = SOMTEmitCGetData(somSelf);
+  SOMTEmitCMethodDebug("SOMTEmitC","somtScanData");
+
+  Proc = (somtEmitProc) somResolveByName(somSelf, prolog);
+  Proc(somSelf);
+
+  ProcEach = (somtEmitProcEach) somResolveByName(somSelf, each);
+  ProcEach(somSelf, NULL);
+
+  Proc = (somtEmitProc) somResolveByName(somSelf, epilog);
+  Proc(somSelf);
+
+  return FALSE;
+}
+
+SOM_Scope boolean SOMLINK somtScanModules(SOMTEmitC SOMSTAR somSelf,
+                                                 /* in */ string prolog,
+                                                 /* in */ string each,
+                                                 /* in */ string epilog)
+{
+  SOMTEmitCData *somThis = SOMTEmitCGetData(somSelf); 
+  SOMTEmitCMethodDebug("SOMTEmitC","somtScanModules");
+  
+  return FALSE;
+}
+
+SOM_Scope boolean SOMLINK somtScanPassthru(SOMTEmitC SOMSTAR somSelf,
+                                                  /* in */ boolean before,
+                                                  /* in */ string prolog,
+                                                  /* in */ string each,
+                                                  /* in */ string epilog)
+{
+  somtEmitProc Proc;
+  somtEmitProcEach ProcEach;
+  SOMTEmitCData *somThis = SOMTEmitCGetData(somSelf);
+  SOMTEmitCMethodDebug("SOMTEmitC","somtScanPassthru");
+
+  Proc = (somtEmitProc) somResolveByName(somSelf, prolog);
+  Proc(somSelf);
+
+  ProcEach = (somtEmitProcEach) somResolveByName(somSelf, each);
+  ProcEach(somSelf, NULL);
+
+  Proc = (somtEmitProc) somResolveByName(somSelf, epilog);
+  Proc(somSelf);
+
+  return FALSE;
+}
+                                                  
+SOM_Scope boolean SOMLINK somtScanBasesF(SOMTEmitC SOMSTAR somSelf,
+                                                /* in */ string filter,
+                                                /* in */ string prolog,
+                                                /* in */ string each,
+                                                /* in */ string epilog,
+                                                /* in */ boolean forceProlog)
+{
+  SOMTEmitCData *somThis = SOMTEmitCGetData(somSelf); 
+  SOMTEmitCMethodDebug("SOMTEmitC","somtScanBasesF");
+  
+  return FALSE;
+}
+
+SOM_Scope boolean SOMLINK somtScanTypedefs(SOMTEmitC SOMSTAR somSelf,
+                                                  /* in */ string prolog,
+                                                  /* in */ string each,
+                                                  /* in */ string epilog)
+{
+  SOMTEmitCData *somThis = SOMTEmitCGetData(somSelf); 
+  SOMTEmitCMethodDebug("SOMTEmitC","somtScanTypedefs");
+  
+  return FALSE;
+}
+
+
+SOM_Scope boolean SOMLINK somtScanBases(SOMTEmitC SOMSTAR somSelf,
+                                               /* in */ string prolog,
+                                               /* in */ string each,
+                                               /* in */ string epilog)
+{
+  somtEmitProc Proc;
+  somtEmitProcEach ProcEach;
+  SOMTEmitCData *somThis = SOMTEmitCGetData(somSelf);
+  SOMTEmitCMethodDebug("SOMTEmitC","somtScanBases");
+  SOMTClassEntryC *cls = _somtTargetClass;
+  SOMTBaseClassEntryC *bases;
+
+  Proc = (somtEmitProc) somResolveByName(somSelf, prolog);
+  Proc(somSelf);
+
+  boolean done;
+  for (done = ((bases=cls->somtGetFirstBaseClass())!=NULL); done;
+       done = ((bases=cls->somtGetNextBaseClass())!=NULL))
+  {       
+    ProcEach = (somtEmitProcEach) somResolveByName(somSelf, each);
+    ProcEach(somSelf, (SOMTEntryC *)bases);
+  }
+
+
+  Proc = (somtEmitProc) somResolveByName(somSelf, epilog);
+  Proc(somSelf);
+
+  return FALSE;
+}
+
+SOM_Scope boolean SOMLINK somtScanBaseIncludes(SOMTEmitC SOMSTAR somSelf,
+                                               /* in */ string prolog,
+                                               /* in */ string each,
+                                               /* in */ string epilog)
+{
+  SOMTEmitCData *somThis = SOMTEmitCGetData(somSelf); 
+  SOMTEmitCMethodDebug("SOMTEmitC","somtScanBaseIncludes");
+  
+  return somSelf->somtScanBases(prolog, each, epilog);
+}
+
+SOM_Scope boolean SOMLINK somtScanInterfaces(SOMTEmitC SOMSTAR somSelf,
+                                                    /* in */ string prolog,
+                                                    /* in */ string each,
+                                                    /* in */ string epilog)
+{
+  SOMTEmitCData *somThis = SOMTEmitCGetData(somSelf); 
+  SOMTEmitCMethodDebug("SOMTEmitC","somtScanInterfaces");
+  
+  return FALSE;
+}
+
+SOM_Scope boolean SOMLINK somtScanConstants(SOMTEmitC SOMSTAR somSelf,
+                                                   /* in */ string prolog,
+                                                   /* in */ string each,
+                                                   /* in */ string epilog)
+{
+  SOMTEmitCData *somThis = SOMTEmitCGetData(somSelf);
+  SOMTEmitCMethodDebug("SOMTEmitC","somtScanBases");
+
+  somtEmitProc Proc;
+  somtEmitProcEach ProcEach;
+  SOMTClassEntryC *cls = _somtTargetClass;
+  SOMTConstEntryC *cons;
+
+  Proc = (somtEmitProc) somResolveByName(somSelf, prolog);
+  Proc(somSelf);
+
+  boolean done;
+
+  for (done = ((cons=cls->somtGetFirstConstant())!=NULL); done;
+       done = ((cons=cls->somtGetNextConstant())!=NULL))
+  {       
+    ProcEach = (somtEmitProcEach) somResolveByName(somSelf, each);
+    ProcEach(somSelf, (SOMTEntryC *)cons);
+  }
+
+  Proc = (somtEmitProc) somResolveByName(somSelf, epilog);
+  Proc(somSelf);
+
+  return FALSE;
+}
+
+SOM_Scope boolean SOMLINK somtScanMethods(SOMTEmitC SOMSTAR somSelf,
+                                                 /* in */ string filter,
+                                                 /* in */ string prolog,
+                                                 /* in */ string each,
+                                                 /* in */ string epilog,
+                                                 /* in */ boolean forceProlog)
+{
+  somtEmitProc Proc;
+  somtEmitProcEach ProcEach;
+  SOMTEmitCData *somThis = SOMTEmitCGetData(somSelf);
+  SOMTEmitCMethodDebug("SOMTEmitC","somtScanMethods");
+
+  Proc = (somtEmitProc) somResolveByName(somSelf, prolog);
+  Proc(somSelf);
+
+  ProcEach = (somtEmitProcEach) somResolveByName(somSelf, each);
+  ProcEach(somSelf, NULL);
+
+  Proc = (somtEmitProc) somResolveByName(somSelf, epilog);
+  Proc(somSelf);
+
+  return FALSE;
+}
+                                               
+SOM_Scope boolean SOMLINK somtScanAttributes(SOMTEmitC SOMSTAR somSelf,
+                                                    /* in */ string prolog,
+                                                    /* in */ string each,
+                                                    /* in */ string epilog)
+{
+  SOMTEmitCData *somThis = SOMTEmitCGetData(somSelf);
+  SOMTEmitCMethodDebug("SOMTEmitC","somtScanAttributes");
+  somtEmitProc Proc;
+  somtEmitProcEach ProcEach;
+
+  SOMTClassEntryC *cls = _somtTargetClass;
+  SOMTAttributeEntryC *atts;
+
+
+  Proc = (somtEmitProc) somResolveByName(somSelf, prolog);
+  Proc(somSelf);
+
+  boolean done;
+  for (done = ((atts=cls->somtGetFirstAttribute())!=NULL); done;
+       done = ((atts=cls->somtGetNextAttribute())!=NULL))
+  {       
+    ProcEach = (somtEmitProcEach) somResolveByName(somSelf, each);
+    ProcEach(somSelf, (SOMTEntryC *)atts);
+  }
+
+  Proc = (somtEmitProc) somResolveByName(somSelf, epilog);
+  Proc(somSelf);
+
+  return FALSE;
+}
+
+SOM_Scope boolean SOMLINK somtScanUnions(SOMTEmitC SOMSTAR somSelf,
+                                                /* in */ string prolog,
+                                                /* in */ string each,
+                                                /* in */ string epilog)
+{
+  somtEmitProc Proc;
+  somtEmitProcEach ProcEach;
+  SOMTEmitCData *somThis = SOMTEmitCGetData(somSelf);
+  SOMTEmitCMethodDebug("SOMTEmitC","somtScanUnions");
+
+  Proc = (somtEmitProc) somResolveByName(somSelf, prolog);
+  Proc(somSelf);
+
+  ProcEach = (somtEmitProcEach) somResolveByName(somSelf, each);
+  ProcEach(somSelf, NULL);
+
+  Proc = (somtEmitProc) somResolveByName(somSelf, epilog);
+  Proc(somSelf);
+
+  return FALSE;
+}
+
+SOM_Scope boolean SOMLINK somtScanDataF(SOMTEmitC SOMSTAR somSelf,
+                                               /* in */ string filter,
+                                               /* in */ string prolog,
+                                               /* in */ string each,
+                                               /* in */ string epilog,
+                                               /* in */ boolean forceProlog)
+{
+  SOMTEmitCData *somThis = SOMTEmitCGetData(somSelf); 
+  SOMTEmitCMethodDebug("SOMTEmitC","somtScanDataF");
+  
+  return FALSE;
+}
+
+SOM_Scope boolean SOMLINK somtInherited(SOMTEmitC * somSelf,
+                                        /* in */ SOMTMethodEntryC * entry)
+{
+  SOMTEmitCData *somThis = SOMTEmitCGetData(somSelf); 
+  SOMTEmitCMethodDebug("SOMTEmitC","somtInherited");
+  
+  return FALSE;
+}
+                                               
+SOM_Scope boolean SOMLINK somtOverridden(SOMTEmitC * somSelf,
+                                         /* in */ SOMTMethodEntryC * entry)
+{
+  SOMTEmitCData *somThis = SOMTEmitCGetData(somSelf); 
+  SOMTEmitCMethodDebug("SOMTEmitC","somtOverridden");
+  
+  return FALSE;                                         
+}
+
+SOM_Scope void SOMLINK somtEmitFullPassthru(SOMTEmitC * somSelf,
+                                            /* in */ boolean before,
+                                            /* in */ string language)
+{
+  SOMTEmitCData *somThis = SOMTEmitCGetData(somSelf); 
+  SOMTEmitCMethodDebug("SOMTEmitC","somtEmitFullPassthru");
+  
+  
+}
+
+SOM_Scope SOMTEntryC * SOMLINK somtGetNextGlobalDefinition(SOMTEmitC * somSelf)
+{
+  SOMTEmitCData *somThis = SOMTEmitCGetData(somSelf); 
+  SOMTEmitCMethodDebug("SOMTEmitC","somtGetNextGlobalDefinition");
+  
+  return NULL;
+}
+
+SOM_Scope boolean SOMLINK somtNewNoProc(SOMTEmitC * somSelf,
+                                        /* in */ SOMTEntryC * entry)
+{
+  SOMTEmitCData *somThis = SOMTEmitCGetData(somSelf); 
+  SOMTEmitCMethodDebug("SOMTEmitC","somtNewNoProc");
+  
+  return FALSE;
+}
+
+SOM_Scope boolean SOMLINK somtPrivOrPub(SOMTEmitC * somSelf,
+                                        /* in */ SOMTEntryC * entry)
+{
+  SOMTEmitCData *somThis = SOMTEmitCGetData(somSelf); 
+  SOMTEmitCMethodDebug("SOMTEmitC","somtPrivOrPub");
+  
+  return FALSE;
+}
+
+SOM_Scope boolean SOMLINK somtCheckVisibility(SOMTEmitC * somSelf,
+                                              /* in */ SOMTMethodEntryC * entry)
+{
+  SOMTEmitCData *somThis = SOMTEmitCGetData(somSelf); 
+  SOMTEmitCMethodDebug("SOMTEmitC","somtCheckVisibility");
+  
+  return FALSE;
+}
+
+SOM_Scope boolean SOMLINK somtImplemented(SOMTEmitC * somSelf,
+                                          /* in */ SOMTMethodEntryC * entry)
+{
+  SOMTEmitCData *somThis = SOMTEmitCGetData(somSelf); 
+  SOMTEmitCMethodDebug("SOMTEmitC","somtImplemented");
+  
+  return FALSE;
+}
+
+SOM_Scope boolean SOMLINK somtVA(SOMTEmitC * somSelf,
+                                 /* in */ SOMTEntryC * entry)
+{
+  SOMTEmitCData *somThis = SOMTEmitCGetData(somSelf); 
+  SOMTEmitCMethodDebug("SOMTEmitC","somtVA");
+  
+  return FALSE;
+}
+
+SOM_Scope boolean SOMLINK somtAll(SOMTEmitC * somSelf,
+                                  /* in */ SOMTMethodEntryC * entry)
+{
+  SOMTEmitCData *somThis = SOMTEmitCGetData(somSelf); 
+  SOMTEmitCMethodDebug("SOMTEmitC","somtAll");
+  
+  return FALSE;
+}
+
+SOM_Scope boolean SOMLINK somtLink(SOMTEmitC * somSelf,
+                                   /* in */ SOMTEntryC * entry)
+{
+
+  SOMTEmitCData *somThis = SOMTEmitCGetData(somSelf); 
+  SOMTEmitCMethodDebug("SOMTEmitC","somtLink");
+  
+  return FALSE;
+}
+
+SOM_Scope void SOMLINK somDumpSelfInt(SOMTEmitC * somSelf,
+                                      /* in */ long level)
+{
+  SOMTEmitCData *somThis = SOMTEmitCGetData(somSelf); 
+  SOMTEmitCMethodDebug("SOMTEmitC","somDumpSelfInt");
+  
+}
+
+SOM_Scope boolean SOMLINK somtAllVisible(SOMTEmitC * somSelf,
+                                         /* in */ SOMTMethodEntryC * entry)
+{
+  SOMTEmitCData *somThis = SOMTEmitCGetData(somSelf); 
+  SOMTEmitCMethodDebug("SOMTEmitC","somtAllVisible");
+  
+  return FALSE;
+}
+
+SOM_Scope boolean SOMLINK somtNew(SOMTEmitC * somSelf,
+                                  /* in */ SOMTMethodEntryC * entry)
+{
+  SOMTEmitCData *somThis = SOMTEmitCGetData(somSelf); 
+  SOMTEmitCMethodDebug("SOMTEmitC","somtNew");
+  
+  return FALSE;
+}
+
+SOM_Scope SOMTEntryC * SOMLINK somtGetFirstGlobalDefinition(SOMTEmitC * somSelf)
+{
+  SOMTEmitCData *somThis = SOMTEmitCGetData(somSelf); 
+  SOMTEmitCMethodDebug("SOMTEmitC","somtGetFirstGlobalDefinition");
+  
+  return NULL;
+}
+
+SOM_Scope boolean SOMLINK somtNewProc(SOMTEmitC * somSelf,
+                                      /* in */ SOMTEntryC * entry)
+{
+  SOMTEmitCData *somThis = SOMTEmitCGetData(somSelf); 
+  SOMTEmitCMethodDebug("SOMTEmitC","somtNewProc");
+  
+  return FALSE;
+}
+
diff -urN somfree\some\src\scentry.cpp newsomfree3\some\src\scentry.cpp
--- somfree\some\src\scentry.cpp	Thu Jan 01 07:00:00 1970
+++ newsomfree3\some\src\scentry.cpp	Sat Mar 16 14:09:26 2024
@@ -0,0 +1,371 @@
+/**************************************************************************
+ *
+ *  Copyright 2015, 2017 Yuri Prokushev
+ *
+ *  This file is part of osFree project
+ *
+ *  This program is free software: you can redistribute it and/or modify it
+ *  under the terms of the GNU Lesser General Public License as published by the
+ *  Free Software Foundation, either version 3 of the License, or (at your
+ *  option) any later version.
+ * 
+ *  This program is distributed in the hope that it will be useful, but WITHOUT
+ *  ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ *  FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for
+ *  more details.
+ *
+ *  You should have received a copy of the GNU Lesser General Public License
+ *  along with this program.  If not, see <http://www.gnu.org/licenses/>
+ *
+ */
+
+#ifndef SOM_Module_Source
+#define SOM_Module_Source
+#endif
+
+#define SOMTEntryC_Class_Source
+
+
+#define __PRIVATE__
+#include <rhbopt.h>
+#include <stdio.h>
+#include <string.h>
+#include <stdlib.h>
+#include "rhbsc.h"
+
+#include "scentry.xih"
+
+SOM_Scope string  SOMLINK _get_somtEntryName(SOMTEntryC SOMSTAR somSelf)
+{
+  SOMTEntryCData *somThis = SOMTEntryCGetData(somSelf);
+  SOMTEntryCMethodDebug("SOMTEntryC","_get_somtEntryName");
+  
+  return _somtEntryName;
+}
+
+
+SOM_Scope string SOMLINK _get_somtCScopedName(SOMTEntryC SOMSTAR somSelf)
+{
+  SOMTEntryCData *somThis = SOMTEntryCGetData(somSelf);
+  SOMTEntryCMethodDebug("SOMTEntryC","_get_somtCScopedName");
+
+  return _CScopedName;  // <modulename>_<interfacename>
+}
+
+SOM_Scope string SOMLINK _get_somtIDLScopedName(SOMTEntryC SOMSTAR somSelf)
+{
+  SOMTEntryCData *somThis = SOMTEntryCGetData(somSelf);
+  SOMTEntryCMethodDebug("SOMTEntryC","_get_somtIDLScopedName");
+
+  return _IDLScopedName;
+}
+
+SOM_Scope unsigned long SOMLINK _get_somtSourceLineNumber(SOMTEntryC SOMSTAR somSelf)
+{
+  SOMTEntryCData *somThis = SOMTEntryCGetData(somSelf);
+  SOMTEntryCMethodDebug("SOMTEntryC","_get_somtSourceLineNumber");
+
+  RHBelement * element=_es->data;
+  
+  return element->defined_line;
+}
+
+SOM_Scope TypeCode SOMLINK _get_somtTypeCode(SOMTEntryC SOMSTAR somSelf)
+{
+  SOMTEntryCData *somThis = SOMTEntryCGetData(somSelf);
+  SOMTEntryCMethodDebug("SOMTEntryC","_get_somtTypeCode");
+
+  return 0;
+}
+
+SOM_Scope string SOMLINK _get_somtEntryComment(SOMTEntryC SOMSTAR somSelf)
+{
+  SOMTEntryCData *somThis = SOMTEntryCGetData(somSelf);
+  SOMTEntryCMethodDebug("SOMTEntryC","_get_somtEntryComment");
+
+  return NULL;
+}
+
+SOM_Scope string SOMLINK _get_somtElementTypeName(SOMTEntryC SOMSTAR somSelf)
+{
+  SOMTEntryCData *somThis = SOMTEntryCGetData(somSelf);
+  SOMTEntryCMethodDebug("SOMTEntryC","_get_somtElementTypeName");
+
+  return NULL;
+}
+
+SOM_Scope boolean SOMLINK _get_somtIsReference(SOMTEntryC SOMSTAR somSelf)
+{
+  SOMTEntryCData *somThis = SOMTEntryCGetData(somSelf);
+  SOMTEntryCMethodDebug("SOMTEntryC","_get_somtIsReference");
+
+  return FALSE;
+}
+
+SOM_Scope long SOMLINK somtSetSymbolsOnEntry(SOMTEntryC SOMSTAR somSelf,
+	                                                   /* in */ SOMTEmitC SOMSTAR emitter,
+	                                                   /* in */ string prefix)
+{
+  char buf[250];
+  char modbuf[25000];
+
+  SOMTEntryCData *somThis = SOMTEntryCGetData(somSelf);
+  SOMTEntryCMethodDebug("SOMTEntryC","somtSetSymbolsOnEntry");
+  SOMTTemplateOutputC *templ = emitter->_get_somtTemplate();
+
+  buf[0]=0;
+  strcat(buf, prefix);
+  templ->somtSetSymbolCopyBoth(strcat(buf, "Name"), somSelf->_get_somtEntryName());
+
+  buf[0]=0;
+  strcat(buf, prefix);
+  templ->somtSetSymbolCopyBoth(strcat(buf, "IDSScopedName"), _IDLScopedName);
+
+  buf[0]=0;
+  strcat(buf, prefix);
+  templ->somtSetSymbolCopyBoth(strcat(buf, "CScopedName"), _CScopedName);
+
+  buf[0]=0;
+  strcat(buf, prefix);
+  templ->somtSetSymbolCopyBoth(strcat(buf, "Comment"), somSelf->_get_somtEntryComment());
+
+  buf[0]=0;
+  char buf2[20];
+  strcat(buf, prefix);
+  sprintf(buf2, "%d", somSelf->_get_somtSourceLineNumber());
+  templ->somtSetSymbolCopyBoth(strcat(buf, "LineNumber"), buf2);
+
+  buf[0]=0;
+  modbuf[0]=0;
+  strcat(buf, prefix);
+  somSelf->somtGetModifierList(modbuf);
+  templ->somtSetSymbolCopyBoth(strcat(buf, "Mods"), modbuf);
+  
+  return 1;
+}
+
+void get_c_name(RHBelement *element,char *buf,size_t buflen)
+{
+	if (element->parent())
+	{
+		get_c_name(element->parent(),buf,buflen);
+		if (buf[0])
+		{
+			strncat(buf,"_",buflen);
+		}
+		strncat(buf,element->id,buflen);
+	}
+	else
+	{
+		if (element->id)
+		{
+			strncpy(buf,element->id,buflen);
+		}
+		else
+		{
+			buf[0]=0;
+		}
+	}
+}
+
+void get_ir_name(RHBelement *element,char *buf,size_t buflen)
+{
+	if (element->parent())
+	{
+		get_ir_name(element->parent(),buf,buflen);
+		if (strcmp(buf,"::"))
+		{
+			strncat(buf,"::",buflen);
+		}
+		strncat(buf,element->id,buflen);
+	}
+	else
+	{
+		strncpy(buf,"::",buflen);
+		if (element->id)
+		{
+			strncat(buf,element->id,buflen);
+		}
+	}
+}
+
+SOM_Scope void SOMLINK somtSetEntryStruct(SOMTEntryC SOMSTAR somSelf,
+	                                                /* inout */ Entry *es)
+{
+  char buf[250];
+  SOMTEntryCData *somThis = SOMTEntryCGetData(somSelf);
+  SOMTEntryCMethodDebug("SOMTEntryC","somtSetEntryStruct");
+
+  _es=es;
+
+  RHBelement * element=_es->data;
+
+// Store names for future usage
+
+  _somtEntryName=es->name;
+  get_c_name(element, buf, sizeof(buf));
+  _CScopedName=(string) SOMMalloc(strlen(buf)+1);
+  strncpy(_CScopedName, buf, strlen(buf));
+  
+  memset(buf, 0, sizeof(buf));
+  get_ir_name(element, buf, sizeof(buf));
+  _IDLScopedName=(string) SOMMalloc(strlen(buf)+1);
+  strncpy(_IDLScopedName, buf, strlen(buf));
+
+// Store modifiers in associative array
+ 
+  char name[250];
+  char value[2048];
+  
+ 	RHBelement *e=element->children();
+	while (e)
+	{
+    RHBmodifier *m=e->is_modifier();
+    if (m) 
+    {
+			int i=0;
+      
+      name[0]=0;
+      value[0]=0;
+      
+      strcat(name, m->id);
+
+			while (m->modifier_data.get(i))
+			{
+        strcat(value, m->modifier_data.get(i));
+				i++;
+      }
+
+      _Stab->somstAssociateCopyBoth(name, value);      
+    }
+		e=e->next();
+	}
+
+}
+
+SOM_Scope long SOMLINK somtFormatModifier(SOMTEntryC SOMSTAR somSelf,
+	                                                /* in */ string buffer,
+	                                                /* in */ string name,
+	                                                /* in */ string value)
+{
+  SOMTEntryCData *somThis = SOMTEntryCGetData(somSelf);
+  SOMTEntryCMethodDebug("SOMTEntryC","somtFormatModifier");
+
+  strcat(buffer, name);
+  strcat(buffer, ": ");
+  strcat(buffer, value);
+  return strlen(buffer);
+}
+
+SOM_Scope long SOMLINK somtGetModifierList(SOMTEntryC SOMSTAR somSelf,
+                                           /* in */ string buffer)
+{
+  char str[4096];
+  
+  SOMTEntryCData *somThis = SOMTEntryCGetData(somSelf);
+  SOMTEntryCMethodDebug("SOMTEntryC","somtGetModifierList");
+ 
+  unsigned long i=1;
+  
+  while(_Stab->somstGetIthKey(i))
+  {
+    str[0]=0;
+    somSelf->somtFormatModifier(str, _Stab->somstGetIthKey(i), _Stab->somstGetIthValue(i));
+    
+    strcat(buffer, str);
+    strcat(buffer, "\n");
+    i++;
+  }
+ 
+  return i-1;
+}
+
+SOM_Scope boolean SOMLINK somtGetNextModifier(SOMTEntryC SOMSTAR somSelf,
+	                                                    /* inout */ string *modifierName,
+	                                                    /* inout */ string *modifierValue)
+{
+  SOMTEntryCData *somThis = SOMTEntryCGetData(somSelf);
+  SOMTEntryCMethodDebug("SOMTEntryC","somtGetNextModifier");
+
+  _iterator++;
+  if (!_Stab->somstGetIthKey(_iterator)) return FALSE;
+  
+  *modifierName=_Stab->somstGetIthKey(_iterator);
+  *modifierValue=_Stab->somstGetIthValue(_iterator);
+  return TRUE;
+}
+
+SOM_Scope string SOMLINK somtGetModifierValue(SOMTEntryC SOMSTAR somSelf,
+	                                                    /* in */ string modifierName)
+{
+  SOMTEntryCData *somThis = SOMTEntryCGetData(somSelf);
+  SOMTEntryCMethodDebug("SOMTEntryC","somtGetModifierValue");
+
+  return _Stab->somstGetAssociation(modifierName);
+}
+
+SOM_Scope boolean SOMLINK somtGetFirstModifier(SOMTEntryC SOMSTAR somSelf,
+	                                                     /* inout */ string *modifierName,
+	                                                     /* inout */ string *modifierValue)
+{
+  SOMTEntryCData *somThis = SOMTEntryCGetData(somSelf);
+  SOMTEntryCMethodDebug("SOMTEntryC","somtGetFirstModifier");
+
+  if (!_Stab->somstGetIthKey(1)) return FALSE;
+  
+  *modifierName=_Stab->somstGetIthKey(1);
+  *modifierValue=_Stab->somstGetIthValue(1);
+  _iterator=1;
+  return TRUE;
+}
+
+SOM_Scope Entry *SOMLINK _get_somtEntryStruct(SOMTEntryC * somSelf)
+{
+  SOMTEntryCData *somThis = SOMTEntryCGetData(somSelf);
+  SOMTEntryCMethodDebug("SOMTEntryC","_get_somtEntryStruct");
+
+  return _es;
+}
+
+SOM_Scope void SOMLINK somDefaultInit(SOMTEntryC SOMSTAR somSelf, somInitCtrl *ctrl)
+{
+  SOMTEntryCData *somThis; // set by BeginInitializer 
+  somInitCtrl globalCtrl;
+  somBooleanVector myMask;
+  SOMTEntryCMethodDebug("SOMTEntryC", "somDefaultInit");
+  
+  SOMTEntryC_BeginInitializer_somDefaultInit;
+  SOMTEntryC_Init_SOMObject_somDefaultInit(somSelf, ctrl);
+
+  _CScopedName=NULL;
+  _IDLScopedName=NULL;
+  _Stab = new SOMStringTableC();
+  _iterator=0;
+}
+
+SOM_Scope void SOMLINK somDestruct(SOMTEntryC *somSelf, octet doFree, somDestructCtrl* ctrl)
+{
+  SOMTEntryCData *somThis; /* set by BeginDestructor */
+  somDestructCtrl globalCtrl;
+  somBooleanVector myMask;
+  SOMTEntryCMethodDebug("SOMTEntryC","somDestruct");
+  SOMTEntryC_BeginDestructor;
+  /*
+  * local SOMTEntryC deinitialization code added by programmer
+  */
+  if (_CScopedName) SOMFree(_CScopedName);
+  if (_IDLScopedName) SOMFree(_IDLScopedName);
+  delete _Stab;
+  
+  SOMTEntryC_EndDestructor;
+}
+
+// ??? ╩ръ с√Є№ ё Єръшьш тх∙рьш? ╨рёёшэїЁюэшчшьё ...
+const char * RHBmodifier_list::get(int i)
+{
+		if (i < _length)
+		{
+			return _buffer[i];
+		}
+		return 0;
+}
diff -urN somfree\some\src\scenum.cpp newsomfree3\some\src\scenum.cpp
--- somfree\some\src\scenum.cpp	Thu Jan 01 07:00:00 1970
+++ newsomfree3\some\src\scenum.cpp	Sat Mar 16 14:09:26 2024
@@ -0,0 +1,54 @@
+/**************************************************************************
+ *
+ *  Copyright 2015, 2017 Yuri Prokushev
+ *
+ *  This file is part of osFree project
+ *
+ *  This program is free software: you can redistribute it and/or modify it
+ *  under the terms of the GNU Lesser General Public License as published by the
+ *  Free Software Foundation, either version 3 of the License, or (at your
+ *  option) any later version.
+ * 
+ *  This program is distributed in the hope that it will be useful, but WITHOUT
+ *  ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ *  FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for
+ *  more details.
+ *
+ *  You should have received a copy of the GNU Lesser General Public License
+ *  along with this program.  If not, see <http://www.gnu.org/licenses/>
+ *
+ */
+
+#ifndef SOM_Module_scenum_Source
+#define SOM_Module_scenum_Source
+#endif
+
+#define SOMTEnumEntryC_Class_Source
+
+#include "scenum.xih"
+
+SOM_Scope long SOMLINK somtSetSymbolsOnEntry(SOMTEnumEntryC SOMSTAR somSelf,
+	                                           /* in */ SOMTEmitC SOMSTAR emitter,
+	                                           /* in */ string prefix)
+{
+  SOMTEnumEntryCData *somThis = SOMTEnumEntryCGetData(somSelf);
+  SOMTEnumEntryCMethodDebug("SOMTEnumEntryC","somtSetSymbolsOnEntry");
+  
+  return 0;
+}
+
+SOM_Scope SOMTEnumNameEntryC SOMSTAR SOMLINK somtGetNextEnumName(SOMTEnumEntryC SOMSTAR somSelf)
+{
+  SOMTEnumEntryCData *somThis = SOMTEnumEntryCGetData(somSelf);
+  SOMTEnumEntryCMethodDebug("SOMTEnumEntryC","somtGetNextEnumName");
+  
+  return NULL;
+}
+
+SOM_Scope SOMTEnumNameEntryC SOMSTAR SOMLINK somtGetFirstEnumName(SOMTEnumEntryC SOMSTAR somSelf)
+{
+  SOMTEnumEntryCData *somThis = SOMTEnumEntryCGetData(somSelf);
+  SOMTEnumEntryCMethodDebug("SOMTEnumEntryC","somtGetFirstEnumName");
+  
+  return NULL;
+}
diff -urN somfree\some\src\scenumnm.cpp newsomfree3\some\src\scenumnm.cpp
--- somfree\some\src\scenumnm.cpp	Thu Jan 01 07:00:00 1970
+++ newsomfree3\some\src\scenumnm.cpp	Sat Mar 16 14:09:26 2024
@@ -0,0 +1,54 @@
+/**************************************************************************
+ *
+ *  Copyright 2015, 2017 Yuri Prokushev
+ *
+ *  This file is part of osFree project
+ *
+ *  This program is free software: you can redistribute it and/or modify it
+ *  under the terms of the GNU Lesser General Public License as published by the
+ *  Free Software Foundation, either version 3 of the License, or (at your
+ *  option) any later version.
+ * 
+ *  This program is distributed in the hope that it will be useful, but WITHOUT
+ *  ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ *  FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for
+ *  more details.
+ *
+ *  You should have received a copy of the GNU Lesser General Public License
+ *  along with this program.  If not, see <http://www.gnu.org/licenses/>
+ *
+ */
+
+#ifndef SOM_Module_scenumnm_Source
+#define SOM_Module_scenumnm_Source
+#endif
+
+#define SOMTEnumNameEntryC_Class_Source
+
+#include "scenumnm.xih"
+
+SOM_Scope long SOMLINK somtSetSymbolsOnEntry(SOMTEnumNameEntryC SOMSTAR somSelf,
+	                                           /* in */ SOMTEmitC SOMSTAR emitter,
+	                                           /* in */ string prefix)
+{
+  SOMTEnumNameEntryCData *somThis = SOMTEnumNameEntryCGetData(somSelf);
+  SOMTEnumNameEntryCMethodDebug("SOMTEnumNameEntryC","somtSetSymbolsOnEntry");
+  
+  return 0;
+}
+
+SOM_Scope SOMTEnumEntryC SOMSTAR SOMLINK _get_somtEnumPtr(SOMTEnumNameEntryC SOMSTAR somSelf)
+{
+  SOMTEnumNameEntryCData *somThis = SOMTEnumNameEntryCGetData(somSelf);
+  SOMTEnumNameEntryCMethodDebug("SOMTEnumNameEntryC","_get_somtEnumPtr");
+  
+  return NULL;
+}
+
+SOM_Scope unsigned long SOMLINK _get_somtEnumVal(SOMTEnumNameEntryC SOMSTAR somSelf)
+{
+  SOMTEnumNameEntryCData *somThis = SOMTEnumNameEntryCGetData(somSelf);
+  SOMTEnumNameEntryCMethodDebug("SOMTEnumNameEntryC","_get_somtEnumVal");
+  
+  return 0;
+}
diff -urN somfree\some\src\scmeta.cpp newsomfree3\some\src\scmeta.cpp
--- somfree\some\src\scmeta.cpp	Thu Jan 01 07:00:00 1970
+++ newsomfree3\some\src\scmeta.cpp	Sat Mar 16 14:09:26 2024
@@ -0,0 +1,44 @@
+/**************************************************************************
+ *
+ *  Copyright 2014, 2017 Yuri Prokushev
+ *
+ *  This file is part of osFree project
+ *
+ *  This program is free software: you can redistribute it and/or modify it
+ *  under the terms of the GNU Lesser General Public License as published by the
+ *  Free Software Foundation, either version 3 of the License, or (at your
+ *  option) any later version.
+ * 
+ *  This program is distributed in the hope that it will be useful, but WITHOUT
+ *  ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ *  FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for
+ *  more details.
+ *
+ *  You should have received a copy of the GNU Lesser General Public License
+ *  along with this program.  If not, see <http://www.gnu.org/licenses/>
+ *
+ */
+
+#ifndef SOM_Module_scmeta_Source
+#define SOM_Module_scmeta_Source
+#endif
+
+#define SOMTMetaClassEntryC_Class_Source
+
+#include "scmeta.xih"
+
+SOM_Scope SOMTClassEntryC * SOMLINK _get_somtMetaClassDef(SOMTMetaClassEntryC * somSelf)
+{
+  SOMTMetaClassEntryCData *somThis = SOMTMetaClassEntryCGetData(somSelf);
+  SOMTMetaClassEntryCMethodDebug("SOMTMetaClassEntryC","_get_somtMetaClassDef");
+  
+  return NULL;
+}
+
+SOM_Scope string SOMLINK _get_somtMetaFile(SOMTMetaClassEntryC * somSelf)
+{
+  SOMTMetaClassEntryCData *somThis = SOMTMetaClassEntryCGetData(somSelf);
+  SOMTMetaClassEntryCMethodDebug("SOMTMetaClassEntryC","_get_somtMetaFile");
+  
+  return NULL;
+}
diff -urN somfree\some\src\scmethod.cpp newsomfree3\some\src\scmethod.cpp
--- somfree\some\src\scmethod.cpp	Thu Jan 01 07:00:00 1970
+++ newsomfree3\some\src\scmethod.cpp	Sat Mar 16 14:09:26 2024
@@ -0,0 +1,212 @@
+/**************************************************************************
+ *
+ *  Copyright 2015, 2017 Yuri Prokushev
+ *
+ *  This file is part of osFree project
+ *
+ *  This program is free software: you can redistribute it and/or modify it
+ *  under the terms of the GNU Lesser General Public License as published by the
+ *  Free Software Foundation, either version 3 of the License, or (at your
+ *  option) any later version.
+ * 
+ *  This program is distributed in the hope that it will be useful, but WITHOUT
+ *  ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ *  FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for
+ *  more details.
+ *
+ *  You should have received a copy of the GNU Lesser General Public License
+ *  along with this program.  If not, see <http://www.gnu.org/licenses/>
+ *
+ */
+
+#ifndef SOM_Module_scmethod_Source
+#define SOM_Module_scmethod_Source
+#endif
+
+#define SOMTMethodEntryC_Class_Source
+
+#include "scmethod.xih"
+
+SOM_Scope SOMTMethodEntryC * SOMLINK _get_somtOriginalMethod(SOMTMethodEntryC * somSelf)
+{
+  SOMTMethodEntryCData *somThis = SOMTMethodEntryCGetData(somSelf);
+  SOMTMethodEntryCMethodDebug("SOMTMethodEntryC","_get_somtOriginalMethod");
+
+  return NULL;
+}
+
+SOM_Scope boolean SOMLINK _get_somtIsVarargs(SOMTMethodEntryC * somSelf)
+{
+  SOMTMethodEntryCData *somThis = SOMTMethodEntryCGetData(somSelf);
+  SOMTMethodEntryCMethodDebug("SOMTMethodEntryC","_get_somtIsVarargs");
+
+  return NULL;
+}
+
+SOM_Scope SOMTParameterEntryC * SOMLINK somtGetNextParameter(SOMTMethodEntryC * somSelf)
+{
+  SOMTMethodEntryCData *somThis = SOMTMethodEntryCGetData(somSelf);
+  SOMTMethodEntryCMethodDebug("SOMTMethodEntryC","somtGetNextParameter");
+
+  return NULL;
+}
+
+SOM_Scope SOMTEntryC * SOMLINK _get_somtMethodGroup(SOMTMethodEntryC * somSelf)
+{
+  SOMTMethodEntryCData *somThis = SOMTMethodEntryCGetData(somSelf);
+  SOMTMethodEntryCMethodDebug("SOMTMethodEntryC","_get_somtMethodGroup");
+
+  return NULL;
+}
+
+SOM_Scope boolean SOMLINK _get_somtIsOneway(SOMTMethodEntryC * somSelf)
+{
+  SOMTMethodEntryCData *somThis = SOMTMethodEntryCGetData(somSelf);
+  SOMTMethodEntryCMethodDebug("SOMTMethodEntryC","_get_somtIsOneway");
+
+  return FALSE;
+}
+
+SOM_Scope SOMTParameterEntryC * SOMLINK somtGetNthParameter(SOMTMethodEntryC * somSelf,
+                                                            /* in */ short n)
+{
+  SOMTMethodEntryCData *somThis = SOMTMethodEntryCGetData(somSelf);
+  SOMTMethodEntryCMethodDebug("SOMTMethodEntryC","somtGetNthParameter");
+
+  return NULL;
+}
+
+SOM_Scope string SOMLINK somtGetShortParamNameList(SOMTMethodEntryC * somSelf,
+                                                   /* in */ string buffer,
+                                                   /* in */ string selfParm,
+                                                   /* in */ string varargsParm)
+{
+  SOMTMethodEntryCData *somThis = SOMTMethodEntryCGetData(somSelf);
+  SOMTMethodEntryCMethodDebug("SOMTMethodEntryC","somtGetShortParamNameList");
+
+  return NULL;
+}
+
+SOM_Scope string SOMLINK somtGetIDLParamList(SOMTMethodEntryC * somSelf,
+                                             /* in */ string buffer)
+{
+  SOMTMethodEntryCData *somThis = SOMTMethodEntryCGetData(somSelf);
+  SOMTMethodEntryCMethodDebug("SOMTMethodEntryC","somtGetIDLParamList");
+
+  return NULL;
+}
+
+SOM_Scope string *SOMLINK _get_somtContextArray(SOMTMethodEntryC * somSelf)
+{
+  SOMTMethodEntryCData *somThis = SOMTMethodEntryCGetData(somSelf);
+  SOMTMethodEntryCMethodDebug("SOMTMethodEntryC","_get_somtContextArray");
+
+  return NULL;
+}
+
+SOM_Scope SOMTParameterEntryC * SOMLINK somtGetFirstParameter(SOMTMethodEntryC * somSelf)
+{
+  SOMTMethodEntryCData *somThis = SOMTMethodEntryCGetData(somSelf);
+  SOMTMethodEntryCMethodDebug("SOMTMethodEntryC","somtGetFirstParameter");
+
+  return NULL;
+}
+
+SOM_Scope long SOMLINK somtSetSymbolsOnEntry(SOMTMethodEntryC * somSelf,
+                                             /* in */ SOMTEmitC * emitter,
+                                             /* in */ string prefix)
+{
+  SOMTMethodEntryCData *somThis = SOMTMethodEntryCGetData(somSelf);
+  SOMTMethodEntryCMethodDebug("SOMTMethodEntryC","somtSetSymbolsOnEntry");
+
+  return 0;
+}
+
+SOM_Scope string SOMLINK somtGetFullCParamList(SOMTMethodEntryC * somSelf,
+                                               /* in */ string buffer,
+                                               /* in */ string varargsParm)
+{
+  SOMTMethodEntryCData *somThis = SOMTMethodEntryCGetData(somSelf);
+  SOMTMethodEntryCMethodDebug("SOMTMethodEntryC","somtGetFullCParamList");
+
+  return NULL;
+}
+
+SOM_Scope void SOMLINK somDumpSelfInt(SOMTMethodEntryC * somSelf,
+                                      /* in */ long level)
+{
+  SOMTMethodEntryCData *somThis = SOMTMethodEntryCGetData(somSelf);
+  SOMTMethodEntryCMethodDebug("SOMTMethodEntryC","somDumpSelfInt");
+
+
+}
+
+SOM_Scope string SOMLINK somtGetShortCParamList(SOMTMethodEntryC * somSelf,
+                                                /* in */ string buffer,
+                                                /* in */ string selfParm,
+                                                /* in */ string varargsParm)
+{
+  SOMTMethodEntryCData *somThis = SOMTMethodEntryCGetData(somSelf);
+  SOMTMethodEntryCMethodDebug("SOMTMethodEntryC","somtGetShortCParamList");
+
+  return NULL;
+}
+
+SOM_Scope boolean SOMLINK _get_somtIsPrivateMethod(SOMTMethodEntryC * somSelf)
+{
+  SOMTMethodEntryCData *somThis = SOMTMethodEntryCGetData(somSelf);
+  SOMTMethodEntryCMethodDebug("SOMTMethodEntryC","_get_somtIsPrivateMethod");
+
+  return FALSE;
+}
+
+SOM_Scope SOMTStructEntryC * SOMLINK somtGetNextException(SOMTMethodEntryC * somSelf)
+{
+  SOMTMethodEntryCData *somThis = SOMTMethodEntryCGetData(somSelf);
+  SOMTMethodEntryCMethodDebug("SOMTMethodEntryC","somtGetNextException");
+
+  return NULL;
+}
+
+SOM_Scope short SOMLINK _get_somtArgCount(SOMTMethodEntryC * somSelf)
+{
+  SOMTMethodEntryCData *somThis = SOMTMethodEntryCGetData(somSelf);
+  SOMTMethodEntryCMethodDebug("SOMTMethodEntryC","_get_somtArgCount");
+
+  return 0;
+}
+
+SOM_Scope string SOMLINK _get_somtCReturnType(SOMTMethodEntryC * somSelf)
+{
+  SOMTMethodEntryCData *somThis = SOMTMethodEntryCGetData(somSelf);
+  SOMTMethodEntryCMethodDebug("SOMTMethodEntryC","_get_somtCReturnType");
+
+  return NULL;
+}
+
+SOM_Scope SOMTStructEntryC * SOMLINK somtGetFirstException(SOMTMethodEntryC * somSelf)
+{
+  SOMTMethodEntryCData *somThis = SOMTMethodEntryCGetData(somSelf);
+  SOMTMethodEntryCMethodDebug("SOMTMethodEntryC","somtGetFirstException");
+
+  return NULL;
+}
+
+SOM_Scope SOMTClassEntryC * SOMLINK _get_somtOriginalClass(SOMTMethodEntryC * somSelf)
+{
+  SOMTMethodEntryCData *somThis = SOMTMethodEntryCGetData(somSelf);
+  SOMTMethodEntryCMethodDebug("SOMTMethodEntryC","_get_somtOriginalClass");
+
+  return NULL;
+}
+
+SOM_Scope string SOMLINK somtGetFullParamNameList(SOMTMethodEntryC * somSelf,
+                                                  /* in */ string buffer,
+                                                  /* in */ string varargsParm)
+{
+  SOMTMethodEntryCData *somThis = SOMTMethodEntryCGetData(somSelf);
+  SOMTMethodEntryCMethodDebug("SOMTMethodEntryC","somtGetFullParamNameList");
+
+  return NULL;
+}
+
diff -urN somfree\some\src\scmodule.cpp newsomfree3\some\src\scmodule.cpp
--- somfree\some\src\scmodule.cpp	Thu Jan 01 07:00:00 1970
+++ newsomfree3\some\src\scmodule.cpp	Sat Mar 16 14:09:26 2024
@@ -0,0 +1,190 @@
+/**************************************************************************
+ *
+ *  Copyright 2014, 2017 Yuri Prokushev
+ *
+ *  This file is part of osFree project
+ *
+ *  This program is free software: you can redistribute it and/or modify it
+ *  under the terms of the GNU Lesser General Public License as published by the
+ *  Free Software Foundation, either version 3 of the License, or (at your
+ *  option) any later version.
+ * 
+ *  This program is distributed in the hope that it will be useful, but WITHOUT
+ *  ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ *  FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for
+ *  more details.
+ *
+ *  You should have received a copy of the GNU Lesser General Public License
+ *  along with this program.  If not, see <http://www.gnu.org/licenses/>
+ *
+ */
+
+#ifndef SOM_Module_scmodule_Source
+#define SOM_Module_scmodule_Source
+#endif
+
+#define SOMTModuleEntryC_Class_Source
+
+#include "scmodule.xih"
+
+SOM_Scope SOMTEnumEntryC * SOMLINK somtGetNextModuleEnum(SOMTModuleEntryC * somSelf)
+{
+  SOMTModuleEntryCData *somThis = SOMTModuleEntryCGetData(somSelf);
+  SOMTModuleEntryCMethodDebug("SOMTModuleEntryC","somtGetNextModuleEnum");
+
+  return NULL;
+}
+
+SOM_Scope SOMTModuleEntryC * SOMLINK _get_somtOuterModule(SOMTModuleEntryC * somSelf)
+{
+  SOMTModuleEntryCData *somThis = SOMTModuleEntryCGetData(somSelf);
+  SOMTModuleEntryCMethodDebug("SOMTModuleEntryC","_get_somtOuterModule");
+
+  return NULL;
+}
+
+SOM_Scope SOMTConstEntryC * SOMLINK somtGetNextModuleConstant(SOMTModuleEntryC * somSelf)
+{
+  SOMTModuleEntryCData *somThis = SOMTModuleEntryCGetData(somSelf);
+  SOMTModuleEntryCMethodDebug("SOMTModuleEntryC","somtGetNextModuleConstant");
+
+  return NULL;
+}
+
+SOM_Scope SOMTStructEntryC * SOMLINK somtGetNextModuleStruct(SOMTModuleEntryC * somSelf)
+{
+  SOMTModuleEntryCData *somThis = SOMTModuleEntryCGetData(somSelf);
+  SOMTModuleEntryCMethodDebug("SOMTModuleEntryC","somtGetNextModuleStruct");
+
+  return NULL;
+}
+
+SOM_Scope SOMTClassEntryC * SOMLINK somtGetNextInterface(SOMTModuleEntryC * somSelf)
+{
+  SOMTModuleEntryCData *somThis = SOMTModuleEntryCGetData(somSelf);
+  SOMTModuleEntryCMethodDebug("SOMTModuleEntryC","somtGetNextInterface");
+
+  return NULL;
+}
+
+SOM_Scope SOMTSequenceEntryC * SOMLINK somtGetNextModuleSequence(SOMTModuleEntryC * somSelf)
+{
+  SOMTModuleEntryCData *somThis = SOMTModuleEntryCGetData(somSelf);
+  SOMTModuleEntryCMethodDebug("SOMTModuleEntryC","somtGetNextModuleSequence");
+
+  return NULL;
+}
+
+SOM_Scope SOMTUnionEntryC * SOMLINK somtGetFirstModuleUnion(SOMTModuleEntryC * somSelf)
+{
+  SOMTModuleEntryCData *somThis = SOMTModuleEntryCGetData(somSelf);
+  SOMTModuleEntryCMethodDebug("SOMTModuleEntryC","somtGetFirstModuleUnion");
+
+  return NULL;
+}
+
+SOM_Scope SOMTEntryC * SOMLINK somtGetFirstModuleDef(SOMTModuleEntryC * somSelf)
+{
+  SOMTModuleEntryCData *somThis = SOMTModuleEntryCGetData(somSelf);
+  SOMTModuleEntryCMethodDebug("SOMTModuleEntryC","somtGetFirstModuleDef");
+
+  return NULL;
+}
+
+SOM_Scope SOMTModuleEntryC * SOMLINK somtGetNextModule(SOMTModuleEntryC * somSelf)
+{
+  SOMTModuleEntryCData *somThis = SOMTModuleEntryCGetData(somSelf);
+  SOMTModuleEntryCMethodDebug("SOMTModuleEntryC","somtGetNextModule");
+
+  return NULL;
+}
+
+SOM_Scope SOMTConstEntryC * SOMLINK somtGetFirstModuleConstant(SOMTModuleEntryC * somSelf)
+{
+  SOMTModuleEntryCData *somThis = SOMTModuleEntryCGetData(somSelf);
+  SOMTModuleEntryCMethodDebug("SOMTModuleEntryC","somtGetFirstModuleConstant");
+
+  return NULL;
+}
+
+SOM_Scope SOMTEntryC * SOMLINK somtGetNextModuleDef(SOMTModuleEntryC * somSelf)
+{
+  SOMTModuleEntryCData *somThis = SOMTModuleEntryCGetData(somSelf);
+  SOMTModuleEntryCMethodDebug("SOMTModuleEntryC","somtGetNextModuleDef");
+
+  return NULL;
+}
+
+SOM_Scope SOMTUnionEntryC * SOMLINK somtGetNextModuleUnion(SOMTModuleEntryC * somSelf)
+{
+  SOMTModuleEntryCData *somThis = SOMTModuleEntryCGetData(somSelf);
+  SOMTModuleEntryCMethodDebug("SOMTModuleEntryC","somtGetNextModuleUnion");
+
+  return NULL;
+}
+
+SOM_Scope SOMTModuleEntryC * SOMLINK somtGetFirstModule(SOMTModuleEntryC * somSelf)
+{
+  SOMTModuleEntryCData *somThis = SOMTModuleEntryCGetData(somSelf);
+  SOMTModuleEntryCMethodDebug("SOMTModuleEntryC","somtGetFirstModule");
+
+  return false;
+}
+
+SOM_Scope SOMTStructEntryC * SOMLINK somtGetFirstModuleStruct(SOMTModuleEntryC * somSelf)
+{
+  SOMTModuleEntryCData *somThis = SOMTModuleEntryCGetData(somSelf);
+  SOMTModuleEntryCMethodDebug("SOMTModuleEntryC","somtGetFirstModuleStruct");
+
+  return NULL;
+}
+
+SOM_Scope SOMTTypedefEntryC * SOMLINK somtGetFirstModuleTypedef(SOMTModuleEntryC * somSelf)
+{
+  SOMTModuleEntryCData *somThis = SOMTModuleEntryCGetData(somSelf);
+  SOMTModuleEntryCMethodDebug("SOMTModuleEntryC","somtGetFirstModuleTypedef");
+
+  return NULL;
+}
+
+SOM_Scope string SOMLINK _get_somtModuleFile(SOMTModuleEntryC * somSelf)
+{
+  SOMTModuleEntryCData *somThis = SOMTModuleEntryCGetData(somSelf);
+  SOMTModuleEntryCMethodDebug("SOMTModuleEntryC","_get_somtModuleFile");
+
+  return NULL;
+}
+
+SOM_Scope SOMTSequenceEntryC * SOMLINK somtGetFirstModuleSequence(SOMTModuleEntryC * somSelf)
+{
+  SOMTModuleEntryCData *somThis = SOMTModuleEntryCGetData(somSelf);
+  SOMTModuleEntryCMethodDebug("SOMTModuleEntryC","somtGetFirstModuleSequence");
+
+  return NULL;
+}
+
+SOM_Scope SOMTEnumEntryC * SOMLINK somtGetFirstModuleEnum(SOMTModuleEntryC * somSelf)
+{
+  SOMTModuleEntryCData *somThis = SOMTModuleEntryCGetData(somSelf);
+  SOMTModuleEntryCMethodDebug("SOMTModuleEntryC","somtGetFirstModuleEnum");
+
+  return NULL;
+}
+
+SOM_Scope SOMTTypedefEntryC * SOMLINK somtGetNextModuleTypedef(SOMTModuleEntryC * somSelf)
+{
+  SOMTModuleEntryCData *somThis = SOMTModuleEntryCGetData(somSelf);
+  SOMTModuleEntryCMethodDebug("SOMTModuleEntryC","somtGetNextModuleTypedef");
+
+  return NULL;
+}
+
+SOM_Scope SOMTClassEntryC * SOMLINK somtGetFirstInterface(SOMTModuleEntryC * somSelf)
+{
+  SOMTModuleEntryCData *somThis = SOMTModuleEntryCGetData(somSelf);
+  SOMTModuleEntryCMethodDebug("SOMTModuleEntryC","somtGetFirstInterface");
+
+  return NULL;
+}
+
+
diff -urN somfree\some\src\scparm.cpp newsomfree3\some\src\scparm.cpp
--- somfree\some\src\scparm.cpp	Thu Jan 01 07:00:00 1970
+++ newsomfree3\some\src\scparm.cpp	Sat Mar 16 14:09:26 2024
@@ -0,0 +1,89 @@
+/**************************************************************************
+ *
+ *  Copyright 2018 Yuri Prokushev
+ *
+ *  This file is part of osFree project
+ *
+ *  This program is free software: you can redistribute it and/or modify it
+ *  under the terms of the GNU Lesser General Public License as published by the
+ *  Free Software Foundation, either version 3 of the License, or (at your
+ *  option) any later version.
+ * 
+ *  This program is distributed in the hope that it will be useful, but WITHOUT
+ *  ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ *  FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for
+ *  more details.
+ *
+ *  You should have received a copy of the GNU Lesser General Public License
+ *  along with this program.  If not, see <http://www.gnu.org/licenses/>
+ *
+ */
+
+#ifndef SOM_Module_scparm_Source
+#define SOM_Module_scparm_Source
+#endif
+
+#define SOMTParameterEntryC_Class_Source
+
+#define __PRIVATE__
+#include <rhbopt.h>
+#include <stdio.h>
+#include <string.h>
+#include <stdlib.h>
+#include "rhbsc.h"
+
+#include "scparm.xih"
+
+SOM_Scope long SOMLINK somtSetSymbolsOnEntry(SOMTParameterEntryC SOMSTAR somSelf,
+	                                           /* in */ SOMTEmitC SOMSTAR emitter,
+	                                           /* in */ string prefix)
+{
+//  char buf[250];
+  
+  SOMTParameterEntryCData *somThis = SOMTParameterEntryCGetData(somSelf);
+  SOMTParameterEntryCMethodDebug("SOMTParameterEntryC","somtSetSymbolsOnEntry");
+  
+  SOMTTemplateOutputC *templ = emitter->_get_somtTemplate();
+
+  SOMTParameterEntryC_parent_SOMTCommonEntryC_somtSetSymbolsOnEntry(somSelf, emitter, prefix);
+//  RHBattribute *c=somSelf->_get_somtEntryStruct()->data->is_attribute();
+  
+//  RHBtype *t=c->attribute_type->is_base_type();
+
+//  buf[0]=0;
+//  strcat(buf, prefix);
+//  templ->somtSetSymbolCopyBoth(strcat(buf, "BaseType"), c->attribute_type->id);
+
+// чфхё№ эрфю юЄЁрсюЄрЄ№ фхъырЁрЄюЁ√  
+  return 1;
+}
+
+
+SOM_Scope void SOMLINK somDumpSelfInt(SOMTParameterEntryC * somSelf,
+                                      /* in */ long level)
+{
+  SOMTParameterEntryCData *somThis = SOMTParameterEntryCGetData(somSelf);
+  SOMTParameterEntryCMethodDebug("SOMTParameterEntryC","somDumpSelfInt");
+
+
+}
+
+SOM_Scope string SOMLINK _get_somtCParameterDeclaration(SOMTParameterEntryC SOMSTAR somSelf)
+{
+  return NULL;
+}
+
+SOM_Scope string SOMLINK _get_somtIDLParameterDeclaration(SOMTParameterEntryC SOMSTAR somSelf)
+{
+  return NULL;
+}
+
+SOM_Scope string SOMLINK _get_somtPascalParameterDeclaration(SOMTParameterEntryC SOMSTAR somSelf)
+{
+  return NULL;
+}
+
+SOM_Scope somtParameterDirectionT SOMLINK _get_somtParameterDirection(SOMTParameterEntryC SOMSTAR somSelf)
+{
+  return somtInOutE;  
+}
diff -urN somfree\some\src\scpass.cpp newsomfree3\some\src\scpass.cpp
--- somfree\some\src\scpass.cpp	Thu Jan 01 07:00:00 1970
+++ newsomfree3\some\src\scpass.cpp	Sat Mar 16 14:09:26 2024
@@ -0,0 +1,70 @@
+/**************************************************************************
+ *
+ *  Copyright 2015, 2017 Yuri Prokushev
+ *
+ *  This file is part of osFree project
+ *
+ *  This program is free software: you can redistribute it and/or modify it
+ *  under the terms of the GNU Lesser General Public License as published by the
+ *  Free Software Foundation, either version 3 of the License, or (at your
+ *  option) any later version.
+ * 
+ *  This program is distributed in the hope that it will be useful, but WITHOUT
+ *  ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ *  FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for
+ *  more details.
+ *
+ *  You should have received a copy of the GNU Lesser General Public License
+ *  along with this program.  If not, see <http://www.gnu.org/licenses/>
+ *
+ */
+
+#ifndef SOM_Module_scpass_Source
+#define SOM_Module_scpass_Source
+#endif
+
+#define SOMTPassthruEntryC_Class_Source
+
+#include "scpass.xih"
+
+SOM_Scope long SOMLINK somtSetSymbolsOnEntry(SOMTPassthruEntryC SOMSTAR somSelf,
+	                                           /* in */ SOMTEmitC SOMSTAR emitter,
+	                                           /* in */ string prefix)
+{
+  SOMTPassthruEntryCData *somThis = SOMTPassthruEntryCGetData(somSelf);
+  SOMTPassthruEntryCMethodDebug("SOMTPassthruEntryC","somtSetSymbolsOnEntry");
+
+  return 0;
+}
+
+SOM_Scope string SOMLINK _get_somtPassthruTarget(SOMTPassthruEntryC SOMSTAR somSelf)
+{
+  SOMTPassthruEntryCData *somThis = SOMTPassthruEntryCGetData(somSelf);
+  SOMTPassthruEntryCMethodDebug("SOMTPassthruEntryC","_get_somtPassthruTarget");
+
+  return NULL;
+}
+
+SOM_Scope string SOMLINK _get_somtPassthruBody(SOMTPassthruEntryC SOMSTAR somSelf)
+{
+  SOMTPassthruEntryCData *somThis = SOMTPassthruEntryCGetData(somSelf);
+  SOMTPassthruEntryCMethodDebug("SOMTPassthruEntryC","_get_somtPassthruBody");
+
+  return NULL;
+}
+
+SOM_Scope string SOMLINK _get_somtPassthruLanguage(SOMTPassthruEntryC SOMSTAR somSelf)
+{
+  SOMTPassthruEntryCData *somThis = SOMTPassthruEntryCGetData(somSelf);
+  SOMTPassthruEntryCMethodDebug("SOMTPassthruEntryC","_get_somtPassthruLanguage");
+
+  return NULL;
+}
+
+SOM_Scope boolean SOMLINK somtIsBeforePassthru(SOMTPassthruEntryC SOMSTAR somSelf)
+{
+  SOMTPassthruEntryCData *somThis = SOMTPassthruEntryCGetData(somSelf);
+  SOMTPassthruEntryCMethodDebug("SOMTPassthruEntryC","somtIsBeforePassthru");
+
+  return FALSE;
+}
diff -urN somfree\some\src\scseqnce.cpp newsomfree3\some\src\scseqnce.cpp
--- somfree\some\src\scseqnce.cpp	Thu Jan 01 07:00:00 1970
+++ newsomfree3\some\src\scseqnce.cpp	Sat Mar 16 14:09:27 2024
@@ -0,0 +1,79 @@
+/**************************************************************************
+ *
+ *  Copyright 2018 Yuri Prokushev
+ *
+ *  This file is part of osFree project
+ *
+ *  This program is free software: you can redistribute it and/or modify it
+ *  under the terms of the GNU Lesser General Public License as published by the
+ *  Free Software Foundation, either version 3 of the License, or (at your
+ *  option) any later version.
+ * 
+ *  This program is distributed in the hope that it will be useful, but WITHOUT
+ *  ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ *  FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for
+ *  more details.
+ *
+ *  You should have received a copy of the GNU Lesser General Public License
+ *  along with this program.  If not, see <http://www.gnu.org/licenses/>
+ *
+ */
+
+#ifndef SOM_Module_scseqnce_Source
+#define SOM_Module_scseqnce_Source
+#endif
+
+#define SOMTSequenceEntryC_Class_Source
+
+#define __PRIVATE__
+#include <rhbopt.h>
+#include <stdio.h>
+#include <string.h>
+#include <stdlib.h>
+#include "rhbsc.h"
+
+#include "scseqnce.xih"
+
+SOM_Scope long SOMLINK somtSetSymbolsOnEntry(SOMTSequenceEntryC SOMSTAR somSelf,
+	/* in */ SOMTEmitC SOMSTAR emitter,
+	/* in */ string prefix)
+{
+//  char buf[250];
+  
+  SOMTSequenceEntryCData *somThis = SOMTSequenceEntryCGetData(somSelf);
+  SOMTSequenceEntryCMethodDebug("SOMTSequenceEntryC","somtSetSymbolsOnEntry");
+  
+  SOMTTemplateOutputC *templ = emitter->_get_somtTemplate();
+
+  SOMTSequenceEntryC_parent_SOMTEntryC_somtSetSymbolsOnEntry(somSelf, emitter, prefix);
+//  RHBattribute *c=somSelf->_get_somtEntryStruct()->data->is_attribute();
+  
+//  RHBtype *t=c->attribute_type->is_base_type();
+
+//  buf[0]=0;
+//  strcat(buf, prefix);
+//  templ->somtSetSymbolCopyBoth(strcat(buf, "BaseType"), c->attribute_type->id);
+
+// чфхё№ эрфю юЄЁрсюЄрЄ№ фхъырЁрЄюЁ√  
+  return 1;
+}
+
+
+SOM_Scope void SOMLINK somDumpSelfInt(SOMTSequenceEntryC SOMSTAR somSelf,
+                                      /* in */ long level)
+{
+  SOMTSequenceEntryCData *somThis = SOMTSequenceEntryCGetData(somSelf);
+  SOMTSequenceEntryCMethodDebug("SOMTSequenceEntryC","somDumpSelfInt");
+
+
+}
+
+SOM_Scope SOMTEntryC SOMSTAR SOMLINK _get_somtSeqType(SOMTSequenceEntryC SOMSTAR somSelf)
+{
+  return NULL;
+}
+
+SOM_Scope long SOMLINK _get_somtSeqLength(SOMTSequenceEntryC SOMSTAR somSelf)
+{
+  return 0;
+}
diff -urN somfree\some\src\scstring.cpp newsomfree3\some\src\scstring.cpp
--- somfree\some\src\scstring.cpp	Thu Jan 01 07:00:00 1970
+++ newsomfree3\some\src\scstring.cpp	Sat Mar 16 14:09:27 2024
@@ -0,0 +1,77 @@
+/**************************************************************************
+ *
+ *  Copyright 2018 Yuri Prokushev
+ *
+ *  This file is part of osFree project
+ *
+ *  This program is free software: you can redistribute it and/or modify it
+ *  under the terms of the GNU Lesser General Public License as published by the
+ *  Free Software Foundation, either version 3 of the License, or (at your
+ *  option) any later version.
+ * 
+ *  This program is distributed in the hope that it will be useful, but WITHOUT
+ *  ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ *  FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for
+ *  more details.
+ *
+ *  You should have received a copy of the GNU Lesser General Public License
+ *  along with this program.  If not, see <http://www.gnu.org/licenses/>
+ *
+ */
+
+#ifndef SOM_Module_scstring_Source
+#define SOM_Module_scstring_Source
+#endif
+
+#define SOMTStringEntryC_Class_Source
+
+#define __PRIVATE__
+#include <rhbopt.h>
+#include <stdio.h>
+#include <string.h>
+#include <stdlib.h>
+#include "rhbsc.h"
+
+#include "scstring.xih"
+
+SOM_Scope long SOMLINK somtSetSymbolsOnEntry(SOMTStringEntryC SOMSTAR somSelf,
+	                                           /* in */ SOMTEmitC SOMSTAR emitter,
+	                                           /* in */ string prefix)
+{
+//  char buf[250];
+  
+  SOMTStringEntryCData *somThis = SOMTStringEntryCGetData(somSelf);
+  SOMTStringEntryCMethodDebug("SOMTStringEntryC","somtSetSymbolsOnEntry");
+  
+  SOMTTemplateOutputC *templ = emitter->_get_somtTemplate();
+
+  SOMTStringEntryC_parent_SOMTEntryC_somtSetSymbolsOnEntry(somSelf, emitter, prefix);
+//  RHBattribute *c=somSelf->_get_somtEntryStruct()->data->is_attribute();
+  
+//  RHBtype *t=c->attribute_type->is_base_type();
+
+//  buf[0]=0;
+//  strcat(buf, prefix);
+//  templ->somtSetSymbolCopyBoth(strcat(buf, "BaseType"), c->attribute_type->id);
+
+// чфхё№ эрфю юЄЁрсюЄрЄ№ фхъырЁрЄюЁ√  
+  return 1;
+}
+
+
+SOM_Scope void SOMLINK somDumpSelfInt(SOMTStringEntryC * somSelf,
+                                      /* in */ long level)
+{
+  SOMTStringEntryCData *somThis = SOMTStringEntryCGetData(somSelf);
+  SOMTStringEntryCMethodDebug("SOMTStringEntryC","somDumpSelfInt");
+
+
+}
+
+SOM_Scope long SOMLINK _get_somtStringLength(SOMTStringEntryC * somSelf)
+{
+  SOMTStringEntryCData *somThis = SOMTStringEntryCGetData(somSelf);
+  SOMTStringEntryCMethodDebug("SOMTStringEntryC","_get_somtStringLength");
+ 
+  return 0; 
+}
diff -urN somfree\some\src\scstruct.cpp newsomfree3\some\src\scstruct.cpp
--- somfree\some\src\scstruct.cpp	Thu Jan 01 07:00:00 1970
+++ newsomfree3\some\src\scstruct.cpp	Sat Mar 16 14:09:27 2024
@@ -0,0 +1,73 @@
+/**************************************************************************
+ *
+ *  Copyright 2015, 2017 Yuri Prokushev
+ *
+ *  This file is part of osFree project
+ *
+ *  This program is free software: you can redistribute it and/or modify it
+ *  under the terms of the GNU Lesser General Public License as published by the
+ *  Free Software Foundation, either version 3 of the License, or (at your
+ *  option) any later version.
+ * 
+ *  This program is distributed in the hope that it will be useful, but WITHOUT
+ *  ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ *  FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for
+ *  more details.
+ *
+ *  You should have received a copy of the GNU Lesser General Public License
+ *  along with this program.  If not, see <http://www.gnu.org/licenses/>
+ *
+ */
+
+#ifndef SOM_Module_scstruct_Source
+#define SOM_Module_scstruct_Source
+#endif
+
+#define SOMTStructEntryC_Class_Source
+
+#include "scstruct.xih"
+#include <scemit.xh>
+#include <sctdef.xh>
+#include <scclass.xh>
+
+SOM_Scope long SOMLINK somtSetSymbolsOnEntry(SOMTStructEntryC SOMSTAR somSelf,
+	                                           /* in */ SOMTEmitC SOMSTAR emitter,
+	                                           /* in */ string prefix)
+{
+  SOMTStructEntryCData *somThis = SOMTStructEntryCGetData(somSelf);
+  SOMTStructEntryCMethodDebug("SOMTStructEntryC","somtSetSymbolsOnEntry");
+
+  return 0;
+}
+
+SOM_Scope SOMTTypedefEntryC SOMSTAR SOMLINK somtGetNextMember(SOMTStructEntryC SOMSTAR somSelf)
+{
+  SOMTStructEntryCData *somThis = SOMTStructEntryCGetData(somSelf);
+  SOMTStructEntryCMethodDebug("SOMTStructEntryC","somtGetNextMember");
+
+  return NULL;
+}
+
+SOM_Scope boolean SOMLINK _get_somtIsException(SOMTStructEntryC SOMSTAR somSelf)
+{
+  SOMTStructEntryCData *somThis = SOMTStructEntryCGetData(somSelf);
+  SOMTStructEntryCMethodDebug("SOMTStructEntryC","_get_somtIsException");
+
+  return FALSE;
+}
+
+SOM_Scope SOMTTypedefEntryC SOMSTAR SOMLINK somtGetFirstMember(SOMTStructEntryC SOMSTAR somSelf)
+{
+  SOMTStructEntryCData *somThis = SOMTStructEntryCGetData(somSelf);
+  SOMTStructEntryCMethodDebug("SOMTStructEntryC","somtGetFirstMember");
+
+  return NULL;
+}
+
+SOM_Scope SOMTClassEntryC SOMSTAR SOMLINK _get_somtStructClass(SOMTStructEntryC SOMSTAR somSelf)
+{
+  SOMTStructEntryCData *somThis = SOMTStructEntryCGetData(somSelf);
+  SOMTStructEntryCMethodDebug("SOMTStructEntryC","_get_somtStructClass");
+
+  return NULL;
+}
diff -urN somfree\some\src\sctdef.cpp newsomfree3\some\src\sctdef.cpp
--- somfree\some\src\sctdef.cpp	Thu Jan 01 07:00:00 1970
+++ newsomfree3\some\src\sctdef.cpp	Sat Mar 16 14:09:27 2024
@@ -0,0 +1,77 @@
+/**************************************************************************
+ *
+ *  Copyright 2015, 2017 Yuri Prokushev
+ *
+ *  This file is part of osFree project
+ *
+ *  This program is free software: you can redistribute it and/or modify it
+ *  under the terms of the GNU Lesser General Public License as published by the
+ *  Free Software Foundation, either version 3 of the License, or (at your
+ *  option) any later version.
+ * 
+ *  This program is distributed in the hope that it will be useful, but WITHOUT
+ *  ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ *  FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for
+ *  more details.
+ *
+ *  You should have received a copy of the GNU Lesser General Public License
+ *  along with this program.  If not, see <http://www.gnu.org/licenses/>
+ *
+ */
+
+#ifndef SOM_Module_sctdef_Source
+#define SOM_Module_sctdef_Source
+#endif
+
+#define SOMTTypedefEntryC_Class_Source
+
+#define __PRIVATE__
+#include <rhbopt.h>
+#include <stdio.h>
+#include <string.h>
+#include <stdlib.h>
+#include "rhbsc.h"
+
+#include "sctdef.xih"
+
+SOM_Scope long SOMLINK somtSetSymbolsOnEntry(SOMTTypedefEntryC SOMSTAR somSelf,
+	                                           /* in */ SOMTEmitC SOMSTAR emitter,
+	                                           /* in */ string prefix)
+{
+  SOMTTypedefEntryCData *somThis = SOMTTypedefEntryCGetData(somSelf);
+  SOMTTypedefEntryCMethodDebug("SOMTTypedefEntryC","somtSetSymbolsOnEntry");
+  
+  return 0;
+}
+
+SOM_Scope SOMTEntryC SOMSTAR SOMLINK _get_somtTypedefType(SOMTTypedefEntryC SOMSTAR somSelf)
+{
+  SOMTTypedefEntryCData *somThis = SOMTTypedefEntryCGetData(somSelf);
+  SOMTTypedefEntryCMethodDebug("SOMTTypedefEntryC","_get_somtTypedefType");
+  
+  return NULL;
+}
+
+SOM_Scope SOMTCommonEntryC SOMSTAR SOMLINK somtGetNextDeclarator(SOMTTypedefEntryC SOMSTAR somSelf)
+{
+  SOMTTypedefEntryCData *somThis = SOMTTypedefEntryCGetData(somSelf);
+  SOMTTypedefEntryCMethodDebug("SOMTTypedefEntryC","somtGetNextDeclarator");
+  
+  return NULL;
+}
+
+SOM_Scope TypeCode SOMLINK _get_somtTypeCode(SOMTTypedefEntryC SOMSTAR somSelf)
+{
+  SOMTTypedefEntryCData *somThis = SOMTTypedefEntryCGetData(somSelf);
+  SOMTTypedefEntryCMethodDebug("SOMTTypedefEntryC","_get_somtTypeCode");
+  
+  return 0;
+}
+
+SOM_Scope SOMTCommonEntryC SOMSTAR SOMLINK somtGetFirstDeclarator(SOMTTypedefEntryC SOMSTAR somSelf)
+{
+  SOMTTypedefEntryCData *somThis = SOMTTypedefEntryCGetData(somSelf);
+  SOMTTypedefEntryCMethodDebug("SOMTTypedefEntryC","somtGetFirstDeclarator");
+  
+  return NULL;
+}
diff -urN somfree\some\src\sctmplt.cpp newsomfree3\some\src\sctmplt.cpp
--- somfree\some\src\sctmplt.cpp	Thu Jan 01 07:00:00 1970
+++ newsomfree3\some\src\sctmplt.cpp	Sat Mar 16 14:09:27 2024
@@ -0,0 +1,410 @@
+/**************************************************************************
+ *
+ *  Copyright 2015, 2017, 2022 Yuri Prokushev
+ *
+ *  This file is part of osFree project
+ *
+ *  This program is free software: you can redistribute it and/or modify it
+ *  under the terms of the GNU Lesser General Public License as published by the
+ *  Free Software Foundation, either version 3 of the License, or (at your
+ *  option) any later version.
+ * 
+ *  This program is distributed in the hope that it will be useful, but WITHOUT
+ *  ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ *  FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for
+ *  more details.
+ *
+ *  You should have received a copy of the GNU Lesser General Public License
+ *  along with this program.  If not, see <http://www.gnu.org/licenses/>
+ *
+ */
+
+#ifndef SOM_Module_sctmplt_Source
+#define SOM_Module_sctmplt_Source
+#endif
+
+#define SOMTTemplateOutputC_Class_Source
+
+#include "sctmplt.xih"
+
+#include <somstrt.xh>
+
+#include <emitlib.h>
+
+//@todo Need to add abstraction layer for file operations.
+// Problem is file opened and closed by somc.dll, but reading anywhere.
+// Solution - return bak aomtok* set of functions back to somc.dll as in som 2.1
+
+SOM_Scope string SOMLINK somtExpandSymbol(SOMTTemplateOutputC SOMSTAR somSelf,
+	                                        /* in */ string s,
+	                                        /* in */ string buf)
+{
+  SOMTTemplateOutputCData *somThis = SOMTTemplateOutputCGetData(somSelf);
+  SOMTTemplateOutputCMethodDebug("SOMTTemplateOutputC","somtExpandSymbol");
+  
+  return NULL;
+}                                          
+
+SOM_Scope void SOMLINK somtSetOutputFile(SOMTTemplateOutputC SOMSTAR somSelf,
+	                                       /* inout */ FILE *fp)
+{
+  SOMTTemplateOutputCData *somThis = SOMTTemplateOutputCGetData(somSelf);
+  SOMTTemplateOutputCMethodDebug("SOMTTemplateOutputC","somtSetOutputFile");
+  
+  _fp=fp;
+}                                          
+
+/****************************************************
+ *
+ * ─юсрты хЄ юяЁхфхыхэш  ёхъЎшщ шч сєЇхЁр defString
+ * 
+ */
+SOM_Scope void SOMLINK somtAddSectionDefinitions(SOMTTemplateOutputC SOMSTAR somSelf,
+	                                               /* in */ string defString)
+{
+  string line = NULL;
+  string section = NULL;
+  string content = NULL;
+  string m = NULL;
+  string buf = NULL;
+  SOMTTemplateOutputCData *somThis = SOMTTemplateOutputCGetData(somSelf);
+  SOMTTemplateOutputCMethodDebug("SOMTTemplateOutputC","somtAddSectionDefinitions");
+
+  buf = somtStrDup(defString);
+  line = strtok(buf, "\n");
+  while(line) {
+    // wait for colon in first column
+    if (strchr(line, ':')==line)
+    {
+      if (section) 
+      {
+        somSelf->somtSetSymbolCopyBoth(section, content);
+        SOMFree(content);
+        content=NULL;
+      }
+      section=line+1;
+    } else {
+      if (line[0]=='\\') line++;
+      if (content) 
+      {
+        m=(string)SOMMalloc(strlen(content)+strlen(line)+2);
+        sprintf(m, "%s%s\n", content, line);
+        SOMFree(content);
+        content=NULL;
+      } else {
+        m=(string)SOMMalloc(strlen(line)+2);
+        sprintf(m, "%s\n", line);
+      }
+      
+      content=m;
+    }
+    line  = strtok(NULL, "\n");
+  }
+
+  if (section) 
+  {
+    somSelf->somtSetSymbolCopyBoth(section, content);
+    SOMFree(content);
+    content=NULL;
+  }
+
+  SOMFree(buf);
+}
+
+SOM_Scope void SOMLINK somtSetSymbolCopyBoth(SOMTTemplateOutputC SOMSTAR somSelf,
+	                                           /* in */ string name,
+	                                           /* in */ string value)
+{
+  SOMTTemplateOutputCData *somThis = SOMTTemplateOutputCGetData(somSelf);
+  SOMTTemplateOutputCMethodDebug("SOMTTemplateOutputC","somtSetSymbolCopyBoth");
+
+  if (!name) return;
+  if (!strlen(name)) return;
+  _stab->somstAssociateCopyBoth(name, value);
+}
+                                             
+SOM_Scope void SOMLINK somtOutputSection(SOMTTemplateOutputC SOMSTAR somSelf,
+	                                       /* in */ string sectionName)
+{
+  SOMTTemplateOutputCData *somThis = SOMTTemplateOutputCGetData(somSelf);
+  SOMTTemplateOutputCMethodDebug("SOMTTemplateOutputC","somtOutputSection");
+
+  if (sectionName)
+  {
+    somSelf->somto(somSelf->somtGetSymbol(sectionName));
+  }
+}
+
+SOM_Scope string SOMLINK somtGetSymbol(SOMTTemplateOutputC SOMSTAR somSelf,
+	                                     /* in */ string name)
+{
+  SOMTTemplateOutputCData *somThis = SOMTTemplateOutputCGetData(somSelf);
+  SOMTTemplateOutputCMethodDebug("SOMTTemplateOutputC","somtGetSymbol");
+
+  if (name)
+  {
+    return _stab->somstGetAssociation(name);
+  }
+  else
+  {
+    return NULL;
+  }
+}
+
+SOM_Scope boolean SOMLINK somtCheckSymbol(SOMTTemplateOutputC SOMSTAR somSelf,
+	                                        /* in */ string name)
+{
+  string value=NULL;
+  SOMTTemplateOutputCData *somThis = SOMTTemplateOutputCGetData(somSelf);
+  SOMTTemplateOutputCMethodDebug("SOMTTemplateOutputC","somtCheckSymbol");
+  
+  if (!name) return FALSE;
+  value=somSelf->somtGetSymbol(name);
+  if (!value) return FALSE;
+  if (!strlen(value)) return FALSE;
+  return TRUE;
+}
+
+SOM_Scope void SOMLINK somtSetSymbol(SOMTTemplateOutputC SOMSTAR somSelf,
+	                                   /* in */ string name,
+	                                   /* in */ string value)
+{
+  SOMTTemplateOutputCData *somThis = SOMTTemplateOutputCGetData(somSelf);
+  SOMTTemplateOutputCMethodDebug("SOMTTemplateOutputC","somtSetSymbol");
+
+  if (name && value) _stab->somstAssociate(name, value);
+}
+
+/*********************************************************
+ *
+ * ╤ўшЄ√трхЄ юяЁхфхыхэш  ёхъЎшщ шч Їрщыр ш фюсры хЄ шї т ьрёёшт юяЁхфхыхэш  ёхъЎшщ
+ *
+ * !TODO: ═хЄ эшъръющ яЁютхЁъш, ўЄю тёх тыхчхЄ т т√фхыхээє■ ярь Є№. ═шъръшї яЁютхЁюъ
+ * эр ЁрчьхЁ√ ш ъюфшЁютъш...
+ *
+ * !TODO: ═хяюэ Єэю, ъръ юяЁхфхышЄ№ё , т ъръюь Ёхцшьх ЁрсюЄрхЄ fread яЁш юЄъЁ√Єшш 
+ * т Ёхцшьх !b. ┬шэфют√щ ЁрэЄрщь ьхэ хЄ \n\r эр \n ш тёх...
+ *
+ */
+
+SOM_Scope void SOMLINK somtReadSectionDefinitions(SOMTTemplateOutputC SOMSTAR somSelf,
+	                                                /* inout */ FILE *fp)
+{
+  size_t fsize=0;
+  size_t afsize=0;
+  string buffer = NULL;
+  SOMTTemplateOutputCData *somThis = SOMTTemplateOutputCGetData(somSelf);
+  SOMTTemplateOutputCMethodDebug("SOMTTemplateOutputC","somtReadSectionDefinitions");
+  
+  fseek(fp, 0, SEEK_END);
+  fsize = ftell(fp);
+  rewind(fp);
+
+  buffer = (string)SOMMalloc(fsize + 1);
+  memset (buffer, 0, fsize + 1);
+
+  afsize=fread(buffer, fsize, 1, fp);
+  *(buffer+fsize)  = 0;
+
+  somSelf->somtAddSectionDefinitions(buffer);
+  
+  SOMFree(buffer);
+}
+
+SOM_Scope void SOMLINK somto(SOMTTemplateOutputC SOMSTAR somSelf,
+	                           /* in */ string tmplt)
+{
+  string line;
+  string srcbuf;
+  char tagbuf[2048];
+  unsigned long tagpos=0;
+  char ch;
+  char *outline;
+  
+  SOMTTemplateOutputCData *somThis = SOMTTemplateOutputCGetData(somSelf);
+  SOMTTemplateOutputCMethodDebug("SOMTTemplateOutputC","somto");
+  
+  if (tmplt && tmplt[0])
+  {
+    memset (tagbuf,0,2048);
+    outline=(char *)SOMMalloc(MAX_OUTPUT_LINE_LENGTH);
+
+    // Search keys for substitution.
+    srcbuf = somtStrDup(tmplt);
+
+    line = strtok(srcbuf, "\n");
+    _conditionalLine=FALSE;
+    while(line) 
+    {
+      while (ch=*(line++))
+      {
+        if (ch=='?')
+        {
+          _conditionalLine=TRUE;
+          ch=*(line++);
+        }
+        switch (ch)
+        {
+          case '\\':
+            ch=*(line++);
+            switch (ch)
+            {
+              case 'n':
+                fputc('\n', _fp);
+                break;
+              case 'r':
+                fputc('\r', _fp);
+                break;
+              case 't':
+                fputc('\t', _fp);
+                break;
+              case 'a':
+                fputc(0x07, _fp);
+                break;
+              case 'b':
+                fputc(0x08, _fp);
+                break;
+              case 'f':
+                fputc(0x0c, _fp);
+                break;
+              case 'v':
+                fputc(0x0b, _fp);
+                break;
+              default:
+                fputc(ch, _fp);
+                break;
+            }
+            break;
+          case '<':
+            while ((ch=*(line++))!='>')
+            {
+              if (ch=='\\') tagpos++;
+              tagbuf[tagpos]=ch;
+              tagpos++;
+            }
+            
+            fputs(somSelf->somtGetSymbol(tagbuf), _fp);
+            memset (tagbuf,0,2048);
+            tagpos=0;
+            break;
+          default:
+            fputc(ch, _fp);
+            break;
+        }
+      }
+      fputc('\n', _fp);
+      line  = strtok(NULL, "\n");
+      _conditionalLine=FALSE;
+    }
+    SOMFree(srcbuf);
+    SOMFree(outline);
+  }
+}
+
+SOM_Scope void SOMLINK somtSetSymbolCopyValue(SOMTTemplateOutputC SOMSTAR somSelf,
+	                                            /* in */ string name,
+	                                            /* in */ string value)
+{
+  SOMTTemplateOutputCData *somThis = SOMTTemplateOutputCGetData(somSelf);
+  SOMTTemplateOutputCMethodDebug("SOMTTemplateOutputC","somtSetSymbolCopyValue");
+  
+  _stab->somstAssociateCopyValue(name, value);
+}
+
+// @todo add oidl style comments like # and ;
+SOM_Scope void SOMLINK somtOutputComment(SOMTTemplateOutputC SOMSTAR somSelf,
+	                                       /* in */ string comment)
+{
+  string line;
+  string buf;
+
+  SOMTTemplateOutputCData *somThis = SOMTTemplateOutputCGetData(somSelf);
+  SOMTTemplateOutputCMethodDebug("SOMTTemplateOutputC","somtOutputComment");
+
+  if (comment && comment[0])
+  {
+    if (comment[0]==0x01) // comment style passed in comment string
+    {
+      if(!_somtCommentStyle)  // if style 0 then style in comment string
+      {
+        _somtCommentStyle=(somtCommentStyleT)comment[0]; // @fix sure? or convert from oidl style comment? Can be checked on copyrightS
+      }
+      comment+=2;
+    }
+  
+    if (_somtCommentNewline) fprintf(_fp, "\n");
+    if (_somtCommentStyle==somtCBlockE) fprintf(_fp, "/*\n");
+    if (_somtCommentStyle==somtPBlockE) fprintf(_fp, "(*\n");
+    if (_somtCommentStyle==somtPBorlandE) fprintf(_fp, "{\n");
+  
+    buf = somtStrDup(comment);
+
+    line = strtok(buf, "\n");
+    while(line) 
+    {
+      switch (_somtCommentStyle)
+      {
+        case somtDashesE: fprintf(_fp, "-- %s\n", line);
+          break;
+        case somtCPPE: fprintf(_fp, "// %s\n", line);
+          break;
+        case somtCSimpleE: fprintf(_fp, "/* %s */\n", line);
+          break;
+        case somtCBlockE: fprintf(_fp, " *  %s\n", line);
+          break;
+        case somtPSimpleE: fprintf(_fp, "(* %s *)\n", line);
+          break;
+        case somtPBlockE: fprintf(_fp, " *  %s\n", line);
+          break;
+      }
+    
+      line  = strtok(NULL, "\n");
+    }
+    if (_somtCommentStyle==somtCBlockE) fprintf(_fp, " */\n");
+    if (_somtCommentStyle==somtPBlockE) fprintf(_fp, " *)\n");
+    if (_somtCommentStyle==somtPBorlandE) fprintf(_fp, "}\n");
+    SOMFree(buf);
+  }
+}
+
+SOM_Scope void SOMLINK somtSetSymbolCopyName(SOMTTemplateOutputC SOMSTAR somSelf,
+	                                           /* in */ string name,
+	                                           /* in */ string value)
+{
+  SOMTTemplateOutputCData *somThis = SOMTTemplateOutputCGetData(somSelf);
+  SOMTTemplateOutputCMethodDebug("SOMTTemplateOutputC","somtSetSymbolCopyName");
+  
+  _stab->somstAssociateCopyKey(name, value);
+}
+
+
+SOM_Scope void SOMLINK somDefaultInit(SOMTTemplateOutputC SOMSTAR somSelf, somInitCtrl *ctrl)
+{
+  SOMTTemplateOutputCData *somThis; // set by BeginInitializer 
+  somInitCtrl globalCtrl;
+  somBooleanVector myMask;
+  SOMTTemplateOutputCMethodDebug("SOMTTemplateOutputC", "somDefaultInit");
+  
+  SOMTTemplateOutputC_BeginInitializer_somDefaultInit;
+  SOMTTemplateOutputC_Init_SOMObject_somDefaultInit(somSelf, ctrl);
+  _stab=new SOMStringTableC();
+  _fp=stdout;
+  _somtLineLength=72;
+  _somtCommentNewline=FALSE;
+  _somtCommentStyle=somtDashesE;
+}
+
+SOM_Scope void SOMLINK somDestruct(SOMTTemplateOutputC *somSelf, octet doFree, somDestructCtrl* ctrl)
+{
+  SOMTTemplateOutputCData *somThis; /* set by BeginDestructor */
+  somDestructCtrl globalCtrl;
+  somBooleanVector myMask;
+  SOMTTemplateOutputCMethodDebug("SOMTTemplateOutputC","somDestruct");
+  SOMTTemplateOutputC_BeginDestructor;
+  /*
+  * local SOMTTemplateOutputC deinitialization code added by programmer
+  */
+  _stab->somFree();
+  
+  SOMTTemplateOutputC_EndDestructor;
+}
diff -urN somfree\some\src\scunion.cpp newsomfree3\some\src\scunion.cpp
--- somfree\some\src\scunion.cpp	Thu Jan 01 07:00:00 1970
+++ newsomfree3\some\src\scunion.cpp	Sat Mar 16 14:09:27 2024
@@ -0,0 +1,46 @@
+/**************************************************************************
+ *
+ *  Copyright 2015, 2017 Yuri Prokushev
+ *
+ *  This file is part of osFree project
+ *
+ *  This program is free software: you can redistribute it and/or modify it
+ *  under the terms of the GNU Lesser General Public License as published by the
+ *  Free Software Foundation, either version 3 of the License, or (at your
+ *  option) any later version.
+ * 
+ *  This program is distributed in the hope that it will be useful, but WITHOUT
+ *  ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ *  FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for
+ *  more details.
+ *
+ *  You should have received a copy of the GNU Lesser General Public License
+ *  along with this program.  If not, see <http://www.gnu.org/licenses/>
+ *
+ */
+
+#ifndef SOM_Module_scunion_Source
+#define SOM_Module_scunion_Source
+#endif
+
+#define SOMTUnionEntryC_Class_Source
+
+#include "scunion.xih"
+
+SOM_Scope long SOMLINK somtSetSymbolsOnEntry(SOMTUnionEntryC SOMSTAR somSelf,
+	                                           /* in */ SOMTEmitC SOMSTAR emitter,
+	                                           /* in */ string prefix)
+{
+  SOMTUnionEntryCData *somThis = SOMTUnionEntryCGetData(somSelf);
+  SOMTUnionEntryCMethodDebug("SOMTUnionEntryC","somtSetSymbolsOnEntry");
+  
+  return 0;
+}
+
+SOM_Scope SOMTEntryC SOMSTAR SOMLINK _get_somtSwitchType(SOMTUnionEntryC SOMSTAR somSelf)
+{
+  SOMTUnionEntryCData *somThis = SOMTUnionEntryCGetData(somSelf);
+  SOMTUnionEntryCMethodDebug("SOMTUnionEntryC","_get_somtSwitchType");
+  
+  return NULL;
+}
diff -urN somfree\some\src\scusrtyp.cpp newsomfree3\some\src\scusrtyp.cpp
--- somfree\some\src\scusrtyp.cpp	Thu Jan 01 07:00:00 1970
+++ newsomfree3\some\src\scusrtyp.cpp	Sat Mar 16 14:09:27 2024
@@ -0,0 +1,68 @@
+/**************************************************************************
+ *
+ *  Copyright 2018 Yuri Prokushev
+ *
+ *  This file is part of osFree project
+ *
+ *  This program is free software: you can redistribute it and/or modify it
+ *  under the terms of the GNU Lesser General Public License as published by the
+ *  Free Software Foundation, either version 3 of the License, or (at your
+ *  option) any later version.
+ * 
+ *  This program is distributed in the hope that it will be useful, but WITHOUT
+ *  ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ *  FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for
+ *  more details.
+ *
+ *  You should have received a copy of the GNU Lesser General Public License
+ *  along with this program.  If not, see <http://www.gnu.org/licenses/>
+ *
+ */
+
+#ifndef SOM_Module_scusrtyp_Source
+#define SOM_Module_scusrtyp_Source
+#endif
+
+#define SOMTStringEntryC_Class_Source
+
+#define __PRIVATE__
+#include <rhbopt.h>
+#include <stdio.h>
+#include <string.h>
+#include <stdlib.h>
+#include "rhbsc.h"
+
+#define SOMTUserDefinedTypeEntryC_Class_Source
+
+#include "scusrtyp.xih"
+
+SOM_Scope long SOMLINK somtSetSymbolsOnEntry(SOMTUserDefinedTypeEntryC SOMSTAR somSelf,
+	                                           /* in */ SOMTEmitC SOMSTAR emitter,
+	                                           /* in */ string prefix)
+{
+  SOMTUserDefinedTypeEntryCData *somThis = SOMTUserDefinedTypeEntryCGetData(somSelf);
+  SOMTUserDefinedTypeEntryCMethodDebug("SOMTUserDefinedTypeEntryC","somtSetSymbolsOnEntry");
+  
+  return 1;
+}
+
+
+SOM_Scope void SOMLINK somDumpSelfInt(SOMTUserDefinedTypeEntryC * somSelf,
+                                      /* in */ long level)
+{
+}
+
+SOM_Scope SOMTEntryC SOMSTAR SOMLINK _get_somtBaseTypeObj(SOMTUserDefinedTypeEntryC SOMSTAR somSelf)
+{
+  return NULL;
+}
+
+SOM_Scope SOMTTypedefEntryC SOMSTAR SOMLINK _get_somtOriginalTypedef(SOMTUserDefinedTypeEntryC SOMSTAR somSelf)
+{
+  return NULL;
+}
+
+SOM_Scope SOMTEntryC SOMSTAR SOMLINK _get_somtTypeObj(SOMTUserDefinedTypeEntryC SOMSTAR somSelf)
+{
+  return NULL;
+}
diff -urN somfree\some\src\scutil.cpp newsomfree3\some\src\scutil.cpp
--- somfree\some\src\scutil.cpp	Thu Jan 01 07:00:00 1970
+++ newsomfree3\some\src\scutil.cpp	Sat Mar 16 14:09:27 2024
@@ -0,0 +1,505 @@
+/**************************************************************************
+ *
+ *  Copyright 2014, 2017, 2022 Yuri Prokushev
+ *
+ *  This file is part of osFree project
+ *
+ *  This program is free software: you can redistribute it and/or modify it
+ *  under the terms of the GNU Lesser General Public License as published by the
+ *  Free Software Foundation, either version 3 of the License, or (at your
+ *  option) any later version.
+ * 
+ *  This program is distributed in the hope that it will be useful, but WITHOUT
+ *  ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ *  FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for
+ *  more details.
+ *
+ *  You should have received a copy of the GNU Lesser General Public License
+ *  along with this program.  If not, see <http://www.gnu.org/licenses/>
+ *
+ */
+
+
+#define __PRIVATE__
+#include <rhbopt.h>
+#include <stdio.h>
+#include <string.h>
+#include <stdlib.h>
+#include "rhbsc.h"
+#undef __PRIVATE__
+
+#include <scentry.xh>
+#include <scmodule.xh>
+#include <scclass.xh>
+#include <scunion.xh>
+#include <scattrib.xh>
+#include <scbase.xh>
+#include <sccommon.xh>
+#include <scconst.xh>
+#include <scdata.xh>
+#include <scenum.xh>
+#include <scenumnm.xh>
+#include <scmeta.xh>
+#include <scmethod.xh>
+#include <scparm.xh>
+#include <scpass.xh>
+#include <scseqnce.xh>
+#include <scstring.xh>
+#include <scstruct.xh>
+#include <sctdef.xh>
+#include <scusrtyp.xh>
+#include <emitlib.h>
+
+Stab objrefs;
+
+boolean registerobjref(SOMTEntryC * objref)
+{
+  return TRUE;
+}
+
+boolean registered(SOMTEntryC * objref)
+{
+  char buffer [50];
+
+  if (!objrefs.size)
+  {
+    somtcreateStab(&objrefs, 100, sizeof(SEntry));
+  }
+  sprintf (buffer, "%08p", objref);
+  return somtgetEntry(&objrefs, buffer)?TRUE:FALSE;
+}
+
+SOMEXTERN SOMTEntryC * SOMLINK somtGetObjectWrapper(Entry * ep)
+{
+  SOMTEntryC * objref;
+  if (ep)
+  {
+    if (ep->objref)
+    {
+      if (registered((SOMTEntryC *)(ep->objref)))
+      {
+        return (SOMTEntryC *)(ep->objref);
+      }
+    }
+
+    switch ( ep->type )
+    {
+      case SOMTArgumentE:
+        objref=(SOMTEntryC *)new SOMTParameterEntryC();
+        break;
+      case SOMTAttE:
+        objref=(SOMTEntryC *)new SOMTAttributeEntryC();
+        break;
+      case SOMTBadEntryE:
+        SOMError(SOM_Fatal, __FILE__, __LINE__);
+        break;
+      case SOMTBaseE:
+        objref=(SOMTEntryC *)new SOMTBaseClassEntryC();
+        break;
+      case SOMTClassE:
+        objref=(SOMTEntryC *)new SOMTClassEntryC();
+        break;
+      case SOMTConstE:
+        objref=(SOMTEntryC *)new SOMTConstEntryC();
+        break;
+      case SOMTDataE:
+        objref=(SOMTEntryC *)new SOMTDataEntryC();
+        break;
+      case SOMTEnumBE:
+        objref=(SOMTEntryC *)new SOMTEnumNameEntryC();
+        break;
+      case SOMTEnumE:
+      case SOMTEnumPE:
+        objref=(SOMTEntryC *)new SOMTEnumEntryC();
+        break;
+      case SOMTFloatBE:
+      case SOMTAnyBE:
+      case SOMTGroupE:
+      case SOMTCopyrightE:
+      case SOMTLongBE:
+      case SOMTNegativeBE:
+      case SOMTOctetBE:
+      case SOMTTypeCodeBE:
+      case SOMTBooleanBE:
+      case SOMTCaseEntryE:
+      case SOMTCaseListE:
+      case SOMTCaseSTME:
+      case SOMTCharBE:
+      case SOMTDclListE:
+      case SOMTDefaultE:
+      case SOMTDoubleBE:
+      case SOMTEBaseE:
+      case SOMTEEnumE:
+      case SOMTShortBE:
+      case SOMTStringBE:
+      case SOMTUnsignedLongBE:
+      case SOMTUnsignedShortBE:
+      case SOMTVoidBE:
+      case SOMTVoidPtrBE:
+        objref=(SOMTEntryC *)new SOMTEntryC();
+        break;
+      case SOMTMetaE:
+        objref=(SOMTEntryC *)new SOMTMetaClassEntryC();
+        break;
+      case SOMTModuleE:
+        objref=(SOMTEntryC *)new SOMTModuleEntryC();
+        break;
+      case SOMTNewMethodE:
+      case SOMTOverriddenMethodE:
+      case SOMTOverrideMethodE:
+        objref=(SOMTEntryC *)new SOMTMethodEntryC();
+        break;
+      case SOMTPassthruE:
+        objref=(SOMTEntryC *)new SOMTPassthruEntryC();
+        break;
+      case SOMTSequenceE:
+      case SOMTSequenceTDE:
+        objref=(SOMTEntryC *)new SOMTSequenceEntryC();
+        break;
+      case SOMTStringE:
+        objref=(SOMTEntryC *)new SOMTStringEntryC();
+        break;
+      case SOMTStructE:
+      case SOMTStructPE:
+      case SOMTStructSE:
+        objref=(SOMTEntryC *)new SOMTStructEntryC();
+        break;
+      case SOMTTyDclE:
+      case SOMTTypedefE:
+        objref=(SOMTEntryC *)new SOMTTypedefEntryC();
+        break;
+      case SOMTTypedefBE:
+        objref=(SOMTEntryC *)new SOMTUserDefinedTypeEntryC();
+        break;
+      case SOMTUnionE:
+      case SOMTUnionPE:
+      case SOMTUnionSE:
+        objref=(SOMTEntryC *)new SOMTUnionEntryC();
+        break;
+      case SOMTEmitterBeginE:
+        SOMError(SOM_Fatal, __FILE__, __LINE__);
+        break;
+      case SOMTEmitterEndE:
+        SOMError(SOM_Fatal, __FILE__, __LINE__);
+        break;
+      default:
+        SOMError(SOM_Fatal, __FILE__, __LINE__);
+    }
+    objref->somtSetEntryStruct(ep);
+    registerobjref((SOMTEntryC *)objref);
+    ep->objref=(Entry *)objref;
+  }
+  else
+  {
+    return NULL;
+  }
+
+  return (SOMTEntryC *)(ep->objref);
+}
+
+SOMEXTERN char * SOMLINK somtStrCat(int count,...)
+{
+  va_list args;
+  char * res;
+  int len=1;
+
+  va_start(args, count);
+
+  for (int i=0;i<count;i++)
+  {
+    len+=strlen(va_arg(args, char *));
+  }
+
+  va_end(args);
+
+  res=(char *)SOMMalloc(len);
+  res[0]=0;
+
+  va_start(args, count);
+
+  for (int i=0;i<count;i++)
+  {
+    res=strcat(res, va_arg(args, char *));
+  }
+
+  va_end(args);
+
+  return res;
+}
+
+void dumpMethodOrData(Entry * ep)
+{
+  somPrintf("\teptype = %08p\n", ep->u.m.eptype);
+  somPrintf("\tptrs = %08p\n", ep->u.m.ptrs);
+  somPrintf("\tarray = %08p\n", ep->u.m.array);
+  somPrintf("\tarrays = %s\n", ep->u.m.arrays);
+  somPrintf("\tdefn = %s\n", ep->u.m.defn);
+  somPrintf("\ttype = %s\n", ep->u.m.type);
+  somPrintf("\tvarargs = %s\n", ep->u.m.varargs ? "true" : "false");
+  somPrintf("\tprivate = %s\n", ep->u.m.isprivate ? "true" : "false");
+  somPrintf("\tinout = %d\n", ep->u.m.inoutmode);
+  somPrintf("\tselfref = %s\n", ep->u.m.isselfref ? "true" : "false");
+  somPrintf("\toneway = %s\n", ep->u.m.isoneway ? "true" : "false");
+  somPrintf("\targcnt = %d\n", ep->u.m.argcnt);
+  somPrintf("\targs = %08p\n", ep->u.m.args);
+  somPrintf("\tomethod = %08p\n", ep->u.m.omethod);
+  somPrintf("\toparent = %08p\n", ep->u.m.oparent);
+  somPrintf("\tgroup = %08p\n", ep->u.m.group);
+  somPrintf("\tnext = %08p\n", ep->u.m.next);
+  somPrintf("\tctxsa = %08p\n", ep->u.m.ctxsa);
+  somPrintf("\traiseslist = %08p\n", ep->u.m.raiseslist);
+}
+
+SOMEXTERN void SOMLINK somtShowEntry(Entry * ep)
+{
+  if (ep)
+  {
+    somPrintf("      somtShowEntry: Entry at %08p, name = %s, type = %d\n", ep, ep->name, ep->type);
+    somPrintf("\tlineno = %d\n", ep->lineno);
+    switch ( ep->type )
+    {
+      case SOMTAnyBE:
+        somPrintf("\t SOMTAnyBE\n");
+        break;
+      case     SOMTArgumentE:
+        somPrintf("\t SOMTArgumentE\n");
+        dumpMethodOrData(ep);
+        break;
+      case     SOMTAttE:
+        somPrintf("\t SOMTAttE\n");
+        break;
+      case     SOMTBadEntryE:
+        somPrintf("\t SOMTBadEntryE\n");
+        break;
+      case     SOMTBaseE:
+        somPrintf("\t SOMTBaseE\n");
+        somPrintf("\tparentdef = %08p\n", ep->u.p.parentdef);
+        break;
+      case     SOMTBooleanBE:
+        somPrintf("\t SOMTBooleanBE\n");
+        break;
+      case     SOMTCaseEntryE:
+        somPrintf("\t SOMTCaseEntryE\n");
+        break;
+      case     SOMTCaseListE:
+        somPrintf("\t SOMTCaseListE\n");
+        break;
+      case     SOMTCaseSTME:
+        somPrintf("\t SOMTCaseSTME\n");
+        break;
+      case     SOMTCharBE:
+        somPrintf("\t SOMTCharBE\n");
+        break;
+      case     SOMTClassE:
+        somPrintf("\tClass Definition Entry:\n");
+        somPrintf("\tfile = %s\n", ep->u.c.file);
+        somPrintf("\tmeta = %08p\n", ep->u.c.meta);
+        somPrintf("\tparent = %08p\n", ep->u.c.parent);
+        somPrintf("\tparents = %08p\n", ep->u.c.parents);
+        somPrintf("\trelease = %08p\n", ep->u.c.release);
+        somPrintf("\tpassthru = %08p\n", ep->u.c.passthrus);
+        somPrintf("\tdata = %08p\n", ep->u.c.data);
+        somPrintf("\ttc = %08p\n", ep->tc);
+        somPrintf("\tmethodcnt = %08d\n", ep->u.c.methodcnt);
+        somPrintf("\tmethods = %08p\n", ep->u.c.methods);
+        somPrintf("\tinherited = %08p\n", ep->u.c.inherited);
+        somPrintf("\tpubdefs = %08p\n", ep->u.c.pubdefs);
+        somPrintf("\tmod = %08p\n", ep->u.c.mod);
+        somPrintf("\tcls = %08p\n", ep->u.c.cls);
+        somPrintf("\tforward = %s\n", ep->u.c.isforward ? "true" : "false");
+        break;
+      case     SOMTConstE:
+        somPrintf("\t SOMTConstE\n");
+        break;
+      case     SOMTCopyrightE:
+        somPrintf("\t SOMTCopyrightE\n");
+        break;
+      case     SOMTDataE:
+        somPrintf("\t SOMTDataE\n");
+        dumpMethodOrData(ep);
+        break;
+      case     SOMTDclListE:
+        somPrintf("\t SOMTDclListE\n");
+        break;
+      case     SOMTDefaultE:
+        somPrintf("\t SOMTDefaultE\n");
+        break;
+      case     SOMTDoubleBE:
+        somPrintf("\t SOMTDoubleBE\n");
+        break;
+      case     SOMTEBaseE:
+        somPrintf("\t SOMTEBaseE\n");
+        break;
+      case     SOMTEEnumE:
+        somPrintf("\t SOMTEEnumE\n");
+        break;
+      case     SOMTEnumBE:
+        somPrintf("\t SOMTEnumBE\n");
+        break;
+      case     SOMTEnumE:
+        somPrintf("\t SOMTEnumE\n");
+        break;
+      case     SOMTEnumPE:
+        somPrintf("\t SOMTEnumPE\n");
+        break;
+      case     SOMTFloatBE:
+        somPrintf("\t SOMTFloatBE\n");
+        break;
+      case     SOMTGroupE:
+        somPrintf("\t SOMTGroupE\n");
+        break;
+      case     SOMTLongBE:
+        somPrintf("\t SOMTLongBE\n");
+        break;
+      case     SOMTMetaE:
+        somPrintf("\t SOMTMetaE\n");
+        break;
+      case     SOMTModuleE:
+        somPrintf("\t SOMTModuleE\n");
+        break;
+      case     SOMTNegativeBE:
+        somPrintf("\t SOMTNegativeBE\n");
+        break;
+      case     SOMTNewMethodE:
+        somPrintf("\t SOMTNewMethodE\n");
+        dumpMethodOrData(ep);
+        break;
+      case     SOMTOctetBE:
+        somPrintf("\t SOMTOctetBE\n");
+        break;
+      case     SOMTOverriddenMethodE:
+        somPrintf("\t SOMTOverriddenMethodE\n");
+        dumpMethodOrData(ep);
+        break;
+      case     SOMTOverrideMethodE:
+        somPrintf("\t SOMTOverrideMethodE\n");
+        dumpMethodOrData(ep);
+        break;
+      case     SOMTPassthruE:
+        somPrintf("\t SOMTPassthruE\n");
+        break;
+      case     SOMTSequenceE:
+        somPrintf("\t SOMTSequenceE\n");
+        break;
+      case     SOMTSequenceTDE:
+        somPrintf("\t SOMTSequenceTDE\n");
+        break;
+      case     SOMTShortBE:
+        somPrintf("\t SOMTShortBE\n");
+        break;
+      case     SOMTStringBE:
+        somPrintf("\t SOMTStringBE\n");
+        break;
+      case     SOMTStringE:
+        somPrintf("\t SOMTStringE\n");
+        break;
+      case     SOMTStructE:
+        somPrintf("\t SOMTStructE\n");
+        break;
+      case     SOMTStructPE:
+        somPrintf("\t SOMTStructPE\n");
+        break;
+      case     SOMTStructSE:
+        somPrintf("\t SOMTStructSE\n");
+        somPrintf("\tdcllist = %08p\n", ep->u.struc.dcllist);
+        somPrintf("\tcls = %08p\n", ep->u.struc.cls);
+        somPrintf("\texception = %s\n", ep->u.struc.isexcept ? "true" : "false");
+        somPrintf("\tmutref = %s\n", ep->u.struc.ismutref ? "true" : "false");
+        break;
+      case     SOMTTyDclE:
+        somPrintf("\t SOMTTyDclE\n");
+        break;
+      case     SOMTTypeCodeBE:
+        somPrintf("\t SOMTTypeCodeBE\n");
+        break;
+      case     SOMTTypedefBE:
+        somPrintf("\t SOMTTypedefBE\n");
+        dumpMethodOrData(ep);
+        break;
+      case     SOMTTypedefE:
+        somPrintf("\t SOMTTypedefE\n");
+        break;
+      case     SOMTUnionE:
+        somPrintf("\t SOMTUnionE\n");
+        break;
+      case     SOMTUnionPE:
+        somPrintf("\t SOMTUnionPE\n");
+        break;
+      case     SOMTUnionSE:
+        somPrintf("\t SOMTUnionSE\n");
+        break;
+      case     SOMTUnsignedLongBE:
+        somPrintf("\t SOMTUnsignedLongBE\n");
+        break;
+      case     SOMTUnsignedShortBE:
+        somPrintf("\t SOMTUnsignedShortBE\n");
+        break;
+      case     SOMTVoidBE:
+        somPrintf("\t SOMTVoidBE\n");
+        break;
+      case     SOMTVoidPtrBE:
+        somPrintf("\t SOMTVoidPtrBE\n");
+        dumpMethodOrData(ep);
+        break;
+  // This is special case SOMTTypes used on call of emitter start and emitter end
+  /*    case     SOMTEmitterBeginE:
+        result="SOMTEmitterBeginE";
+        break;
+      case     SOMTEmitterEndE:
+        result="SOMTEmitterEndE";
+        break; */
+      default:
+        somPrintf("Error: somtShowEntry, bad entry type of %d", ep->type);
+//        SOM_Error(SOM_Fatal, __FILE__, __LINE__);
+        SOMError(SOM_Fatal, __FILE__, __LINE__);
+    }
+  }
+  else 
+  {
+    somPrintf("somtShowEntry: NULL entry\n");
+  }
+}
+
+SOMEXTERN char * SOMLINK somtStrDup(char *str)
+{
+  return strcpy((char *)SOMMalloc(strlen(str)+1), str);
+}
+
+SOMEXTERN char * SOMLINK somtMakeIncludeStr(boolean local, char *stem, char *suffix)
+{
+  char * st;
+  char * en;
+  if (local)
+  {
+    en=st="\"";
+  }
+  else
+  {
+    st="<";
+    en=">";
+  }
+  return somtStrCat(5, st, stem, ".", suffix, en);
+}
+
+SOMEXTERN char * SOMLINK somtNewSymbol(char *prefix, char *stem)
+{
+  return strcat(strcpy((char *)SOMMalloc(strlen(prefix)+strlen(stem)+1), prefix), stem);
+}
+
+SOMEXTERN char * SOMLINK somtGetFileStem(char *fullName)
+{
+  char * res;
+  char * pt;
+  res=strcpy((char *)SOMMalloc(strlen(fullName)+1), fullName);
+  pt=strrchr(res, '.');
+  if (pt)
+  {
+    res[res-pt]=0;
+  }
+  return res;
+}
+
+SOMEXTERN char * SOMLINK somtEntryTypeName(SOMTTypes type)
+{
+  return somttypeSL(type);
+}
diff -urN somfree\some\src\somstrt.cpp newsomfree3\some\src\somstrt.cpp
--- somfree\some\src\somstrt.cpp	Thu Jan 01 07:00:00 1970
+++ newsomfree3\some\src\somstrt.cpp	Sat Mar 16 14:09:27 2024
@@ -0,0 +1,465 @@
+/**************************************************************************
+ *
+ *  Copyright 2015, 2017, 2022 Yuri Prokushev
+ *
+ *  This file is part of osFree project
+ *
+ *  This program is free software: you can redistribute it and/or modify it
+ *  under the terms of the GNU Lesser General Public License as published by the
+ *  Free Software Foundation, either version 3 of the License, or (at your
+ *  option) any later version.
+ * 
+ *  This program is distributed in the hope that it will be useful, but WITHOUT
+ *  ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ *  FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for
+ *  more details.
+ *
+ *  You should have received a copy of the GNU Lesser General Public License
+ *  along with this program.  If not, see <http://www.gnu.org/licenses/>
+ *
+ */
+
+#ifndef SOM_Module_somstrt_Source
+  #define SOM_Module_somstrt_Source
+#endif /* SOM_Module_somstrt_Source */
+
+#define SOMStringTableC_Class_Source
+
+#define __STDC_LIMIT_MACROS
+#define __STDC_CONSTANT_MACROS
+
+#include <stdint.h>
+#include <string.h>
+
+#define __PRIVATE__
+#include "rhbopt.h"
+#undef __PRIVATE__
+
+#include "somstrt.xih"
+
+typedef struct entryT {
+    string key;
+    string value;
+    entryT *next;
+} *tablePT;
+
+SOM_Scope short SOMLINK somstAssociate(SOMStringTableC SOMSTAR somSelf,
+                                       /* in */ string key,
+	                                     /* in */ string value)
+{
+  entryT *map;
+  SOMStringTableCData *somThis = SOMStringTableCGetData(somSelf);
+  SOMStringTableCMethodDebug("SOMStringTableC","somstAssociate");
+
+  if (!key) return 0;
+  //if (!strnlen(key, SIZE_MAX)) return 0;
+  if (!strlen(key)) return 0;
+  if (_numberOfEntries==ULONG_MAX) return 0;
+  
+  if(_table->key==NULL) 
+  {
+    _table->key=key;
+    _table->value=value;
+    _numberOfEntries++;
+    _table->next=NULL;
+    return 1;
+  }
+
+  for(map=_table;;map=map->next) 
+  {
+    if(!strncmp(key,map->key, SIZE_MAX)) 
+    {
+      map->value=value;
+      _numberOfEntries++;
+      return -1;
+    }
+
+    if(map->next==NULL) 
+    {
+      map->next=(struct entryT*)SOMMalloc(sizeof(struct entryT));
+      if(!map->next) return 0;
+      map=map->next;
+      map->key=key;
+      map->value=value;
+      _numberOfEntries++;
+      map->next=NULL;
+      return 1;
+    }
+  }
+};
+
+SOM_Scope boolean SOMLINK somstClearAssociation(SOMStringTableC SOMSTAR somSelf,
+	                                              /* in */ string key)
+{
+  struct entryT *map;
+  struct entryT *last;
+  unsigned long key_len=0;
+  SOMStringTableCData *somThis = SOMStringTableCGetData(somSelf);
+  SOMStringTableCMethodDebug("SOMStringTableC","somstClearAssociation");
+
+  if (!key) return NULL;
+  key_len=strlen(key);
+  if (!key_len) return NULL;
+
+  last=_table;
+
+  for(map=_table;map!=NULL;map=map->next) 
+  {
+    if(map->key && !strncmp(key,map->key, key_len+1)) 
+    {
+      if (map==_table)
+      {
+        _table=map->next;
+      } else {
+        last->next=map->next;
+      }
+      SOMFree(map);
+      _numberOfEntries--;
+      return TRUE;
+    } else {
+      last=map;
+    }
+  }
+  return FALSE;
+}                                                
+
+SOM_Scope short SOMLINK somstAssociateCopyBoth(SOMStringTableC SOMSTAR somSelf,
+	                                             /* in */ string key,
+	                                             /* in */ string value)
+{
+  entryT *map;
+  unsigned long value_len=0;
+  unsigned long key_len=0;
+  SOMStringTableCData *somThis = SOMStringTableCGetData(somSelf);
+  SOMStringTableCMethodDebug("SOMStringTableC","somstAssociateCopyBoth");
+  
+  if (!key) return 0;
+  //if (!strnlen(key, SIZE_MAX)) return 0;
+  if (!strlen(key)) return 0;
+  if (_numberOfEntries==ULONG_MAX) return 0;
+  //if (value) value_len=strnlen(value, SIZE_MAX);
+  if (value) value_len=strlen(value);
+  //key_len=strnlen(key, SIZE_MAX);
+  key_len=strlen(key);
+  
+  if(_table->key==NULL) 
+  {
+    _table->key=(string)SOMMalloc(key_len+1);
+    if(!_table->key) return 0;
+    strncpy(_table->key,key, key_len+1);
+    _table->value=(string)SOMMalloc(value_len+1);
+    if(!_table->value) return 0;
+    if (value)
+    {
+      strncpy(_table->value,value, value_len+1);
+    } else {
+      SOMFree(_table->value);
+    }
+    _numberOfEntries++;
+    _table->next=NULL;
+    return 1;
+  }
+
+  for(map=_table;;map=map->next) 
+  {
+    if(!strncmp(key,map->key, key_len+1)) 
+    {
+      if(map->value!=NULL) 
+      {
+        SOMFree(map->value);
+        map->value=(string)SOMMalloc(value_len+1);
+        if(!map->value) return 0;
+        if (value)
+        {
+          strncpy(map->value,value, value_len+1);
+        } else {
+          SOMFree(map->value);
+        }
+        _numberOfEntries++;
+        return -1;
+      }
+    }
+
+    if(map->next==NULL) 
+    {
+      map->next=(struct entryT*)SOMMalloc(sizeof(struct entryT));
+      if(!map->next) return 0;
+      map=map->next;
+      map->next=NULL;
+      map->key=(string)SOMMalloc(key_len+1);
+      if(!map->key) return 0;
+      strncpy(map->key,key, key_len+1);
+      map->value=(string)SOMMalloc(value_len+1);
+      if(!map->value) return 0;
+      if (value)
+      {
+        strncpy(map->value,value, value_len+1);
+      } else {
+        SOMFree(map->value);
+      }
+//      somPrintf("%s=%s\n", map->key, map->value);
+      _numberOfEntries++;
+      return 1;
+    }
+  }
+}
+
+SOM_Scope string SOMLINK somstGetIthValue(SOMStringTableC SOMSTAR somSelf,
+	                                        /* in */ unsigned long i)
+{
+  struct entryT *map;
+  unsigned long count = 0;
+  SOMStringTableCData *somThis = SOMStringTableCGetData(somSelf);
+  SOMStringTableCMethodDebug("SOMStringTableC","somstGetIthValue");
+
+  for(map=_table;map!=NULL;map=map->next) 
+  {
+    count++;
+    if(map->key && count==i) 
+    {
+      return map->value;
+    }
+  }
+  return NULL;
+}
+
+SOM_Scope string SOMLINK somstGetAssociation(SOMStringTableC SOMSTAR somSelf,
+	                                           /* in */ string key)
+{
+  struct entryT *map;
+  unsigned long key_len=0;
+  SOMStringTableCData *somThis = SOMStringTableCGetData(somSelf);
+  SOMStringTableCMethodDebug("SOMStringTableC","somstGetAssociation");
+
+  if (!key) return NULL;
+  //key_len=strnlen(key, SIZE_MAX);
+  key_len=strlen(key);
+  if (!key_len) return NULL;
+  for(map=_table;map!=NULL;map=map->next) 
+  {
+    if(map->key && !strncmp(key,map->key, key_len+1)) 
+    {
+//      somPrintf("%s=%s\n", key, map->value);
+      return map->value;
+    }
+  }
+  return NULL;
+}
+
+SOM_Scope string SOMLINK somstGetIthKey(SOMStringTableC SOMSTAR somSelf,
+	                                      /* in */ unsigned long i)
+{
+  struct entryT *map;
+  unsigned long count=0;
+  SOMStringTableCData *somThis = SOMStringTableCGetData(somSelf);
+  SOMStringTableCMethodDebug("SOMStringTableC","somstGetIthKey");
+
+  for(map=_table;map!=NULL;map=map->next) 
+  {
+    count++;
+    if(map->key && count==i) 
+    {
+      return map->key;
+    }
+  }
+  return NULL;
+}
+
+SOM_Scope void SOMLINK somDefaultInit(SOMStringTableC SOMSTAR somSelf, somInitCtrl *ctrl)
+{
+  SOMStringTableCData *somThis; /* set by BeginInitializer */
+  somInitCtrl globalCtrl;
+  somBooleanVector myMask;
+  SOMStringTableCMethodDebug("SOMStringTableC", "somDefaultInit");
+  
+  SOMStringTableC_BeginInitializer_somDefaultInit;
+  SOMStringTableC_Init_SOMObject_somDefaultInit(somSelf, ctrl);
+  
+  _table=(struct entryT *)SOMMalloc(sizeof(struct entryT));
+  if(!_table) return;
+  _table->key=NULL;
+  _table->value=NULL;
+  _table->next=NULL;
+  _tableSize=100;
+  _numberOfEntries=0;
+}
+
+SOM_Scope short SOMLINK somstAssociateCopyKey(SOMStringTableC SOMSTAR somSelf,
+	                                            /* in */ string key,
+	                                            /* in */ string value)
+{
+  entryT *map;
+  SOMStringTableCData *somThis = SOMStringTableCGetData(somSelf);
+  SOMStringTableCMethodDebug("SOMStringTableC","somstAssociateCopyKey");
+
+  if (!key) return 0;
+  //if (!strnlen(key, SIZE_MAX)) return 0;
+  if (!strlen(key)) return 0;
+  if (_numberOfEntries==ULONG_MAX) return 0;
+
+  if(_table->key==NULL) 
+  {
+    //_table->key=(string)SOMMalloc(strnlen(key, SIZE_MAX)+1);
+	_table->key=(string)SOMMalloc(strlen(key)+1);
+    if(!_table->key) return 0;
+    strncpy(_table->key,key, SIZE_MAX);
+    _table->value=value;
+    _numberOfEntries++;
+    _table->next=NULL;
+    return 1;
+  }
+
+  for(map=_table;;map=map->next) 
+  {
+    if(!strncmp(key,map->key, SIZE_MAX)) 
+    {
+      if(map->value!=NULL) 
+      {
+        map->value=value;
+        _numberOfEntries++;
+        return -1;
+      }
+    }
+
+    if(map->next==NULL) 
+    {
+      map->next=(struct entryT*)SOMMalloc(sizeof(struct entryT));
+      if(!map->next) return 0;
+      map=map->next;
+      //map->key=(string)SOMMalloc(strnlen(key, SIZE_MAX)+1);
+	  map->key=(string)SOMMalloc(strlen(key)+1);
+      if(!map->key) return 0;
+      strncpy(map->key,key, SIZE_MAX);
+      map->value=value;
+      _numberOfEntries++;
+      map->next=NULL;
+      return 1;
+    }
+  }
+}
+
+SOM_Scope unsigned long SOMLINK _get_somstTargetCapacity(SOMStringTableC SOMSTAR somSelf)
+{
+  SOMStringTableCData *somThis = SOMStringTableCGetData(somSelf);
+  SOMStringTableCMethodDebug("SOMStringTableC","_get_somstTargetCapacity");
+
+  return _tableSize;
+};
+
+
+SOM_Scope void SOMLINK _set_somstTargetCapacity(SOMStringTableC SOMSTAR somSelf,
+	                                              /* in */ unsigned long somstTargetCapacity)
+{
+  SOMStringTableCData *somThis = SOMStringTableCGetData(somSelf);
+  SOMStringTableCMethodDebug("SOMStringTableC","_set_somstTargetCapacity");
+
+  _tableSize=somstTargetCapacity;
+}
+
+SOM_Scope short SOMLINK somstAssociateCopyValue(SOMStringTableC SOMSTAR somSelf,
+	                                              /* in */ string key,
+	                                              /* in */ string value)
+{
+  entryT *map;
+  SOMStringTableCData *somThis = SOMStringTableCGetData(somSelf);
+  SOMStringTableCMethodDebug("SOMStringTableC","somstAssociateCopyValue");
+  
+  if (!key) return 0;
+  //if (!strnlen(key, SIZE_MAX)) return 0;
+  if (!strlen(key)) return 0;
+  if (_numberOfEntries==ULONG_MAX) return 0;
+
+  if(_table->key==NULL) 
+  {
+    _table->key=key;
+    //_table->value=(string)SOMMalloc(strnlen(value, SIZE_MAX)+1);
+	_table->value=(string)SOMMalloc(strlen(value)+1);
+    if(!_table->value) return 0;
+    strncpy(_table->value,value, SIZE_MAX);
+    _numberOfEntries++;
+    _table->next=NULL;
+    return 1;
+  }
+
+  for(map=_table;;map=map->next) 
+  {
+    if(!strncmp(key,map->key, SIZE_MAX)) 
+    {
+      if(map->value!=NULL) 
+      {
+        SOMFree(map->value);
+        //map->value=(string)SOMMalloc(strnlen(value, SIZE_MAX)+1);
+		map->value=(string)SOMMalloc(strlen(value)+1);
+        if(!map->value) return 0;
+        strncpy(map->value,value, SIZE_MAX);
+        _numberOfEntries++;
+        return -1;
+      }
+    }
+
+    if(map->next==NULL) 
+    {
+      map->next=(struct entryT*)SOMMalloc(sizeof(struct entryT));
+      if(!map->next) return 0;
+      map=map->next;
+      map->key=key;
+      //map->value=(string)SOMMalloc(strnlen(value, SIZE_MAX)+1);
+	  map->value=(string)SOMMalloc(strlen(value)+1);
+      if(!map->value) return 0;
+      strncpy(map->value,value, SIZE_MAX);
+      _numberOfEntries++;
+      map->next=NULL;
+      return 1;
+    }
+  }
+}
+	 
+SOM_Scope void SOMLINK somDestruct(SOMStringTableC *somSelf, octet doFree, somDestructCtrl* ctrl)
+{
+  struct entryT *m, *mp;
+  SOMStringTableCData *somThis; /* set by BeginDestructor */
+  somDestructCtrl globalCtrl;
+  somBooleanVector myMask;
+  SOMStringTableCMethodDebug("SOMStringTableC","somDestruct");
+  SOMStringTableC_BeginDestructor;
+  /*
+  * local SOMStringTableC deinitialization code added by programmer
+  */
+  if(!_table) return;
+  m=_table;
+  while(m!=NULL) 
+  {
+    if(m->key!=NULL) SOMFree(m->key);
+    if(m->value!=NULL) SOMFree(m->value);
+    mp=m;
+    m=m->next;
+    SOMFree(mp);
+  }
+  SOMFree(_table);
+  
+  SOMStringTableC_EndDestructor;
+}
+
+SOM_Scope void SOMLINK somDumpSelfInt(SOMStringTableC SOMSTAR somSelf, long level)
+{
+  struct entryT *m;
+  SOMStringTableCData *somThis = SOMStringTableCGetData(somSelf);
+  Environment *ev = somGetGlobalEnvironment();
+  SOMStringTableC_parent_SOMObject_somDumpSelfInt(somSelf, level);
+  
+  if(!_table) return;
+  m=_table;
+  while(m!=NULL) 
+  {
+    somLPrintf(level, "Key: %s Value: %s\n", m->key, m->value);
+    m=m->next;
+  }
+}
+
+SOM_Scope unsigned long SOMLINK _get_somstAssociationsCount(SOMStringTableC SOMSTAR somSelf)
+{
+  SOMStringTableCData *somThis = SOMStringTableCGetData(somSelf);
+  SOMStringTableCMethodDebug("SOMStringTableC","_get_somstAssociationsCount");
+
+  return _numberOfEntries;
+}
diff -urN somfree\some\win32\link386.c newsomfree3\some\win32\link386.c
--- somfree\some\win32\link386.c	Thu Jan 01 07:00:00 1970
+++ newsomfree3\some\win32\link386.c	Sat Mar 16 14:09:27 2024
@@ -0,0 +1,25 @@
+/**************************************************************************
+ *
+ *  Copyright 2008, Roger Brown
+ *
+ *  This file is part of Roger Brown's Toolkit.
+ *
+ *  This program is free software: you can redistribute it and/or modify it
+ *  under the terms of the GNU Lesser General Public License as published by the
+ *  Free Software Foundation, either version 3 of the License, or (at your
+ *  option) any later version.
+ * 
+ *  This program is distributed in the hope that it will be useful, but WITHOUT
+ *  ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ *  FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for
+ *  more details.
+ *
+ *  You should have received a copy of the GNU Lesser General Public License
+ *  along with this program.  If not, see <http://www.gnu.org/licenses/>
+ *
+ */
+
+#define LINK386_SOM
+#define LINK386_SOMC
+
+#include <link386.h>
diff -urN somfree\some\win32\some.def newsomfree3\some\win32\some.def
--- somfree\some\win32\some.def	Thu Jan 01 07:00:00 1970
+++ newsomfree3\some\win32\some.def	Sat Mar 16 14:09:27 2024
@@ -0,0 +1,105 @@
+LIBRARY some
+VERSION		1.0
+EXPORTS
+  SOMStringTableCCClassData       @1 DATA
+  SOMStringTableCClassData        @2 DATA
+  SOMStringTableCNewClass         @3
+   
+  SOMTAttributeEntryCCClassData   @4 DATA
+  SOMTAttributeEntryCClassData    @5 DATA
+  SOMTAttributeEntryCNewClass     @6
+
+  SOMTBaseClassEntryCCClassData   @7 DATA
+  SOMTBaseClassEntryCClassData    @8 DATA
+  SOMTBaseClassEntryCNewClass     @9
+  
+  SOMTClassEntryCCClassData       @10 DATA
+  SOMTClassEntryCClassData        @11 DATA
+  SOMTClassEntryCNewClass         @12
+  
+  SOMTCommonEntryCCClassData      @13 DATA
+  SOMTCommonEntryCClassData       @14 DATA
+  SOMTCommonEntryCNewClass        @15
+  
+  SOMTConstEntryCCClassData       @16 DATA
+  SOMTConstEntryCClassData        @17 DATA
+  SOMTConstEntryCNewClass         @18
+  
+  SOMTDataEntryCCClassData        @19 DATA
+  SOMTDataEntryCClassData         @20 DATA
+  SOMTDataEntryCNewClass          @21
+  
+  SOMTEmitCCClassData             @22 DATA
+  SOMTEmitCClassData              @23 DATA
+  SOMTEmitCNewClass               @24
+
+  SOMTEntryCCClassData            @25 DATA
+  SOMTEntryCClassData             @26 DATA
+  SOMTEntryCNewClass              @27
+
+  SOMTEnumEntryCCClassData        @28 DATA
+  SOMTEnumEntryCClassData         @29 DATA
+  SOMTEnumEntryCNewClass          @30
+
+  SOMTEnumNameEntryCCClassData    @31 DATA
+  SOMTEnumNameEntryCClassData     @32 DATA
+  SOMTEnumNameEntryCNewClass      @33
+  
+  SOMTMetaClassEntryCCClassData   @34 DATA
+  SOMTMetaClassEntryCClassData    @35 DATA
+  SOMTMetaClassEntryCNewClass     @36
+
+  SOMTMethodEntryCCClassData      @37 DATA
+  SOMTMethodEntryCClassData       @38 DATA
+  SOMTMethodEntryCNewClass        @39
+  
+  SOMTModuleEntryCCClassData      @40 DATA
+  SOMTModuleEntryCClassData       @41 DATA
+  SOMTModuleEntryCNewClass        @42
+
+  SOMTParameterEntryCCClassData   @43 DATA
+  SOMTParameterEntryCClassData    @44 DATA
+  SOMTParameterEntryCNewClass     @45
+
+  SOMTPassthruEntryCCClassData    @46 DATA
+  SOMTPassthruEntryCClassData     @47 DATA
+  SOMTPassthruEntryCNewClass      @48
+   
+  SOMTSequenceEntryCCClassData    @49 DATA
+  SOMTSequenceEntryCClassData     @50 DATA
+  SOMTSequenceEntryCNewClass      @51
+  
+  SOMTStringEntryCCClassData      @52 DATA
+  SOMTStringEntryCClassData       @53 DATA
+  SOMTStringEntryCNewClass        @54
+  
+  SOMTStructEntryCCClassData      @55 DATA
+  SOMTStructEntryCClassData       @56 DATA
+  SOMTStructEntryCNewClass        @57
+  
+  SOMTTemplateOutputCCClassData   @58 DATA
+  SOMTTemplateOutputCClassData    @59 DATA
+  SOMTTemplateOutputCNewClass     @60
+  
+  SOMTTypedefEntryCCClassData     @61 DATA
+  SOMTTypedefEntryCClassData      @62 DATA
+  SOMTTypedefEntryCNewClass       @63
+  
+  SOMTUnionEntryCCClassData       @64 DATA
+  SOMTUnionEntryCClassData        @65 DATA
+  SOMTUnionEntryCNewClass         @66
+
+  SOMTUserDefinedTypeEntryCCClassData     @67 DATA
+  SOMTUserDefinedTypeEntryCClassData      @68 DATA
+  SOMTUserDefinedTypeEntryCNewClass       @69
+
+  somtEntryTypeName               @70
+  somtGetFileStem                 @71
+  somtGetObjectWrapper            @72
+  somtMakeIncludeStr              @73
+  somtNewSymbol                   @74
+  somtShowEntry                   @75
+  somtStrCat                      @76
+  somtStrDup                      @77   
+
+   
\ No newline at end of file
diff -urN somfree\some\win32\some.mak newsomfree3\some\win32\some.mak
--- somfree\some\win32\some.mak	Thu Jan 01 07:00:00 1970
+++ newsomfree3\some\win32\some.mak	Sat Mar 16 14:09:27 2024
@@ -0,0 +1,181 @@
+#
+#  Copyright 2022, Yuri Prokushev
+#
+#  This file is part of osFree project
+#
+#  This program is free software: you can redistribute it and/or modify it
+#  under the terms of the GNU Lesser General Public License as published by the
+#  Free Software Foundation, either version 3 of the License, or (at your
+#  option) any later version.
+# 
+#  This program is distributed in the hope that it will be useful, but WITHOUT
+#  ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+#  FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for
+#  more details.
+#
+#  You should have received a copy of the GNU Lesser General Public License
+#  along with this program.  If not, see <http://www.gnu.org/licenses/>
+#
+
+!include $(MAKEDEFS)
+
+OUTDIR=$(OUTDIR_BIN)
+INTDIR=$(BUILDTYPE)
+
+DLLNAME=some
+
+TARGET_DLL=$(OUTDIR)\$(DLLNAME).dll
+TARGET_PDB=$(OUTDIR)\$(DLLNAME).pdb
+TARGET_MAP=$(INTDIR)\$(DLLNAME).map
+TARGET_DEF=..\$(PLATFORM_DEF)\$(DLLNAME).def
+
+PARTOPTS=	$(STDOPT)								\
+			/DWIN32_LEAN_AND_MEAN 					\
+			/DHAVE_CONFIG_HPP							\
+			/D_USE_SOME_								\
+			/I..\win32								\
+			/I..\include							\
+			/I..\src								\
+			/I..\..\include\$(PLATFORM)				\
+			/I..\..\include\$(PLATFORM_DEF)			\
+			/I..\..\include							\
+			/I..\..\somidl\$(PLATFORM)				\
+			/I..\..\somcdr\$(PLATFORM)\$(BUILDTYPE)	\
+			/I..\..\somcdr\include					\
+			/I..\..\somcdr\src						\
+			/I..\..\rhbmtut\include					\
+			/I..\..\somkpub\include					\
+			/I..\..\somtk\include					\
+			/I..\..\somc\include					\
+			/I..\..\somipc2\include					\
+			$(CC_OUT_PDB)$(TARGET_PDB)	
+
+OBJS=		$(INTDIR)\scattrib.obj	\
+		$(INTDIR)\scbase.obj	\
+		$(INTDIR)\scclass.obj	\
+		$(INTDIR)\sccommon.obj	\
+		$(INTDIR)\scconst.obj	\
+		$(INTDIR)\scdata.obj	\
+		$(INTDIR)\scemit.obj	\
+		$(INTDIR)\scentry.obj	\
+		$(INTDIR)\scenum.obj	\
+		$(INTDIR)\scenumnm.obj	\
+		$(INTDIR)\scmeta.obj	\
+		$(INTDIR)\scmethod.obj	\
+		$(INTDIR)\scmodule.obj	\
+		$(INTDIR)\scparm.obj	\
+		$(INTDIR)\scpass.obj	\
+		$(INTDIR)\scseqnce.obj	\
+		$(INTDIR)\scstring.obj	\
+		$(INTDIR)\scstruct.obj	\
+		$(INTDIR)\sctdef.obj	\
+		$(INTDIR)\sctmplt.obj	\
+		$(INTDIR)\scunion.obj	\
+		$(INTDIR)\scusrtyp.obj	\
+		$(INTDIR)\somstrt.obj	\
+		$(INTDIR)\scutil.obj	\
+		$(INTDIR)\link386.obj
+
+all: $(TARGET_DLL)
+
+clean:
+	$(CLEAN) $(TARGET_DLL) $(TARGET_PDB) $(TARGET_MAP) $(OBJS) $(INTDIR)\$(DLLNAME).res $(OUTDIR)\$(DLLNAME).exp $(OUTDIR)\$(DLLNAME).lib
+	
+$(TARGET_DLL): $(OBJS) $(OUTDIR) $(TARGET_DEF) $(INTDIR)\$(DLLNAME).res
+	$(CC) $(CC_OUT_DLL)$@ $(OBJS)		\
+			$(INTDIR)\$(DLLNAME).res	\
+			$(CC_OUT_PDB)$(TARGET_PDB)	\
+			$(CC_LINK)					\
+			$(LDFLAGS)					\
+			$(LD_DEF)$(TARGET_DEF)
+	$(POSTLINK_DLL) $@
+
+
+$(INTDIR)\scutil.obj: ..\src\scutil.cpp
+	$(CXX) /c $(PARTOPTS) $(CC_OUT_OBJ)$@ ..\src\scutil.cpp
+
+$(INTDIR)\scattrib.obj: ..\src\scattrib.cpp $(INTDIR)
+	$(CXX) /c /I$(INTDIR) $(PARTOPTS) $(CC_OUT_OBJ)$@ ..\src\scattrib.cpp
+
+$(INTDIR)\scbase.obj: ..\src\scbase.cpp $(INTDIR)
+	$(CXX) /c /I$(INTDIR) $(PARTOPTS) $(CC_OUT_OBJ)$@ ..\src\scbase.cpp
+
+$(INTDIR)\scclass.obj: ..\src\scclass.cpp $(INTDIR)
+	$(CXX) /c /I$(INTDIR) $(PARTOPTS) $(CC_OUT_OBJ)$@ ..\src\scclass.cpp
+
+$(INTDIR)\sccommon.obj: ..\src\sccommon.cpp $(INTDIR)
+	$(CXX) /c /I$(INTDIR) $(PARTOPTS) $(CC_OUT_OBJ)$@ ..\src\sccommon.cpp
+
+$(INTDIR)\scconst.obj: ..\src\scconst.cpp $(INTDIR)
+	$(CXX) /c /I$(INTDIR) $(PARTOPTS) $(CC_OUT_OBJ)$@ ..\src\scconst.cpp
+
+$(INTDIR)\scdata.obj: ..\src\scdata.cpp $(INTDIR)
+	$(CXX) /c /I$(INTDIR) $(PARTOPTS) $(CC_OUT_OBJ)$@ ..\src\scdata.cpp
+
+$(INTDIR)\scemit.obj: ..\src\scemit.cpp $(INTDIR)
+	$(CXX) /c /I$(INTDIR) $(PARTOPTS) $(CC_OUT_OBJ)$@ ..\src\scemit.cpp
+
+$(INTDIR)\scentry.obj: ..\src\scentry.cpp $(INTDIR)
+	$(CXX) /c /I$(INTDIR) $(PARTOPTS) $(CC_OUT_OBJ)$@ ..\src\scentry.cpp
+
+$(INTDIR)\scenum.obj: ..\src\scenum.cpp $(INTDIR)
+	$(CXX) /c /I$(INTDIR) $(PARTOPTS) $(CC_OUT_OBJ)$@ ..\src\scenum.cpp
+
+$(INTDIR)\scenumnm.obj: ..\src\scenumnm.cpp $(INTDIR)
+	$(CXX) /c /I$(INTDIR) $(PARTOPTS) $(CC_OUT_OBJ)$@ ..\src\scenumnm.cpp
+
+$(INTDIR)\scmeta.obj: ..\src\scmeta.cpp $(INTDIR)
+	$(CXX) /c /I$(INTDIR) $(PARTOPTS) $(CC_OUT_OBJ)$@ ..\src\scmeta.cpp
+
+$(INTDIR)\scmethod.obj: ..\src\scmethod.cpp $(INTDIR)
+	$(CXX) /c /I$(INTDIR) $(PARTOPTS) $(CC_OUT_OBJ)$@ ..\src\scmethod.cpp
+
+$(INTDIR)\scmodule.obj: ..\src\scmodule.cpp $(INTDIR)
+	$(CXX) /c /I$(INTDIR) $(PARTOPTS) $(CC_OUT_OBJ)$@ ..\src\scmodule.cpp
+
+$(INTDIR)\scparm.obj: ..\src\scparm.cpp $(INTDIR)
+	$(CXX) /c /I$(INTDIR) $(PARTOPTS) $(CC_OUT_OBJ)$@ ..\src\scparm.cpp
+
+$(INTDIR)\scpass.obj: ..\src\scpass.cpp $(INTDIR)
+	$(CXX) /c /I$(INTDIR) $(PARTOPTS) $(CC_OUT_OBJ)$@ ..\src\scpass.cpp
+
+$(INTDIR)\scseqnce.obj: ..\src\scseqnce.cpp $(INTDIR)
+	$(CXX) /c /I$(INTDIR) $(PARTOPTS) $(CC_OUT_OBJ)$@ ..\src\scseqnce.cpp
+
+$(INTDIR)\scstring.obj: ..\src\scstring.cpp $(INTDIR)
+	$(CXX) /c /I$(INTDIR) $(PARTOPTS) $(CC_OUT_OBJ)$@ ..\src\scstring.cpp
+
+$(INTDIR)\scstruct.obj: ..\src\scstruct.cpp $(INTDIR)
+	$(CXX) /c /I$(INTDIR) $(PARTOPTS) $(CC_OUT_OBJ)$@ ..\src\scstruct.cpp
+
+$(INTDIR)\sctdef.obj: ..\src\sctdef.cpp $(INTDIR)
+	$(CXX) /c /I$(INTDIR) $(PARTOPTS) $(CC_OUT_OBJ)$@ ..\src\sctdef.cpp
+
+$(INTDIR)\sctmplt.obj: ..\src\sctmplt.cpp $(INTDIR)
+	$(CXX) /c /I$(INTDIR) $(PARTOPTS) $(CC_OUT_OBJ)$@ ..\src\sctmplt.cpp
+
+$(INTDIR)\scunion.obj: ..\src\scunion.cpp $(INTDIR)
+	$(CXX) /c /I$(INTDIR) $(PARTOPTS) $(CC_OUT_OBJ)$@ ..\src\scunion.cpp
+
+$(INTDIR)\scusrtyp.obj: ..\src\scusrtyp.cpp $(INTDIR)
+	$(CXX) /c /I$(INTDIR) $(PARTOPTS) $(CC_OUT_OBJ)$@ ..\src\scusrtyp.cpp
+
+$(INTDIR)\somstrt.obj: ..\src\somstrt.cpp $(INTDIR)
+	$(CXX) /c /I$(INTDIR) $(PARTOPTS) $(CC_OUT_OBJ)$@ ..\src\somstrt.cpp
+
+$(INTDIR)\link386.obj: ..\win32\link386.c $(INTDIR)
+	$(CC) /c $(PARTOPTS) $(CC_OUT_OBJ)$@ ..\win32\link386.c
+
+$(INTDIR):
+	mkdir $@
+
+$(INTDIR)\$(DLLNAME).res: ..\win32\$(DLLNAME).rc
+	rc /nologo /r /I.. /I..\..\include\$(PLATFORM) /fo$@ ..\win32\$(DLLNAME).rc
+
+dist:
+
+
+
+
+test:
+
diff -urN somfree\some\win32\some.rc newsomfree3\some\win32\some.rc
--- somfree\some\win32\some.rc	Thu Jan 01 07:00:00 1970
+++ newsomfree3\some\win32\some.rc	Sat Mar 16 14:09:27 2024
@@ -0,0 +1,50 @@
+/**************************************************************************
+ *
+ *  Copyright 2022, Yuri Prokushev
+ *
+ *  This file is part of osFree project
+ *
+ *  This program is free software: you can redistribute it and/or modify it
+ *  under the terms of the GNU Lesser General Public License as published by the
+ *  Free Software Foundation, either version 3 of the License, or (at your
+ *  option) any later version.
+ * 
+ *  This program is distributed in the hope that it will be useful, but WITHOUT
+ *  ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ *  FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for
+ *  more details.
+ *
+ *  You should have received a copy of the GNU Lesser General Public License
+ *  along with this program.  If not, see <http://www.gnu.org/licenses/>
+ *
+ */
+
+#include <windows.h>
+#include <depvers.h>
+
+1 VERSIONINFO
+	PRODUCTVERSION DEPVERS_somtkpkg_INT4
+	FILEOS VOS__WINDOWS32
+	FILEVERSION DEPVERS_som_INT4
+	FILETYPE VFT_DLL
+BEGIN
+	BLOCK "StringFileInfo"
+	BEGIN
+		BLOCK "140904E4"
+		BEGIN
+			VALUE "CompanyName","Yuri Prokushev\000\000"
+			VALUE "LegalCopyright","Copyright й Yuri Prokushev 2021\000\000"
+			VALUE "ProductName",DEPVERS_somtkpkg_PRODUCTNAME
+			VALUE "ProductVersion",DEPVERS_somtkpkg_STR4
+			VALUE "Comments","Uncontrolled Release\000\000"
+			VALUE "FileDescription","SOM kernel\000\000"
+			VALUE "FileVersion",DEPVERS_som_STR4
+			VALUE "InternalName","some\000\000"
+			VALUE "OriginalFilename","SOME.DLL\000\000"
+		END
+	END
+    BLOCK "VarFileInfo"
+    BEGIN
+        VALUE "Translation", 0x1409, 1252
+    END
+END
diff -urN somfree\somenv\os2\somenv.cmd newsomfree3\somenv\os2\somenv.cmd
--- somfree\somenv\os2\somenv.cmd	Thu Jan 01 07:00:00 1970
+++ newsomfree3\somenv\os2\somenv.cmd	Sat Mar 16 14:09:27 2024
@@ -0,0 +1,19 @@
+@echo off
+rem $Id$
+
+if "%SOMBASE%x" == "x" goto firsttime
+
+set PATH=%SOMBASE%\bin;%PATH%
+set LIB=.;%SOMBASE%\lib;%LIB%
+set INCLUDE=.;%SOMBASE%\include;%INCLUDE%
+set SMMINCLUDE=.;%SOMBASE%\include
+set SOMENV=%SOMBASE%\etc\somenv.ini
+set SC=%SOMBASE%\bin\sc.exe
+set SOMIR=%SOMBASE%\etc\som.ir
+
+goto end
+
+:firsttime
+echo Edit %0 to set SOMBASE.
+
+:end
diff -urN somfree\someprep\makedefs.cf newsomfree3\someprep\makedefs.cf
--- somfree\someprep\makedefs.cf	Thu Jan 01 07:00:00 1970
+++ newsomfree3\someprep\makedefs.cf	Sat Mar 16 14:09:27 2024
@@ -0,0 +1,3 @@
+NAME someprep
+DEPENDS irdump
+PROVIDES someprep
diff -urN somfree\someprep\win32\someprep.mak newsomfree3\someprep\win32\someprep.mak
--- somfree\someprep\win32\someprep.mak	Thu Jan 01 07:00:00 1970
+++ newsomfree3\someprep\win32\someprep.mak	Sat Mar 16 14:09:27 2024
@@ -0,0 +1,234 @@
+#
+#  Copyright 2022, Yuri Prokushev
+#
+#  This file is part of osFree project
+#
+#  This program is free software: you can redistribute it and/or modify it
+#  under the terms of the GNU Lesser General Public License as published by the
+#  Free Software Foundation, either version 3 of the License, or (at your
+#  option) any later version.
+# 
+#  This program is distributed in the hope that it will be useful, but WITHOUT
+#  ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+#  FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for
+#  more details.
+#
+#  You should have received a copy of the GNU Lesser General Public License
+#  along with this program.  If not, see <http://www.gnu.org/licenses/>
+#
+
+!include $(MAKEDEFS)
+
+IDLTOOL=$(RHBTOOLS_BIN)\idltool.exe
+SC=$(SOMTOOLS_BIN)\sc.exe
+PDL=$(SOMTOOLS_BIN)\pdl.exe
+SOMIDL_IDL=..\..\somidl
+SOMIDL_HEADERS=$(SOMIDL_IDL)\$(PLATFORM)
+
+SOME_DIR=..\..\some
+SOMC_DIR=..\..\somc
+
+SOME_INTDIR=$(SOME_DIR)\$(PLATFORM)\$(BUILDTYPE)
+
+SOMEINCL=-I$(SOME_DIR) -I$(SOMIDL_IDL)
+
+PUBLIC_IDLS=$(SOMIDL_IDL)\scattrib.idl	\
+			$(SOMIDL_IDL)\scbase.idl	\
+			$(SOMIDL_IDL)\scclass.idl	\
+			$(SOMIDL_IDL)\sccommon.idl	\
+			$(SOMIDL_IDL)\scconst.idl	\
+			$(SOMIDL_IDL)\scdata.idl	\
+			$(SOMIDL_IDL)\scemit.idl	\
+			$(SOMIDL_IDL)\scentry.idl	\
+			$(SOMIDL_IDL)\scenum.idl	\
+			$(SOMIDL_IDL)\scenumnm.idl	\
+			$(SOMIDL_IDL)\scmeta.idl	\
+			$(SOMIDL_IDL)\scmethod.idl	\
+			$(SOMIDL_IDL)\scmodule.idl	\
+			$(SOMIDL_IDL)\scparm.idl	\
+			$(SOMIDL_IDL)\scpass.idl	\
+			$(SOMIDL_IDL)\scseqnce.idl	\
+			$(SOMIDL_IDL)\scstring.idl	\
+			$(SOMIDL_IDL)\scstruct.idl	\
+			$(SOMIDL_IDL)\sctdef.idl	\
+			$(SOMIDL_IDL)\sctmplt.idl	\
+			$(SOMIDL_IDL)\scunion.idl	\
+			$(SOMIDL_IDL)\scusrtyp.idl	\
+			$(SOMIDL_IDL)\somstrt.idl
+
+
+SOME_IH=	$(SOME_INTDIR)\scattrib.h	\
+			$(SOME_INTDIR)\scbase.h	\
+			$(SOME_INTDIR)\scclass.h	\
+			$(SOME_INTDIR)\sccommon.h	\
+			$(SOME_INTDIR)\scconst.h	\
+			$(SOME_INTDIR)\scdata.h	\
+			$(SOME_INTDIR)\scemit.h	\
+			$(SOME_INTDIR)\scentry.h	\
+			$(SOME_INTDIR)\scenum.h	\
+			$(SOME_INTDIR)\scenumnm.h	\
+			$(SOME_INTDIR)\scmeta.h	\
+			$(SOME_INTDIR)\scmethod.h	\
+			$(SOME_INTDIR)\scmodule.h	\
+			$(SOME_INTDIR)\scparm.h	\
+			$(SOME_INTDIR)\scpass.h	\
+			$(SOME_INTDIR)\scseqnce.h	\
+			$(SOME_INTDIR)\scstring.h	\
+			$(SOME_INTDIR)\scstruct.h	\
+			$(SOME_INTDIR)\sctdef.h	\
+			$(SOME_INTDIR)\sctmplt.h	\
+			$(SOME_INTDIR)\scunion.h	\
+			$(SOME_INTDIR)\scusrtyp.h	\
+			$(SOME_INTDIR)\somstrt.h	\
+			$(SOME_INTDIR)\scattrib.ih	\
+			$(SOME_INTDIR)\scbase.ih	\
+			$(SOME_INTDIR)\scclass.ih	\
+			$(SOME_INTDIR)\sccommon.ih	\
+			$(SOME_INTDIR)\scconst.ih	\
+			$(SOME_INTDIR)\scdata.ih	\
+			$(SOME_INTDIR)\scemit.ih	\
+			$(SOME_INTDIR)\scentry.ih	\
+			$(SOME_INTDIR)\scenum.ih	\
+			$(SOME_INTDIR)\scenumnm.ih	\
+			$(SOME_INTDIR)\scmeta.ih	\
+			$(SOME_INTDIR)\scmethod.ih	\
+			$(SOME_INTDIR)\scmodule.ih	\
+			$(SOME_INTDIR)\scparm.ih	\
+			$(SOME_INTDIR)\scpass.ih	\
+			$(SOME_INTDIR)\scseqnce.ih	\
+			$(SOME_INTDIR)\scstring.ih	\
+			$(SOME_INTDIR)\scstruct.ih	\
+			$(SOME_INTDIR)\sctdef.ih	\
+			$(SOME_INTDIR)\sctmplt.ih	\
+			$(SOME_INTDIR)\scunion.ih	\
+			$(SOME_INTDIR)\scusrtyp.ih	\
+			$(SOME_INTDIR)\somstrt.ih	\
+			$(SOME_INTDIR)\scattrib.xh	\
+			$(SOME_INTDIR)\scbase.xh	\
+			$(SOME_INTDIR)\scclass.xh	\
+			$(SOME_INTDIR)\sccommon.xh	\
+			$(SOME_INTDIR)\scconst.xh	\
+			$(SOME_INTDIR)\scdata.xh	\
+			$(SOME_INTDIR)\scemit.xh	\
+			$(SOME_INTDIR)\scentry.xh	\
+			$(SOME_INTDIR)\scenum.xh	\
+			$(SOME_INTDIR)\scenumnm.xh	\
+			$(SOME_INTDIR)\scmeta.xh	\
+			$(SOME_INTDIR)\scmethod.xh	\
+			$(SOME_INTDIR)\scmodule.xh	\
+			$(SOME_INTDIR)\scparm.xh	\
+			$(SOME_INTDIR)\scpass.xh	\
+			$(SOME_INTDIR)\scseqnce.xh	\
+			$(SOME_INTDIR)\scstring.xh	\
+			$(SOME_INTDIR)\scstruct.xh	\
+			$(SOME_INTDIR)\sctdef.xh	\
+			$(SOME_INTDIR)\sctmplt.xh	\
+			$(SOME_INTDIR)\scunion.xh	\
+			$(SOME_INTDIR)\scusrtyp.xh	\
+			$(SOME_INTDIR)\somstrt.xh	\
+			$(SOME_INTDIR)\scattrib.xih	\
+			$(SOME_INTDIR)\scbase.xih	\
+			$(SOME_INTDIR)\scclass.xih	\
+			$(SOME_INTDIR)\sccommon.xih	\
+			$(SOME_INTDIR)\scconst.xih	\
+			$(SOME_INTDIR)\scdata.xih	\
+			$(SOME_INTDIR)\scemit.xih	\
+			$(SOME_INTDIR)\scentry.xih	\
+			$(SOME_INTDIR)\scenum.xih	\
+			$(SOME_INTDIR)\scenumnm.xih	\
+			$(SOME_INTDIR)\scmeta.xih	\
+			$(SOME_INTDIR)\scmethod.xih	\
+			$(SOME_INTDIR)\scmodule.xih	\
+			$(SOME_INTDIR)\scparm.xih	\
+			$(SOME_INTDIR)\scpass.xih	\
+			$(SOME_INTDIR)\scseqnce.xih	\
+			$(SOME_INTDIR)\scstring.xih	\
+			$(SOME_INTDIR)\scstruct.xih	\
+			$(SOME_INTDIR)\sctdef.xih	\
+			$(SOME_INTDIR)\sctmplt.xih	\
+			$(SOME_INTDIR)\scunion.xih	\
+			$(SOME_INTDIR)\scusrtyp.xih	\
+			$(SOME_INTDIR)\somstrt.xih
+
+SOME_H=	$(SOMIDL_HEADERS)\scattrib.h	\
+			$(SOMIDL_HEADERS)\scbase.h	\
+			$(SOMIDL_HEADERS)\scclass.h	\
+			$(SOMIDL_HEADERS)\sccommon.h	\
+			$(SOMIDL_HEADERS)\scconst.h	\
+			$(SOMIDL_HEADERS)\scdata.h	\
+			$(SOMIDL_HEADERS)\scemit.h	\
+			$(SOMIDL_HEADERS)\scentry.h	\
+			$(SOMIDL_HEADERS)\scenum.h	\
+			$(SOMIDL_HEADERS)\scenumnm.h	\
+			$(SOMIDL_HEADERS)\scmeta.h	\
+			$(SOMIDL_HEADERS)\scmethod.h	\
+			$(SOMIDL_HEADERS)\scmodule.h	\
+			$(SOMIDL_HEADERS)\scparm.h	\
+			$(SOMIDL_HEADERS)\scpass.h	\
+			$(SOMIDL_HEADERS)\scseqnce.h	\
+			$(SOMIDL_HEADERS)\scstring.h	\
+			$(SOMIDL_HEADERS)\scstruct.h	\
+			$(SOMIDL_HEADERS)\sctdef.h	\
+			$(SOMIDL_HEADERS)\sctmplt.h	\
+			$(SOMIDL_HEADERS)\scunion.h	\
+			$(SOMIDL_HEADERS)\scusrtyp.h	\
+			$(SOMIDL_HEADERS)\somstrt.h	\
+			$(SOMIDL_HEADERS)\scattrib.xh	\
+			$(SOMIDL_HEADERS)\scbase.xh	\
+			$(SOMIDL_HEADERS)\scclass.xh	\
+			$(SOMIDL_HEADERS)\sccommon.xh	\
+			$(SOMIDL_HEADERS)\scconst.xh	\
+			$(SOMIDL_HEADERS)\scdata.xh	\
+			$(SOMIDL_HEADERS)\scemit.xh	\
+			$(SOMIDL_HEADERS)\scentry.xh	\
+			$(SOMIDL_HEADERS)\scenum.xh	\
+			$(SOMIDL_HEADERS)\scenumnm.xh	\
+			$(SOMIDL_HEADERS)\scmeta.xh	\
+			$(SOMIDL_HEADERS)\scmethod.xh	\
+			$(SOMIDL_HEADERS)\scmodule.xh	\
+			$(SOMIDL_HEADERS)\scparm.xh	\
+			$(SOMIDL_HEADERS)\scpass.xh	\
+			$(SOMIDL_HEADERS)\scseqnce.xh	\
+			$(SOMIDL_HEADERS)\scstring.xh	\
+			$(SOMIDL_HEADERS)\scstruct.xh	\
+			$(SOMIDL_HEADERS)\sctdef.xh	\
+			$(SOMIDL_HEADERS)\sctmplt.xh	\
+			$(SOMIDL_HEADERS)\scunion.xh	\
+			$(SOMIDL_HEADERS)\scusrtyp.xh	\
+			$(SOMIDL_HEADERS)\somstrt.xh
+
+DIRS=	$(SOME_INTDIR)			
+
+all: 	$(DIRS)			\
+		$(PUBLIC_IDLS)	\
+		$(SOME_H)	\
+		$(SOME_IH)
+
+clean:
+	$(CLEAN) $(SOME_IH) $(SOME_H) $(PUBLIC_IDLS)
+	 
+
+$(DIRS):
+	mkdir $@
+
+$(PUBLIC_IDLS):
+	"$(IDLTOOL)" "$(PDL)"		\
+		$(SOME_DIR)			\
+		-o $@
+
+$(SOME_IH): 
+	"$(IDLTOOL)" "$(SC)" $(SOME_DIR)	\
+					-o $@ -p -I$(SOME_DIR) -I$(SOMIDL_IDL) -I$(SOMC_DIR)\include
+
+$(SOME_H): 
+	"$(IDLTOOL)" "$(SC)" $(SOME_DIR)	\
+					-o $@ -I$(SOME_DIR) -I$(SOMIDL_IDL) -I$(SOMC_DIR)\include
+
+
+dist:
+
+
+
+
+test:
+
diff -urN somfree\somhh\os2\somhh.cmd newsomfree3\somhh\os2\somhh.cmd
--- somfree\somhh\os2\somhh.cmd	Thu Jan 01 07:00:00 1970
+++ newsomfree3\somhh\os2\somhh.cmd	Sat Mar 16 14:09:27 2024
@@ -0,0 +1,26 @@
+@echo off
+
+if "%SOMBASE%"=="" goto sombase
+
+if not exist %SOMBASE%\include\somhh.gen goto normal
+echo Generating the SOM DTS C++ bindings in progress...
+goto end
+
+:normal
+echo Generating the SOM DTS C++ Usage Bindings:
+set SC=%SOMBASE%\bin\sc.exe
+cd %SOMBASE%\include
+set SMNOADDSTAR=
+echo somhh.gen > somxh.gen
+%SC% -%% -S100000 -shh -mnoqualifytypes -musexhpass *.idl
+if not errorlevel 0 GOTO end
+if exist somdtype.idl %SC% -shh -DEMIT_SOMDTYPES -mnoqualifytypes -musexhpass somdtype.idl
+if exist somhh.gen del somhh.gen
+goto end
+
+:sombase
+echo SOMBASE should be set before running somhh.
+goto end
+
+:end
+
diff -urN somfree\somhh\win32\somhh.cmd newsomfree3\somhh\win32\somhh.cmd
--- somfree\somhh\win32\somhh.cmd	Thu Jan 01 07:00:00 1970
+++ newsomfree3\somhh\win32\somhh.cmd	Sat Mar 16 14:09:27 2024
@@ -0,0 +1,33 @@
+@echo off
+
+if "%ProgramFiles%\somtk\bin\" == "%~dp0" set SOMBASE=%ProgramFiles%\somtk
+if "%ProgramFiles(x86)%\somtk\bin\" == "%~dp0" set SOMBASE=%ProgramFiles(x86)%\somtk
+if "%ProgramFiles(Arm)%\somtk\bin\" == "%~dp0" set SOMBASE=%ProgramFiles(Arm)%\somtk
+if "%ProgramW6432%\somtk\bin\" == "%~dp0" set SOMBASE=%ProgramW6432%\somtk
+
+if "%SOMBASE%x" == "x" if exist "%ProgramFiles%\somtk" set SOMBASE=%ProgramFiles%\somtk
+
+if "%SOMBASE%"=="" goto sombase
+
+if not exist %SOMBASE%\include\somhh.gen goto normal
+echo Generating the SOM DTS C++ bindings in progress...
+goto end
+
+:normal
+echo Generating the SOM DTS C++ Usage Bindings:
+set SC=%SOMBASE%\bin\sc.exe
+cd %SOMBASE%\include
+set SMNOADDSTAR=
+echo somhh.gen > somxh.gen
+%SC% -%% -S100000 -shh -mnoqualifytypes -musexhpass *.idl
+if not errorlevel 0 GOTO end
+if exist somdtype.idl %SC% -shh -DEMIT_SOMDTYPES -mnoqualifytypes -musexhpass somdtype.idl
+if exist somhh.gen del somhh.gen
+goto end
+
+:sombase
+echo SOMBASE should be set before running somhh.
+goto end
+
+:end
+
diff -urN somfree\somipc\src\_rhbsc.cpp newsomfree3\somipc\src\_rhbsc.cpp
--- somfree\somipc\src\_rhbsc.cpp	Thu Jan 01 07:00:00 1970
+++ newsomfree3\somipc\src\_rhbsc.cpp	Sat Mar 16 14:09:19 2024
@@ -0,0 +1,525 @@
+/**************************************************************************
+ *
+ *  Copyright 1998-2010, Roger Brown
+ *
+ *  This file is part of Roger Brown's Toolkit.
+ *
+ *  This program is free software: you can redistribute it and/or modify it
+ *  under the terms of the GNU Lesser General Public License as published by the
+ *  Free Software Foundation, either version 3 of the License, or (at your
+ *  option) any later version.
+ * 
+ *  This program is distributed in the hope that it will be useful, but WITHOUT
+ *  ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ *  FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for
+ *  more details.
+ *
+ *  You should have received a copy of the GNU Lesser General Public License
+ *  along with this program.  If not, see <http://www.gnu.org/licenses/>
+ *
+ */
+ 
+/* 
+ * $Id$
+ */
+
+#include <rhbopt.h>
+#include <stdio.h>
+#include <string.h>
+#include <stdlib.h>
+
+#ifdef HAVE_SIGNAL_H
+#	include <signal.h>
+#endif
+
+#include <rhbsc.h>
+
+static boolean default_emitflag;
+
+class modifier_arg
+{
+public:
+	char *name;
+	char *value;
+	modifier_arg *next;
+	modifier_arg(const char *p) : name(NULL),value(NULL),next(NULL)
+	{
+		if (p)
+		{
+			size_t n=1+strlen(p);
+
+			name=new char[n];
+			memcpy(name,p,n);
+
+			n=0;
+
+			while (name[n])
+			{
+				if (name[n]=='=')
+				{
+					name[n]=0;
+					value=name+n;
+					break;
+				}
+
+				n++;
+			}
+		}
+	}
+
+	~modifier_arg()
+	{
+		if (name) delete []name;
+	}
+};
+
+static int do_emit(
+	modifier_arg * /* mod_list */ ,
+	const char *emitter_name,
+	const char *output_filename,
+	int argc,
+	char **argv)
+{
+	int rc=1;
+	static const char *valid_emitter[]={
+		"xh","xih","h","ih","api","kih","ir","tc"
+	};
+	int i=sizeof(valid_emitter)/sizeof(valid_emitter[0]);
+
+	while (i--)
+	{
+		if (!strcmp(emitter_name,valid_emitter[i]))
+		{
+			break;
+		}
+	}
+
+	if (i < 0)
+	{
+		fprintf(stderr,"Unknown emitter %s\n",emitter_name);
+		return 1;
+	}
+
+	RHBPreprocessor preprocessor;
+	const char *root_idl=NULL;
+	FILE *fp=stdin;
+
+	if (argc) fp=NULL;
+
+	RHBFile f(argc,argv,fp);
+
+	if (f.failed())
+	{
+		return 1;
+	}
+
+	preprocessor.push_stream(&f);
+
+	{
+		RHBPreprocessor *p=&preprocessor;
+		RHBrepository r(p,"");
+
+		r.build(p);
+
+		if (p->Errors())
+		{
+			fprintf(stderr,"Errors were detected\n");
+
+			return 1;
+		}
+
+		if (p->includes)
+		{
+			RHBelement *e=p->includes->children();
+
+			while (e)
+			{
+				RHBinclude_file *f=e->is_include_file();
+
+				if (f && f->id)
+				{
+					const char *p=f->id;
+					int k=strlen(p);
+					while (k--)
+					{
+						if (p[k]=='.')
+						{
+							if (!strcmp(p+k,".idl"))
+							{
+								root_idl=p;
+							}
+
+							break;
+						}
+					}
+
+					if (root_idl) 
+					{
+						break;
+					}
+				}
+
+				e=e->next();
+			}
+		}
+
+		if (!root_idl)
+		{
+			fprintf(stderr,"unable to determine root IDL filename\n");
+		}
+		else
+		{
+			rc=0;
+
+			if (!strcmp(emitter_name,"ir"))
+			{
+				boolean old_emit=default_emitflag;
+				default_emitflag=1;
+				RHBir_file out(output_filename);
+		/*		printf("This should be the IR generator\n",buf);*/
+				RHBir_emitter emitter(&r,&out);
+				emitter.generate(&out,root_idl);
+#ifdef _PLATFORM_MACINTOSH_
+				fsetfileinfo(buf,SOMIR_CREATOR,SOMIR_TYPE);
+#endif
+				default_emitflag=old_emit;
+			}
+			else
+			{
+				RHBtextfile out(output_filename);
+
+				if (!strcmp(emitter_name,"tc"))
+				{
+					RHBtc_emitter emitter(&r);
+
+					emitter.generate(&out,root_idl);
+				}
+				else
+				{
+					if (!strcmp(emitter_name,"kih"))
+					{
+						RHBkernel_emitter emitter(&r);
+
+						emitter.generate(&out,root_idl);
+					}
+					else
+					{
+						if (!strcmp(emitter_name,"api"))
+						{
+							RHBapi_emitter emitter(&r);
+
+							emitter.generate(&out,root_idl);
+						}
+						else
+						{
+							RHBheader_emitter emitter(&r);
+
+							emitter.cplusplus=0;
+							emitter.internal=0;
+							emitter.testonly=0;
+
+							if (0==strcmp(emitter_name,"ih"))
+							{
+								emitter.internal=1;
+							}
+				
+							if (0==strcmp(emitter_name,"xih"))
+							{
+								emitter.internal=1;
+								emitter.cplusplus=1;
+							}
+
+							if (0==strcmp(emitter_name,"xh"))
+							{
+								emitter.cplusplus=1;
+							}
+
+							emitter.generate(&out,root_idl);
+						}
+					}
+				}
+			}
+		}
+
+		r.destroy();
+		r.delete_all(&r);
+	}
+
+	return rc;
+}
+
+void bomb(const char *p)
+{
+	if (!p) p="unknown error";
+#ifdef _WIN32
+	fprintf(stderr,"SC: fatal: %s\n",p);
+	fflush(stdout);
+	fflush(stderr);
+#	ifdef _DEBUG
+#		ifdef _M_IX86
+			__asm int 3;
+#		else
+			((int *)0)[0]=0;
+#		endif
+#	else
+		exit(1);
+#	endif
+#else
+#ifdef _PLATFORM_MACINTOSH_xxx
+	if (p)
+	{
+		unsigned char buf[256];
+		buf[0]=strlen(p);
+		if (*p) memcpy(&buf[1],p,buf[0]);
+		DebugStr(buf);
+	}
+	else
+	{
+		DebugStr("\p");
+	}
+#else
+	fprintf(stderr,"SC: fatal: %s\n",p);
+	fflush(stdout);
+	fflush(stderr);
+	exit(1);
+#endif
+#endif
+}
+
+boolean RHBshould_emit_on(RHBelement *)
+{
+	return 1;
+}
+
+boolean RHBshould_emit_off(RHBelement *)
+{
+	return 0;
+}
+
+boolean RHBshould_emit_default(RHBelement * /*t */)
+{
+	return default_emitflag;
+}
+
+#ifndef HAVE_VSNPRINTF
+int vsnprintf(char *tgt,size_t /*tgtlen*/,const char *fmt,va_list ap)
+{
+	/* SunOS returns a char *, ANSI returns an int */
+
+	vsprintf(tgt,fmt,ap);
+
+	return strlen(tgt);
+}
+#endif
+
+#ifndef HAVE_SNPRINTF
+int snprintf(char *tgt,size_t len,const char *fmt,...)
+{
+	va_list ap;
+	int rc=-1;
+
+	va_start(ap,fmt);
+
+	rc=vsnprintf(tgt,len,fmt,ap);
+
+	va_end(ap);
+
+	return rc;
+}
+#endif
+
+class args
+{
+public:
+	modifier_arg *mods;
+	char **argv;
+	args(int argc,char **d) : argv(new char *[argc+1])
+	{
+		mods=NULL;
+		argv[argc]=NULL;
+		while (argc--)
+		{
+			argv[argc]=d[argc];
+		}
+	}
+	~args()
+	{
+		delete [] argv;
+
+		while (mods)
+		{
+			modifier_arg *p=mods;
+			mods=mods->next;
+			delete p;
+		}
+	}
+
+	void add_modifier(const char *m)
+	{
+		modifier_arg *p=new modifier_arg(m);
+
+		if (mods)
+		{
+			modifier_arg *q=mods;
+			while (q->next) q=q->next;
+			q->next=p;
+		}
+		else
+		{
+			mods=p;
+		}
+	}
+};
+
+int main(int argc,char **argv)
+{
+	const char *appname=argv[0];
+	int i=0;
+	const char *emitter_name=NULL;
+	const char *output_filename=NULL;
+#if defined(HAVE_SIGNAL_H) && defined(SIG_BLOCK)
+	sigset_t sigs;
+	sigfillset(&sigs);
+	sigprocmask(SIG_BLOCK,&sigs,NULL);
+#endif
+
+	if (!argc) 
+	{
+		fprintf(stderr,"no argument list\n");
+
+		return 1;
+	}
+
+	argc--;
+	argv++;
+
+	{
+		args a(argc,argv);
+
+		argv=a.argv;
+
+		while (i < argc)
+		{
+			int drop=0;
+			const char *p=argv[i];
+
+			if (
+#ifdef _WIN32
+				(*p=='/')||
+#endif
+				(*p=='-'))
+			{
+				if ((p[1]=='o')
+	#ifdef _WIN32
+					||(p[1]=='O')
+	#endif
+					)
+				{
+					if (output_filename)
+					{
+						fprintf(stderr,"%s: output file already specified\n",appname);
+						return 1;
+					}
+
+					output_filename=argv[i+1];
+					drop=2;
+				}
+				else
+				{
+					if ((p[1]=='e')
+	#ifdef _WIN32
+						||(p[1]=='E')
+						||(p[1]=='S')
+	#endif
+						||(p[1]=='s')
+						)
+					{
+						if (emitter_name)
+						{
+							fprintf(stderr,"%s: emitter already specified\n",appname);
+							return 1;
+						}
+
+						if (p[2])
+						{
+							emitter_name=p+2;
+							drop=1;
+						}
+						else
+						{
+							emitter_name=argv[i+1];
+							drop=2;
+						}
+					}
+					else
+					{
+						if ((p[1]=='m')
+	#ifdef _WIN32
+							||(p[1]=='M')
+	#endif
+
+							)
+						{
+							if (p[2])
+							{
+								a.add_modifier(p);
+								drop=1;
+							}
+							else
+							{
+								a.add_modifier(argv[i+1]);
+								drop=2;
+							}
+						}
+						else
+						{
+							fprintf(stderr,"%s: Unknown switch \'%s\'\n",appname,p);
+							return 1;
+						}
+					}
+				}
+			}
+
+			if (drop)
+			{
+				int k=i;
+
+				while ((k+drop) < argc)
+				{
+					argv[k]=argv[k+drop];
+					k++;
+				}
+
+				argc-=drop;
+
+				argv[argc]=NULL;
+			}
+			else
+			{
+				i++;
+			}
+		}
+
+		if (!emitter_name)
+		{
+			fprintf(stderr,"%s: no emitter specified\n",appname);
+
+			return 1;
+		}
+
+		i=do_emit(a.mods,emitter_name,output_filename,argc,argv);
+	}
+
+#if defined(_WIN32) && defined(_DEBUG) && (_MSC_VER >= 1200) && !defined(_WIN32_WCE) && !defined(_WIN64)
+	if (_CrtDumpMemoryLeaks())
+	{
+		__asm int 3;
+
+		_CrtDumpMemoryLeaks();
+
+		__asm int 3;
+	}
+#endif
+
+	return i;
+}
diff -urN somfree\somipc\src\rhbsc.cpp newsomfree3\somipc\src\rhbsc.cpp
--- somfree\somipc\src\rhbsc.cpp	Sun Mar 17 21:36:11 2024
+++ newsomfree3\somipc\src\rhbsc.cpp	Thu Jan 26 23:00:41 2023
@@ -252,7 +252,7 @@
 {
 	if (!p) p="unknown error";
 #ifdef _WIN32
-	fprintf(stderr,"SC: fatal: %s\n",p);
+	printf("SC: fatal: %s\n",p);
 	fflush(stdout);
 	fflush(stderr);
 #	ifdef _DEBUG
@@ -278,7 +278,7 @@
 		DebugStr("\p");
 	}
 #else
-	fprintf(stderr,"SC: fatal: %s\n",p);
+	printf("SC: fatal: %s\n",p);
 	fflush(stdout);
 	fflush(stderr);
 	exit(1);
@@ -473,8 +473,22 @@
 						}
 						else
 						{
-							fprintf(stderr,"%s: Unknown switch \'%s\'\n",appname,p);
-							return 1;
+							if ((p[1]=='v'))
+							{
+								drop=1;
+							}
+							else
+							{
+								if ((p[1]=='c'))
+								{
+									drop=1;
+								}
+								else
+								{
+									fprintf(stderr,"%s: Unknown switch \'%s\'\n",appname,p);
+									return 1;
+								}
+							}
 						}
 					}
 				}
diff -urN somfree\somipc2\include\rhbsc.h newsomfree3\somipc2\include\rhbsc.h
--- somfree\somipc2\include\rhbsc.h	Thu Jan 01 07:00:00 1970
+++ newsomfree3\somipc2\include\rhbsc.h	Sat Mar 16 14:09:27 2024
@@ -0,0 +1,1317 @@
+/**************************************************************************
+ *
+ *  Copyright 1998-2010, Roger Brown
+ *
+ *  This file is part of Roger Brown's Toolkit.
+ *
+ *  This program is free software: you can redistribute it and/or modify it
+ *  under the terms of the GNU Lesser General Public License as published by the
+ *  Free Software Foundation, either version 3 of the License, or (at your
+ *  option) any later version.
+ * 
+ *  This program is distributed in the hope that it will be useful, but WITHOUT
+ *  ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ *  FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for
+ *  more details.
+ *
+ *  You should have received a copy of the GNU Lesser General Public License
+ *  along with this program.  If not, see <http://www.gnu.org/licenses/>
+ *
+ */
+ 
+/* 
+ * $Id: rhbsc.h 2 2013-01-10 05:54:51Z somtoolkit $
+ */
+
+#ifndef __RHBOPT_H__
+#error __RHBOPT_H__ not defined
+#endif
+
+
+/* SOM Compiler
+
+  compiles IDL files (and only IDL files)
+
+  generates...
+
+  .h
+  .ih
+
+  C++ will be supported by testing for __cplusplus on compilation...
+
+  .xih should just include .ih
+  .xh should just include .h
+
+  */
+
+/* currently, 'union' is missing, 
+
+module U
+{
+	union KeyUnion switch (short)
+	{
+		case 1: octet data_1;
+		case 2: short data_2;
+		case 4: long data_4;
+		default: string data_z;
+	};
+};
+
+  should produce
+
+typedef struct U_KeyUnion 
+{
+	short _d;
+	union 
+	{
+		octet  data_1;
+		short  data_2;
+		long  data_4;
+		string  data_z;
+	} _u;
+} U_KeyUnion;
+
+  but, oops!
+
+	g++ may need -fno-rtti for binary compatibility?
+
+*/
+
+
+#include <ctype.h>
+
+#ifdef _WIN32
+	#ifndef _PLATFORM_WIN32_
+		#define _PLATFORM_WIN32_
+	#endif
+#else
+	#if (!defined(_PLATFORM_MACINTOSH_)) && (!defined(__OS2__)) && (!defined(_PLATFORM_UNIX_))
+		/* previously used to look for 'unix' first */
+		#define _PLATFORM_UNIX_
+	#endif
+#endif
+
+#ifndef HAVE_SNPRINTF
+extern int snprintf(char *,size_t,const char *,...);
+#endif
+#ifndef HAVE_VSNPRINTF
+extern int vsnprintf(char *,size_t,const char *,va_list);
+#endif
+
+extern void bomb(const char *);
+
+extern char double_quote;
+extern char single_quote;
+
+typedef unsigned char boolean;
+typedef unsigned char octet;
+typedef char * string;
+
+class RHBPreprocessor;
+class RHBinclude_file;
+class RHBinclude_list;
+class RHBFile;
+
+class RHBStream
+{
+public:
+	RHBStream();
+	virtual ~RHBStream();
+	virtual char get_char()=0;
+	virtual int is_eof()=0;
+	virtual void un_get(char c)=0;	
+	virtual RHBinclude_file *File()=0;
+	virtual RHBFile *is_file()=0;
+	virtual int GetLine();
+	virtual void print_identity(FILE *)=0;
+};
+
+class RHBFile : public RHBStream
+{
+	int argc;
+	char **argv;
+	FILE *fp;
+	char un_got;
+	char filename[1024];
+	int line_number;
+public:
+	inline int failed()
+	{
+		if (fp) return 0;
+		return 1;
+	}
+	int GetLine();
+	RHBinclude_file *incl;
+	RHBFile(int argc,char **argv,FILE *);
+	RHBFile *parent;
+	RHBFile *is_file();
+	char get_char();
+	void un_get(char c);
+	int is_eof();
+	void print_identity(FILE *);
+	RHBinclude_file *File();
+	void update_file_line(const char *,int);
+
+	inline const char *_get_filename()
+	{
+		if (filename[0])
+		{
+			return filename;
+		}
+
+		return NULL;
+	}
+};
+
+class RHBelement;
+class RHBrepository;
+
+typedef boolean (*RHBshould_emit)(RHBelement *);
+
+boolean RHBshould_emit_on(RHBelement *);
+boolean RHBshould_emit_off(RHBelement *);
+boolean RHBshould_emit_default(RHBelement *);
+
+class RHBPreprocessor
+{
+	char text[1024];
+	long lText;
+	int in_text;
+	RHBStream *streamStack[1024];
+	int stream_level;
+	int get_next_token(char *buf);
+	void Close();
+	void past_white_space();
+	RHBshould_emit emit_root;
+	long error_count;
+public:
+	RHBinclude_list *includes;
+	RHBinclude_file *CurrentFile();
+	int CurrentLine();
+	void err(const char *,const char *);
+	void push_stream(RHBStream *str);
+	void add_path(const char *p);
+	RHBPreprocessor();
+	int get_token(char *buf,size_t buflen);
+	char get_non_whitespace();
+
+	RHBStream *currStream();
+
+	inline long Errors()
+	{
+		return error_count;
+	}
+
+	inline void SetEmitRoot(RHBshould_emit a)
+	{
+		emit_root=a;
+	}
+
+	inline RHBshould_emit GetEmitRoot()
+	{
+		return emit_root;
+	}
+
+	RHBelement *scope;
+
+	void pragma_clear();
+};
+
+class RHBmodule;
+class RHBtype;
+class RHBparameter;
+class RHBoperation;
+class RHBinherited_operation;
+class RHBimplementation;
+class RHBinterface;
+class RHBexception;
+class RHBconstant;
+class RHBenum;
+class RHBcontext_string;
+class RHBelement;
+class RHBsequence_type;
+class RHBstring_type;
+class RHBvalue;
+class RHBmodifier;
+class RHBtype_def;
+class RHBstruct;
+class RHBstruct_element;
+class RHBarray;
+class RHBpointer_type;
+class RHBqualified_type;
+class RHBsequence_type;
+class RHBunion;
+class RHBunion_element;
+class RHBbase_type;
+class RHBany_type;
+class RHBTypeCode_type;
+class RHBattribute;
+
+class RHBelement_sequence
+{
+	unsigned long _length;
+	unsigned long _maximum;
+	RHBelement **_buffer;
+public:
+	RHBelement_sequence();
+	~RHBelement_sequence();
+
+	RHBelement *get(unsigned long i);
+
+	inline unsigned long length()
+	{
+		return _length;
+	}
+
+	void add(RHBelement *e);
+	void remove(RHBelement *e);
+	RHBelement *contains(RHBelement *e);
+	int index(RHBelement *e);
+};
+
+class RHBelement_new_scope
+{
+	RHBPreprocessor *pp;
+	RHBelement *old;
+public:
+	RHBelement_new_scope(RHBPreprocessor *p,RHBelement *e);
+	~RHBelement_new_scope();
+};
+
+class RHBmodifier_list
+{
+	int _length,_maximum;
+	string *_buffer;
+public:
+	RHBmodifier_list();
+	~RHBmodifier_list();
+	void add(const char *p);
+	const char * get(int i);
+	inline int length()
+	{
+		return _length;
+	}
+};
+
+class RHBelement
+{
+protected:
+	const char *class_name;
+	RHBelement *_parent;
+	RHBelement *_next;
+	RHBelement *_children;
+/*	RHBelement *_last;*/
+	RHBelement *_mem_next;
+public:
+	void remove_quotes(char *buf);
+	RHBinclude_file *defined_in;
+	int defined_line;
+	RHBshould_emit emit_root;
+
+static void delete_all(RHBelement *ex);
+static RHBelement *_mem_first;
+
+	inline RHBelement *next()
+	{
+		return _next;
+	}
+
+	inline RHBelement *children()
+	{
+		return _children;
+	}
+
+	inline RHBelement *parent()
+	{
+		return _parent;
+	}
+	inline const char *classname()
+	{
+		return class_name;
+	}
+
+	RHBmodifier_list modifier_data;
+
+	void read_modifier(RHBPreprocessor *pp,char *buf,size_t buflen,boolean passthru_flag);
+	void add_modifier_value(const char *buf);
+
+	int has_modifier_value(const char *p);
+	const char *get_modifier_string(const char *name);
+	void set_pragma_modifier(RHBPreprocessor *pp,const char *name,const char *value);
+
+	void build_id(char *buf,size_t buflen);
+	char *id;
+	boolean is_called(const char *buf);
+	void _set_id(const char *buf);
+	char *prefix;
+	void _set_prefix(const char *buf);
+	void _set_global_id(const char *buf);
+	void _set_version(const char *buf);
+	char *global_id;
+	char *version;
+	RHBelement(const char *class_n,RHBPreprocessor *pp,const char *name);
+	virtual ~RHBelement();
+	const char * _get_id();
+	void add(RHBPreprocessor *pp,RHBelement *child);
+	void add_nocheck(RHBPreprocessor *pp,RHBelement *child);
+	void remove(RHBelement *child);
+	virtual void build(RHBPreprocessor *pp)=0;
+	virtual RHBmodule *is_module();
+	virtual RHBinherited_operation *is_inherited_operation();
+	virtual RHBinterface *is_interface();
+	virtual RHBparameter *is_parameter();
+	virtual RHBoperation *is_operation();
+	virtual RHBtype *is_type();
+	virtual RHBexception *is_exception();
+	virtual RHBconstant *is_constant();
+	virtual RHBcontext_string *is_context();
+	virtual RHBinclude_file *is_include_file();
+	virtual RHBvalue *is_value();
+	virtual RHBmodifier *is_modifier();
+	virtual RHBrepository *is_repository();
+	virtual RHBattribute *is_attribute();
+	RHBtype *wrap_with_pointer(RHBPreprocessor *pp,char *buf,size_t buflen,RHBtype *t);
+	RHBtype *wrap_as_array(RHBPreprocessor *pp,char *buf,size_t buflen,RHBtype *t);
+	RHBelement * find_named_element(RHBPreprocessor *pp,char *buf,size_t nlen);
+	RHBelement *has_named_element(const char *);
+	RHBinterface * read_interface(RHBPreprocessor *pp,char *buf,size_t buflen);
+	RHBtype * read_type(RHBPreprocessor *pp,char *buf,size_t buflen);
+	RHBtype * read_struct(RHBPreprocessor *pp,char *buf,size_t buflen);
+	RHBtype * read_union(RHBPreprocessor *pp,char *buf,size_t buflen);
+	RHBtype * read_typedef(RHBPreprocessor *pp,char *buf,size_t buflen);
+	RHBmodule * read_module(RHBPreprocessor *pp,char *buf,size_t buflen);
+	RHBconstant * read_constant(RHBPreprocessor *pp,char *buf,size_t buflen);
+	RHBexception * read_exception(RHBPreprocessor *pp,char *buf,size_t buflen);
+	RHBenum * read_enum(RHBPreprocessor *pp,char *buf,size_t buflen);
+	RHBelement * read_pragma(RHBPreprocessor *pp,char *buf,size_t buflen);
+	RHBelement *read_token(RHBPreprocessor *pp,char *buf,size_t buflen);
+	RHBvalue *read_number(RHBPreprocessor *pp,char *buf,size_t buflen);
+	RHBvalue *read_string_value(RHBPreprocessor *pp,char *buf,size_t buflen);
+	void dump_ids(const char *p);
+
+	void reset_defined_in(RHBPreprocessor *pp);
+
+	virtual void destroy();
+
+	void gen_global_id();
+};
+
+class RHBinclude_file : public RHBelement
+{
+public:
+	RHBinclude_file(RHBPreprocessor *pp,const char *name);
+	void build(RHBPreprocessor *pp);
+	RHBinclude_file *is_include_file();
+	RHBelement *included_during;
+};
+
+class RHBinclude_list : public RHBelement
+{
+public:
+	RHBinclude_list(RHBPreprocessor *pp,const char *name);
+	RHBinclude_file *included(RHBPreprocessor *pp,const char *fname,RHBinclude_file *curr);
+	void build(RHBPreprocessor *pp);
+};
+
+class RHBmodule : public RHBelement
+{
+public:
+	RHBmodule(RHBPreprocessor *pp,const char *name);
+	void build(RHBPreprocessor *pp);
+	RHBmodule *is_module();
+};
+
+class RHBrepository : public RHBmodule
+{
+public:
+	RHBrepository(RHBPreprocessor *_pp,const char *name);
+	void build(RHBPreprocessor *pp);
+	RHBrepository *is_repository();
+	RHBPreprocessor &_pp;
+};
+
+class RHBtype : public RHBelement
+{
+public:
+	RHBtype(RHBPreprocessor *pp,const char *name);
+	RHBtype *is_type();
+	void build(RHBPreprocessor *pp);
+	virtual RHBenum *is_enum();
+	virtual RHBstruct *is_struct();
+	virtual RHBtype_def *is_typedef();
+	virtual RHBstruct_element *is_struct_element();
+	virtual RHBarray *is_array();
+	virtual RHBpointer_type * is_pointer();
+	virtual RHBstring_type *is_string();
+	virtual RHBqualified_type *is_qualified();
+	virtual RHBsequence_type *is_sequence();
+	virtual RHBunion *is_union();
+	virtual RHBunion_element *is_union_element();
+	virtual RHBbase_type *is_base_type();
+	virtual RHBany_type *is_any();
+	virtual RHBTypeCode_type *is_TypeCode();
+};
+
+class RHBbase_type : public RHBtype
+{
+public:
+	RHBbase_type(RHBPreprocessor *pp,
+			const char *name,
+			RHBtype *va_type,
+			boolean in_by_ref,
+			boolean floating);
+
+	boolean _floating;
+	RHBtype * _va_type;
+	boolean _in_by_ref;
+	RHBbase_type *is_base_type();
+
+static void boot_root_types(RHBPreprocessor *pp,RHBrepository *rp);
+};
+
+class RHBTypeCode_type: public RHBbase_type
+{
+public:
+	RHBTypeCode_type(RHBPreprocessor *pp,
+			const char *name,
+			RHBtype *va_type,
+			boolean in_by_ref);
+	RHBTypeCode_type *is_TypeCode();
+};
+
+class RHBany_type: public RHBbase_type
+{
+public:
+	RHBany_type(RHBPreprocessor *pp,
+			const char *name,
+			RHBtype *va_type,
+			boolean in_by_ref);
+	RHBany_type *is_any();
+};
+
+class RHBqualified_type : public  RHBtype
+{
+public:
+	RHBqualified_type(RHBPreprocessor *pp,const char *name);
+	RHBtype *base_type;
+	RHBqualified_type *is_qualified();
+};
+
+class RHBtype_def : public RHBtype
+{
+public:
+	RHBtype_def(RHBPreprocessor *pp,const char *name);
+	RHBtype *alias_for;
+	RHBtype_def *is_typedef();
+};
+
+class RHBarray : public RHBtype
+{
+public:
+	RHBarray(RHBPreprocessor *pp,const char *name);
+	RHBvalue *elements;
+	RHBtype *array_of;
+	RHBarray *is_array();
+};
+
+class RHBstruct : public RHBtype
+{
+public:
+	RHBstruct(RHBPreprocessor *pp,const char *name);
+	RHBstruct *is_struct();
+};
+
+class RHBunion : public RHBtype
+{
+public:
+	RHBunion(RHBPreprocessor *pp,const char *name);
+	RHBtype *switch_type;
+	RHBunion *is_union();
+	RHBelement_sequence elements;
+	long default_index;
+};
+
+class RHBstruct_element : public RHBtype
+{
+public:
+	RHBstruct_element(RHBPreprocessor *pp,const char *name);
+	RHBtype *element_type;
+	RHBstruct_element *is_struct_element();
+};
+
+class RHBunion_element : public RHBtype
+{
+public:
+	RHBunion_element(RHBPreprocessor *pp,const char *name);
+	RHBtype *element_type;
+	RHBvalue *switch_value;
+	RHBunion_element *is_union_element();
+};
+
+class RHBpointer_type : public RHBtype
+{
+public:
+	RHBpointer_type(RHBPreprocessor *pp,const char *name);
+	char type[2];
+	RHBtype *pointer_to;
+	RHBpointer_type * is_pointer();
+};
+
+class RHBsequence_type : public RHBtype
+{
+public:
+	RHBsequence_type(RHBPreprocessor *pp,const char *name);
+	RHBvalue * length;
+	RHBtype *sequence_of;
+	RHBsequence_type *is_sequence();
+};
+
+class RHBstring_type : public RHBtype
+{
+public:
+	RHBstring_type(RHBPreprocessor *pp,const char *name);
+	RHBvalue * length;
+	RHBstring_type *is_string();
+};
+
+class RHBinterface : public RHBtype
+{
+public:
+	RHBinterface(RHBPreprocessor *pp,const char *name);
+	void build(RHBPreprocessor *pp);
+	RHBinterface *is_interface();
+
+	RHBelement_sequence _parents;
+	RHBelement_sequence passthru_list;
+	RHBelement_sequence _metaclass_of;
+
+	void read_implementation(RHBPreprocessor *pp,char *buf,size_t buflen);
+	void build_instance_data(RHBPreprocessor *pp);
+
+	RHBstruct *instanceData;
+	RHBstruct *classData;
+	RHBstruct *cclassData;
+
+	void list_all_operations(RHBelement_sequence *seq);
+	void inherit_operations(RHBPreprocessor *pp,RHBinterface *iface);
+
+	boolean is_subclass_of(RHBinterface *p);
+};
+
+class RHBparameter : public RHBtype
+{
+public:
+	RHBparameter(RHBPreprocessor *pp,const char *name);
+	char mode[6];
+	RHBtype *parameter_type;
+	RHBparameter *is_parameter();
+};
+
+class RHBattribute : public RHBtype
+{
+public:
+	RHBattribute *is_attribute();
+	RHBattribute(RHBPreprocessor *pp,const char *name);
+	boolean readonly;
+	RHBtype *attribute_type;
+	void generate_accessors(RHBPreprocessor *pp,RHBinterface *iface);
+};
+
+class RHBvalue : public RHBtype
+{
+public:
+	RHBvalue(RHBPreprocessor *pp,const char *name);
+	~RHBvalue();
+	boolean was_quoted;
+	string value_string;
+	RHBvalue *is_value();
+	RHBconstant *assigned_value;
+	virtual long numeric_value();
+	long read_hex_value(const char *p);
+	long read_octal_value(const char *p);
+};
+
+class RHBconstant : public RHBvalue
+{
+public:
+	RHBconstant(RHBPreprocessor *pp,const char *name);
+	void read_c_value(RHBPreprocessor *pp,char *buf,size_t buflen);
+	RHBconstant *is_constant();
+	RHBtype *constant_type;
+	RHBvalue *const_val;
+	RHBtype *const_typecode_val;
+	virtual long numeric_value();
+	boolean is_numeric();
+	boolean is_const_TypeCode();
+	RHBenum *is_const_enum();
+	boolean is_private;
+};
+
+class RHBequation : public RHBconstant
+{
+public:
+	RHBequation(RHBPreprocessor *pp,const char *name);
+	virtual long numeric_value();
+	RHBvalue *val1;
+	RHBvalue *val2;
+	char op[5];
+};
+
+class RHBenum : public RHBtype
+{
+public:
+	RHBenum(RHBPreprocessor *pp,const char *name);
+	RHBenum *is_enum();
+};
+
+class RHBenum_val : public RHBvalue
+{
+public:
+	RHBenum_val(RHBPreprocessor *pp,const char *name);
+};
+
+class RHBexception : public RHBtype
+{
+public:
+	RHBexception(RHBPreprocessor *pp,const char *name);
+	void build(RHBPreprocessor *pp);
+	RHBexception *is_exception();
+};
+
+class RHBmodifier : public RHBtype
+{
+public:
+	RHBmodifier(RHBPreprocessor *pp,const char *name);
+	void build(RHBPreprocessor *pp);
+	RHBmodifier *is_modifier();
+};
+
+class RHBinherited_operation : public RHBtype
+{
+public:
+	RHBinherited_operation(RHBPreprocessor *pp,const char *name);
+	void build(RHBPreprocessor *pp);
+	RHBinherited_operation *is_inherited_operation();
+	RHBoperation *original;
+};
+
+class RHBcontext_string: public RHBelement
+{
+public:
+	RHBcontext_string(RHBPreprocessor *pp,const char *name);
+	~RHBcontext_string();
+	void build(RHBPreprocessor *pp);
+	string value;
+	RHBcontext_string *is_context();
+
+};
+
+class RHBoperation : public RHBtype
+{
+public:
+	RHBoperation(RHBPreprocessor *pp,const char *name);
+	void build(RHBPreprocessor *pp);
+	RHBelement_sequence exception_list;
+	RHBelement_sequence context_list;
+	boolean oneWay;
+	RHBtype *return_type;
+	RHBoperation *is_operation();
+	RHBparameter *get_parameter(int i);
+	boolean can_auto_stub();
+};
+
+class RHBattribute_accessor : public RHBoperation
+{
+public:
+	RHBattribute_accessor(RHBPreprocessor *pp,const char *name);
+	RHBattribute *for_attribute;
+};
+
+class RHBoutput
+{
+public:
+	virtual void write(const void *p,size_t len)=0;
+	virtual ~RHBoutput();
+};
+
+class RHBtextfile : public RHBoutput
+{
+	char *filename;
+	FILE *fp;
+public:
+	RHBtextfile(const char *name);
+	~RHBtextfile();
+	void write(const void *p,size_t len);
+};
+
+class RHBemitter
+{
+	RHBrepository *_rr;
+public:
+	const char *idl_name;
+	inline RHBrepository *GetRepository()
+	{
+		return _rr;
+	}
+	int nolegacy()
+	{
+		return 1;
+	}
+	const char *get_corbastring();
+	const char *unquote(char *tgt,const char *src);
+	RHBemitter(RHBrepository *rr);
+	virtual ~RHBemitter();
+
+	boolean CheckTrueCORBA(RHBtype *type);
+	virtual boolean ShouldEmit(RHBelement *t);
+
+	RHBelement_sequence generated_references;
+	RHBelement_sequence generated_definitions;
+	RHBelement_sequence is_generating_reference;
+	RHBelement_sequence is_generating_definition;
+
+	boolean has_generated_reference(RHBtype *type);
+	boolean has_generated_definition(RHBtype *type);
+
+	virtual boolean must_generate(RHBtype *type);
+	virtual boolean generate(RHBoutput *out,const char *f, const char *emitter_name)=0;
+	void get_ir_name(RHBelement *element,char *buf,size_t buflen);
+	void get_c_name(RHBelement *element,char *buf,size_t buflen);
+	void get_global_id(RHBelement *element,char *buf,size_t buflen);
+	const char *short_file_name(const char *long_file_name);
+	static RHBtype *unwind_typedef(RHBtype *t);
+	RHBtype *is_SOMFOREIGN(RHBtype *t);
+
+	void out_printf(RHBoutput *,const char *,...);
+	void dump_nest(RHBoutput *out,int nest);
+};
+
+/* this is the base class for header file generators,
+	first C then C++ derived from those */
+
+#if 0  
+class RHBheader_emitter : public RHBemitter
+{
+static const char *szSOM_RESOLVE_DATA;
+public:
+	RHBmodifier_list sequences;
+	RHBelement_sequence generated_types;
+	RHBelement_sequence generated_apply_stubs;
+	RHBmodifier_list generated_statics;
+	int is_kernel_class(RHBinterface *);
+
+	char idl_filestem[256];
+	char idl_conditional[512];
+	char file_guard[512];
+	RHBheader_emitter(RHBrepository *rr);
+	boolean cplusplus;
+	boolean internal;
+	boolean testonly;
+
+	void preflight_macros_from_idl_filename(const char *);
+
+	void undoublebar(RHBoutput *out,const char *);
+
+	void type_size_expand(RHBoutput *out,int nest,const char *t,struct type_size *a,size_t n);
+	int get_cif(RHBinterface *iface,char *buf,size_t buflen);
+	int is_unsigned(RHBtype *type);
+	int is_long(RHBtype *type);
+	int count_ClassData(RHBinterface *);
+	int get_init_operations(RHBinterface *,RHBelement_sequence *);
+	int get_va_operations(RHBinterface *,RHBelement_sequence *);
+
+	boolean useAlignmentHelper(void) { return cplusplus; };
+	boolean is_derived_from(RHBinterface *iface,RHBinterface *base);
+
+	void generate_type(RHBtype *type,RHBoutput *out,int nesting);
+	void generate_prototype(RHBtype *type,RHBoutput *out);
+	void generate_passthrus(RHBoutput *out,RHBelement *root,int nest);
+	void generate_usage(RHBtype *type,RHBoutput *out);
+	boolean generate(RHBoutput *out,const char *f, const char *emitter_name);
+
+	void generate_exception(RHBexception *s,RHBoutput *out,int nesting,const char *alias_name);
+	void generate_struct(RHBstruct *s,RHBoutput *out,int nesting,const char *alias_name,boolean user_data,boolean instanceData);
+	void generate_union(RHBunion *s,RHBoutput *out,int nesting,boolean user_data);
+	void generate_typedef(RHBtype_def *s,RHBoutput *out,int nesting);
+	void generate_enum(RHBenum *s,RHBoutput *out,int nesting);
+	static boolean is_in_floating(RHBparameter *param);
+	void generate_sizeof_va_list_param(RHBoutput *,RHBparameter *,int nesting);
+	void generate_headers(RHBoutput *out,int nest);
+	void generate_module(RHBoutput *out,RHBmodule *mod,int nest);
+	void generate_modules(RHBoutput *out,RHBmodule *mod,int nest);
+	void generate_class_protos(RHBoutput *out,RHBmodule *mod,int nest);
+	void generate_class_proto(RHBoutput *out,RHBinterface *iface,int nest);
+	void generate_types(RHBoutput *out,RHBelement *mod,int nest);
+	void generate_classes(RHBoutput *out,RHBmodule *mod,int nest,int apiOnlyFlag);
+	void generate_class(RHBoutput *out,RHBinterface *iface,int nest,int apiOnlyFlag);
+	void generate_instance_data(RHBoutput *out,RHBinterface *iface,int nest);
+	void generate_class_data(RHBoutput *out,RHBinterface *iface,int nest);
+	void generate_somTDs(RHBoutput *out,RHBinterface *iface,int nest);
+	void generate_somTD(RHBoutput *out,RHBinterface *iface,RHBoperation *op,int nest);
+	void generate_name_lookups(RHBoutput *out,RHBinterface *iface,int nest);
+	void generate_name_lookup(RHBoutput *out,RHBinterface *iface,RHBoperation *op,int nest);
+	RHBelement *generate_va_proto(RHBoutput *out,RHBinterface *iface,RHBoperation *op,int nest,int flag,const char *prefix);
+	void generate_va_stub(RHBoutput *out,RHBinterface *iface,RHBoperation *op,int nest,int flag,const char *prefix);
+	void generate_parameter_list(RHBoutput *out,RHBinterface *iface,RHBoperation *op,int nesting,boolean include_somSelf,boolean do_const_in);
+	void generate_name_only_parameter_list(RHBoutput *out,RHBinterface *iface,RHBoperation *op,boolean expand_self);
+	void generate_inline_operation(RHBoutput *out,RHBinterface *iface,RHBoperation *op,int nest);
+	void generate_inline_somNew_operation(RHBoutput *out,RHBinterface *iface,RHBoperation *op,int nest);
+	RHBinterface *find_highest_common_parent(RHBelement_sequence *seq); 
+	void generate_inline_varg_operation(RHBoutput *out,RHBinterface *iface,RHBoperation *op,int nest);
+	void generate_macro_operation(RHBoutput *out,RHBinterface *iface,RHBoperation *op,int nest);
+	void generate_inherited_macros(RHBoutput *out,RHBelement_sequence *duplicates,RHBinterface *iface,RHBinterface *parent);
+	struct dts_override *is_dts_override(RHBoperation *op);
+	void dts_parent_macro(RHBoutput *out,RHBinterface *iface,int num,RHBinterface *parent,RHBoperation *op,int nest);
+	void write_macro_args(RHBoutput *out,RHBoperation *op,int include_somself);
+	void generate_dts_macros(RHBoutput *out,RHBinterface *);
+	void generate_redispatch_stub(RHBoutput *out,RHBinterface *iface,RHBoperation *op,int nest);
+	void generate_redispatch_stub_proto(RHBoutput *out,RHBinterface *iface,RHBoperation *op,int nest);
+	void generate_apply_stub(RHBoutput *out,RHBinterface *iface,RHBoperation *op,int nest);
+	void generate_apply_stub_proto(RHBoutput *out,RHBinterface *iface,RHBoperation *op,int nest);
+	void generate_struct_element(RHBstruct_element *el,RHBoutput *out,int nest);
+	void generate_somId(RHBoutput *out,int nest,RHBelement *el,
+				const char *strPrefix,
+				const char *idPrefix,boolean ir_spec,boolean recurse);
+	RHBtype *generate_array_slice_typedef(RHBoutput *,int,RHBtype *,const char *n);
+	boolean do_const_param(RHBparameter *param);
+	void call_parent_constructors(RHBoutput *,RHBinterface *,int,const char *args);
+	void use_type(RHBoutput *out,RHBtype *typ,const char *name);
+	void init_type(RHBoutput *out,RHBtype *typ);
+	void get_sequence_name(RHBsequence_type *seq,char *name,size_t len);
+	void generate_rdsizetype(RHBoutput *,const char *,int);
+	void generate_operation_proto(RHBoutput *out,RHBinterface *iface,RHBoperation *op,int nest);
+	void get_function_prefix(RHBinterface *iface,char *buf,size_t buflen);
+	boolean get_meta_class(RHBinterface *iface,char *buf);
+	boolean get_actual_meta_class(RHBinterface *iface,char *buf,size_t buflen);
+	RHBinterface *get_meta_class_interface(RHBinterface *iface);
+	void generate_parent_macro(RHBoutput *out,RHBinterface *iface,RHBinterface *parent,RHBoperation *op,int nest);
+	RHBtype * get_most_primitive_name(RHBtype *typ,char *name,size_t namelen);
+	void generate_sequence(RHBoutput *out,RHBtype *typ,int nest);
+	void generate_constant(RHBoutput *out,RHBconstant *typ,int nest);
+	void generate_interface(RHBoutput *out,RHBinterface *iface,int nest);
+	int get_parent_index(RHBinterface *iface,RHBinterface *if2);
+	void generate_new_class(RHBoutput *out,RHBinterface *op,RHBelement_sequence *overrides,int nest);
+	boolean operation_needs_environment(RHBinterface *iface,RHBoperation *op);
+	boolean operation_needs_context(RHBinterface *iface,RHBoperation *op);
+	boolean parameter_by_reference(RHBparameter *param,RHBtype **array_of);
+	boolean operation_has_return(RHBoperation *op);
+	void use_va_arg(RHBoutput *out,const char *ap,RHBtype *typ,boolean byRef);
+	RHBtype *get_va_type(RHBtype *typ,boolean cast_floating);
+	int align_for(long curr,int align);
+	void determine_overrides(RHBinterface *iface,RHBinterface *candidates,RHBelement_sequence *seq);
+	void determine_inherited(RHBinterface *iface,RHBinterface *candidates,RHBelement_sequence *seq);
+	boolean does_override(RHBinterface *iface,const char *name);
+	boolean do_som21_macro(RHBinterface *iface,const char *name);
+	boolean has_same_ABI(RHBoperation *op1,RHBoperation *op2);
+	boolean same_ABI_type(RHBtype *t1,RHBtype *t2);
+	boolean some_ABI_kind_of_pointer(RHBtype *t);
+	void generate_versions(RHBoutput *out,RHBinterface *iface,const char *ext,const char *mod_name,int nest);
+	boolean is_multiple_inherited(RHBinterface *iface);
+	boolean will_generate_static(const char *p);
+	void ifdef_import_export(RHBoutput *out,RHBinterface *iface,int nest);
+	void extern_c_begin(RHBoutput *out,int nest);
+	void extern_c_end(RHBoutput *out,int nest);
+	void align_begin(RHBoutput *out,boolean user_data,int nest);
+	void align_end(RHBoutput *out,boolean user_data,int nest);
+	boolean is_operation_procedure(RHBoperation *op);
+	boolean is_operation_noself(RHBoperation *op);
+	void least_ambiguous_interface(RHBinterface *iface,const char *iface_name,char *buf,size_t buflen);
+
+	void generate_class_guard(RHBoutput *out,int nest,RHBinterface *iface,boolean how);
+
+	void begin_generate_static(RHBoutput *out,const char *name,int nest);
+	void end_generate_static(RHBoutput *out,const char *name,int nest);
+	void generate_init_zero(RHBoutput *out,const char *name,RHBtype *typ,int nest,unsigned long initial_value);
+
+	void generate_somMethodInfo(RHBoutput *out,RHBinterface *iface,RHBoperation *op,int nest,int auto_stub);
+	void generate_internal_class_data(RHBoutput *out,RHBinterface *iface);
+	void generate_internal_cclass_data(RHBoutput *out,RHBinterface *iface);
+	void generate_internal_ctrl_macros(RHBoutput *out,RHBinterface *iface);
+	void generate_beginassignop(
+			RHBoutput *out,
+			RHBinterface *iface);
+	void generate_begininit(
+			RHBoutput *out,
+			RHBinterface *iface,
+			const char *meth_name);
+	void generate_begindestruct(
+			RHBoutput *out,
+			RHBinterface *iface);
+	void generate_enddestruct(
+			RHBoutput *out,
+			RHBinterface *iface);
+	void generate_parent_initdestruct(
+			RHBoutput *out,
+			RHBinterface *iface);
+	void enum_attributes(RHBoutput *out,RHBinterface *iface);
+	void generate_internal_attribute(RHBoutput *out,RHBinterface *iface,RHBattribute *attr);
+	int generate_parent_resolved(RHBoutput *out,RHBinterface *iface,RHBinterface *parent,RHBoperation *op,int mode);
+	void gen_set_attribute(RHBoutput *out,RHBinterface *iface,RHBattribute *attr);
+	void gen_get_attribute(RHBoutput *out,RHBinterface *iface,RHBattribute *attr);
+	void generate_passthru(RHBoutput *out,RHBinterface *iface,const char *which);
+
+/*	inline void * operator new(size_t s)
+	{
+		return 0;
+	}*/
+
+	void gen_typecode_macro(RHBoutput *out,RHBtype *type,int nest);
+	void gen_typecode_inner(RHBoutput *out,RHBtype *type,int nest);
+	void gen_shortname(RHBoutput *out,RHBtype *type,const char *lead,int nest);
+	void gen_shortname_sequence(RHBoutput *out,RHBtype *type,int nest);
+
+	boolean type_is_sequence(RHBtype *t);
+	boolean type_is_any(RHBtype *t);
+	boolean op_is_varg(RHBoperation *op);
+	RHBtype *get_array_slice(RHBtype *t);
+
+	void public_class_data(RHBoutput *out,int nest,RHBinterface *iface,const char *n);
+	void public_class_data_resolve(RHBoutput *out,int nest,RHBinterface *iface,const char *n);
+};
+#endif
+
+#ifdef _USE_SOME_
+class RHBsome_emitter : public RHBemitter
+{
+static const char *szSOM_RESOLVE_DATA;
+public:
+	RHBmodifier_list sequences;
+	RHBelement_sequence generated_types;
+	RHBelement_sequence generated_apply_stubs;
+	RHBmodifier_list generated_statics;
+	int is_kernel_class(RHBinterface *);
+
+	char idl_filestem[256];
+	char idl_conditional[512];
+	char file_guard[512];
+	RHBsome_emitter(RHBrepository *rr);
+	boolean cplusplus;
+	boolean internal;
+	boolean testonly;
+	void preflight_macros_from_idl_filename(const char *);
+#if 0
+
+	void undoublebar(RHBoutput *out,const char *);
+
+	void type_size_expand(RHBoutput *out,int nest,const char *t,struct type_size *a,size_t n);
+	int get_cif(RHBinterface *iface,char *buf,size_t buflen);
+	int is_unsigned(RHBtype *type);
+	int is_long(RHBtype *type);
+	int count_ClassData(RHBinterface *);
+	int get_init_operations(RHBinterface *,RHBelement_sequence *);
+	int get_va_operations(RHBinterface *,RHBelement_sequence *);
+
+	boolean useAlignmentHelper(void) { return cplusplus; };
+	boolean is_derived_from(RHBinterface *iface,RHBinterface *base);
+
+	void generate_type(RHBtype *type,RHBoutput *out,int nesting);
+	void generate_prototype(RHBtype *type,RHBoutput *out);
+	void generate_passthrus(RHBoutput *out,RHBelement *root,int nest);
+	void generate_usage(RHBtype *type,RHBoutput *out);
+#endif
+	boolean generate(RHBoutput *out,const char *f, const char *emitter_name);
+#if 0
+	void generate_exception(RHBexception *s,RHBoutput *out,int nesting,const char *alias_name);
+	void generate_struct(RHBstruct *s,RHBoutput *out,int nesting,const char *alias_name,boolean user_data,boolean instanceData);
+	void generate_union(RHBunion *s,RHBoutput *out,int nesting,boolean user_data);
+	void generate_typedef(RHBtype_def *s,RHBoutput *out,int nesting);
+	void generate_enum(RHBenum *s,RHBoutput *out,int nesting);
+	static boolean is_in_floating(RHBparameter *param);
+	void generate_sizeof_va_list_param(RHBoutput *,RHBparameter *,int nesting);
+	void generate_headers(RHBoutput *out,int nest);
+	void generate_module(RHBoutput *out,RHBmodule *mod,int nest);
+	void generate_modules(RHBoutput *out,RHBmodule *mod,int nest);
+	void generate_class_protos(RHBoutput *out,RHBmodule *mod,int nest);
+	void generate_class_proto(RHBoutput *out,RHBinterface *iface,int nest);
+	void generate_types(RHBoutput *out,RHBelement *mod,int nest);
+	void generate_classes(RHBoutput *out,RHBmodule *mod,int nest,int apiOnlyFlag);
+	void generate_class(RHBoutput *out,RHBinterface *iface,int nest,int apiOnlyFlag);
+	void generate_instance_data(RHBoutput *out,RHBinterface *iface,int nest);
+	void generate_class_data(RHBoutput *out,RHBinterface *iface,int nest);
+	void generate_somTDs(RHBoutput *out,RHBinterface *iface,int nest);
+	void generate_somTD(RHBoutput *out,RHBinterface *iface,RHBoperation *op,int nest);
+	void generate_name_lookups(RHBoutput *out,RHBinterface *iface,int nest);
+	void generate_name_lookup(RHBoutput *out,RHBinterface *iface,RHBoperation *op,int nest);
+	RHBelement *generate_va_proto(RHBoutput *out,RHBinterface *iface,RHBoperation *op,int nest,int flag,const char *prefix);
+	void generate_va_stub(RHBoutput *out,RHBinterface *iface,RHBoperation *op,int nest,int flag,const char *prefix);
+	void generate_parameter_list(RHBoutput *out,RHBinterface *iface,RHBoperation *op,int nesting,boolean include_somSelf,boolean do_const_in);
+	void generate_name_only_parameter_list(RHBoutput *out,RHBinterface *iface,RHBoperation *op,boolean expand_self);
+	void generate_inline_operation(RHBoutput *out,RHBinterface *iface,RHBoperation *op,int nest);
+	void generate_inline_somNew_operation(RHBoutput *out,RHBinterface *iface,RHBoperation *op,int nest);
+	RHBinterface *find_highest_common_parent(RHBelement_sequence *seq); 
+	void generate_inline_varg_operation(RHBoutput *out,RHBinterface *iface,RHBoperation *op,int nest);
+	void generate_macro_operation(RHBoutput *out,RHBinterface *iface,RHBoperation *op,int nest);
+	void generate_inherited_macros(RHBoutput *out,RHBelement_sequence *duplicates,RHBinterface *iface,RHBinterface *parent);
+	struct dts_override *is_dts_override(RHBoperation *op);
+	void dts_parent_macro(RHBoutput *out,RHBinterface *iface,int num,RHBinterface *parent,RHBoperation *op,int nest);
+	void write_macro_args(RHBoutput *out,RHBoperation *op,int include_somself);
+	void generate_dts_macros(RHBoutput *out,RHBinterface *);
+	void generate_redispatch_stub(RHBoutput *out,RHBinterface *iface,RHBoperation *op,int nest);
+	void generate_redispatch_stub_proto(RHBoutput *out,RHBinterface *iface,RHBoperation *op,int nest);
+	void generate_apply_stub(RHBoutput *out,RHBinterface *iface,RHBoperation *op,int nest);
+	void generate_apply_stub_proto(RHBoutput *out,RHBinterface *iface,RHBoperation *op,int nest);
+	void generate_struct_element(RHBstruct_element *el,RHBoutput *out,int nest);
+	void generate_somId(RHBoutput *out,int nest,RHBelement *el,
+				const char *strPrefix,
+				const char *idPrefix,boolean ir_spec,boolean recurse);
+	RHBtype *generate_array_slice_typedef(RHBoutput *,int,RHBtype *,const char *n);
+	boolean do_const_param(RHBparameter *param);
+	void call_parent_constructors(RHBoutput *,RHBinterface *,int,const char *args);
+	void use_type(RHBoutput *out,RHBtype *typ,const char *name);
+	void init_type(RHBoutput *out,RHBtype *typ);
+	void get_sequence_name(RHBsequence_type *seq,char *name,size_t len);
+	void generate_rdsizetype(RHBoutput *,const char *,int);
+	void generate_operation_proto(RHBoutput *out,RHBinterface *iface,RHBoperation *op,int nest);
+	void get_function_prefix(RHBinterface *iface,char *buf,size_t buflen);
+	boolean get_meta_class(RHBinterface *iface,char *buf);
+	boolean get_actual_meta_class(RHBinterface *iface,char *buf,size_t buflen);
+	RHBinterface *get_meta_class_interface(RHBinterface *iface);
+	void generate_parent_macro(RHBoutput *out,RHBinterface *iface,RHBinterface *parent,RHBoperation *op,int nest);
+	RHBtype * get_most_primitive_name(RHBtype *typ,char *name,size_t namelen);
+	void generate_sequence(RHBoutput *out,RHBtype *typ,int nest);
+	void generate_constant(RHBoutput *out,RHBconstant *typ,int nest);
+	void generate_interface(RHBoutput *out,RHBinterface *iface,int nest);
+	int get_parent_index(RHBinterface *iface,RHBinterface *if2);
+	void generate_new_class(RHBoutput *out,RHBinterface *op,RHBelement_sequence *overrides,int nest);
+	boolean operation_needs_environment(RHBinterface *iface,RHBoperation *op);
+	boolean operation_needs_context(RHBinterface *iface,RHBoperation *op);
+	boolean parameter_by_reference(RHBparameter *param,RHBtype **array_of);
+	boolean operation_has_return(RHBoperation *op);
+	void use_va_arg(RHBoutput *out,const char *ap,RHBtype *typ,boolean byRef);
+	RHBtype *get_va_type(RHBtype *typ,boolean cast_floating);
+	int align_for(long curr,int align);
+	void determine_overrides(RHBinterface *iface,RHBinterface *candidates,RHBelement_sequence *seq);
+	void determine_inherited(RHBinterface *iface,RHBinterface *candidates,RHBelement_sequence *seq);
+	boolean does_override(RHBinterface *iface,const char *name);
+	boolean do_som21_macro(RHBinterface *iface,const char *name);
+	boolean has_same_ABI(RHBoperation *op1,RHBoperation *op2);
+	boolean same_ABI_type(RHBtype *t1,RHBtype *t2);
+	boolean some_ABI_kind_of_pointer(RHBtype *t);
+	void generate_versions(RHBoutput *out,RHBinterface *iface,const char *ext,const char *mod_name,int nest);
+	boolean is_multiple_inherited(RHBinterface *iface);
+	boolean will_generate_static(const char *p);
+	void ifdef_import_export(RHBoutput *out,RHBinterface *iface,int nest);
+	void extern_c_begin(RHBoutput *out,int nest);
+	void extern_c_end(RHBoutput *out,int nest);
+	void align_begin(RHBoutput *out,boolean user_data,int nest);
+	void align_end(RHBoutput *out,boolean user_data,int nest);
+	boolean is_operation_procedure(RHBoperation *op);
+	boolean is_operation_noself(RHBoperation *op);
+	void least_ambiguous_interface(RHBinterface *iface,const char *iface_name,char *buf,size_t buflen);
+
+	void generate_class_guard(RHBoutput *out,int nest,RHBinterface *iface,boolean how);
+
+	void begin_generate_static(RHBoutput *out,const char *name,int nest);
+	void end_generate_static(RHBoutput *out,const char *name,int nest);
+	void generate_init_zero(RHBoutput *out,const char *name,RHBtype *typ,int nest,unsigned long initial_value);
+
+	void generate_somMethodInfo(RHBoutput *out,RHBinterface *iface,RHBoperation *op,int nest,int auto_stub);
+	void generate_internal_class_data(RHBoutput *out,RHBinterface *iface);
+	void generate_internal_cclass_data(RHBoutput *out,RHBinterface *iface);
+	void generate_internal_ctrl_macros(RHBoutput *out,RHBinterface *iface);
+	void generate_beginassignop(
+			RHBoutput *out,
+			RHBinterface *iface);
+	void generate_begininit(
+			RHBoutput *out,
+			RHBinterface *iface,
+			const char *meth_name);
+	void generate_begindestruct(
+			RHBoutput *out,
+			RHBinterface *iface);
+	void generate_enddestruct(
+			RHBoutput *out,
+			RHBinterface *iface);
+	void generate_parent_initdestruct(
+			RHBoutput *out,
+			RHBinterface *iface);
+	void enum_attributes(RHBoutput *out,RHBinterface *iface);
+	void generate_internal_attribute(RHBoutput *out,RHBinterface *iface,RHBattribute *attr);
+	int generate_parent_resolved(RHBoutput *out,RHBinterface *iface,RHBinterface *parent,RHBoperation *op,int mode);
+	void gen_set_attribute(RHBoutput *out,RHBinterface *iface,RHBattribute *attr);
+	void gen_get_attribute(RHBoutput *out,RHBinterface *iface,RHBattribute *attr);
+	void generate_passthru(RHBoutput *out,RHBinterface *iface,const char *which);
+	void gen_typecode_macro(RHBoutput *out,RHBtype *type,int nest);
+	void gen_typecode_inner(RHBoutput *out,RHBtype *type,int nest);
+	void gen_shortname(RHBoutput *out,RHBtype *type,const char *lead,int nest);
+	void gen_shortname_sequence(RHBoutput *out,RHBtype *type,int nest);
+
+	boolean type_is_sequence(RHBtype *t);
+	boolean type_is_any(RHBtype *t);
+	boolean op_is_varg(RHBoperation *op);
+	RHBtype *get_array_slice(RHBtype *t);
+
+	void public_class_data(RHBoutput *out,int nest,RHBinterface *iface,const char *n);
+	void public_class_data_resolve(RHBoutput *out,int nest,RHBinterface *iface,const char *n);
+#endif
+};
+#endif //_USE_SOME_
+
+typedef int (* myFunc)(int x,int y);
+
+class SOMIR_element;
+class SOMIR_record;
+class SOMIR_free;
+
+class RHBir_file : public RHBoutput
+{
+	FILE *fp;
+	SOMIR_free *freeListItems;
+	long fileLength;
+	char filename[256];
+public:
+	long _get_fileLength() { return fileLength; }
+	RHBir_file(const char *name);
+	const char *_get_filename() { return filename; }
+
+	long rootContainer;
+
+	void write(const void *p,size_t len);
+
+	~RHBir_file();
+
+	void seek(long);
+	void read(void *,unsigned long);
+	boolean load(void);
+	void free(long,long);
+	long alloc(long,const char *,int);
+};
+
+#if 0
+class RHBir_emitter : public RHBemitter
+{
+public:
+	RHBir_file *irFile;
+	RHBir_emitter(RHBrepository *rr,RHBir_file *);
+	~RHBir_emitter();
+	 boolean generate(RHBoutput *out,const char *f, const char *emitter_name);
+};
+#endif
+
+#ifdef USE_SOURCE_EMITTER
+class RHBsource_emitter: public RHBheader_emitter
+{
+public:
+	RHBsource_emitter(RHBrepository *rr,RHBinclude_list *incls);
+	boolean generate(RHBoutput *out,const char *f, const char *emitter_name);
+	void gen_def_for_each_class(RHBoutput *out,RHBelement *el);
+
+	void gen_enum_classes(RHBoutput *out,RHBelement *el);
+	void gen_overrides(RHBoutput *out,RHBinterface *iface);
+	void gen_override_source(RHBoutput *out,RHBinterface *iface,RHBoperation *op);
+	void gen_introduced(RHBoutput *out,RHBinterface *iface);
+	void gen_introduced_source(RHBoutput *out,RHBinterface *iface,RHBoperation *op);
+};
+#endif
+
+#if 0
+class RHBkernel_emitter: public RHBheader_emitter
+{
+public:
+	RHBkernel_emitter(RHBrepository *rr);
+	boolean generate(RHBoutput *out,const char *f, const char *emitter_name);
+	RHBinterface *get_interface(const char *);
+	boolean can_override_op(RHBoperation *);
+	boolean is_overridden(RHBoperation *);
+	boolean is_aggregate(RHBoperation *);
+};
+
+class RHBapi_emitter: public RHBheader_emitter
+{
+public:
+	RHBapi_emitter(RHBrepository *rr);
+	boolean generate(RHBoutput *out,const char *f, const char *emitter_name);
+};
+#endif
+
+#ifndef _USE_SOME_
+#define tk_null      1
+#define tk_void      2
+#define tk_short     3
+#define tk_long      4
+#define tk_ushort    5
+#define tk_ulong     6
+#define tk_float     7
+#define tk_double    8
+#define tk_boolean   9
+#define tk_char      10
+#define tk_octet     11
+#define tk_any       12
+#define tk_TypeCode  13
+#define tk_Principal 14
+#define tk_objref    15
+#define tk_struct    16
+#define tk_union     17
+#define tk_enum      18
+#define tk_string    19
+#define tk_sequence  20
+#define tk_array     21
+
+#define tk_pointer   101 
+#define tk_self      102 
+#define tk_foreign   103 
+
+#else
+  #define __PRIVATE__
+  #include <sm.h>
+//  #include <scentry.xh>
+//  #include <scemit.xh>
+//  #include <scclass.xh>
+  #include <emitlib.h>
+#endif // !_USE_SOME_
+
+
+#define only_ibm_som  1
+#define gen_tc_macros 0
+
+struct RHBself_tracker
+{
+	RHBtype *current;
+	RHBself_tracker *previous;
+};
+
+#if 0
+class RHBtc_emitter: public RHBemitter
+{
+	boolean useAlignmentHelper(void) { return 1 /*0 */; };
+public:
+	RHBtc_emitter(RHBrepository *rr);
+	~RHBtc_emitter();
+	boolean generate(RHBoutput *out,const char *f, const char *emitter_name);
+	RHBelement_sequence extern_data;
+	RHBelement_sequence static_data;
+	RHBelement_sequence string_data;
+	RHBelement_sequence referenced_tcs;
+	void build_initial_list(RHBelement *el);
+	void generate_externs(RHBoutput *out);
+	void generate_aligns(RHBoutput *out,RHBelement_sequence *seq);
+	RHBconstant *find_constant_for(RHBtype *type,RHBelement_sequence *seq);
+	void build_secondary_list(RHBelement *el);
+	void need_type(RHBtype *type);
+	void need_string(const char *str);
+	RHBvalue *find_string(const char *str);
+	void generate_strings(RHBoutput *out);
+	void generate_string(RHBoutput *out,RHBvalue *val);
+	void generate_tc_pointers(RHBoutput *out,RHBelement_sequence *seq);
+	void generate_tc_pointer(RHBoutput *out,RHBconstant *c);
+	void generate_tcs(RHBoutput *out,RHBelement_sequence *seq);
+	void generate_tc(RHBoutput *out,RHBconstant *c);
+	void generate_TCKind(RHBoutput *out,RHBtype *type);
+	void generate_length(RHBoutput *out,RHBtype *type);
+	void generate_alignment(RHBoutput *out,RHBtype *type);
+	void generate_sequence_data(RHBoutput *out,const char *name,RHBtype *type);
+	void generate_interface_sequence_data(RHBoutput *out,RHBinterface *iface);
+	void generate_enum_sequence_data(RHBoutput *out,RHBenum *en);
+	void generate_sequence_sequence_data(RHBoutput *out,RHBsequence_type *seq);
+	void generate_string_sequence_data(RHBoutput *out,RHBstring_type *str);
+	void generate_struct_sequence_data(RHBoutput *out,RHBtype *str);
+	void generate_extra_params(RHBoutput *out,RHBconstant *con,RHBtype *type);
+	const char *struct_type_for_type(RHBtype *type);
+	const char *element_type_for_type(RHBtype *type);
+	void generate_idl_name(RHBoutput *out,RHBtype *type);
+	void generate_name(RHBoutput *out,RHBtype *type);
+};
+#endif
+
+void generate_TypeCode(RHBemitter *em,RHBoutput *out,RHBtype *type,const char *name);
+
diff -urN somfree\somipc2\include\rhbscifr.h newsomfree3\somipc2\include\rhbscifr.h
--- somfree\somipc2\include\rhbscifr.h	Thu Jan 01 07:00:00 1970
+++ newsomfree3\somipc2\include\rhbscifr.h	Sat Mar 16 14:09:27 2024
@@ -0,0 +1,50 @@
+/**************************************************************************
+ *
+ *  Copyright 1998-2010, Roger Brown
+ *
+ *  This file is part of Roger Brown's Toolkit.
+ *
+ *  This program is free software: you can redistribute it and/or modify it
+ *  under the terms of the GNU Lesser General Public License as published by the
+ *  Free Software Foundation, either version 3 of the License, or (at your
+ *  option) any later version.
+ * 
+ *  This program is distributed in the hope that it will be useful, but WITHOUT
+ *  ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ *  FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for
+ *  more details.
+ *
+ *  You should have received a copy of the GNU Lesser General Public License
+ *  along with this program.  If not, see <http://www.gnu.org/licenses/>
+ *
+ */
+ 
+/* 
+ * $Id: rhbscifr.h 2 2013-01-10 05:54:51Z somtoolkit $
+ */
+
+#ifndef RHBSCIFR_H
+	#define RHBSCIFR_H
+
+	/* #define RHBSC_dk_none 1UL */
+	#define RHBSC_dk_all 2UL
+	#define RHBSC_dk_Attribute 3UL
+	#define RHBSC_dk_Constant 4UL
+	#define RHBSC_dk_Exception 5UL
+	#define RHBSC_dk_Interface 6UL
+	#define RHBSC_dk_Module 7UL
+	#define RHBSC_dk_Operation 8UL
+	#define RHBSC_dk_Typedef 9UL
+	/* #define RHBSC_dk_Alias 10UL*/
+	/* #define RHBSC_dk_Struct 11UL */
+	/* #define RHBSC_dk_Union 12UL*/
+	/*#define RHBSC_dk_Enum 13UL*/
+	/*#define RHBSC_dk_Primitive 14UL*/
+	/*#define RHBSC_dk_String 15UL*/
+	/*#define RHBSC_dk_Sequence 16UL*/
+	/*#define RHBSC_dk_Array 17UL*/
+	#define RHBSC_dk_Repository 18UL
+	/*#define RHBSC_dk_Wstring 19UL*/
+	/*#define RHBSC_dk_Fixed 20UL*/
+
+#endif
diff -urN somfree\somipc2\makedefs.cf newsomfree3\somipc2\makedefs.cf
--- somfree\somipc2\makedefs.cf	Thu Jan 01 07:00:00 1970
+++ newsomfree3\somipc2\makedefs.cf	Sat Mar 16 14:09:27 2024
@@ -0,0 +1,4 @@
+NAME somipc2
+DEPENDS somc some
+PROVIDES somipc2
+VERSION 1.0
diff -urN somfree\somipc2\src\rhbidl.cpp newsomfree3\somipc2\src\rhbidl.cpp
--- somfree\somipc2\src\rhbidl.cpp	Thu Jan 01 07:00:00 1970
+++ newsomfree3\somipc2\src\rhbidl.cpp	Sat Mar 16 14:09:27 2024
@@ -0,0 +1,4736 @@
+/**************************************************************************
+ *
+ *  Copyright 1998-2010, Roger Brown
+ *
+ *  This file is part of Roger Brown's Toolkit.
+ *
+ *  This program is free software: you can redistribute it and/or modify it
+ *  under the terms of the GNU Lesser General Public License as published by the
+ *  Free Software Foundation, either version 3 of the License, or (at your
+ *  option) any later version.
+ * 
+ *  This program is distributed in the hope that it will be useful, but WITHOUT
+ *  ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ *  FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for
+ *  more details.
+ *
+ *  You should have received a copy of the GNU Lesser General Public License
+ *  along with this program.  If not, see <http://www.gnu.org/licenses/>
+ *
+ */
+ 
+/* 
+ * $Id: rhbidl.cpp 2 2013-01-10 05:54:51Z somtoolkit $
+ */
+
+#include <rhbopt.h>
+
+/* IDL compiler */
+
+#include <stdio.h>
+#include <string.h>
+#include <stdlib.h>
+
+#include <rhbsc.h>
+
+char double_quote='\"';
+char single_quote='\'';
+
+RHBmodule::RHBmodule(RHBPreprocessor *pp,const char *name) :
+RHBelement("RHBmodule",pp,name)
+{
+
+}
+
+void RHBmodule::build(RHBPreprocessor *pp)
+{
+	char buf[256];
+	RHBelement_new_scope scope(pp,this);
+
+	buf[0]=0;
+
+	while (1)
+	{
+		RHBelement *e;
+
+		if (!buf[0])
+		{
+			if (!pp->get_token(buf,sizeof(buf)))
+			{
+				pp->err("Failed while building module",id);
+
+				return;
+			}
+		}
+
+		if (0==strcmp(buf,"}"))
+		{
+			pp->get_token(buf,sizeof(buf));
+
+			if (strcmp(buf,";"))
+			{
+				pp->err("module should tail with a ;",buf);
+
+				return;
+			}
+
+			buf[0]=0;
+
+			return;
+		}
+
+		e=read_token(pp,buf,sizeof(buf));
+
+		if (!e)
+		{
+			pp->err("failed to understand token",buf);
+			return;
+		}
+	}
+}
+
+RHBrepository::RHBrepository(RHBPreprocessor *pp,const char *name) :
+/*RHBelement("RHBrepository",pp,name),*/
+	RHBmodule(pp,name),
+	_pp(*pp)
+{
+	RHBbase_type::boot_root_types(/*pp*/0,this);
+}
+
+void RHBrepository::build(RHBPreprocessor *pp)
+{
+	char buf[1024];
+	RHBelement_new_scope scope(pp,this);
+
+	buf[0]=0;
+
+	while (1)
+	{
+		RHBelement *e;
+
+		if (!buf[0])
+		{
+			if (!pp->get_token(buf,sizeof(buf)))
+			{
+				return;
+			}
+		}
+
+		e=read_token(pp,buf,sizeof(buf));
+
+		if (!e)
+		{
+			pp->err("token failed to build",buf);
+
+			return;
+		}
+	}
+}
+
+RHBelement * RHBelement::read_token(RHBPreprocessor *pp,char *buf,size_t buflen)
+{
+	if (!buf[0])
+	{
+		return 0;
+	}
+
+	if (!strcmp(buf,"interface"))
+	{
+		return read_interface(pp,buf,buflen);
+	}
+
+	if (!strcmp(buf,"typedef"))
+	{
+		return read_typedef(pp,buf,buflen);
+	}
+
+	if (!strcmp(buf,"exception"))
+	{
+		return read_exception(pp,buf,buflen);
+	}
+
+	if (!strcmp(buf,"const"))
+	{
+		return read_constant(pp,buf,buflen);
+	}
+
+	if (!strcmp(buf,"module"))
+	{
+		return read_module(pp,buf,buflen);
+	}
+
+	if (!strcmp(buf,"#pragma"))
+	{
+		return read_pragma(pp,buf,buflen);
+	}
+
+	if (0==strcmp(buf,"enum"))
+	{
+		return read_enum(pp,buf,buflen);
+	}
+
+	if (0==strcmp(buf,"struct"))
+	{
+		RHBtype *t=read_struct(pp,buf,buflen);
+
+		if (strcmp(buf,";"))
+		{
+			pp->err("should be ';'",buf);
+		}
+		else
+		{
+			buf[0]=0;
+		}
+
+		return t;
+	}
+
+	if (0==strcmp(buf,"union"))
+	{
+		RHBtype *t=read_union(pp,buf,buflen);
+
+		if (strcmp(buf,";"))
+		{
+			pp->err("should be ';'",buf);
+		}
+		else
+		{
+			buf[0]=0;
+		}
+
+		return t;
+	}
+
+	return 0;
+}
+
+void RHBelement::reset_defined_in(RHBPreprocessor *pp)
+{
+	if (pp)
+	{
+		defined_in=pp->CurrentFile();
+		defined_line=pp->CurrentLine();
+		emit_root=pp->GetEmitRoot();
+	}
+	else
+	{
+		defined_in=0;
+		emit_root=0;
+		defined_line=0;
+	}
+}
+
+RHBelement *RHBelement::_mem_first;
+
+void RHBelement::delete_all(RHBelement *ex)
+{
+	while (_mem_first)
+	{
+		RHBelement *el;
+
+		el=_mem_first;
+
+/*		printf("el==%s::%s\n",el->class_name,el->id);*/
+
+		if (el->_parent)
+		{
+			el->_parent->remove(el);
+		}
+
+		el->destroy();
+
+		if (ex != el)
+		{
+			delete el;
+		}
+		else
+		{
+			printf("dont delete root\n");
+		}
+	}
+}
+
+void RHBelement::destroy()
+{
+	RHBelement *el;
+
+	while (_children)
+	{
+		el=_children;
+
+		remove(el);
+
+		el->destroy();
+
+		delete el;
+	}
+
+	el=_mem_first;
+
+	if (el==this)
+	{
+		_mem_first=_mem_next;
+	}
+	else
+	{
+		while (el->_mem_next != this)
+		{
+			el=el->_mem_next;
+		}
+
+		el->_mem_next=_mem_next;
+	}
+}
+
+RHBelement::RHBelement(const char *cls,RHBPreprocessor *pp,const char *name) 
+{
+	class_name=cls;
+	_children=NULL;
+/*	_last=0;*/
+	_parent=NULL;
+	_next=NULL;
+	id=NULL;
+	prefix=NULL;
+	global_id=NULL;
+	version=NULL;
+
+	_mem_next=_mem_first;
+	_mem_first=this;
+
+	if (pp)
+	{
+		defined_in=pp->CurrentFile();
+		defined_line=pp->CurrentLine();
+		emit_root=pp->GetEmitRoot();
+	}
+	else
+	{
+		defined_in=0;
+		emit_root=0;
+		defined_line=0;
+	}
+
+	if (name)
+	{
+		if (*name)
+		{
+/*			if (!isalnum(*name))
+			{
+				if (*name!='_')
+				{
+					pp->err(cls,name);
+					bomb("RHBelement::RHBelement()");
+				}
+			}
+			*/
+			size_t len=strlen(name)+1;
+			id=new char [len];
+
+			strncpy(id,name,len);
+
+#ifdef _DEBUG
+/*			if (!strcmp(id,"string"))
+			{
+				printf("string created %p\n",this);
+			}*/
+#endif
+		}
+	}
+}
+
+RHBelement::~RHBelement() 
+{
+	if (id) 
+	{
+		delete id;
+		id=NULL;
+	}
+
+	if (prefix) 
+	{
+		delete prefix;
+		prefix=NULL;
+	}
+
+	if (global_id) 
+	{
+		delete global_id;
+		global_id=NULL;
+	}
+
+	if (version) 
+	{
+		delete version;
+		version=NULL;
+	}
+}
+
+RHBinterface * RHBelement::read_interface(RHBPreprocessor *pp,char *buf,size_t buflen)
+{
+	RHBinterface *ifac;
+	char b[256];
+	RHBelement *el;
+
+	if (!buf[0]) return 0;
+
+	if (strcmp(buf,"interface"))
+	{
+		return 0;
+	}
+
+	buf[0]=0;
+
+	pp->get_token(b,sizeof(b));
+
+	strncpy(buf,b,buflen);
+
+	ifac=NULL;
+
+	el=find_named_element(pp,b,sizeof(b));
+
+	if (el)
+	{
+		ifac=el->is_interface();
+	}
+
+	if (ifac)
+	{
+		if (ifac->parent() != this)
+		{
+/*			printf("## ignoring interface %s, creating %s::%s\n",
+					ifac->id,
+					id,
+					ifac->id);
+*/
+			ifac=new RHBinterface(pp,ifac->id);
+
+			add(pp,ifac);
+		}
+	}
+
+	if (!ifac)
+	{
+		ifac=new RHBinterface(pp,buf);
+
+		add(pp,ifac);
+
+		b[0]=0;
+	}
+
+	buf[0]=0;
+
+	if (!b[0])
+	{
+		pp->get_token(b,sizeof(b));
+	}
+
+	if (0==strcmp(b,";"))
+	{
+		return ifac;
+	}
+
+	if (ifac->next())
+	{
+		if (ifac->parent()==this)
+		{
+			remove(ifac);
+		}
+		else
+		{
+			ifac=new RHBinterface(pp,ifac->id);
+		}
+
+		add(pp,ifac);
+	}
+
+	if (0==strcmp(b,":"))
+	{
+		/* construct parent list */
+		b[0]=0;
+
+		while (1)
+		{
+			RHBinterface *f=0;
+
+			if (!b[0])
+			{
+				pp->get_token(b,sizeof(b));
+			}
+
+			if (!strcmp(b,"{"))
+			{
+				break;
+			}
+
+			el=find_named_element(pp,b,sizeof(b));
+
+			if (el)
+			{
+				f=el->is_interface();
+			}
+
+			if (!f)
+			{
+				pp->err("Can't find interface ",b);
+
+				return 0;
+			}
+
+			ifac->_parents.add(f);
+
+			if (!b[0])
+			{
+				pp->get_token(b,sizeof(b));
+			}
+			if (strcmp(b,","))
+			{
+				break;
+			}
+
+			b[0]=0;
+		}
+	}
+
+	if (0==strcmp(b,"{"))
+	{
+		/* changed the defined_in now */
+
+		ifac->reset_defined_in(pp);
+
+		ifac->build(pp);
+	}
+
+	return ifac;
+}
+
+RHBtype * RHBelement::read_type(RHBPreprocessor *pp,char *buf,size_t buflen)
+{
+	RHBtype *rt=NULL;
+
+	if (!buf[0])
+	{
+		pp->get_token(buf,buflen);
+	}
+
+	if ((0==strcmp(buf,"signed"))||(0==strcmp(buf,"unsigned")))
+	{
+		RHBtype *t2;
+		RHBqualified_type *qt;
+
+		qt=new RHBqualified_type(pp,buf);
+
+		buf[0]=0;
+
+		t2=read_type(pp,buf,buflen);
+
+		qt->base_type=t2;
+
+		return qt;
+	}
+
+	if (0==strcmp(buf,"enum"))
+	{
+		/* need to build an enum */
+
+		return read_enum(pp,buf,buflen);
+	}
+
+	if (0==strcmp(buf,"string"))
+	{	
+		RHBstring_type *t=0;
+
+		buf[0]=0;
+
+		pp->get_token(buf,buflen);
+
+		if (0==strcmp(buf,"<"))
+		{
+			t=new RHBstring_type(pp,"string");
+			/* read a number */
+
+			pp->get_token(buf,buflen);
+
+			t->length=read_number(pp,buf,buflen);
+
+			if (!buf[0])
+			{
+				pp->get_token(buf,buflen);
+			}
+
+			if (strcmp(buf,">"))
+			{
+				pp->err("length should tail with >",buf);
+			}
+
+			buf[0]=0;
+		}
+		else
+		{
+			char b2[256];
+			RHBelement *el;
+			RHBtype *tt;
+
+			strncpy(b2,"string",sizeof(b2));
+			el=find_named_element(0,b2,sizeof(b2));
+			tt=el->is_type();
+			t=tt->is_string();
+/*			if (!t) __asm int 3;*/
+			return tt;
+		}
+
+		if (!buf[0])
+		{
+			pp->get_token(buf,buflen);
+		}
+
+		return t;
+	}
+
+	if (0==strcmp(buf,"struct"))
+	{
+		rt=read_struct(pp,buf,buflen);
+	}
+	else
+	{
+		if (0==strcmp(buf,"union"))
+		{
+			rt=read_union(pp,buf,buflen);
+		}
+		else
+		{
+			if (0==strcmp(buf,"sequence"))
+			{
+				RHBsequence_type *ts;
+
+				pp->get_token(buf,buflen);
+
+				if (strcmp(buf,"<"))
+				{
+					pp->err("sequence should follow with <",buf);
+
+					return 0;
+				}
+
+				pp->get_token(buf,buflen);
+
+/*				if (0==strcmp(buf,"banana_type"))
+				{
+					printf("building banana_type\n");
+				}
+*/
+				rt=read_type(pp,buf,buflen);
+
+				if (!rt)
+				{
+					pp->err("Failed to read sequence type",buf);
+
+					return 0;
+				}
+
+				if (rt->is_pointer())
+				{
+					pp->err("Can't have a sequence of pointers - wrap with TypeDef\n",buf);
+
+					return 0;
+				}
+
+				ts=new RHBsequence_type(pp,rt->id);
+
+				ts->sequence_of=rt;
+
+				if (!buf[0])
+				{
+					pp->get_token(buf,buflen);
+				}
+
+				if (!strcmp(buf,","))
+				{
+					pp->get_token(buf,buflen);
+
+					ts->length=read_number(pp,buf,buflen);
+
+					if (!buf[0])
+					{
+						pp->get_token(buf,buflen);
+					}
+				}
+				
+				if (strcmp(buf,">"))
+				{
+					pp->err("sequence should tail with >",buf);
+
+					return 0;
+				}
+
+				buf[0]=0;
+				rt=ts;
+			}
+			else
+			{
+				RHBelement *el;
+
+				rt=0;
+
+				el=find_named_element(pp,buf,buflen);
+
+				if (!el)
+				{
+					return 0;
+				}
+
+				if (!buf[0])
+				{
+					pp->get_token(buf,buflen);
+				}
+
+				if (el)
+				{
+					rt=el->is_type();
+				}
+				else
+				{
+					pp->err("Failed to find type",buf);
+					return 0;
+				}
+
+/*				if (el->is_modifier())
+				{
+					printf("Modifier again %s\n",el->id);
+				}*/
+			}
+		}
+	}
+
+	if (!buf[0])
+	{
+		pp->get_token(buf,buflen);
+	}
+
+/*	while ((0==strcmp(buf,"*"))||(0==strcmp(buf,"&")))
+	{
+		RHBpointer_type *t2;
+
+		t2=new RHBpointer_type(0);
+
+		strcpy(t2->type,buf);
+
+		buf[0]=0;
+		t2->pointer_to=t;
+
+		t=t2;
+
+		pp->get_token(buf);
+	}
+*/
+	return rt;
+}
+
+RHBtype * RHBelement::read_typedef(RHBPreprocessor *pp,char *buf,size_t buflen)
+{
+	RHBtype *t;
+	RHBtype_def *t2;
+
+	if (!buf[0])
+	{
+		return 0;
+	}
+
+	if (strcmp(buf,"typedef"))
+	{
+		return 0;
+	}
+
+	buf[0]=0;
+
+	pp->get_token(buf,buflen);
+
+	t=read_type(pp,buf,buflen);
+
+	if (!buf[0])
+	{
+		pp->get_token(buf,buflen);
+	}
+
+	while (0==strcmp(buf,"*"))
+	{
+		t=wrap_with_pointer(pp,buf,buflen,t);
+
+		if (!buf[0])
+		{
+			pp->get_token(buf,buflen);
+		}
+	}
+
+	t2=new RHBtype_def(pp,buf);
+
+	pp->get_token(buf,buflen);
+
+	if (0==strcmp(buf,"["))
+	{
+		t=wrap_as_array(pp,buf,buflen,t);
+	}
+
+	if (!buf[0])
+	{
+		pp->get_token(buf,buflen);
+	}
+
+	if (0==strcmp(buf,";"))
+	{
+		RHBelement *e;
+
+		t2->alias_for=t;
+
+		e=_children;
+
+		while (e)
+		{
+			if (0==strcmp(t2->id,e->id))
+			{
+				const char *old_file=e->defined_in->id;
+				int old_line=e->defined_line;
+
+				printf("## previous def in %s:%d\n",old_file,old_line);
+
+				pp->err("Duplication of typedef",buf);
+
+				buf[0]=0;
+
+				return e->is_type();
+			}
+
+			e=e->_next;
+		}
+
+		add(pp,t2);
+
+		buf[0]=0;
+
+		return t2;
+	}
+
+	pp->err("typedef error near",buf);
+
+	delete t2;
+
+	return 0;
+}
+
+RHBmodule * RHBelement::read_module(RHBPreprocessor *pp,char *buf,size_t buflen)
+{
+	RHBmodule *m;
+	RHBelement *el;
+	char name[64];
+
+	if (strcmp(buf,"module"))
+	{
+		pp->err("Should say 'module'",buf);
+
+		return 0;
+	}
+
+	pp->get_token(buf,buflen);
+
+	m=0;
+
+	strncpy(name,buf,sizeof(name));
+
+	el=find_named_element(pp,buf,buflen);
+
+	if (el)
+	{
+		m=el->is_module();
+	}
+
+	if (!m)
+	{
+		m=new RHBmodule(pp,name);
+
+		add(pp,m);
+
+		buf[0]=0;
+	}
+
+	if (!buf[0])
+	{
+		pp->get_token(buf,buflen);
+	}
+
+	if (0==strcmp(buf,";"))
+	{
+		buf[0]=0;
+
+		return m;
+	}
+
+	if (strcmp(buf,"{"))
+	{
+		pp->err("module should open with braces",buf);
+
+		return 0;
+	}
+
+	buf[0]=0;
+
+	m->build(pp);
+
+	return m;
+}
+
+RHBexception::RHBexception(RHBPreprocessor *pp,const char *name)
+:/*	RHBelement("RHBexception",pp,name),*/
+	RHBtype(pp,name)
+{
+}
+
+void RHBexception::build(RHBPreprocessor *pp)
+{
+	char buf[256];
+
+	buf[0]=0;
+
+	while (1)
+	{
+		RHBtype *t;
+		RHBstruct_element *s;
+
+		if (!buf[0])
+		{
+			pp->get_token(buf,sizeof(buf));
+		}
+
+		if (0==strcmp(buf,"}"))
+		{
+			pp->get_token(buf,sizeof(buf));
+
+			if (strcmp(buf,";"))
+			{
+				pp->err("exception should tail with ;",buf);
+				return;
+			}
+
+			return;
+		}
+
+		t=read_type(pp,buf,sizeof(buf));
+
+		if (!t)
+		{
+			pp->err("exception should contain types",buf);
+			return;
+		}
+
+		if (!buf[0])
+		{
+			pp->get_token(buf,sizeof(buf));
+		}
+
+		while (0==strcmp(buf,"*"))
+		{
+			t=wrap_with_pointer(pp,buf,sizeof(buf),t);
+
+			if (!buf[0])
+			{
+				pp->get_token(buf,sizeof(buf));
+			}
+		}
+
+		s=new RHBstruct_element(pp,buf);
+
+		s->element_type=t;
+
+		add(pp,s);
+
+		pp->get_token(buf,sizeof(buf));
+
+		while (0==strcmp(buf,"["))
+		{
+			s->element_type=wrap_as_array(pp,buf,sizeof(buf),s->element_type);
+
+			if (!buf[0])
+			{
+				pp->get_token(buf,sizeof(buf));
+			}
+		}
+
+		if (strcmp(buf,";"))
+		{
+			pp->err("exception parameter should tail with a ;",buf);
+			return;
+		}
+
+		buf[0]=0;
+	}
+}
+
+RHBexception * RHBelement::read_exception(RHBPreprocessor *pp,char *buf,size_t buflen)
+{
+	RHBexception *e;
+
+	if (strcmp(buf,"exception"))
+	{
+		pp->err("Should be the word exception",buf);
+
+		return 0;
+	}
+
+	pp->get_token(buf,buflen);
+
+	e=new RHBexception(pp,buf);
+
+	add(pp,e);
+
+	pp->get_token(buf,buflen);
+
+	if (0==strcmp(buf,";"))
+	{
+		pp->err("exception should open with {",buf);
+
+		return e;
+	}
+
+	if (strcmp(buf,"{"))
+	{
+		pp->err("exception should open with {",buf);
+
+		return 0;
+	}
+
+	buf[0]=0;
+
+	e->build(pp);
+
+	return e;
+}
+
+RHBconstant * RHBelement::read_constant(RHBPreprocessor *pp,char *buf,size_t buflen)
+{
+	RHBtype *t;
+	RHBconstant *c;
+
+	if (strcmp(buf,"const"))
+	{
+		pp->err("should say const",buf);
+
+		return 0;
+	}
+
+	pp->get_token(buf,buflen);
+
+/*	if (!strcmp(buf,"completion_status"))
+	{
+		printf("looking..\n");
+	}
+*/
+	t=read_type(pp,buf,buflen);
+
+	if (!t)
+	{
+		pp->err("Failed to read type for constant",buf);
+
+		return 0;
+	}
+
+	if (!buf[0])
+	{
+		pp->get_token(buf,buflen);
+	}
+
+#ifdef _DEBUG__XX
+	if (!strcmp(buf,"kODNoEditor"))
+	{
+		__asm int 3;
+	}
+#endif
+
+	c=new RHBconstant(pp,buf);
+	add(pp,c);
+
+	buf[0]=0;
+
+	c->constant_type=t;
+
+	c->read_c_value(pp,buf,buflen);
+
+/*	printf("added constant %s\n",c->id);*/
+
+	return c;
+}
+
+RHBmodule * RHBelement::is_module()
+{
+	return 0;
+}
+
+RHBinterface * RHBelement::is_interface()
+{
+	return 0;
+}
+
+RHBtype * RHBelement::is_type()
+{
+	return 0;
+}
+
+RHBparameter * RHBelement::is_parameter()
+{
+	return 0;
+}
+
+RHBinterface::RHBinterface(RHBPreprocessor *pp,const char *name)
+: /*RHBelement("RHBinterface",pp,name), */RHBtype(pp,name)
+{
+	instanceData=0;
+	classData=0;
+	cclassData=0;
+}
+
+RHBattribute::RHBattribute(RHBPreprocessor *pp,const char *name)
+: /*RHBelement("RHBattribute",pp,name),*/ RHBtype(pp,name)
+{
+	readonly=0;
+}
+
+RHBconstant::RHBconstant(RHBPreprocessor *pp,const char *name)
+: /*RHBelement("RHBconstant",pp,name), */
+/*  RHBtype(pp,name),*/
+  RHBvalue(pp,name)
+{
+	value_string=0;
+	const_val=0;
+	const_typecode_val=0;
+	is_private=0;
+}
+
+RHBtype::RHBtype(RHBPreprocessor *pp,const char *name)
+: RHBelement("RHBtype",pp,name)
+{
+}
+
+RHBelement * RHBelement::find_named_element(RHBPreprocessor *pp,char *n,size_t nlen)
+{
+	RHBelement *e=_children;
+
+	if (!n) bomb("find_named_element with no name");
+
+	while (e)
+	{
+		if (0==strcmp(e->id,n))
+		{
+			if (!pp)
+			{
+				n[0]=0;
+
+				return e;
+			}
+
+			pp->get_token(n,nlen);
+
+			if (strcmp(n,"::"))
+			{
+				return e;
+			}
+
+			pp->get_token(n,nlen);
+
+			e=e->_children;
+		}
+		else
+		{
+			e=e->_next;
+		}
+	}
+
+	if (_parent)
+	{
+		e=_parent->find_named_element(pp,n,nlen);
+	}
+
+/*	if (!e)
+	{
+		if (is_interface())
+		{
+			RHBinterface *iface=is_interface();
+			int i=iface->_parents.length();
+			int j=0;
+
+			while (j < i)
+			{
+				RHBinterface *i2=iface->_parents.get(j)->is_interface();
+				j++;
+				e=i2->find_named_element(pp,n);
+				if (e) return e;
+			}
+		}
+	}
+*/
+	return e;
+}
+
+static void append_name(char *buf,size_t buflen,RHBelement *e)
+{
+/*	if (e->parent)
+	{
+		e->parent->append_name(buf,e->parent);
+	}
+*/
+	if (buf[0])
+	{
+		strncat(buf,"_",buflen);
+	}
+
+	strncat(buf,e->id,buflen);
+}
+
+void RHBinterface::build(RHBPreprocessor *pp)
+{
+	char buf[256];
+
+	if (instanceData)
+	{
+		pp->err("Interface is already built\n",id);
+	}
+	else
+	{
+		buf[0]=0;
+
+		append_name(buf,sizeof(buf),this);
+
+		strncat(buf,"Data",sizeof(buf));
+
+		instanceData=new RHBstruct(pp,buf);
+	}
+
+	{
+		size_t k=0;
+
+		while (k < _parents.length())
+		{
+			RHBinterface *par=_parents.get(k)->is_interface();
+			if (par)
+			{
+				inherit_operations(pp,par);
+			}
+			k++;
+		}
+	}
+
+	buf[0]=0;
+
+	while (1)
+	{
+		RHBelement *e;
+		boolean readOnly=0;
+		boolean oneWay=0;
+
+		if (!buf[0])
+		{
+			if (!pp->get_token(buf,sizeof(buf)))
+			{
+				pp->err("Could not complete interface",id);
+
+				return;
+			}
+		}
+
+		if (0==strcmp(buf,"}"))
+		{
+			build_instance_data(pp);
+
+			/* this should be the end */
+
+			pp->get_token(buf,sizeof(buf));
+
+			if (strcmp(buf,";"))
+			{
+				pp->err("Should be a ;",buf);
+
+				return;
+			}
+
+			return;
+		}
+
+		if (0==strcmp(buf,"readonly"))
+		{
+			buf[0]=0;
+
+			pp->get_token(buf,sizeof(buf));
+
+			readOnly=1;
+		}
+
+		if (0==strcmp(buf,"attribute"))
+		{
+			RHBtype *t;
+			RHBattribute *attr;
+
+			pp->get_token(buf,sizeof(buf));
+
+			t=read_type(pp,buf,sizeof(buf));
+
+			if (!t) 
+			{
+				pp->err("Failed to read type of attribute",buf);
+
+				return;
+			}
+
+			while (t)
+			{
+				RHBtype *t2=t;
+
+				if (!buf[0])
+				{
+					pp->get_token(buf,sizeof(buf));
+				}
+
+				while (0==strcmp(buf,"*"))
+				{
+					t2=wrap_with_pointer(pp,buf,sizeof(buf),t2);
+
+					if (!buf[0])
+					{
+						pp->get_token(buf,sizeof(buf));
+					}
+				}
+
+				attr=new RHBattribute(pp,buf);
+
+				add(pp,attr);
+
+				attr->readonly=readOnly;
+
+				pp->get_token(buf,sizeof(buf));
+
+				while (0==strcmp(buf,"["))
+				{
+					t2=wrap_as_array(pp,buf,sizeof(buf),t2);
+
+					if (!buf[0])
+					{
+						pp->get_token(buf,sizeof(buf));
+					}
+				}
+
+				attr->attribute_type=t2;
+
+				if (strcmp(buf,";"))
+				{
+					if (strcmp(buf,","))
+					{
+						pp->err("Error reading attribute",buf);
+
+						return;
+					}
+				}
+				else
+				{
+					t=0;
+				}
+
+				buf[0]=0;
+
+				attr->generate_accessors(pp,this);
+
+/*				RHBstruct_element *ie;
+
+				ie=new RHBstruct_element(pp,attr->id);
+
+				ie->element_type=attr->attribute_type;
+
+				instanceData->add(pp,ie);*/
+			}
+
+			continue;
+		}
+
+		if (0==strcmp(buf,"implementation"))
+		{
+			buf[0]=0;
+
+			read_implementation(pp,buf,sizeof(buf));
+
+			continue;
+		}
+
+		if (0==strcmp(buf,"oneway"))
+		{
+			buf[0]=0;
+
+			pp->get_token(buf,sizeof(buf));
+
+			oneWay=1;
+		}
+
+		e=read_token(pp,buf,sizeof(buf));
+
+		if (!e)
+		{
+			RHBtype *t;
+			RHBoperation *op;
+
+			t=read_type(pp,buf,sizeof(buf));
+
+			if (!t)
+			{
+				pp->err("Should be a type",buf);
+				return;
+			}
+
+			while (t)
+			{
+				char name[256];
+				RHBtype *t2=t;
+
+				if (!buf[0])
+				{
+					pp->get_token(buf,sizeof(buf));
+				}
+
+				while (0==strcmp(buf,"*"))
+				{
+					t2=wrap_with_pointer(pp,buf,sizeof(buf),t2);
+
+					if (!buf[0])
+					{
+						pp->get_token(buf,sizeof(buf));
+					}
+				}
+
+				strncpy(name,buf,sizeof(name));
+
+				pp->get_token(buf,sizeof(buf));
+
+				if (0==strcmp(buf,"("))
+				{
+					op=new RHBoperation(pp,name);
+
+					op->oneWay=oneWay;
+
+					add(pp,op);
+
+					op->return_type=t2;
+
+					op->build(pp);
+
+					buf[0]=0;
+
+					t=0;
+				}
+				else
+				{
+					RHBstruct_element *e2;
+
+					while (0==strcmp(buf,"["))
+					{
+						t2=wrap_as_array(pp,buf,sizeof(buf),t2);
+						if (!buf[0])
+						{
+							pp->get_token(buf,sizeof(buf));
+						}
+					}
+
+					e2=new RHBstruct_element(pp,name);
+
+					e2->element_type=t2;
+
+					add(pp,e2);
+
+					if (strcmp(buf,","))
+					{
+						if (strcmp(buf,";"))
+						{
+							pp->err("wrong terminator...",buf);
+
+							return;
+						}
+						else
+						{
+							t=0;
+						}
+					}
+
+					buf[0]=0;
+				}
+			}
+		}
+	}
+}
+
+void RHBinterface::build_instance_data(RHBPreprocessor *pp)
+{
+	RHBelement *el;
+
+	el=children();
+
+	while (el)
+	{
+		if (el->is_type())
+		{
+			if (el->is_type()->is_attribute())
+			{
+				RHBattribute *attr=el->is_type()->is_attribute();
+				if (!attr->has_modifier_value("nodata"))
+				{
+					RHBstruct_element *ie;
+
+					ie=new RHBstruct_element(pp,attr->id);
+
+					ie->element_type=attr->attribute_type;
+
+					instanceData->add(pp,ie);
+				}
+/*				else
+				{
+					printf("%s::%s has no data\n",id,attr->id);
+				}*/
+			}
+		}
+
+		el=el->next();
+	}
+}
+
+RHBbase_type::RHBbase_type(
+		RHBPreprocessor *pp,
+		const char *name,
+		RHBtype *va_type,
+		boolean in_by_ref,
+		boolean floating)
+: /*RHBelement("RHBbase_type",pp,name),*/RHBtype(pp,name)
+{
+	_floating=floating;
+	_va_type=va_type;
+	_in_by_ref=in_by_ref;
+}
+
+RHBtype_def::RHBtype_def(RHBPreprocessor *pp,const char *name)
+: /*RHBelement("RHBtype_def",pp,name),*/RHBtype(pp,name)
+{
+	alias_for=0;
+}
+
+void RHBelement::remove(RHBelement *ch)
+{
+	RHBelement *c;
+
+	if (ch->_parent != this)
+	{
+		bomb("mismatched parent in RHBelement::remove");
+
+		exit(1);
+	}
+
+	ch->_parent=0;
+
+	c=_children;
+
+	if (c==ch)
+	{
+		_children=ch->_next;
+	}
+	else
+	{
+		while (c->_next != ch)
+		{
+			c=c->_next;
+		}
+
+		c->_next=ch->_next;
+	}
+
+	ch->_next=0;
+}
+
+void RHBelement::add(RHBPreprocessor *pp,RHBelement *child)
+{
+	if (isdigit(child->id[0]))
+	{
+		bomb("RHBelement::add::isdigit()");
+	}
+
+	if (!isalpha(child->id[0]))
+	{
+		if (child->id[0]!='_')
+		{
+			bomb("RHBelement::add::!isalpha()");
+		}
+	}
+
+	if (!child->_parent)
+	{
+		if (child->_next)
+		{
+			child->_next=0;
+		}
+
+		if (_children)
+		{
+			RHBelement *e;
+
+			e=_children;
+
+			while (e)
+			{
+				if (0==strcmp(e->id,child->id))
+				{
+					char buf[1024];
+
+					snprintf(buf,sizeof(buf),"named item already defined in %s:%ld",
+							e->defined_in->id,(long)e->defined_line);
+					pp->err(buf,e->id);
+
+					bomb("RHBelement::add");
+				}
+
+				if (e->_next)
+				{
+					e=e->_next;
+				}
+				else
+				{
+					break;
+				}
+			}
+
+			e->_next=child;
+		}
+		else
+		{
+			_children=child;
+		}
+
+		child->_parent=this;
+	}
+	else
+	{
+			bomb("RHBelement::add");
+	}
+
+	child->gen_global_id();
+}
+
+void RHBelement::add_nocheck(RHBPreprocessor *pp,RHBelement *child)
+{
+	if (!child->_parent)
+	{
+		if (child->_next)
+		{
+			child->_next=0;
+		}
+
+		if (_children)
+		{
+			RHBelement *e=_children;
+
+			while (e)
+			{
+				if (e->id && child->id && (0==strcmp(e->id,child->id)))
+				{
+					char buf[1024];
+
+					snprintf(buf,sizeof(buf),"named item already defined in %s:%ld",
+							e->defined_in->id,(long)e->defined_line);
+					pp->err(buf,e->id);
+
+					bomb("RHBelement::add");
+				}
+
+				if (e->_next)
+				{
+					e=e->_next;
+				}
+				else
+				{
+					break;
+				}
+			}
+
+			e->_next=child;
+		}
+		else
+		{
+			_children=child;
+		}
+
+		child->_parent=this;
+	}
+	else
+	{
+		bomb("RHBelement::add_nocheck");
+	}
+}
+
+RHBtype *RHBtype::is_type()
+{
+	return this;
+}
+
+RHBinterface *RHBinterface::is_interface()
+{
+	return this;
+}
+
+void RHBtype::build(RHBPreprocessor *  /*pp*/)
+{
+
+}
+
+RHBqualified_type::RHBqualified_type(RHBPreprocessor *pp,const char *name)
+: /*RHBelement("RHBqualified_type",pp,name),*/RHBtype(pp,name)
+{
+}
+
+RHBpointer_type::RHBpointer_type(RHBPreprocessor *pp,const char *name)
+: /*RHBelement("RHBpointer_type",pp,name),*/RHBtype(pp,name)
+{
+}
+
+RHBelement * RHBelement::read_pragma(RHBPreprocessor *pp,char *buf,size_t buflen)
+{
+	if (strcmp(buf,"#pragma"))
+	{
+		pp->err("Should have said pragma...\n",buf);
+		return 0;
+	}
+
+	pp->get_token(buf,buflen);
+
+	if (0==strcmp(buf,"somemittypes"))
+	{
+		pp->get_token(buf,buflen);
+
+		if (!strcmp(buf,"on"))
+		{
+			pp->SetEmitRoot(RHBshould_emit_on);
+		}
+		else
+		{
+			if (!strcmp(buf,"off"))
+			{
+				pp->SetEmitRoot(RHBshould_emit_off);
+			}
+			else
+			{
+				pp->SetEmitRoot(RHBshould_emit_default);
+			}
+		}
+
+		buf[0]=0;
+
+		return this;
+	}
+
+	if (0==strcmp(buf,"modifier"))
+	{
+		RHBtype *t;
+
+		pp->get_token(buf,buflen);
+
+		t=read_type(pp,buf,buflen);
+
+		if (!t)
+		{
+			pp->err("Should have been a type",buf);
+
+			return 0;
+		}
+
+		if (!buf[0])
+		{
+			pp->get_token(buf,buflen);
+		}
+
+		if (strcmp(buf,":"))
+		{
+			pp->err("Should have been a ':'",buf);
+
+			return 0;
+		}
+
+/*		pp->get_token(buf,buflen);
+
+		RHBelement *e=t->find_named_element(pp,buf,buflen);
+
+		if (!e)
+		{
+			e=new RHBmodifier(pp,buf);
+			t->add(pp,e);
+		}
+
+		pp->get_token(buf,buflen);
+
+		if (strcmp(buf,"="))
+		{
+			pp->err("Should have been '='",buf);
+
+			return 0;
+		}*/
+
+		t->read_modifier(pp,buf,buflen,0);
+
+		return this;
+	}
+
+	if (0==strcmp(buf,"prefix"))
+	{
+		pp->get_token(buf,buflen);
+		pp->scope->_set_prefix(buf);
+
+		if (pp->scope != this)
+		{
+			bomb("hmm?");
+		}
+
+		set_pragma_modifier(pp,"prefix",buf);
+
+		buf[0]=0;
+
+		return this;
+	}
+
+	if (0==strcmp(buf,"ID"))
+	{
+		RHBelement *id2;
+
+		pp->get_token(buf,buflen);
+
+		id2=find_named_element(pp,buf,buflen);
+
+		id2->_set_global_id(buf);
+
+		id2->set_pragma_modifier(pp,"ID",buf);
+
+		buf[0]=0;
+
+		return this;
+	}
+
+	if (0==strcmp(buf,"version"))
+	{
+		RHBelement *id2;
+		char *p;
+		char c;
+
+		pp->get_token(buf,buflen);
+
+		id2=find_named_element(pp,buf,buflen);
+
+		p=&buf[strlen(buf)];
+
+		do
+		{
+			c=pp->get_non_whitespace();
+
+			if (c)
+			{
+				*p=c;
+				p++;
+			}
+
+		} while (c);
+
+		*p=0;
+		id2->_set_version(buf);
+
+		id2->set_pragma_modifier(pp,"version",buf);
+
+		buf[0]=0;
+
+		return this;
+	}
+
+#if 0
+	fprintf(stderr,"#pragma %s ....\n",buf);
+	fflush(stderr);
+#endif
+
+	buf[0]=0;
+
+	pp->pragma_clear();
+
+	return this;
+}
+
+RHBenum * RHBelement::read_enum(RHBPreprocessor *pp,char *buf,size_t buflen)
+{
+	RHBenum *t;
+
+	if (!buf[0])
+	{
+		return 0;
+	}
+
+	if (strcmp(buf,"enum"))
+	{
+		return 0;
+	}
+
+	pp->get_token(buf,buflen);
+
+	t=new RHBenum(pp,buf);
+
+	add(pp,t);
+
+	pp->get_token(buf,buflen);
+
+	if (0==strcmp(buf,";"))
+	{
+		buf[0]=0;
+
+		return t;
+	}
+	
+	if (0==strcmp(buf,"{"))
+	{
+		long val=1;		/* for SOM enums begin at one */
+
+		buf[0]=0;
+
+		do
+		{
+
+			pp->get_token(buf,buflen);
+
+			RHBenum_val *tv=new RHBenum_val(pp,buf);
+			char b[256];
+			int i=snprintf(b,sizeof(b),"%ld",(long)val);
+
+			tv->value_string=new char[i+1];
+			strncpy(tv->value_string,b,i+1);
+
+			val++;
+
+			t->add(pp,tv);
+
+			if (!pp->get_token(buf,buflen))
+			{
+				return 0;
+			}
+
+		} while (strcmp(buf,"}"));
+
+		buf[0]=0;
+	}
+
+	pp->get_token(buf,buflen);
+
+	if (0==strcmp(buf,";"))
+	{
+		buf[0]=0;
+
+		return t;
+	}
+
+	return t;
+}
+
+RHBvalue::RHBvalue(RHBPreprocessor *pp,const char *name)
+: /*RHBelement("RHBvalue",pp,name),*/RHBtype(pp,name)
+{
+	value_string=0;
+	was_quoted=0;
+	assigned_value=NULL;
+}
+
+RHBvalue::~RHBvalue()
+{
+	if (value_string)
+	{
+		delete value_string;
+		value_string=NULL;
+	}
+}
+
+RHBenum::RHBenum(RHBPreprocessor *pp,const char *name)
+: /*RHBelement("RHBenum",pp,name),*/RHBtype(pp,name)
+{
+}
+
+RHBenum_val::RHBenum_val(RHBPreprocessor *pp,const char *name)
+: /*RHBelement("RHBenum_val",pp,name),
+  RHBtype(pp,name),*/
+  RHBvalue(pp,name)
+{
+	value_string=0;
+}
+
+RHBtype * RHBelement::read_struct(RHBPreprocessor *pp,char *buf,size_t buflen)
+{
+	RHBstruct *t=0;
+
+	if (!buf[0])
+	{
+		return 0;
+	}
+
+	if (strcmp(buf,"struct"))
+	{
+		return 0;
+	}
+
+	buf[0]=0;
+
+	pp->get_token(buf,buflen);
+
+	if (strcmp(buf,"{"))
+	{
+		t=new RHBstruct(pp,buf);
+
+		add(pp,t);
+		pp->get_token(buf,buflen);
+	}
+	else
+	{
+		t=new RHBstruct(pp,0);
+	}
+
+	if (0==strcmp(buf,"{"))
+	{
+		RHBstruct_element *el;
+
+		buf[0]=0;
+
+		while (1)
+		{
+			if (!buf[0])
+			{
+				pp->get_token(buf,buflen);
+			}
+
+			RHBtype *t2=read_type(pp,buf,buflen);
+
+			if (!buf[0])
+			{
+				pp->get_token(buf,buflen);
+			}
+
+			while (1)
+			{
+				RHBtype *t3=t2;
+
+				while (0==strcmp(buf,"*"))
+				{
+					t3=wrap_with_pointer(pp,buf,buflen,t3);
+
+					if (!buf[0])
+					{
+						pp->get_token(buf,buflen);
+					}
+				}
+
+				el=new RHBstruct_element(pp,buf);
+
+				el->element_type=t3;
+
+				t->add(pp,el);
+
+				if (!pp->get_token(buf,buflen))
+				{
+					return 0;
+				}
+
+				while (0==strcmp(buf,"["))
+				{
+					el->element_type=wrap_as_array(pp,buf,buflen,el->element_type);
+	
+					if (!buf[0])
+					{
+						pp->get_token(buf,buflen);
+					}
+				}
+
+				if (strcmp(buf,","))
+				{
+					break;
+				}
+
+				pp->get_token(buf,buflen);
+			}
+
+			if (strcmp(buf,";"))
+			{
+				pp->err("building a struct, should be ;",buf);
+
+				return 0;
+			}
+
+			if (!pp->get_token(buf,buflen))
+			{
+				return 0;
+			}
+
+			if (0==strcmp(buf,"}"))
+			{
+				break;
+			}
+		}
+
+		buf[0]=0;
+	}
+
+	if (!buf[0])
+	{
+		pp->get_token(buf,buflen);
+	}
+
+	return t;
+}
+
+RHBstruct::RHBstruct(RHBPreprocessor *pp,const char *name)
+: /*RHBelement("RHBstruct",pp,name),*/RHBtype(pp,name)
+{
+}
+
+RHBstruct_element::RHBstruct_element(RHBPreprocessor *pp,const char *name)
+: /*RHBelement("RHBstruct_element",pp,name),*/RHBtype(pp,name)
+{
+}
+
+RHBunion::RHBunion(RHBPreprocessor *pp,const char *name)
+: /*RHBelement("RHBunion",pp,name),*/RHBtype(pp,name)
+{
+	default_index=-1;
+}
+
+RHBunion_element::RHBunion_element(RHBPreprocessor *pp,const char *name)
+: /*RHBelement("RHBunion_element",pp,name),*/RHBtype(pp,name)
+{
+}
+
+RHBarray::RHBarray(RHBPreprocessor *pp,const char *name)
+: /*RHBelement("RHBarray",pp,name),*/RHBtype(pp,name)
+{
+	elements=0;
+}
+
+RHBsequence_type::RHBsequence_type(RHBPreprocessor *pp,const char *name)
+: /*RHBelement("RHBsequence",pp,name),*/RHBtype(pp,name)
+{
+	length=0;
+}
+
+RHBstring_type::RHBstring_type(RHBPreprocessor *pp,const char *name)
+: /*RHBelement("RHBstring_type",pp,name),*/RHBtype(pp,name)
+{
+	length=0;
+}
+
+RHBtype *RHBelement::wrap_as_array(RHBPreprocessor *pp,char *buf,size_t buflen,RHBtype *t)
+{
+	RHBvalue *elements[256];
+	int nDimensions=0;
+
+	if (!buf[0]) 
+	{
+		pp->get_token(buf,buflen);
+	}
+
+	while (!strcmp(buf,"["))
+	{
+/*		RHBarray *ta;*/
+
+		pp->get_token(buf,buflen);
+/*
+		ta=new RHBarray(pp,buf);*/
+
+		/* this may be a constant */
+
+/*		ta->elements=read_number(pp,buf);
+
+		ta->array_of=t;*/
+
+		elements[nDimensions++]=read_number(pp,buf,buflen);
+
+		if (!buf[0])
+		{
+			pp->get_token(buf,buflen);
+		}
+
+		if (strcmp(buf,"]"))
+		{
+			pp->err("Should be ']'",buf);
+
+			return 0;
+		}
+
+		pp->get_token(buf,buflen);
+
+/*		t=ta;*/
+	}
+
+	if (nDimensions)
+	{
+		int i=nDimensions;
+
+		while (i--)
+		{
+			RHBarray *ta=new RHBarray(pp,"0");
+			ta->elements=elements[i];
+			ta->array_of=t;
+			t=ta;
+		}
+	}
+
+	return t;
+}
+
+RHBconstant *RHBelement::is_constant()
+{
+	return 0;
+}
+
+RHBconstant *RHBconstant::is_constant()
+{
+	return this;
+}
+
+void RHBelement::dump_ids(const char *p)
+{
+	RHBelement *c;
+
+	char buf[1024];
+
+	buf[0]=0;
+
+	if (p) strncpy(buf,p,sizeof(buf));
+
+	if (id)
+	{
+		strncat(buf,"::",sizeof(buf));
+		strncat(buf,id,sizeof(buf));
+	}
+
+/*	printf("%s [%s]",buf,class_name);*/
+
+	if (defined_in)
+	{
+/*		printf("%s",defined_in->id);*/
+	}
+
+/*	printf("\n");*/
+
+	c=_children;
+
+	while (c)
+	{
+		c->dump_ids(buf);
+		c=c->_next;
+	}
+
+}
+
+RHBelement_sequence::RHBelement_sequence()
+{
+	_buffer=0;
+	_length=0;
+	_maximum=0;
+}
+
+RHBelement_sequence::~RHBelement_sequence()
+{
+	if (_buffer) delete _buffer;
+}
+
+RHBelement *RHBelement_sequence::get(unsigned long i)
+{
+	if (i >= _length) return 0;
+	return _buffer[i];
+}
+
+RHBoperation::RHBoperation(RHBPreprocessor *pp,const char *name)
+: /*RHBelement("RHBoperation",pp,name),*/RHBtype(pp,name)
+{
+	oneWay=0;
+	return_type=0;
+}
+
+RHBparameter::RHBparameter(RHBPreprocessor *pp,const char *name)
+: /*RHBelement("RHBparameter",pp,name),*/RHBtype(pp,name)
+{
+}
+
+RHBmodifier::RHBmodifier(RHBPreprocessor *pp,const char *name)
+: /*RHBelement("RHBmodifier",pp,name),*/RHBtype(pp,name)
+{
+}
+
+void RHBmodifier::build(RHBPreprocessor *  /*pp*/)
+{
+}
+
+void RHBoperation::build(RHBPreprocessor *pp)
+{
+	char buf[256];
+
+/*	opening round bracket should have been detected already
+buf[0]=0;
+
+	pp->get_token(buf);
+
+	if (strcmp("(",buf))
+	{
+		pp->err("Operation should start with a '('",buf);
+
+		return;
+	}
+*/
+
+	buf[0]=0;
+
+	while (1)
+	{
+		char mode[6];
+		RHBtype *t;
+		RHBparameter *param;
+
+		if (!buf[0])
+		{
+			if (!pp->get_token(buf,sizeof(buf)))
+			{
+				pp->err("failed while building operation ",id);
+
+				return;
+			}
+		}
+
+		if (0==strcmp(buf,")"))
+		{
+			buf[0]=0;
+
+			break;
+		}
+
+		if (strcmp(buf,"in"))
+		{
+			if (strcmp(buf,"out"))
+			{
+				if (strcmp(buf,"inout"))
+				{
+					pp->err("parameter should in in,inout or out",buf);
+
+					return;
+				}
+			}
+		}
+
+		strncpy(mode,buf,sizeof(mode));
+
+		buf[0]=0;
+
+		pp->get_token(buf,sizeof(buf));
+
+		t=read_type(pp,buf,sizeof(buf));
+
+		if (!t)
+		{
+			pp->err("failed to read parameter type",buf);
+
+			return;
+		}
+
+		if (!buf[0])
+		{
+			pp->get_token(buf,sizeof(buf));
+		}
+
+		while (0==strcmp(buf,"*"))
+		{
+			t=wrap_with_pointer(pp,buf,sizeof(buf),t);
+
+			if (!buf[0])
+			{
+				pp->get_token(buf,sizeof(buf));
+			}
+		}
+
+		param=new RHBparameter(pp,buf);
+		param->parameter_type=t;
+		strncpy(param->mode,mode,sizeof(param->mode));
+		add(pp,param);
+
+		pp->get_token(buf,sizeof(buf));
+
+		if (0==strcmp(buf,")"))
+		{
+			/* end of parameter list */
+
+			buf[0]=0;
+
+			break;
+		}
+
+		if (strcmp(buf,","))
+		{
+			pp->err("parameters should be separated by ,",buf);
+
+			return;
+		}
+
+		buf[0]=0;
+	}
+
+	/* we've read the list, now do the raises and context */
+
+	while (1)
+	{
+		if (!buf[0])
+		{
+			pp->get_token(buf,sizeof(buf));
+		}
+
+		if (0==strcmp(buf,";"))
+		{
+			return;
+		}
+
+		if (0==strcmp(buf,"raises"))
+		{
+			buf[0]=0;
+
+			pp->get_token(buf,sizeof(buf));
+		
+			if (strcmp(buf,"("))
+			{
+				pp->err("raises list should open with a (",buf);
+				buf[0]=0;
+				return;
+			}
+
+			buf[0]=0;
+
+			while (1)
+			{
+				RHBelement *t;
+
+				if (!buf[0])
+				{
+					pp->get_token(buf,sizeof(buf));
+				}
+
+				if (0==strcmp(buf,")"))
+				{
+					buf[0]=0;
+					break;
+				}
+
+				t=find_named_element(pp,buf,sizeof(buf));
+
+				if (!t)
+				{
+					pp->err("did not find exception",buf);
+					buf[0]=0;
+					return;
+				}
+
+				if (!t->is_exception())
+				{
+					pp->err("did not find exception",buf);
+					buf[0]=0;
+					return;
+				}
+
+				exception_list.add(t);
+
+				if (strcmp(buf,","))
+				{
+					if (strcmp(buf,")"))
+					{
+						pp->err("exception list error",buf);
+						buf[0]=0;
+						return;
+					}
+				}
+				else
+				{
+					buf[0]=0;
+				}
+			}
+		}
+		else
+		{
+			if (0==strcmp(buf,"context"))
+			{
+				pp->get_token(buf,sizeof(buf));
+
+				if (strcmp(buf,"("))
+				{
+					pp->err("context should be followed by a (",buf);
+					buf[0]=0;
+					return;
+				}
+
+				buf[0]=0;
+
+				while (1)
+				{
+					if (!buf[0])
+					{
+						pp->get_token(buf,sizeof(buf));
+					}
+
+					RHBcontext_string *str;
+
+					str=new RHBcontext_string(pp,0);
+
+					size_t x=strlen(buf)+1;
+
+					str->value=new char[x];
+
+					strncpy(str->value,buf,x);
+
+					context_list.add(str);
+
+					pp->get_token(buf,sizeof(buf));
+
+					if (!strcmp(buf,")"))
+					{
+						buf[0]=0;
+						break;
+					}
+
+					if (strcmp(buf,","))
+					{
+						pp->err("context strings need comma separator",buf);
+
+						buf[0]=0;
+
+						return;
+					}
+
+					buf[0]=0;
+				}
+			}
+			else
+			{
+				pp->err("unknown trailing operation keyword",buf);
+				buf[0]=0;
+				return;
+			}
+		}
+	}
+}
+
+void RHBinterface::read_implementation(RHBPreprocessor *pp,char *buf,size_t buflen)
+{
+	boolean contents=0;
+
+	if (!buf[0])
+	{
+		pp->get_token(buf,buflen);
+	}
+
+	if (strcmp(buf,"{"))
+	{
+		pp->err("Should start implementation with {",buf);
+
+		return;
+	}
+
+	buf[0]=0;
+
+	while (1)
+	{
+		boolean passthru_flag=0;
+		RHBelement *e=0;
+
+		char name[256];
+
+		if (!buf[0])
+		{
+			pp->get_token(buf,buflen);
+		}
+
+		if (0==strcmp(buf,"}"))
+		{
+			if (!contents)
+			{
+				pp->err("implementation is empty",buf);
+			}
+
+			buf[0]=0;
+
+			break;
+		}
+
+		contents=1;
+
+		if (0==strcmp(buf,"passthru"))
+		{
+			pp->get_token(buf,buflen);
+
+			e=new RHBmodifier(pp,buf);
+
+			passthru_list.add(e);
+	
+			buf[0]=0;
+
+			passthru_flag=1;
+		}
+		else
+		{
+			e=read_type(pp,buf,buflen);
+
+			if (e)
+			{
+				RHBtype *t=e->is_type();
+
+				if (!buf[0])
+				{
+					pp->get_token(buf,buflen);
+				}
+
+				if (t && (strcmp(buf,":")))
+				{
+					while (1)
+					{
+						RHBtype *t2;
+						RHBstruct_element *e2;
+
+						if (!buf[0])
+						{
+							pp->get_token(buf,buflen);
+						}
+
+						t2=t;
+
+						while (0==strcmp(buf,"*"))
+						{
+							t2=wrap_with_pointer(pp,buf,buflen,t2);
+
+							if (!buf[0])
+							{
+								pp->get_token(buf,buflen);
+							}
+						}
+					
+						e2=new RHBstruct_element(pp,buf);
+
+						e2->element_type=t2;
+
+						pp->get_token(buf,buflen);
+
+						while (0==strcmp(buf,"["))
+						{
+							e2->element_type=wrap_as_array(pp,buf,buflen,
+									e2->element_type);
+
+							if (!buf[0])
+							{
+								pp->get_token(buf,buflen);
+							}
+						}
+
+						instanceData->add(pp,e2);
+
+						if (0==strcmp(buf,";"))
+						{
+							buf[0]=0;
+							break;
+						}
+
+						if (strcmp(buf,","))
+						{
+							pp->err("Should be comma or semicolon",buf);
+
+							buf[0]=0;
+
+							break;
+						}
+					}
+
+					continue;
+				}
+			}
+		}
+
+		if (!e)
+		{
+			if (!buf[0])
+			{
+				pp->get_token(buf,buflen);
+			}
+
+			strncpy(name,buf,sizeof(name));
+	
+			if (!e)
+			{
+				e=find_named_element(pp,buf,buflen);
+			}
+		}
+
+		if (!e)
+		{
+			e=new RHBmodifier(pp,name);
+
+			add(pp,e);
+
+			buf[0]=0;
+		}
+
+		if (!buf[0])
+		{
+			pp->get_token(buf,buflen);
+		}
+
+		e->read_modifier(pp,buf,buflen,passthru_flag);
+
+		if (e->is_called("metaclass"))
+		{
+			const char *meta=e->modifier_data.get(0);
+			char buf2[256];
+			RHBelement *em;
+
+			strncpy(buf2,meta,sizeof(buf2));
+
+			remove_quotes(buf2);
+
+/*			printf("'%s' has '%s' as meta class\n",
+				id,buf);
+*/
+			em=find_named_element(0,buf2,sizeof(buf2));
+
+			if (em)
+			{
+				RHBinterface *m=em->is_interface();
+
+				if (m)
+				{
+					m->_metaclass_of.add(this);
+				}
+				else
+				{
+					printf("'%s' is not an interface\n",meta);
+				}
+			}
+			else
+			{
+				printf("can't find metaclass '%s'\n",meta);
+			}
+		}
+	}
+
+	if (!buf[0])
+	{
+		pp->get_token(buf,buflen);
+	}
+
+	if (strcmp(buf,";"))
+	{
+		pp->err("should tail implementation with ;",buf);
+
+		return;
+	}
+
+	buf[0]=0;
+}
+
+boolean RHBelement::is_called(const char *buf)
+{
+	if (buf[0])
+	{
+		if (id)
+		{
+			if (!strcmp(buf,id)) return 1;
+		}
+	}
+	return 0;
+}
+
+int RHBelement_sequence::index(RHBelement *e)
+{
+	int i=0;
+
+	while (1)
+	{
+		if (_buffer[i]==e) return i;
+		i++;
+	}
+}
+
+void RHBelement_sequence::add(RHBelement *e)
+{
+	if (_length==_maximum)
+	{
+		RHBelement **buf;
+		size_t i;
+		typedef RHBelement * RHBelements;
+		_maximum+=32;
+
+		buf=new RHBelements[_maximum];
+
+		i=0;
+
+		while (i < _length)
+		{
+			buf[i]=_buffer[i];
+			i++;
+		}
+
+		if (i)
+		{
+			delete _buffer;
+		}
+
+		_buffer=buf;
+	}
+
+	_buffer[_length]=e;
+	_length++;
+}
+
+
+RHBmodule *RHBmodule::is_module()
+{
+	return this;
+}
+
+void RHBconstant::read_c_value(RHBPreprocessor *pp,char *buf,size_t buflen)
+{
+	if (!buf[0])
+	{
+		pp->get_token(buf,buflen);
+	}
+
+	if (strcmp(buf,"="))
+	{
+		if (strcmp(buf,";"))
+		{
+			pp->err("error in constant",id);
+
+			return;
+		}
+
+		buf[0]=0;
+
+		return;
+	}
+
+	buf[0]=0;
+	const_typecode_val=0;
+
+	if (is_const_TypeCode())
+	{
+		const_typecode_val=read_type(pp,buf,buflen);
+
+		if (!const_typecode_val)
+		{
+			if (!strcmp(buf,"null"))
+			{
+				buf[0]=0;
+			}
+		}
+	}
+	else
+	{
+		RHBenum *en=is_const_enum();
+		if (en)
+		{
+			pp->get_token(buf,buflen);
+			RHBelement *t=en->find_named_element(NULL,buf,buflen);
+			if (t)
+			{
+				const_val=t->is_value();
+				buf[0]=0;
+			}
+			else
+			{
+				pp->err("Error in constant",buf);
+				return;
+			}
+		}
+		else
+		{
+			if (is_numeric())
+			{
+				const_val=read_number(pp,buf,buflen);
+			}
+			else
+			{
+				pp->get_token(buf,buflen);
+
+				if (buf[0]=='\"')
+				{
+					size_t i=strlen(buf)-2; /* strip two quotes */
+
+					was_quoted=1;
+
+					if (((int)i) >=0)
+					{
+						if (i > 0)
+						{
+							memmove(buf,buf+1,i);
+						}
+						buf[i]=0;
+					}
+
+					size_t x=strlen(buf)+1;
+					value_string=new char[x];
+					strncpy(value_string,buf,x);
+					buf[0]=0;
+				}
+				else
+				{
+					RHBelement *t=find_named_element(pp,buf,buflen);
+
+					if (t)
+					{
+						assigned_value=t->is_constant();
+
+						if (!assigned_value)
+						{
+							pp->err("Error in constant",buf);
+						}
+
+						const_val=assigned_value;
+					}
+					else
+					{
+						const_val=read_number(pp,buf,buflen);
+					}
+				}
+			}
+		}
+	}
+
+	if (!buf[0])
+	{
+		pp->get_token(buf,buflen);
+	}
+
+	if (0==strcmp(buf,";"))
+	{
+		buf[0]=0;
+
+		return;
+	}
+
+	pp->err("Error in constant",buf);
+}
+
+boolean RHBconstant::is_const_TypeCode()
+{
+	if (constant_type->is_TypeCode())
+	{
+		return 1;
+	}
+
+	return 0;
+}
+
+boolean RHBconstant::is_numeric()
+{
+	RHBtype *t;
+	RHBbase_type *bt;
+
+	t=constant_type;
+
+	while (t->is_typedef())
+	{
+		t=t->is_typedef()->alias_for;
+	}
+
+	while (t->is_qualified())
+	{
+		t=t->is_qualified()->base_type;
+	}
+
+	if (t->is_enum())
+	{
+		return 1;
+	}
+
+	bt=t->is_base_type();
+
+	if (!bt) 
+	{
+		return 0;
+	}
+
+	if (0==strcmp(bt->id,"string")) return 0;
+
+	return 1;
+}
+
+#if 0
+static void print_id(RHBelement *id)
+{
+	if (id->parent())
+	{
+		print_id(id->parent());
+		printf("::");
+	}
+	if (id->id) printf("%s",id->id);
+}
+#endif
+
+void RHBelement::read_modifier(RHBPreprocessor *pp,char *buf,size_t buflen,boolean passthru_flag)
+{
+	RHBelement *modifier_root=this;
+	RHBelement *current=this;
+
+	if (is_modifier()) 
+	{
+		current=NULL;
+	}
+
+	while (1)
+	{
+		if (!buf[0])
+		{
+			if (!pp->get_token(buf,buflen))
+			{
+				return;
+			}
+		}
+
+		if (!strcmp(buf,":"))
+		{
+			buf[0]=0;
+
+			if (!pp->get_token(buf,buflen))
+			{
+				return;
+			}
+
+			RHBelement *e=NULL;
+			
+			if (current)
+			{
+				modifier_root->find_named_element(pp,buf,buflen);
+			}
+
+			if (!e)
+			{
+				if (modifier_root->is_modifier())
+				{
+					current=NULL;
+
+					int k=modifier_root->modifier_data.length();
+					
+					if (k)
+					{
+						const char *p=modifier_root->modifier_data.get(k-1);
+
+						if (strcmp(p,","))
+						{
+							modifier_root->add_modifier_value(",");
+						}
+					}
+
+					modifier_root->add_modifier_value(buf);
+
+					buf[0]=0;
+
+					break;
+				}
+				else
+				{
+					e=new RHBmodifier(pp,buf);
+
+					current->add(pp,e);
+					modifier_root=current;
+
+					buf[0]=0;
+				}
+			}
+
+			current=e;
+		}
+		else
+		{
+			break;
+		}
+	}
+
+	while (1)
+	{
+		/* assumes current is the working modifier,
+			and buf is the following token */
+
+		if (!buf[0])
+		{
+			if (!pp->get_token(buf,buflen))
+			{
+				return;
+			}
+		}
+
+
+		if (!strcmp(buf,"="))
+		{
+			/* assignment */
+
+			buf[0]=0;
+
+			if (passthru_flag)
+			{
+				while (pp->get_token(buf,buflen))
+				{
+					if (!strcmp(buf,";"))
+					{
+						buf[0]=0;
+						break;
+					}
+					else
+					{
+						if (current)
+						{
+							current->add_modifier_value(buf);
+						}
+						else
+						{
+							modifier_root->add_modifier_value(buf);
+						}
+						buf[0]=0;
+					}
+				}
+
+				return;
+			}
+
+			if (!pp->get_token(buf,buflen))
+			{
+				return;
+			}
+
+			if (current)
+			{
+				current->add_modifier_value(buf);
+			}
+			else
+			{
+				if (modifier_root->modifier_data.length())
+				{
+					pp->err("reading modifier",buf);
+
+					return;
+				}
+				else
+				{
+					modifier_root->add_modifier_value(buf);
+				}
+			}
+
+			buf[0]=0;
+
+			if (!pp->get_token(buf,buflen))
+			{
+				return;
+			}
+		}
+
+		if (!strcmp(buf,","))
+		{
+			buf[0]=0;
+
+			if (!pp->get_token(buf,buflen))
+			{
+				return;
+			}
+
+			RHBelement *e=NULL;
+			
+			if (current)
+			{
+				e=modifier_root->has_named_element(buf);
+			}
+
+			if (!e)
+			{
+				if (modifier_root->is_modifier())
+				{
+					current=NULL;
+
+					int k=modifier_root->modifier_data.length();
+					
+					if (k)
+					{
+						const char *p=modifier_root->modifier_data.get(k-1);
+
+						if (strcmp(p,","))
+						{
+							modifier_root->add_modifier_value(",");
+						}
+					}
+
+					modifier_root->add_modifier_value(buf);
+
+					buf[0]=0;
+				}
+				else
+				{
+					e=new RHBmodifier(pp,buf);
+
+					modifier_root->add(pp,e);
+
+					buf[0]=0;
+				}
+			}
+
+			current=e;
+		}
+		else
+		{
+			if (!strcmp(buf,";"))
+			{
+				buf[0]=0;
+				break;
+			}
+			else
+			{
+				pp->err("reading modifier",buf);
+
+				return;
+			}
+		}
+	}
+
+	if (!current)
+	{
+		current=modifier_root;
+	}
+
+/*	print_id(current); printf("=");
+
+	int k=0;
+
+	while (k < current->modifier_data.length())
+	{
+		const char *p=current->modifier_data.get(k++);
+
+		printf("%s",p);
+
+		if (k < current->modifier_data.length())
+		{
+			printf("|");
+		}
+
+	}
+	printf("\n");*/
+}
+
+#if 0
+void RHBelement::read_modifier(RHBPreprocessor *pp,char *buf,size_t buflen)
+{
+	if (!buf[0])
+	{
+		if (!pp->get_token(buf,buflen))
+		{
+			return;
+		}
+	}
+
+	if (0==strcmp(buf,":"))
+	{
+		char name[256];
+
+		buf[0]=0;
+
+		pp->get_token(name,sizeof(name));
+
+		pp->get_token(buf,buflen);
+
+		if (0==strcmp(buf,":"))
+		{
+			RHBelement *e=find_named_element(pp,name,sizeof(name));
+
+			if (!e)
+			{
+				e=new RHBmodifier(pp,name);
+				add(pp,e);
+			}
+			
+			if (!buf[0])
+			{
+				pp->get_token(buf,buflen);
+			}
+			e->read_modifier(pp,buf,buflen);
+		}
+		else
+		{
+			add_modifier_value(name);
+
+			while (1)
+			{
+				if (!buf[0])
+				{
+					pp->get_token(buf,buflen);
+				}
+
+				if (0==strcmp(buf,";"))
+				{
+					buf[0]=0;
+					return;
+				}
+
+				add_modifier_value(buf);
+
+				buf[0]=0;
+			}
+		}
+	}
+	else
+	{
+		if (0==strcmp(buf,"="))
+		{
+			while (1)
+			{
+				pp->get_token(buf,buflen);
+
+				if (0==strcmp(buf,";"))
+				{
+					buf[0]=0;
+					return;
+				}
+
+				add_modifier_value(buf);
+			}
+		}
+		else
+		{
+			if (0==strcmp(buf,";"))
+			{
+				buf[0]=0;
+				return;
+			}
+
+			pp->err("reading modifier",buf);
+		}
+	}
+}
+#endif
+
+void RHBelement::add_modifier_value(const char *buf)
+{
+/*	char str[1024];
+
+	build_id(str);
+
+	strcat(str,"<");
+	strcat(str,class_name);
+	strcat(str,">");
+
+	printf("..<%s>+=<%s>\n",str,buf);
+	if (!strcmp(buf,"nodata"))
+	{
+		bomb("RHBelement::add_modifier_value::nodata");
+	}*/
+
+	modifier_data.add(buf);
+}
+
+int RHBelement::has_modifier_value(const char *p)
+{
+	RHBelement *el=children();
+
+	while (el)
+	{
+		RHBmodifier *mod=el->is_modifier();
+
+		if (mod)
+		{
+			if (!strcmp(mod->id,p))
+			{
+				return 1;
+			}
+		}
+
+		el=el->next();
+	}
+
+	int j=modifier_data.length();
+
+	while (j--)
+	{
+		if (0==strcmp(modifier_data.get(j),p))
+		{
+			return 1;
+		}
+	}
+
+	return 0;
+}
+
+const char * RHBmodifier_list::get(int i)
+{
+		if (i < _length)
+		{
+			return _buffer[i];
+		}
+		return 0;
+}
+
+void RHBmodifier_list::add(const char *p)
+{
+	if (p)
+	{
+		if (*p)
+		{
+			size_t x=strlen(p)+1;
+			char *q=new char[x];
+			strncpy(q,p,x);
+
+			if (_length==_maximum)
+			{
+				int i=0;
+
+				_maximum+=32;
+
+				char **_buf=new string[_maximum];
+
+				while (i < _length)
+				{
+					_buf[i]=_buffer[i];
+					i++;
+				}
+				if (i) delete _buffer;
+				_buffer=_buf;
+			}
+			_buffer[_length]=q;
+			_length++;
+		}
+	}
+}
+
+RHBelement *RHBelement_sequence::contains(RHBelement *e)
+{
+	long i=_length;
+
+	while (i--)
+	{
+		if (_buffer[i]==e) return e;
+	}
+
+	return 0;
+}
+
+RHBmodifier_list::RHBmodifier_list()
+{
+	_length=0;
+	_buffer=NULL;
+	_maximum=0;
+}
+
+RHBmodifier_list::~RHBmodifier_list()
+{
+	int i=0;
+
+	while (i < _length)
+	{
+		delete _buffer[i];
+
+		i++;
+	}
+
+	if (i)
+	{
+		delete _buffer;
+	}
+}
+
+void RHBelement::build_id(char *buf,size_t buflen)
+{
+	if (_parent) 
+	{
+		_parent->build_id(buf,buflen);
+	}
+	else
+	{
+		*buf=0;
+	}
+
+	if (id)
+	{
+		strncat(buf,"::",buflen);
+		strncat(buf,id,buflen);
+	}
+}
+
+RHBexception *RHBelement::is_exception()
+{
+	return 0;
+}
+
+RHBexception *RHBexception::is_exception()
+{
+	return this;
+}
+
+RHBinclude_file::RHBinclude_file(RHBPreprocessor *pp,const char *name)
+: RHBelement("RHBinclude_file",pp,name)
+{
+	included_during=pp->scope;
+}
+
+RHBcontext_string::RHBcontext_string(RHBPreprocessor *pp,const char *name)
+: RHBelement("RHBcontext_string",pp,name)
+{
+	value=NULL;
+}
+
+RHBcontext_string::~RHBcontext_string()
+{
+	if (value)
+	{
+		delete value;
+		value=NULL;
+	}
+}
+
+void RHBcontext_string::build(RHBPreprocessor * /*pp*/)
+{
+}
+
+void RHBinclude_file::build(RHBPreprocessor * /*pp*/)
+{
+}
+
+RHBtype *RHBelement::wrap_with_pointer(RHBPreprocessor *pp,char *buf,size_t buflen,RHBtype *t)
+{
+	RHBpointer_type *t2;
+	if (strcmp(buf,"*"))
+	{
+		pp->err("Should be a *",buf);
+
+		return 0;
+	}
+
+	t2=new RHBpointer_type(pp,0);
+
+	strncpy(t2->type,buf,sizeof(t2->type));
+
+	buf[0]=0;
+
+	t2->pointer_to=t;
+
+	pp->get_token(buf,buflen);
+
+	return t2;
+}
+
+RHBinclude_file *RHBelement::is_include_file()
+{
+	return 0;
+}
+
+RHBinclude_file *RHBinclude_file::is_include_file()
+{
+	return this;
+}
+
+void RHBattribute::generate_accessors(RHBPreprocessor *pp,RHBinterface *iface)
+{
+	RHBattribute_accessor *aa;
+	char buf[256];
+
+	if (!readonly)
+	{
+		RHBparameter *param;
+		strncpy(buf,"_set_",sizeof(buf));
+		strncat(buf,id,sizeof(buf));
+		aa=new RHBattribute_accessor(pp,buf);
+		aa->for_attribute=this;
+		iface->add(pp,aa);
+		param=new RHBparameter(pp,id);
+		param->parameter_type=attribute_type;
+		strncpy(param->mode,"in",sizeof(param->mode));
+
+		aa->add(pp,param);
+
+		RHBelement *el=aa;
+
+		while (el->parent())
+		{
+			el=el->parent();
+		}
+
+		el=el->children();
+
+		while (el)
+		{
+			if (!strcmp(el->id,"void"))
+			{
+				break;
+			}
+			el=el->next();
+		}
+
+		aa->return_type=el->is_type();
+	}
+	strncpy(buf,"_get_",sizeof(buf));
+	strncat(buf,id,sizeof(buf));
+	aa=new RHBattribute_accessor(pp,buf);
+	aa->for_attribute=this;
+	iface->add(pp,aa);
+	aa->return_type=attribute_type;
+}
+
+RHBattribute_accessor::RHBattribute_accessor(RHBPreprocessor *pp,const char *name)
+: /*RHBelement("RHBattribute_accessor",pp,name),
+  RHBtype(pp,name),*/
+  RHBoperation(pp,name)
+{
+}
+
+RHBvalue * RHBelement::is_value()
+{
+	return 0;
+}
+
+RHBvalue * RHBvalue::is_value()
+{
+	return this;
+}
+
+long RHBvalue::numeric_value()
+{
+	if (value_string) return atol(value_string);
+
+	return 0;
+}
+
+RHBequation::RHBequation(RHBPreprocessor *pp,const char *name)
+: /*RHBelement("RHBequation",pp,name),
+	RHBtype(pp,name),
+	RHBvalue(pp,name),*/
+	RHBconstant(pp,name)
+{
+	val1=0;
+	val2=0;
+	op[0]=0;
+}
+
+RHBvalue * RHBelement::read_number(RHBPreprocessor *pp,char *buf,size_t buflen)
+{
+	RHBvalue *v=NULL;
+
+	if (!buf[0])
+	{
+		pp->get_token(buf,buflen);
+	}
+
+	if (0==strcmp(buf,"("))
+	{
+		buf[0]=0;
+
+		v=read_number(pp,buf,buflen);
+
+		if (strcmp(buf,")"))
+		{
+			pp->err("Should be closing bracket",buf);
+
+			return 0;
+		}
+
+		buf[0]=0;
+
+		return v;
+	}
+
+	if (isdigit(buf[0]))
+	{
+		v=new RHBconstant(pp,0);
+
+		size_t x=strlen(buf)+1;
+		v->value_string=new char [x];
+
+		strncpy(v->value_string,buf,x);
+
+		buf[0]=0;
+	}
+	else
+	{
+		if (buf[0]=='\'')
+		{
+			unsigned long l=0;
+			char *p=buf+1;
+
+			while ((*p) && (*p!='\''))
+			{
+				unsigned char c=*p++;
+				l<<=8;
+				l+=c;
+			}
+
+			v=new RHBconstant(pp,0);
+			int max_len=12;
+			v->value_string=new char[max_len];
+			snprintf(v->value_string,max_len,"0x%08lX",(unsigned long)l);
+			buf[0]=0;
+		}
+		else
+		{
+			if ((buf[0]=='-')||(buf[0]=='~'))
+			{
+				/* make a leading equation */
+			}
+			else
+			{
+				RHBconstant *cn=is_constant();
+				RHBelement *el=NULL;
+
+				if (cn)
+				{
+					RHBtype *ct=cn->constant_type;
+
+					el=ct->find_named_element(pp,buf,buflen);
+				}
+				else
+				{
+					el=find_named_element(pp,buf,buflen);
+				}
+				if (!el)
+				{	
+					pp->err("No element near ",buf);
+				}
+
+				v=el->is_value();
+			}
+		}
+	}
+
+	do
+	{
+		if (!buf[0])
+		{
+			pp->get_token(buf,buflen);
+		}
+
+		if (strcmp(buf,"*"))
+		{
+			if (strcmp(buf,"-"))
+			{
+				if (strcmp(buf,"+"))
+				{
+					if (strcmp(buf,"/"))
+					{
+						if (strcmp(buf,"~"))
+						{
+							return v;
+						}
+					}
+				}
+			}
+		}
+
+		RHBequation *eq=new RHBequation(pp,0);
+
+		strncpy(eq->op,buf,sizeof(eq->op));
+
+		buf[0]=0;
+
+		eq->val1=v;
+
+		eq->val2=read_number(pp,buf,buflen);
+
+		v=eq;
+
+	} while (v);
+
+	return v;
+}
+
+long RHBconstant::numeric_value()
+{
+	if (value_string)
+	{
+		if (value_string[0]=='0')
+		{
+			if (!value_string[1])
+			{
+				return 0;
+			}
+			if ((value_string[1]=='x')||(value_string[1]=='X'))
+			{
+				return read_hex_value(&value_string[2]);
+			}
+			return read_octal_value(&value_string[2]);
+		}
+
+		return atol(value_string);
+	}
+
+	if (const_val)
+	{
+		return const_val->numeric_value();
+	}
+
+	return 0;
+}
+
+long RHBequation::numeric_value()
+{
+	long v1=0,v2=0;
+
+	if (val1) v1=val1->numeric_value();
+	if (val2) v2=val2->numeric_value();
+
+	if (!strcmp(op,"+"))
+	{
+		return v1+v2;
+	}
+
+	if (!strcmp(op,"*"))
+	{
+		return v1*v2;
+	}
+
+	if (!strcmp(op,"-"))
+	{
+		return v1-v2;
+	}
+
+	if (!strcmp(op,"/"))
+	{
+		return v1/v2;
+	}
+
+	return 0;
+}
+
+RHBmodifier * RHBmodifier::is_modifier()
+{
+	return this;
+}
+
+RHBmodifier * RHBelement::is_modifier()
+{
+	return 0;
+}
+
+RHBtype_def * RHBtype::is_typedef()
+{
+	return 0;
+}
+
+RHBenum * RHBtype::is_enum()
+{
+	return 0;
+}
+
+RHBstruct * RHBtype::is_struct()
+{
+	return 0;
+}
+
+RHBtype_def * RHBtype_def::is_typedef()
+{
+	return this;
+}
+
+RHBenum * RHBenum::is_enum()
+{
+	return this;
+}
+
+RHBstruct * RHBstruct::is_struct()
+{
+	return this;
+}
+
+RHBstruct_element *RHBstruct_element::is_struct_element()
+{
+	return this;
+}
+
+RHBstruct_element *RHBtype::is_struct_element()
+{
+	return 0;
+}
+
+RHBarray *RHBarray::is_array()
+{
+	return this;
+}
+
+RHBarray *RHBtype::is_array()
+{
+	return 0;
+}
+RHBpointer_type * RHBtype::is_pointer()
+{
+	return 0;
+}
+
+RHBpointer_type * RHBpointer_type::is_pointer()
+{
+	return this;
+}
+
+RHBstring_type *RHBtype::is_string()
+{
+	return 0;
+}
+
+RHBstring_type *RHBstring_type::is_string()
+{
+	return this;
+}
+
+RHBqualified_type *RHBtype::is_qualified()
+{
+	return 0;
+}
+
+RHBqualified_type *RHBqualified_type::is_qualified()
+{
+	return this;
+}
+
+RHBsequence_type *RHBtype::is_sequence()
+{
+	return 0;
+}
+
+RHBsequence_type *RHBsequence_type::is_sequence()
+{
+	return this;
+}
+
+RHBunion * RHBtype::is_union()
+{
+	return 0;
+}
+
+RHBunion_element * RHBtype::is_union_element()
+{
+	return 0;
+}
+
+RHBtype *RHBelement::read_union(RHBPreprocessor *pp,char *buf,size_t buflen)
+{
+	RHBunion *u;
+	RHBelement *el;
+	int count=0;
+
+	if (!buf[0])
+	{
+		pp->get_token(buf,buflen);
+	}
+
+	if (strcmp(buf,"union"))
+	{
+		pp->err("This is supposed to say union",buf);
+		return 0;
+	}
+
+	pp->get_token(buf,buflen);
+
+	el=find_named_element(pp,buf,buflen);
+
+	if (el)
+	{
+		RHBtype *t;
+
+		t=el->is_type();
+		u=t->is_union();
+	}
+	else
+	{
+		u=new RHBunion(pp,buf);
+		add(pp,u);
+	}
+
+	pp->get_token(buf,buflen);
+
+	if (strcmp(buf,"switch"))
+	{
+		return u;
+	}
+
+	pp->get_token(buf,buflen);
+
+	if (strcmp(buf,"("))
+	{
+		pp->err("This is supposed to open with bracket\n",buf);
+		return 0;
+	}
+
+	pp->get_token(buf,buflen);
+
+	u->switch_type=read_type(pp,buf,buflen);
+
+	if (!buf[0])
+	{
+		pp->get_token(buf,buflen);
+	}
+
+	if (strcmp(buf,")"))
+	{
+		pp->err("This is supposed to close with bracket\n",buf);
+		return 0;
+	}
+
+	pp->get_token(buf,buflen);
+
+	if (strcmp(buf,"{"))
+	{
+		pp->err("This is supposed to open with braces\n",buf);
+		return 0;
+	}
+
+	buf[0]=0;
+
+	while (u)
+	{
+		RHBunion_element *uel;
+		RHBvalue *val;
+		RHBtype *tp;
+
+		if (!buf[0])
+		{
+			if (!pp->get_token(buf,buflen))
+			{
+				return 0;
+			}
+		}
+
+		if (0==strcmp(buf,"}"))
+		{
+			buf[0]=0;
+			pp->get_token(buf,buflen);
+
+			return u;
+		}
+
+		val=0;
+
+		if (0==strcmp(buf,"default"))
+		{
+			u->default_index=count;
+			buf[0]=0;
+		}
+		else
+		{
+			RHBelement *type=u->switch_type;
+
+			if (strcmp(buf,"case"))
+			{
+				pp->err("Should say 'case'\n",buf);
+
+				return 0;
+			}
+
+			buf[0]=0;
+
+			pp->get_token(buf,buflen);
+
+			val=type->read_number(pp,buf,buflen);
+		}
+
+		if (!buf[0])
+		{
+			pp->get_token(buf,buflen);
+		}
+
+		if (strcmp(buf,":"))
+		{
+			pp->err("Should say ':'\n",buf);
+
+			return 0;
+		}
+
+		pp->get_token(buf,buflen);
+
+		tp=read_type(pp,buf,buflen);
+
+		if (!tp)
+		{
+			pp->err("Should have been a type\n",buf);
+
+			return 0;
+		}
+
+		if (!buf[0])
+		{
+			pp->get_token(buf,buflen);
+		}
+
+		uel=new RHBunion_element(pp,buf);
+
+		uel->switch_value=val;
+		uel->element_type=tp;
+			
+		/* adding as a sequence, not as
+			a named list,
+			elements can have duplicate
+			entries */
+		u->elements.add(uel);
+		count++;
+
+		pp->get_token(buf,buflen);
+
+		if (strcmp(buf,";"))
+		{
+			pp->err("Should have been a colon\n",buf);
+
+			return 0;
+		}
+
+		buf[0]=0;
+	}
+
+	return u;
+}
+
+RHBunion * RHBunion::is_union()
+{
+	return this;
+}
+
+RHBunion_element * RHBunion_element::is_union_element()
+{
+	return this;
+}
+
+RHBoperation *RHBelement::is_operation()
+{
+	return 0;
+}
+
+RHBoperation *RHBoperation::is_operation()
+{
+	return this;
+}
+
+#if 0
+boolean is_in_floating(RHBparameter *param)
+{
+	if (!strcmp(param->mode,"in"))
+	{
+		RHBtype *t=unwind_typedef(param->parameter_type);
+		if (t)
+		{
+			RHBbase_type *bt=t->is_base_type();
+
+			if (bt)
+			{
+				if (bt->_floating)
+				{
+					return 1;
+				}
+			}
+		}
+	}
+
+	return 0;
+}
+#endif
+
+boolean RHBoperation::can_auto_stub()
+{
+	int has_floats=0;
+	RHBelement *el=children();
+
+	while (el)
+	{
+		RHBparameter *param=el->is_parameter();
+
+		if (param)
+		{
+//			if (is_in_floating(param))
+//			{
+//				has_floats++;
+//			}
+		}
+		el=el->next();
+	}
+
+	if (has_floats < 14)
+	{
+		return 1;
+	}
+
+	return 0;
+}
+
+RHBbase_type *RHBtype::is_base_type()
+{
+	return 0;
+}
+
+RHBbase_type *RHBbase_type::is_base_type()
+{
+	return this;
+}
+
+RHBparameter *RHBparameter::is_parameter()
+{
+	return this;
+}
+
+RHBparameter *RHBoperation::get_parameter(int i)
+{
+	RHBelement *el;
+	el=children();
+
+	while (el)
+	{
+		RHBparameter *param;
+
+		param=el->is_parameter();
+
+		if (param)
+		{
+			if (!i) return param;
+
+			i--;
+		}
+
+		el=el->next();
+	}
+
+	return 0;
+}
+
+
+RHBany_type *RHBtype::is_any()
+{
+	return 0;
+}
+
+RHBTypeCode_type *RHBtype::is_TypeCode()
+{
+	return 0;
+}
+
+RHBTypeCode_type::RHBTypeCode_type(RHBPreprocessor *pp,
+			const char *name,
+			RHBtype *va_type,
+			boolean in_by_ref)
+: /*RHBelement("RHBTypeCode_type",pp,name),RHBtype(pp,name),*/RHBbase_type(pp,name,va_type,in_by_ref,0)
+{
+}
+
+RHBany_type::RHBany_type(RHBPreprocessor *pp,
+			const char *name,
+			RHBtype *va_type,
+			boolean in_by_ref)
+: /*RHBelement("RHBany_type",pp,name),RHBtype(pp,name),*/RHBbase_type(pp,name,va_type,in_by_ref,0)
+{
+}
+
+RHBany_type * RHBany_type::is_any()
+{
+	return this;
+}
+
+RHBTypeCode_type * RHBTypeCode_type::is_TypeCode()
+{
+	return this;
+}
+
+RHBrepository *RHBrepository::is_repository()
+{
+	return this;
+}
+
+RHBrepository *RHBelement::is_repository()
+{
+	return 0;
+}
+
+void RHBinterface::list_all_operations(RHBelement_sequence *seq)
+{
+	size_t i=0;
+
+	while (i < _parents.length())
+	{
+		RHBinterface *iface;
+
+		iface=_parents.get(i)->is_interface();
+
+		iface->list_all_operations(seq);
+
+		i++;
+	}
+
+	RHBelement *el=children();
+
+	while (el)
+	{
+		RHBoperation *op;
+
+		op=el->is_operation();
+
+		if (op)
+		{
+			if (!seq->contains(op))
+			{
+				seq->add(op);
+			}
+		}
+
+		el=el->next();
+	}
+}
+
+void RHBelement::_set_prefix(const char *buf)
+{
+	char b[256];
+	char *q=b;
+
+	if (buf)
+	{
+		const char *p;
+		p=buf;
+		while (*p)
+		{
+			if (*p != 0x22)
+			{
+				*q=*p;
+				q++;
+			}
+
+			p++;
+		}
+	}
+
+	*q=0;
+
+	if (prefix) delete prefix;
+
+	prefix=0;
+
+	if (b[0])
+	{
+		size_t x=strlen(b)+1;
+		prefix=new char[x];
+		strncpy(prefix,b,x);
+	}
+}
+
+RHBelement_new_scope::RHBelement_new_scope(RHBPreprocessor *p,RHBelement *e)
+{
+	pp=p;
+	old=p->scope;
+	p->scope=e;
+}
+
+RHBelement_new_scope::~RHBelement_new_scope()
+{
+	pp->scope=old;
+}
+
+void RHBelement::_set_global_id(const char *buf)
+{
+	char b[256];
+	char *q=b;
+
+	if (buf)
+	{
+		const char *p=buf;
+
+		while (*p)
+		{
+			if (*p != 0x22)
+			{
+				*q=*p;
+				q++;
+			}
+
+			p++;
+		}
+	}
+
+	*q=0;
+
+	if (global_id) delete global_id;
+	global_id=0;
+
+	if (b[0])
+	{
+		size_t x=strlen(b)+1;
+		global_id=new char[x];
+		strncpy(global_id,b,x);
+	}
+}
+
+void RHBelement::_set_version(const char *buf)
+{
+	char b[256];
+	char *q=b;
+
+	if (buf)
+	{
+		const char *p=buf;
+
+		while (*p)
+		{
+			if (*p != 0x22)
+			{
+				*q=*p;
+				q++;
+			}
+
+			p++;
+		}
+	}
+
+	*q=0;
+
+	if (version) delete version;
+	version=0;
+
+	if (b[0])
+	{
+		size_t x=strlen(b)+1;
+		version=new char[x];
+		strncpy(version,b,x);
+	}
+
+	gen_global_id();
+}
+
+void RHBelement::gen_global_id()
+{
+	unsigned int i;
+	RHBelement *a[256];
+	RHBelement *te;
+	const char *p;
+	char buf[256];
+
+	buf[0]=0;
+
+	if (!is_module())
+	{
+		if (!is_interface())
+		{
+			if (!is_operation())
+			{
+				if (!is_exception())
+				{
+					RHBtype *t=is_type();
+		
+					if (!t)
+					{
+						return;
+					}
+
+					if (!t->is_attribute())
+					{
+						if (!t->is_struct())
+						{
+							if (!t->is_typedef())
+							{
+								if (!t->is_union())
+								{
+									if (!t->is_enum())
+									{
+										return;
+									}
+								}
+							}
+						}
+					}
+				}
+			}
+		}
+	}
+
+	i=0;
+
+	te=this;
+
+	while (te)
+	{
+		if ((te->id)||(te->prefix))
+		{
+			a[i]=te;
+			i++;
+		}
+
+		if (te->prefix)
+		{
+			te=0;
+		}
+		else
+		{
+			te=te->parent();
+		}
+	}
+
+	if (!i) return;
+
+	strncpy(buf,"IDL:",sizeof(buf));
+
+	p=0;
+
+	while (i--)
+	{
+		te=a[i];
+
+		if (te->prefix)
+		{
+			if (p) strncat(buf,"/",sizeof(buf));
+			p=te->prefix;
+			strncat(buf,p,sizeof(buf));
+		}
+		else
+		{
+			if (te->id)
+			{
+				if (p) strncat(buf,"/",sizeof(buf));
+				p=te->id;
+				strncat(buf,p,sizeof(buf));
+			}
+		}
+	}
+
+	p=version;
+
+	if (!p) 
+	{
+		p="1.0";
+	}
+
+	strncat(buf,":",sizeof(buf));
+	strncat(buf,p,sizeof(buf));
+
+/*	printf("%s\n",buf);*/
+
+	_set_global_id(buf);
+}
+
+void RHBelement::set_pragma_modifier(
+		RHBPreprocessor * /*pp*/,
+		const char * /*name*/,
+		const char * /*value*/)
+{
+/*	if (value)
+	{
+		if (*value)
+		{
+			RHBelement *mod;
+
+			mod=new RHBmodifier(pp,name);
+			add(pp,mod);
+			mod->add_modifier_value(value);
+		}
+	}
+*/
+}
+
+RHBcontext_string *RHBcontext_string::is_context()
+{
+	return this;
+}
+
+RHBcontext_string *RHBelement::is_context()
+{
+	return 0;
+}
+
+void RHBelement::remove_quotes(char *buf)
+{
+	char tmp[256];
+	char *p;
+	strncpy(tmp,buf,sizeof(tmp));
+	p=tmp;
+	while (*p)
+	{
+		if ((*p!=double_quote)&&(*p!=single_quote))
+		{
+			*buf++=*p;
+		}
+		p++;
+	}
+	*buf=0;
+}
+
+boolean RHBinterface::is_subclass_of(RHBinterface *other)
+{
+	if (other)
+	{
+		if (this==other) return 1;
+
+		long i=_parents.length();
+
+		while (i--)
+		{
+			if (_parents.get(i)->is_interface()->is_subclass_of(other))
+			{
+				return 1;
+			}
+		}
+	}
+
+	return 0;
+}
+
+const char *RHBelement::get_modifier_string(const char *name)
+{
+	RHBelement *el;
+	char buf[256];
+
+	strncpy(buf,name,sizeof(buf));
+
+	el=find_named_element(0,buf,sizeof(buf));
+
+	if (el)
+	{
+		RHBmodifier *mod=el->is_modifier();
+		if (mod)
+		{
+			return mod->modifier_data.get(0);
+		}
+	}
+
+	return 0;
+}
+
+RHBenum *RHBconstant::is_const_enum()
+{
+	if (constant_type)
+	{
+		return constant_type->is_enum();
+	}
+
+	return NULL;
+}
+
+RHBinherited_operation *RHBelement::is_inherited_operation()
+{
+	return NULL;
+}
+
+void RHBinterface::inherit_operations(RHBPreprocessor *pp,RHBinterface *iface)
+{
+	if (iface)
+	{
+		RHBelement *el=iface->children();
+
+		while (el)
+		{
+			RHBoperation *op=el->is_operation();
+
+			if (op)
+			{
+				RHBelement *e=has_named_element(op->id);
+
+				if (!e)
+				{
+					RHBinherited_operation *iop=new RHBinherited_operation(pp,op->id);
+
+					iop->original=op;
+
+					add(pp,iop);
+				}
+			}
+
+			el=el->next();
+		}
+
+		size_t k=0;
+
+		while (k < iface->_parents.length())
+		{
+			inherit_operations(pp,iface->_parents.get(k)->is_interface());
+
+			k++;
+		}
+	}
+}
+
+RHBinherited_operation::RHBinherited_operation(RHBPreprocessor *pp,const char *name)
+: /*RHBelement("RHBmodifier",pp,name),*/RHBtype(pp,name)
+{
+}
+
+void RHBinherited_operation::build(RHBPreprocessor *  /*pp*/)
+{
+}
+
+RHBinherited_operation *RHBinherited_operation::is_inherited_operation()
+{
+	return this;
+}
+
+RHBelement *RHBelement::has_named_element(const char *p)
+{
+	RHBelement *el=children();
+
+	while (el)
+	{
+		if (!strcmp(el->id,p)) break;
+
+		el=el->next();
+	}
+
+	return el;
+}
+
+RHBinclude_list::RHBinclude_list(RHBPreprocessor *pp,const char *name)
+: RHBelement("RHBinclude_list",pp,name)
+{
+}
+
+void RHBinclude_list::build(RHBPreprocessor * /*pp*/)
+{
+}
+
+RHBinclude_file * RHBinclude_list::included(RHBPreprocessor *pp,const char *b,RHBinclude_file *current)
+{
+	RHBelement *e=_children;
+
+	if (b)
+	{
+		const char *p=b+strlen(b);
+
+		while (p > b)
+		{
+			char c=*--p;
+
+			if ((c==':')||(c=='/')||(c=='\\'))
+			{
+				b=p+1;
+				break;
+			}
+		}
+	}
+
+	if (pp->scope)
+	{
+		pp->scope->_set_prefix(0);
+	}
+
+	while (e)
+	{
+		if (e->id)
+		{
+			if (0==strcmp(e->id,b))
+			{
+				return e->is_include_file();
+			}
+		}
+		else
+		{
+			if (!b) 
+			{
+				return e->is_include_file();
+			}
+
+			if (!b[0]) 
+			{
+				return e->is_include_file();
+			}
+		}
+
+		e=e->next();
+	}
+
+	RHBinclude_file *f=new RHBinclude_file(pp,b);
+
+	if (!f->defined_in)
+	{
+		f->defined_in=current;
+	}
+
+/*	p=f->id;*/
+
+	add_nocheck(pp,f);
+
+	return f;
+}
diff -urN somfree\somipc2\src\rhbsc.cpp newsomfree3\somipc2\src\rhbsc.cpp
--- somfree\somipc2\src\rhbsc.cpp	Thu Jan 01 07:00:00 1970
+++ newsomfree3\somipc2\src\rhbsc.cpp	Sat Mar 16 14:09:27 2024
@@ -0,0 +1,476 @@
+/**************************************************************************
+ * 
+ *  Copyright 1998-2010, Roger Brown
+ *
+ *  This file is part of Roger Brown's Toolkit.
+ *
+ *  This program is free software: you can redistribute it and/or modify it
+ *  under the terms of the GNU Lesser General Public License as published by the
+ *  Free Software Foundation, either version 3 of the License, or (at your
+ *  option) any later version.
+ * 
+ *  This program is distributed in the hope that it will be useful, but WITHOUT
+ *  ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ *  FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for
+ *  more details.
+ *
+ *  You should have received a copy of the GNU Lesser General Public License
+ *  along with this program.  If not, see <http://www.gnu.org/licenses/>
+ *
+ */
+ 
+/* 
+ * $Id: rhbsc.cpp 2 2013-01-10 05:54:51Z somtoolkit $
+ */
+
+
+#include <rhbopt.h>
+#include <stdio.h>
+#include <string.h>
+#include <stdlib.h>
+
+#ifdef HAVE_SIGNAL_H
+#	include <signal.h>
+#endif
+
+#include <rhbsc.h>
+
+static boolean default_emitflag;
+
+class modifier_arg
+{
+public:
+	char *name;
+	char *value;
+	modifier_arg *next;
+	modifier_arg(const char *p) : name(NULL),value(NULL),next(NULL)
+	{
+		if (p)
+		{
+			size_t n=1+strlen(p);
+
+			name=new char[n];
+			memcpy(name,p,n);
+
+			n=0;
+
+			while (name[n])
+			{
+				if (name[n]=='=')
+				{
+					name[n]=0;
+					value=name+n;
+					break;
+				}
+
+				n++;
+			}
+		}
+	}
+
+	~modifier_arg()
+	{
+		if (name) delete []name;
+	}
+};
+
+static int do_emit(
+	modifier_arg * /* mod_list */ ,
+	const char *emitter_name,
+	const char *output_filename,
+	int argc,
+	char **argv)
+{
+	int rc=1;
+
+	RHBPreprocessor preprocessor;
+	const char *root_idl=NULL;
+	FILE *fp=stdin;
+
+	if (argc) fp=NULL;
+
+	RHBFile f(argc,argv,fp);
+
+	if (f.failed())
+	{
+		return 1;
+	}
+
+	preprocessor.push_stream(&f);
+
+	{
+		RHBPreprocessor *p=&preprocessor;
+		RHBrepository r(p,"");
+
+		r.build(p);
+
+		if (p->Errors())
+		{
+			fprintf(stderr,"Errors were detected\n");
+
+			return 1;
+		}
+
+		if (p->includes)
+		{
+			RHBelement *e=p->includes->children();
+
+			while (e)
+			{
+				RHBinclude_file *f=e->is_include_file();
+
+				if (f && f->id)
+				{
+					const char *p=f->id;
+					int k=strlen(p);
+          
+					while (k--)
+					{
+						if (p[k]=='.')
+						{
+							if (!strcmp(p+k,".idl"))
+							{
+								root_idl=p;
+							}
+
+							break;
+						}
+					}
+
+					if (root_idl) 
+					{
+						break;
+					}
+				}
+
+				e=e->next();
+			}
+		}
+
+		if (!root_idl)
+		{
+			fprintf(stderr,"unable to determine root IDL filename\n");
+		}
+		else
+		{
+			rc=0;
+
+			{
+				RHBtextfile out(output_filename);
+
+				{
+					{
+						{
+	    				RHBsome_emitter emitter(&r);
+              emitter.preflight_macros_from_idl_filename(root_idl);
+      				emitter.generate(&out,root_idl,emitter_name);
+            }
+					}
+				}
+			}
+		}
+
+		r.destroy();
+		r.delete_all(&r);
+	}
+
+	return rc;
+}
+
+void bomb(const char *p)
+{
+#ifdef _WIN32
+	printf("SC: bomb: %s\n",p);
+	fflush(stdout);
+	fflush(stderr);
+#	ifdef _M_IX86
+		__asm int 3;
+#	else
+		((int *)0)[0]=0;
+#	endif
+#else
+#ifdef _PLATFORM_MACINTOSH_xxx
+	if (p)
+	{
+		unsigned char buf[256];
+		buf[0]=strlen(p);
+		if (*p) memcpy(&buf[1],p,buf[0]);
+		DebugStr(buf);
+	}
+	else
+	{
+		DebugStr("\p");
+	}
+#else
+	printf("SC: bomb: %s\n",p);
+	fflush(stdout);
+	fflush(stderr);
+	exit(1);
+#endif
+#endif
+}
+
+boolean RHBshould_emit_on(RHBelement *)
+{
+	return 1;
+}
+
+boolean RHBshould_emit_off(RHBelement *)
+{
+	return 0;
+}
+
+boolean RHBshould_emit_default(RHBelement * /*t */)
+{
+	return default_emitflag;
+}
+
+#ifndef HAVE_VSNPRINTF
+int vsnprintf(char *tgt,size_t /*tgtlen*/,const char *fmt,va_list ap)
+{
+	/* SunOS returns a char *, ANSI returns an int */
+
+	vsprintf(tgt,fmt,ap);
+
+	return strlen(tgt);
+}
+#endif
+
+#ifndef HAVE_SNPRINTF
+int snprintf(char *tgt,size_t len,const char *fmt,...)
+{
+	va_list ap;
+	int rc=-1;
+
+	va_start(ap,fmt);
+
+	rc=vsnprintf(tgt,len,fmt,ap);
+
+	va_end(ap);
+
+	return rc;
+}
+#endif
+
+class args
+{
+public:
+	modifier_arg *mods;
+	char **argv;
+	args(int argc,char **d) : argv(new char *[argc+1])
+	{
+		mods=NULL;
+		argv[argc]=NULL;
+		while (argc--)
+		{
+			argv[argc]=d[argc];
+		}
+	}
+	~args()
+	{
+		delete [] argv;
+
+		while (mods)
+		{
+			modifier_arg *p=mods;
+			mods=mods->next;
+			delete p;
+		}
+	}
+
+	void add_modifier(const char *m)
+	{
+		modifier_arg *p=new modifier_arg(m);
+
+		if (mods)
+		{
+			modifier_arg *q=mods;
+			while (q->next) q=q->next;
+			q->next=p;
+		}
+		else
+		{
+			mods=p;
+		}
+	}
+};
+
+/*
+
+a
+m
+c
+e
+h
+H
+?
+i
+o
+q
+s
+v
+w
+x
+S
+C
+D
+I
+U
+l
+y
+r
+V
+
+*/
+int main(int argc,char **argv)
+{
+	const char *appname=argv[0];
+	int i=0;
+	const char *emitter_name=NULL;
+	const char *output_filename=NULL;
+#if defined(HAVE_SIGNAL_H) && defined(SIG_BLOCK)
+	sigset_t sigs;
+	sigfillset(&sigs);
+	sigprocmask(SIG_BLOCK,&sigs,NULL);
+#endif
+
+	if (!argc) 
+	{
+		fprintf(stderr,"no argument list\n");
+
+		return 1;
+	}
+
+	argc--;
+	argv++;
+
+	{
+		args a(argc,argv);
+
+		argv=a.argv;
+
+		while (i < argc)
+		{
+			int drop=0;
+			const char *p=argv[i];
+
+			if (
+#ifdef _WIN32
+				(*p=='/')||
+#endif
+				(*p=='-'))
+			{
+				if ((p[1]=='o')
+	#ifdef _WIN32
+					||(p[1]=='O')
+	#endif
+					)
+				{
+					if (output_filename)
+					{
+						fprintf(stderr,"%s: output file already specified\n",appname);
+						return 1;
+					}
+
+					output_filename=argv[i+1];
+					drop=2;
+				}
+				else
+				{
+					if ((p[1]=='e')
+	#ifdef _WIN32
+						||(p[1]=='E')
+						||(p[1]=='S')
+	#endif
+						||(p[1]=='s')
+						)
+					{
+						if (emitter_name)
+						{
+							fprintf(stderr,"%s: emitter already specified\n",appname);
+							return 1;
+						}
+
+						if (p[2])
+						{
+							emitter_name=p+2;
+							drop=1;
+						}
+						else
+						{
+							emitter_name=argv[i+1];
+							drop=2;
+						}
+					}
+					else
+					{
+						if ((p[1]=='m')
+	#ifdef _WIN32
+							||(p[1]=='M')
+	#endif
+
+							)
+						{
+							if (p[2])
+							{
+								a.add_modifier(p);
+								drop=1;
+							}
+							else
+							{
+								a.add_modifier(argv[i+1]);
+								drop=2;
+							}
+						}
+						else
+						{
+							fprintf(stderr,"%s: Unknown switch \'%s\'\n",appname,p);
+							return 1;
+						}
+					}
+				}
+			}
+
+			if (drop)
+			{
+				int k=i;
+
+				while ((k+drop) < argc)
+				{
+					argv[k]=argv[k+drop];
+					k++;
+				}
+
+				argc-=drop;
+
+				argv[argc]=NULL;
+			}
+			else
+			{
+				i++;
+			}
+		}
+
+		if (!emitter_name)
+		{
+			fprintf(stderr,"%s: no emitter specified\n",appname);
+
+			return 1;
+		}
+
+		i=do_emit(a.mods,emitter_name,output_filename,argc,argv);
+	}
+
+#if defined(_WIN32) && defined(_DEBUG) && (_MSC_VER >= 1200) && !defined(_WIN32_WCE) && !defined(_WIN64)
+	if (_CrtDumpMemoryLeaks())
+	{
+		__asm int 3;
+
+		_CrtDumpMemoryLeaks();
+
+		__asm int 3;
+	}
+#endif
+
+	return i;
+}
diff -urN somfree\somipc2\src\rhbscemt.cpp newsomfree3\somipc2\src\rhbscemt.cpp
--- somfree\somipc2\src\rhbscemt.cpp	Thu Jan 01 07:00:00 1970
+++ newsomfree3\somipc2\src\rhbscemt.cpp	Sat Mar 16 14:09:27 2024
@@ -0,0 +1,432 @@
+/**************************************************************************
+ *
+ *  Copyright 1998-2010, Roger Brown
+ *
+ *  This file is part of Roger Brown's Toolkit.
+ *
+ *  This program is free software: you can redistribute it and/or modify it
+ *  under the terms of the GNU Lesser General Public License as published by the
+ *  Free Software Foundation, either version 3 of the License, or (at your
+ *  option) any later version.
+ * 
+ *  This program is distributed in the hope that it will be useful, but WITHOUT
+ *  ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ *  FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for
+ *  more details.
+ *
+ *  You should have received a copy of the GNU Lesser General Public License
+ *  along with this program.  If not, see <http://www.gnu.org/licenses/>
+ *
+ */
+ 
+/* 
+ * $Id: rhbscemt.cpp 2 2013-01-10 05:54:51Z somtoolkit $
+ */
+
+#include <rhbopt.h>
+/* base emitter */
+
+/* IDL compiler */
+
+#include <stdio.h>
+#include <string.h>
+#include <stdlib.h>
+#include <stdarg.h>
+
+#include <rhbsc.h>
+
+
+RHBemitter::RHBemitter(RHBrepository *rr)
+{
+	_rr=rr;
+	idl_name=0;
+}
+
+void RHBemitter::dump_nest(RHBoutput *out,int nest)
+{
+	while (nest--)
+	{
+		out->write("\t",1);
+	}
+}
+
+boolean RHBemitter::must_generate(RHBtype *)
+{
+	return 1;
+}
+
+RHBoutput::~RHBoutput()
+{
+}
+
+void RHBemitter::get_ir_name(RHBelement *element,char *buf,size_t buflen)
+{
+	if (element->parent())
+	{
+		get_ir_name(element->parent(),buf,buflen);
+		if (strcmp(buf,"::"))
+		{
+			strncat(buf,"::",buflen);
+		}
+		strncat(buf,element->id,buflen);
+	}
+	else
+	{
+		strncpy(buf,"::",buflen);
+		if (element->id)
+		{
+			strncat(buf,element->id,buflen);
+		}
+	}
+}
+
+boolean RHBemitter::ShouldEmit(RHBelement *t)
+{
+	if (!t->defined_in) return 0;
+	if (strcmp(idl_name,t->defined_in->id))
+	{
+		/* this allows a module statement to
+		wrap an include file,
+		ideally should only emit include
+		files if included during processing
+		of the root level */
+
+		if (t->parent() != GetRepository())
+		{
+			return ShouldEmit(t->parent());
+		}
+
+		return 0;
+	}
+
+	if (t->parent() != GetRepository())
+	{
+		return ShouldEmit(t->parent());
+	}
+
+	if (t->is_interface())
+	{
+		return 1;
+	}
+	if (t->is_module())
+	{
+		return 1;
+	}
+	return t->emit_root(t);
+}
+
+
+boolean RHBemitter::CheckTrueCORBA(RHBtype *type)
+{
+	if (!type) return 1;
+
+	if (type->is_operation())
+	{
+		RHBoperation *op=type->is_operation();
+		
+		if (op->return_type)
+		{
+			if (!CheckTrueCORBA(op->return_type))
+			{
+/*				char buf[256];
+
+				get_ir_name(op,buf);
+
+				printf("%s was vetoed\n",buf);
+*/
+				return 0;
+			}
+		}
+
+		int i;
+
+		i=0;
+
+		while (op->get_parameter(i))
+		{
+			RHBparameter *param=op->get_parameter(i);
+
+			i++;
+
+			if (!CheckTrueCORBA(param->parameter_type))
+			{
+/*				char buf[256];
+
+				get_ir_name(param,buf);
+
+				printf("%s was vetoed\n",buf);
+*/
+				return 0;
+			}
+		}
+
+		return 1;
+	}
+
+	if (type->is_typedef())
+	{
+		if (type->is_typedef()->alias_for->is_pointer())
+		{
+			char buf[256];
+			get_ir_name(type,buf,sizeof(buf));
+
+			if (!strcmp(buf,"::SOMFOREIGN"))
+			{
+				return 1;
+			}
+		}
+
+		return CheckTrueCORBA(type->is_typedef()->alias_for);
+	}
+
+	if (type->is_sequence())
+	{
+		return CheckTrueCORBA(type->is_sequence()->sequence_of);
+	}
+
+	if (type->is_array())
+	{
+		return CheckTrueCORBA(type->is_array()->array_of);
+	}
+
+	if (type->is_pointer())
+	{
+		RHBtype *typ=type->is_pointer()->pointer_to;
+
+		if (typ->is_struct()) return 1;
+		if (typ->is_union()) return 1;
+
+		return CheckTrueCORBA(type->is_pointer()->pointer_to);
+	}
+
+	if (type->is_struct())
+	{
+		RHBelement *el;
+
+		el=type->children();
+
+		while (el)
+		{
+			if (el->is_type())
+			{
+				if (!CheckTrueCORBA(el->is_type()))
+				{
+					return 0;
+				}
+			}
+
+			el=el->next();
+		}
+	}
+
+	if (type->is_struct_element())
+	{
+		return CheckTrueCORBA(type->is_struct_element()->element_type);
+	}
+
+	return 1;
+}
+
+void RHBemitter::get_global_id(RHBelement *element,char *buf,size_t buflen)
+{
+	RHBelement *a[256];
+	int i=0;
+	char *p;
+
+	if (element->global_id)
+	{
+		strncpy(buf,element->global_id,buflen);
+		return;
+	}
+
+	strncpy(buf,"IDL:",buflen);
+
+	while (element)
+	{
+		a[i++]=element;
+		if (element->prefix)
+		{
+			element=0;
+		}
+		else
+		{
+			element=element->parent();
+		}
+	}
+
+	p=0;
+
+	while (i--)
+	{
+		if (a[i]->prefix)
+		{
+			if (p) strncat(buf,"/",buflen);
+			p=a[i]->prefix;
+			strncat(buf,p,buflen);
+		}
+
+		if (a[i]->id)
+		{
+			if (p) strncat(buf,"/",buflen);
+			p=a[i]->id;
+			strncat(buf,p,buflen);
+		}
+	}
+
+	strncat(buf,":1.0",buflen);
+}
+
+const char *RHBemitter::short_file_name(const char *long_file_name)
+{
+	const char *p;
+
+	p=long_file_name;
+
+	while (*p) p++;
+
+	while (p > long_file_name)
+	{
+		p--;
+		switch (*p)
+		{
+		case ':':
+		case '/':
+		case '\\':
+			p++;
+			return p;
+		}
+	}
+
+	return long_file_name;
+}
+
+const char *RHBemitter::get_corbastring()
+{
+	const char *p="corbastring";
+
+	if (_rr)
+	{
+		char buf[256];
+		RHBelement *el;
+
+		strncpy(buf,p,sizeof(buf));
+
+		el=_rr->find_named_element(0,buf,sizeof(buf));
+
+		if (el)
+		{
+			if (el->is_modifier())
+			{
+				return p;
+			}
+		}
+	}
+
+	return "string";
+}
+
+void RHBemitter::get_c_name(RHBelement *element,char *buf,size_t buflen)
+{
+	if (element->parent())
+	{
+		get_c_name(element->parent(),buf,buflen);
+		if (buf[0])
+		{
+			strncat(buf,"_",buflen);
+		}
+		strncat(buf,element->id,buflen);
+	}
+	else
+	{
+		if (element->id)
+		{
+			strncpy(buf,element->id,buflen);
+		}
+		else
+		{
+			buf[0]=0;
+		}
+	}
+}
+
+RHBtype *RHBemitter::unwind_typedef(RHBtype *t)
+{
+	while (t)
+	{
+		RHBtype_def *td;
+		RHBqualified_type *qt;
+
+		qt=t->is_qualified();
+
+		if (qt)
+		{
+			break;
+
+/*			t=qt->base_type;*/
+		}
+
+		td=t->is_typedef();
+
+		if (!td) return t;
+
+		t=td->alias_for;
+	}
+
+	return t;
+}
+
+RHBtype *RHBemitter::is_SOMFOREIGN(RHBtype *t)
+{
+	RHBtype_def *td=t->is_typedef();
+
+	if (td)
+	{
+		char buf[256];
+
+		get_ir_name(td,buf,sizeof(buf));
+
+		if (!strcmp(buf,"::SOMFOREIGN"))
+		{
+			return t;
+		}
+
+/*		t=td;
+
+		td=td->alias_for->is_typedef();*/
+	}
+
+	return 0;
+}
+
+const char *RHBemitter::unquote(char *tgt,const char *src)
+{
+	char *p=tgt;
+
+	while (*src)
+	{
+		char c=*src++;
+		if ((c!=double_quote)&&(c!=single_quote))
+		{
+			*p++=c;
+		}
+	}
+
+	*p=0;
+
+	return tgt;
+}
+
+RHBemitter::~RHBemitter()
+{
+}
+
+void RHBemitter::out_printf(RHBoutput *out,const char *fmt,...)
+{
+	char buf[4096];
+	va_list ap;
+	va_start(ap,fmt);
+	int i=vsnprintf(buf,sizeof(buf),fmt,ap);
+	out->write(buf,i);
+	va_end(ap);
+}
+
diff -urN somfree\somipc2\src\rhbschdr.cpp newsomfree3\somipc2\src\rhbschdr.cpp
--- somfree\somipc2\src\rhbschdr.cpp	Thu Jan 01 07:00:00 1970
+++ newsomfree3\somipc2\src\rhbschdr.cpp	Sat Mar 16 14:09:27 2024
@@ -0,0 +1,9481 @@
+/**************************************************************************
+ *
+ *  Copyright 1998-2010, Roger Brown
+ *
+ *  This file is part of Roger Brown's Toolkit.
+ *
+ *  This program is free software: you can redistribute it and/or modify it
+ *  under the terms of the GNU Lesser General Public License as published by the
+ *  Free Software Foundation, either version 3 of the License, or (at your
+ *  option) any later version.
+ * 
+ *  This program is distributed in the hope that it will be useful, but WITHOUT
+ *  ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ *  FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for
+ *  more details.
+ *
+ *  You should have received a copy of the GNU Lesser General Public License
+ *  along with this program.  If not, see <http://www.gnu.org/licenses/>
+ *
+ */
+ 
+/* 
+ * $Id: rhbschdr.cpp 2 2013-01-10 05:54:51Z somtoolkit $
+ */
+
+#include <rhbopt.h>
+/* IDL compiler */
+
+#include <stdio.h>
+#include <string.h>
+#include <stdlib.h>
+
+#include <rhbsc.h>
+
+static const char retVal_name[]="_somC_retVal";
+static const char extern_C_static[]="SOM_EXTERN_C_STATIC";
+const char *RHBheader_emitter::szSOM_RESOLVE_DATA="SOM_RESOLVE_DATA";
+
+class extern_c_proto_t
+{
+	RHBheader_emitter *emit;
+	RHBoutput *out;
+	int nest;
+public:
+	extern_c_proto_t(RHBheader_emitter *e,RHBoutput *o,int n) :
+	  emit(e),
+	  out(o),
+	  nest(n)
+	{
+		if (emit->cplusplus)
+		{
+			emit->out_printf(out,"#ifdef %s\n",extern_C_static);
+			emit->extern_c_begin(out,nest);
+			emit->out_printf(out,"#endif\n");
+		}
+	}
+	~extern_c_proto_t()
+	{
+		if (emit->cplusplus)
+		{
+			emit->out_printf(out,"#ifdef %s\n",extern_C_static);
+			emit->extern_c_end(out,nest);
+			emit->out_printf(out,"#endif\n");
+		}
+	}
+};
+
+/* main emitter */
+
+RHBheader_emitter::RHBheader_emitter(RHBrepository *rr)
+: RHBemitter(rr)
+{
+}
+
+
+void RHBheader_emitter::preflight_macros_from_idl_filename(const char *f)
+{
+	char *p=idl_filestem;
+	char buf[256];
+
+	idl_name=f;
+
+	strncpy(buf,f,sizeof(buf));
+
+	f=&buf[strlen(buf)];
+
+	while (f > buf)
+	{
+		f--;
+
+		if ((*f==':') || (*f=='\\') || (*f=='/'))
+		{
+			f++;
+			break;
+		}
+	}
+
+	strncpy(idl_filestem,f,sizeof(idl_filestem));
+	p=idl_filestem;
+
+	while (*p)
+	{
+		if (*p=='.')
+		{
+			*p=0;
+		}
+		else
+		{
+			p++;
+		}
+	}
+
+	snprintf(idl_conditional,sizeof(idl_conditional),"SOM_Module_%s_Source",idl_filestem);
+	snprintf(file_guard,sizeof(file_guard),"SOM_Module_%s_Header_",idl_filestem);
+}
+
+boolean RHBheader_emitter::generate(RHBoutput *out,const char *f)
+{
+	preflight_macros_from_idl_filename(f);
+	
+	out_printf(out,"/* generated from %s */\n",f);
+
+	if (cplusplus)
+	{
+		if (internal)
+		{
+			strncat(file_guard,"xih",sizeof(file_guard));
+		}
+		else
+		{
+			strncat(file_guard,"xh",sizeof(file_guard));
+		}
+	}
+	else
+	{
+		if (internal)
+		{
+			strncat(file_guard,"ih",sizeof(file_guard));
+		}
+		else
+		{
+			strncat(file_guard,"h",sizeof(file_guard));
+		}
+	}
+
+	out_printf(out,"/* internal conditional is %s */\n",idl_conditional);
+	out_printf(out,"#ifndef %s\n",file_guard);
+	out_printf(out,"\t#define %s 1\n",file_guard);
+
+	if (internal)
+	{
+		out_printf(out,"\t#ifndef %s\n",idl_conditional);
+		out_printf(out,"\t\t#define %s\n",idl_conditional);
+		out_printf(out,"\t#endif /* %s */\n",idl_conditional);
+	}
+
+	generate_passthrus(out,GetRepository(),1);
+
+	generate_headers(out,1);
+
+	generate_module(out,GetRepository(),1);
+
+	out_printf(out,"#endif /* %s */\n",file_guard);
+
+	return 0;
+}
+
+void RHBheader_emitter::generate_passthrus(RHBoutput *out,
+			RHBelement *root,int nest)
+{
+	RHBelement *p=root->children();
+
+	while (p)
+	{
+		if (ShouldEmit(p))
+		{
+			RHBinterface *iface=p->is_interface();
+
+			if (iface)
+			{
+				if (cplusplus)
+				{
+					if (internal)
+					{
+						generate_passthru(out,iface,"C_xih");
+					}
+					else
+					{
+						generate_passthru(out,iface,"C_xh");
+					}
+				}
+				else
+				{
+					if (internal)
+					{
+						generate_passthru(out,iface,"C_ih");
+					}
+					else
+					{
+						generate_passthru(out,iface,"C_h");
+					}
+				}
+			}
+		}
+
+		generate_passthrus(out,p,nest);
+
+		p=p->next();
+	}
+}
+
+void RHBheader_emitter::generate_module(RHBoutput *out,RHBmodule *mod,int nest)
+{
+	if (!internal)
+	{
+		generate_class_protos(out,mod,nest);
+	}
+
+	generate_types(out,mod,nest);
+	generate_classes(out,mod,nest,0);
+	generate_modules(out,mod,nest+1);
+}
+
+
+void RHBheader_emitter::generate_headers(RHBoutput *out,int nest)
+{
+	RHBinclude_list *g=GetRepository()->_pp.includes;
+
+	RHBelement *e=g->children();
+
+	if (out)
+	{
+		if (!internal)
+		{
+			dump_nest(out,nest);
+
+			if (cplusplus)
+			{
+				out_printf(out,"#include <som.xh>\n");
+			}
+			else
+			{
+				out_printf(out,"#include <som.h>\n");
+			}
+		}
+	}
+
+	if (testonly)
+	{
+		out_printf(out,"/* this is only a test */\n");
+	}
+	else
+	{
+		while (e)
+		{
+			RHBinclude_file *i=e->is_include_file();
+
+			if (i)
+			{
+				if (i->defined_in 
+					&& i->defined_in->id 
+#if 0
+					/* emit only immediate children */
+					&& !strcmp(i->defined_in->id,idl_name)
+#endif
+					)
+				{
+					if (i->id && i->id[0] && strcmp(i->id,"-"))
+					{
+						char fn[256];
+						char *p;
+
+						strncpy(fn,i->id,sizeof(fn));
+
+						p=&fn[strlen(fn)];
+
+						while (p > fn)
+						{
+							p--;
+
+							if (*p=='.')
+							{
+								p++;
+								if (cplusplus)
+								{
+									strncpy(p,"xh",fn+sizeof(fn)-p);
+								}
+								else
+								{
+									strncpy(p,"h",fn+sizeof(fn)-p);
+								}
+
+								p=fn;
+							}
+						}
+
+						if (i->included_during==GetRepository())
+						{
+							if (!internal)
+							{
+								dump_nest(out,nest);
+								out_printf(out,"#include <%s>\n",fn);
+							}
+						}
+						else
+						{
+							if (!internal)
+							{
+								dump_nest(out,nest);
+								out_printf(out,"/* #include <%s> */\n",fn);
+							}
+						}
+					}
+				}
+			}
+
+			e=e->next();
+		}
+
+		if (internal)
+		{
+			char fn[256];
+			char *p;
+
+			strncpy(fn,idl_name,sizeof(fn));
+
+			p=&fn[strlen(fn)];
+
+			while (p > fn)
+			{
+				p--;
+
+				if (*p=='.')
+				{
+					p++;
+					if (cplusplus)
+					{
+						strncpy(p,"xh",fn+sizeof(fn)-p);
+					}
+					else
+					{
+						strncpy(p,"h",fn+sizeof(fn)-p);
+					}
+
+					p=fn;
+				}
+			}
+
+			dump_nest(out,nest);
+			out_printf(out,"#include <%s>\n",short_file_name(fn));
+		}
+	}
+}
+
+void RHBheader_emitter::generate_class_protos(RHBoutput *out,RHBmodule *mod,int nest)
+{
+	RHBelement *e;
+
+	e=mod->children();
+
+	while (e)
+	{
+		RHBinterface *iface;
+
+		iface=e->is_interface();
+
+		if (iface)
+		{
+			/* generates class prototypes for
+			classes that have either been defined
+			in this IDL file, or contain no
+			definition in any other IDL file */
+
+
+			if (ShouldEmit(iface))
+			{
+/*				if (!iface->instanceData)*/
+				{
+					generate_class_proto(out,iface,nest);
+				}
+			}
+/*			else
+			{
+				char buf[256];
+				get_ir_name(iface,buf);
+				printf("%s prototype not being emitted\n",buf);
+			}*/
+		}
+
+		e=e->next();
+	}
+}
+
+void RHBheader_emitter::generate_types(RHBoutput *out,RHBelement *mod,int nest)
+{
+	RHBelement *e;
+
+	if (internal) 
+	{
+		return;
+	}
+
+	e=mod->children();
+
+	while (e)
+	{
+		RHBtype *t=0;
+
+		if (ShouldEmit(e))
+		{
+			RHBtype *is_foreign=0;
+			RHBtype *tt=e->is_type();
+			if (tt)
+			{
+				RHBtype_def *d=tt->is_typedef();
+
+	/*			printf("%s\n",e->id);
+
+				if (!strcmp(e->id,"sockaddr"))
+				{
+					__asm int 3;
+				}
+*/
+				if (d)
+				{
+					is_foreign=is_SOMFOREIGN(d->alias_for);
+				}
+			}
+
+			if (!is_foreign)
+			{
+				t=e->is_type();
+			}
+		}
+
+		if (t)
+		{
+			RHBstruct *s;
+			RHBtype_def *td;
+			RHBenum *en;
+			RHBunion *u;
+
+			if (!generated_types.contains(t))
+			{
+				int did_generate=1;
+
+				s=t->is_struct();
+
+				if (s)
+				{
+					generate_struct(s,out,nest,0,1,0);
+				}
+				else
+				{
+					td=t->is_typedef();
+
+					if (td)
+					{
+						generate_typedef(td,out,nest);
+					}
+					else
+					{
+						en=t->is_enum();
+
+						if (en)
+						{
+							generate_enum(en,out,nest);
+						}
+						else
+						{
+							u=t->is_union();
+
+							if (u)
+							{
+								generate_union(u,out,0,1);
+							}
+							else
+							{
+								RHBexception *ex;
+
+								ex=t->is_exception();
+
+								if (ex)
+								{
+									generate_exception(ex,out,0,0);
+								}
+								else
+								{
+									RHBconstant *cn;
+
+									cn=t->is_constant();
+
+									if (cn)
+									{
+										generate_constant(out,cn,0);
+									}
+									else
+									{
+										did_generate=0;
+									}
+								}
+							}
+						}
+					}
+				}
+
+				if (did_generate)
+				{
+					if (!generated_types.contains(t))
+					{
+						generated_types.add(t);
+					}
+
+					if (!internal)
+					{
+						gen_typecode_macro(out,t,nest);
+					}
+				}
+			}
+		}
+
+		e=e->next();
+	}
+}
+
+void RHBheader_emitter::gen_typecode_macro(RHBoutput *out,RHBtype *type,int nest)
+{
+	if (gen_tc_macros)
+	{
+		char n[256];
+
+		if (type->is_constant())
+		{
+			return;
+		}
+
+		if (type->is_exception())
+		{
+			return;
+		}
+
+		dump_nest(out,nest);
+
+		out_printf(out,"#ifdef SOM_TypeCodeNew\n");
+
+		dump_nest(out,nest+1);
+		get_c_name(type,n,sizeof(n));
+		out_printf(out,"#define TypeCodeNew_%s()  \\\n",n);
+
+		gen_typecode_inner(out,type,nest+3);
+		out_printf(out,"\n");
+
+		dump_nest(out,nest);
+		out_printf(out,"#endif /* SOM_TypeCodeNew */\n");
+	}
+}
+
+void RHBheader_emitter::gen_typecode_inner(RHBoutput *out,RHBtype *type,int nest)
+{
+	char n[256];
+	int end_with_null=0;
+
+	while (type->is_typedef())
+	{
+		type=type->is_typedef()->alias_for;
+	}
+
+	dump_nest(out,nest);
+	nest++;
+
+	out_printf(out,"TypeCodeNew(");
+
+	if (type->is_sequence())
+	{
+		out_printf(out,"tk_sequence,\\\n");
+
+		gen_typecode_inner(out,type->is_sequence()->sequence_of,nest);
+		RHBvalue *val=type->is_sequence()->length;
+		long m=0;
+		if (val)
+		{
+			m=val->numeric_value();
+		}
+		out_printf(out,",%ld",m);
+	}
+	else
+	{
+		if (type->is_pointer())
+		{
+			out_printf(out,"tk_pointer,\\\n");
+			gen_typecode_inner(out,type->is_pointer()->pointer_to,nest);
+		}
+		else
+		{
+			if (type->is_interface())
+			{
+				out_printf(out,"tk_objref,");
+				get_ir_name(type,n,sizeof(n));
+				out_printf(out,"%c%s%c",double_quote,n,double_quote);
+			}
+			else
+			{
+				if (type->is_struct())
+				{
+					RHBelement *e=type->children();
+					out_printf(out,"tk_struct,");
+					get_ir_name(type,n,sizeof(n));
+					out_printf(out,"%c%s%c",double_quote,n,double_quote);
+					while (e)
+					{
+						RHBtype *t2=e->is_type();
+						if (t2)
+						{
+							RHBstruct_element *el=t2->is_struct_element();
+							if (el)
+							{
+								out_printf(out,",\\\n");
+								dump_nest(out,nest);
+								out_printf(out,"%c%s%c,\\\n",double_quote,el->id,double_quote);
+								gen_typecode_inner(out,el->element_type,nest+1);
+							}
+						}
+						e=e->next();
+					}
+					end_with_null=1;
+				}
+				else
+				{
+					if (type->is_base_type())
+					{
+						RHBbase_type *bt=type->is_base_type();
+
+						out_printf(out,"tk_%s",bt->id);
+					}
+					else
+					{
+						if (type->is_string())
+						{
+							RHBvalue *val=0;
+							RHBtype *t=type->is_string()->length;
+
+							if (t)
+							{
+								val=t->is_value();
+							}
+							long m=0;
+							if (val)
+							{
+								m=val->numeric_value();
+							}
+							out_printf(out,"tk_string,%ld",m);
+						}
+						else
+						{
+							if (type->is_enum())
+							{
+								RHBelement *e;
+								out_printf(out,"tk_enum");
+								get_ir_name(type,n,sizeof(n));
+								out_printf(out,",%c%s%c",double_quote,n,double_quote);
+								e=type->children();
+								while (e)
+								{
+									out_printf(out,",\\\n");
+									dump_nest(out,nest);
+									out_printf(out,"%c%s%c",double_quote,e->id,double_quote);
+									e=e->next();
+								}
+								end_with_null=1;
+							}
+							else
+							{
+								if (type->is_array())
+								{
+									out_printf(out,"tk_array,\\\n");
+									gen_typecode_inner(out,type->is_array()->array_of,nest);
+									RHBvalue *val=type->is_array()->elements;
+									long m=0;
+									if (val)
+									{
+										m=val->numeric_value();
+									}
+									out_printf(out,",%ld",m);
+								}
+								else
+								{
+									if (type->is_constant())
+									{
+										bomb("is_constant");
+									}
+									else
+									{
+										if (type->is_qualified())
+										{
+											RHBtype *bt;
+											bt=type->is_qualified()->base_type;
+											if (!strcmp(bt->id,"long"))
+											{
+												out_printf(out,"tk_ulong");
+											}
+											else
+											{
+												out_printf(out,"tk_ushort");
+											}
+										}
+										else
+										{
+											printf("error %s\n",type->classname());
+											bomb("error");
+										}
+									}
+								}
+							}
+						}
+					}
+				}
+			}
+		}
+	}
+
+	if (end_with_null)
+	{
+		out_printf(out,",NULL");
+	}
+
+	out_printf(out,")");
+}
+
+void RHBheader_emitter::generate_classes(RHBoutput *out,RHBmodule *mod,int nest,int apiOnlyFlag)
+{
+	RHBelement *e=mod->children();
+
+	while (e)
+	{
+		RHBinterface *iface=e->is_interface();
+
+		if (iface)
+		{
+			if (ShouldEmit(iface))
+			{
+				generate_class(out,iface,nest,apiOnlyFlag);
+			}
+		}
+
+		e=e->next();
+	}
+}
+
+void RHBheader_emitter::generate_modules(RHBoutput *out,RHBmodule *mod,int nest)
+{
+	RHBelement *e;
+
+	e=mod->children();
+
+	while (e)
+	{
+		RHBmodule *c;
+
+		c=e->is_module();
+
+		if (c)
+		{
+			generate_module(out,c,nest);
+		}
+
+		e=e->next();
+	}
+}
+
+void RHBheader_emitter::generate_class_proto(RHBoutput *out,RHBinterface *iface,int nest)
+{
+	char n[256];
+
+	get_c_name(iface,n,sizeof(n));
+
+	if (!cplusplus)
+	{
+		if (strcmp(n,"SOMObject"))
+		{
+			boolean is_false=0;
+
+			if (only_ibm_som && is_false)
+			{
+				dump_nest(out,nest);
+				out_printf(out,"#ifndef %s\n",n);
+				dump_nest(out,nest+1);
+				out_printf(out,"#define %s SOMObject\n",n);
+				dump_nest(out,nest);
+				out_printf(out,"#endif /* %s */\n",n);
+			}
+			else
+			{
+				dump_nest(out,nest);
+				out_printf(out,"#ifndef _IDL_%s_defined\n",n);
+				dump_nest(out,nest+1);
+				out_printf(out,"#define _IDL_%s_defined\n",n);
+				dump_nest(out,nest+1);
+				out_printf(out,"typedef SOMObject %s;\n",n);
+				dump_nest(out,nest);
+				out_printf(out,"#endif /* _IDL_%s_defined */\n",n);
+			}
+		}
+	}
+
+	if (cplusplus)
+	{
+		if (strcmp(n,"SOMObject"))
+		{
+			dump_nest(out,nest);
+			out_printf(out,"class %s;\n",n);
+		}
+	}
+
+	generate_sequence(out,iface,nest);
+}
+
+void RHBheader_emitter::generate_enum(RHBenum *en,RHBoutput *out,int nest)
+{
+	char n[256];
+	RHBelement *el;
+
+	get_c_name(en,n,sizeof(n));
+
+	dump_nest(out,nest);
+	out_printf(out,"#ifndef %s_defined\n",n);
+	dump_nest(out,nest+1);
+	out_printf(out,"#define %s_defined\n",n);
+
+	dump_nest(out,nest+1);
+	out_printf(out,"typedef unsigned long %s;\n",n);
+
+	el=en->children();
+
+	while (el)
+	{
+		RHBtype *t=el->is_type();
+		if (t)
+		{
+			RHBvalue *val=t->is_value();
+
+			if (val)
+			{
+				long m=val->numeric_value();
+
+				if (0)
+				{
+					get_c_name(val,n,sizeof(n));
+					out_printf(out,"/* #define %s %ldUL */\n",n,m);
+				}
+
+				get_c_name(en->parent(),n,sizeof(n));
+
+				dump_nest(out,nest+1);
+
+				if (n[0]) strncat(n,"_",sizeof(n));
+
+				out_printf(out,"#ifndef %s%s\n",n,el->id);
+
+				dump_nest(out,nest+2);
+				out_printf(out,"#define %s%s %ldUL\n",n,el->id,m);
+
+				dump_nest(out,nest+1);
+				out_printf(out,"#endif /* %s%s */\n",n,el->id);
+			}
+		}
+		el=el->next();
+	}
+
+	gen_shortname(out,en,0,nest+1);
+
+	get_c_name(en,n,sizeof(n));
+
+	dump_nest(out,nest);
+	out_printf(out,"#endif /* %s_defined */\n",n);
+}
+
+void RHBheader_emitter::generate_typedef(RHBtype_def *td,RHBoutput *out,int nest)
+{
+	char n[256];
+
+/*	if (!nest) 
+	{
+		printf("blah\n");
+	}
+*/
+	if (td->alias_for->is_sequence())
+	{
+		generate_sequence(out,td->alias_for->is_sequence()->sequence_of,nest);
+	}
+
+	get_c_name(td,n,sizeof(n));
+
+	dump_nest(out,nest);
+
+	out_printf(out,"typedef ");
+
+	use_type(out,td->alias_for,n);
+
+	out_printf(out,";\n");
+
+	generate_sequence(out,td,nest);
+}
+
+void RHBheader_emitter::generate_exception(RHBexception *s,RHBoutput *out,int nesting,const char *alias_name)
+{
+	char c_name[256];
+	RHBelement *el;
+
+	get_c_name(s,c_name,sizeof(c_name));
+
+	out_printf(out,"#define ex_%s   ",c_name);
+
+	{
+		char ir_name[256];
+		get_ir_name(s,ir_name,sizeof(ir_name));
+		out_printf(out,"%c%s%c\n",double_quote,ir_name,double_quote);
+	}
+
+	if (strcmp(c_name,s->id))
+	{
+		out_printf(out,"#ifndef SOM_DONT_USE_SHORT_NAMES\n");
+		out_printf(out,"#ifndef SOMTGD_ex_%s\n",s->id);
+
+		out_printf(out,"#ifndef ex_%s\n",s->id);
+
+		out_printf(out,"#define ex_%s  ex_%s\n",s->id,c_name);
+
+		out_printf(out,"#else\n");
+
+		out_printf(out,"#define SOMTGD_ex_%s\n",s->id);
+		out_printf(out,"#undef ex_%s\n",s->id);
+
+		out_printf(out,"#endif /* ex_%s */\n",s->id);
+
+		out_printf(out,"#endif /* SOMTGD_ex_%s */\n",s->id);
+
+		out_printf(out,"#endif /* SOM_DONT_USE_SHORT_NAMES */\n");
+	}
+
+	dump_nest(out,nesting);
+
+	if (alias_name)
+	{
+		out_printf(out,"typedef struct %s",alias_name);
+	}
+	else
+	{
+		out_printf(out,"typedef struct %s",c_name);
+	}
+
+	if (s->children())
+	{
+		out_printf(out,"\n");
+		dump_nest(out,nesting);
+		out_printf(out,"{\n");
+
+		el=s->children();
+
+		while (el)
+		{
+			RHBtype *t=el->is_type();
+
+			if (t)
+			{
+				RHBstruct_element *se=t->is_struct_element();
+
+				if (se)
+				{
+					generate_struct_element(se,out,nesting+1);
+				}
+			}
+
+			el=el->next();
+		}
+
+		dump_nest(out,nesting);
+		out_printf(out,"} ");
+	}
+	else
+	{
+		out_printf(out," ");
+	}
+
+	if (alias_name)
+	{
+		out_printf(out,"%s;\n",alias_name);
+	}
+	else
+	{
+		out_printf(out,"%s;\n",c_name);
+	}
+
+	gen_shortname(out,s,0,nesting);
+}
+
+void RHBheader_emitter::generate_struct(
+			RHBstruct *s,
+			RHBoutput *out,
+			int nest,
+			const char *alias_name,
+			boolean user_data,
+			boolean instanceData)
+{
+	char n[256];
+	RHBelement *el;
+
+	align_begin(out,user_data,nest);
+
+	get_c_name(s,n,sizeof(n));
+
+	dump_nest(out,nest);
+
+	if (alias_name)
+	{
+		out_printf(out,"typedef struct %s",alias_name);
+	}
+	else
+	{
+		out_printf(out,"typedef struct %s",n);
+	}
+
+	if (s->children())
+	{
+		out_printf(out,"\n");
+
+		dump_nest(out,nest);
+		out_printf(out,"{\n");
+
+		el=s->children();
+
+		while (el)
+		{
+			RHBtype *t=el->is_type();
+
+			if (t)
+			{
+				RHBstruct_element *se=t->is_struct_element();
+
+				if (se)
+				{
+					generate_struct_element(se,out,nest+1);
+				}
+			}
+
+			el=el->next();
+		}
+
+		dump_nest(out,nest);
+		out_printf(out,"} ");
+	}
+	else
+	{
+		out_printf(out," ");
+	}
+
+	if (alias_name)
+	{
+		out_printf(out,"%s;\n",alias_name);
+	}
+	else
+	{
+		out_printf(out,"%s;\n",n);
+	}
+
+	align_end(out,user_data,nest);
+
+	if (!instanceData)
+	{
+		if (user_data) 
+		{
+			generate_sequence(out,s,nest);
+		}
+
+		gen_shortname(out,s,0,nest);
+
+		if (user_data)
+		{
+			gen_shortname_sequence(out,s,nest);
+		}
+	}
+}
+
+void RHBheader_emitter::generate_class(RHBoutput *out,RHBinterface *iface,int nest,int apiOnlyFlag)
+{
+	int doCloseAPI=0;
+
+	if (!ShouldEmit(iface))
+	{
+		return;
+	}
+
+	if (iface->instanceData)
+	{
+		if (internal)
+		{
+			dump_nest(out,nest);
+			out_printf(out,"#ifndef SOM_Scope\n");
+			dump_nest(out,nest+1);
+/*			if (cplusplus)
+			{
+				out_printf(out,"#define SOM_Scope   extern %cC%c \n",double_quote,double_quote);
+			}
+			else
+			{
+				out_printf(out,"#define SOM_Scope \n");
+			}
+*/
+				out_printf(out,"#define SOM_Scope static\n");
+			dump_nest(out,nest);
+			
+			out_printf(out,"#endif /* SOM_Scope */\n");
+
+/*			get_c_name(iface,n);
+			dump_nest(out,nest);
+			i=sprintf(buf,"#ifndef %s_Class_Source\n",n);
+			out->write(buf,i);
+			dump_nest(out,nest+1);
+			i=sprintf(buf,"#define %s_Class_Source\n",n);
+			out->write(buf,i);
+			dump_nest(out,nest);
+			i=sprintf(buf,"#endif %s_Class_Source\n",n);
+			out->write(buf,i);*/
+		}
+	}
+
+	if (iface->instanceData && cplusplus && !internal)
+	{
+		char n[256];
+		get_c_name(iface,n,sizeof(n));
+		out_printf(out,"#ifndef %s_API\n",n);
+		out_printf(out,"#define %s_API\n",n);
+
+		doCloseAPI=1;
+	}
+
+	generate_types(out,iface,nest);
+
+	if (iface->instanceData && !generated_types.contains(iface))
+	{
+		size_t i=0;
+
+		while (i < iface->_parents.length())
+		{
+			RHBelement *el=iface->_parents.get(i);
+
+			if (el)
+			{
+				RHBinterface *par=el->is_interface();
+
+				if (!generated_types.contains(par))
+				{
+				/*	char buf[256];
+					get_ir_name(par,buf);*/
+					generate_class(out,par,nest,apiOnlyFlag);
+				}
+			}
+
+			i++;
+		}
+
+		generated_types.add(iface);
+
+		if (!internal)
+		{
+			generate_somTDs(out,iface,nest);
+		}
+
+		if (!internal)
+		{
+			generate_name_lookups(out,iface,nest);
+		}
+
+		if (!internal)
+		{
+			generate_versions(out,iface,"MajorVersion","majorversion",nest);
+			generate_versions(out,iface,"MinorVersion","minorversion",nest);
+		}
+
+		generate_class_data(out,iface,nest);
+
+
+		if (doCloseAPI)
+		{
+			char n[256];
+			get_c_name(iface,n,sizeof(n));
+			out_printf(out,"#endif /* %s_API */\n",n);
+
+			doCloseAPI=0;
+		}
+
+		if (!apiOnlyFlag)
+		{
+			if (internal)
+			{
+				generate_instance_data(out,iface,nest);
+			}
+
+			generate_interface(out,iface,nest);
+
+			if (cplusplus)
+			{
+				if (internal)
+				{
+					generate_passthru(out,iface,"C_xih_after");
+				}
+				else
+				{
+					generate_passthru(out,iface,"C_xh_after");
+				}
+			}
+			else
+			{
+				if (internal)
+				{
+					generate_passthru(out,iface,"C_ih_after");
+				}
+				else
+				{
+					generate_passthru(out,iface,"C_h_after");
+				}
+			}
+		}
+	}
+
+	if (doCloseAPI)
+	{
+		char n[256];
+		get_c_name(iface,n,sizeof(n));
+		out_printf(out,"#endif /* %s_API */\n",n);
+
+		doCloseAPI=0;
+	}
+}
+
+
+void RHBheader_emitter::generate_struct_element(RHBstruct_element *el,RHBoutput *out,int nest)
+{
+	dump_nest(out,nest);
+
+	use_type(out,el->element_type,el->id);
+
+	out->write(";\n",2);
+}
+
+void RHBheader_emitter::init_type(RHBoutput *out,RHBtype *typ_init)
+{
+	RHBstruct *st=typ_init->is_struct();
+
+	if (st)
+	{
+		RHBelement *el=st->children();
+
+		out_printf(out,"{");
+
+		while (el)
+		{
+			RHBtype *typ=el->is_type();
+
+			if (typ)
+			{
+				RHBstruct_element *se=typ->is_struct_element();
+				if (se)
+				{
+					init_type(out,se->element_type);
+				}
+			}
+
+			el=el->next();
+
+			if (el)
+			{
+				out_printf(out,",");
+			}
+		}
+
+		out_printf(out,"}");
+	}
+	else
+	{
+		RHBsequence_type *seq=typ_init->is_sequence();
+		if (seq)
+		{
+			out_printf(out,"{0,0,NULL}");
+		}
+		else
+		{
+			RHBtype_def *td=typ_init->is_typedef();
+
+			if (td)
+			{
+				init_type(out,td->alias_for);
+			}
+			else
+			{
+				RHBany_type *at=typ_init->is_any();
+				if (at)
+				{
+					out_printf(out,"{NULL,NULL}");
+				}
+				else
+				{
+					if (typ_init->is_interface()
+						||
+						typ_init->is_string()
+						||
+						typ_init->is_TypeCode())
+					{
+						out_printf(out,"NULL");
+					}
+					else
+					{
+						RHBarray *ar=typ_init->is_array();
+						if (ar)
+						{
+							long val=ar->elements->numeric_value();
+							while (val--)
+							{
+								init_type(out,ar->array_of);
+
+								if (val)
+								{
+									out_printf(out,",");
+								}
+							}
+						}
+						else
+						{
+							out_printf(out,"0");
+						}
+					}
+				}
+			}
+		}
+	}
+}
+
+void RHBheader_emitter::use_type(RHBoutput *out,RHBtype *typ,const char *name)
+{	
+	RHBarray *ar=typ->is_array();;
+
+	if (ar)
+	{
+		long val=ar->elements->numeric_value();
+		char valstr[32];
+		snprintf(valstr,sizeof(valstr),"[%ld]",val);
+		int i=strlen(valstr);
+		int k=name ? strlen(name) : 0;
+		char *n2=new char[i+1+k];
+		n2[i+k]=0;
+		if (k)
+		{
+			memcpy(n2,name,k);
+		}
+		memcpy(n2+k,valstr,i);
+
+		use_type(out,ar->array_of,n2);
+
+/*		out_printf(out,"[%ld]",val);*/
+
+		delete n2;
+
+		return;
+	}
+
+	RHBinterface *iface=typ->is_interface();
+
+	if (iface)
+	{
+		char n[256];
+
+		get_c_name(typ,n,sizeof(n));
+
+		if (cplusplus)
+		{
+			out_printf(out,"%s * ",n);
+		}
+		else
+		{
+			out_printf(out,"%s SOMSTAR ",n);
+		}
+	}
+	else
+	{
+		RHBpointer_type *ptr=typ->is_pointer();
+
+		if (ptr)
+		{
+			use_type(out,ptr->pointer_to,0);
+			out_printf(out,"*");
+		}
+		else
+		{
+			RHBstring_type * str;
+
+			str=typ->is_string();
+
+			if (str)
+			{
+				/* hmm */
+				out_printf(out,"%s ",get_corbastring());
+			}
+			else
+			{
+				RHBqualified_type *qual=typ->is_qualified();
+
+				if (qual)
+				{
+					out_printf(out,"%s ",qual->id);
+					use_type(out,qual->base_type,0);
+				}
+				else
+				{
+					char n[256];
+					RHBstruct *st=typ->is_struct();
+
+					if (st)
+					{
+						get_c_name(st,n,sizeof(n)); /* did say 'struct %s '*/
+						out_printf(out,"%s ",n);
+					}
+					else
+					{
+						RHBunion *u=typ->is_union();
+
+						if (u)
+						{
+							get_c_name(u,n,sizeof(n));
+							out_printf(out,"%s ",n);
+						}
+						else
+						{
+							RHBsequence_type *seq=typ->is_sequence();
+
+							if (seq)
+							{
+								get_sequence_name(seq,n,sizeof(n));
+
+								out_printf(out,"%s ",n);
+							}
+							else
+							{
+								get_c_name(typ,n,sizeof(n));
+		
+								if (!n[0])
+								{
+									snprintf(n,sizeof(n),"<<%s>> ",typ->classname());
+								}
+
+								if (0==strcmp(n,"Istring"))
+								{
+									bomb("Istring");
+								}
+
+								out_printf(out,"%s ",n);
+							}
+						}
+					}
+				}
+			}
+		}
+	}
+
+	if (name) 
+	{
+		out_printf(out,"%s",name);
+	}
+}
+
+void RHBheader_emitter::get_sequence_name(RHBsequence_type *seq,char *name,size_t len)
+{
+	char buf[256];
+
+	if (seq==seq->sequence_of)
+	{
+		bomb("get_sequence_name");
+	}
+
+	get_most_primitive_name(seq->sequence_of,buf,sizeof(buf));
+
+	snprintf(name,len,"_IDL_SEQUENCE_%s",buf);
+}
+
+RHBtype * RHBheader_emitter::get_most_primitive_name(RHBtype *typ,char *name,size_t namelen)
+{
+	RHBqualified_type *qual;
+
+	*name=0;
+
+	while (typ->is_typedef())
+	{
+		RHBtype_def *td=typ->is_typedef();
+
+		if (td->alias_for->is_pointer())
+		{
+			break;
+		}
+
+		if (td->alias_for->is_sequence())
+		{
+			break;
+		}
+
+		if (td->alias_for->is_array())
+		{
+			break;
+		}
+
+		char buf[256];
+
+		get_c_name(td->alias_for,buf,sizeof(buf));
+
+		if (0==strcmp(buf,"SOMFOREIGN"))
+		{
+			break;
+		}
+
+		typ=td->alias_for;
+	}
+
+	qual=typ->is_qualified();
+
+	if (qual)
+	{
+		if (0==strcmp(qual->id,"unsigned"))
+		{
+			strncpy(name,"u",namelen);
+
+			get_c_name(qual->base_type,&name[1],namelen-1);
+		}
+		else
+		{
+			get_c_name(qual->base_type,name,namelen);
+		}
+	}
+	else
+	{
+		RHBsequence_type *s=typ->is_sequence();
+
+		if (s)
+		{
+			get_sequence_name(s,name,namelen);
+		}
+		else
+		{
+			if (typ->is_string())
+			{
+				strncpy(name,get_corbastring(),namelen);
+			}
+			else
+			{
+				get_c_name(typ,name,namelen);
+			}
+		}
+	}
+
+	return typ;
+}
+
+void RHBheader_emitter::generate_sequence(RHBoutput *out,RHBtype *typ,int nest)
+{
+	char n[256];
+
+	if (!typ) return;
+
+	typ=get_most_primitive_name(typ,n,sizeof(n));
+
+	if (n[0])
+	{
+		int i=0;
+
+		while (sequences.get(i))
+		{
+			const char *p=sequences.get(i);
+			if (0==strcmp(p,n))
+			{
+				return;
+			}
+
+			i++;
+		}
+
+		sequences.add(n);
+
+		dump_nest(out,nest);
+		out_printf(out,"#ifndef _IDL_SEQUENCE_%s_defined\n",n);
+		dump_nest(out,nest+1);
+		out_printf(out,"#define _IDL_SEQUENCE_%s_defined\n",n);
+
+		dump_nest(out,nest+1);
+
+		if (typ->is_interface() 
+				|| typ->is_pointer() 
+				|| typ->is_qualified() 
+				|| typ->is_array() 
+				|| typ->is_sequence())
+		{
+			out_printf(out,"SOM_SEQUENCE_TYPEDEF_NAME(");
+
+			use_type(out,typ,0);
+
+			out_printf(out,",sequence(%s));\n",n);
+		}
+		else
+		{
+			out_printf(out,"SOM_SEQUENCE_TYPEDEF(%s);\n",n);
+		}
+
+		dump_nest(out,nest);
+		
+		out_printf(out,"#endif /* _IDL_SEQUENCE_%s_defined */\n",n);
+	}
+}
+
+void RHBheader_emitter::generate_union(RHBunion *u,RHBoutput *out,int nesting,boolean user_data)
+{
+	char n[256];
+
+	align_begin(out,user_data,nesting);
+
+	get_c_name(u,n,sizeof(n));
+
+	dump_nest(out,nesting);
+
+	out_printf(out,"typedef struct %s ",n);
+
+	if (u->elements.length())
+	{
+		unsigned long index=0;
+		out->write("\n",1);
+
+		dump_nest(out,nesting);
+
+		out_printf(out,"{\n");
+
+		dump_nest(out,nesting+1);
+
+		use_type(out,u->switch_type,"_d");
+
+		out_printf(out,";\n");
+
+		dump_nest(out,nesting+1);
+
+		out_printf(out,"union\n");
+
+		dump_nest(out,nesting+1);
+
+		out_printf(out,"{\n");
+
+		while (index < u->elements.length())
+		{
+			RHBelement *el=u->elements.get(index);
+			RHBtype *t=el->is_type();
+
+			if (t)
+			{
+				RHBunion_element *e=t->is_union_element();
+
+				if (e)
+				{
+					dump_nest(out,nesting+2);
+					use_type(out,e->element_type,e->id);
+					out_printf(out,";\n");
+				}
+			}
+
+			index++;
+		}
+
+		dump_nest(out,nesting+1);
+		out_printf(out,"} _u;\n");
+		dump_nest(out,nesting);
+		out_printf(out,"} ");
+	}
+
+	out_printf(out,"%s;\n",n);
+
+	align_end(out,user_data,nesting);
+}
+
+void RHBheader_emitter::generate_instance_data(RHBoutput *out,RHBinterface *iface,int nest)
+{
+	if (internal)
+	{
+		generate_class_guard(out,nest,iface,1);
+
+		if (iface->instanceData)
+		{
+			char n[256];
+
+			get_c_name(iface,n,sizeof(n));
+
+			strncat(n,"Data",sizeof(n));
+
+			if (iface->instanceData->children())
+			{
+				RHBelement *el;
+
+				generate_struct(iface->instanceData,out,nest+1,n,1,1);
+
+				el=iface->instanceData->children();
+
+				while (el)
+				{
+					dump_nest(out,nest);
+					out_printf(out,"#ifndef _%s\n",el->id);
+					dump_nest(out,nest+1);
+					out_printf(out,"#define _%s  (somThis->%s)\n",
+							el->id,el->id);
+					dump_nest(out,nest);
+					out_printf(out,"#endif /* _%s */\n",el->id);
+					el=el->next();
+				}
+			}
+			else
+			{
+				dump_nest(out,nest+1);
+				out_printf(out,"typedef void %s;\n",n);
+			}
+		}
+		generate_class_guard(out,nest,iface,0);
+	}
+}
+
+void RHBheader_emitter::generate_class_data(RHBoutput *out,RHBinterface *iface,int nest)
+{
+	if (!iface->classData)
+	{
+		char buf[256];
+		RHBelement *e;
+		RHBinterface *ifa;
+		RHBstruct_element *se;
+		RHBtype *token;
+
+		get_c_name(iface,buf,sizeof(buf));
+		strncat(buf,"ClassDataStructure",sizeof(buf));
+		iface->classData=new RHBstruct(0,buf);
+
+		buf[0]=0;
+
+		get_meta_class(iface,buf);
+
+		if (!buf[0])
+		{
+			strncpy(buf,"SOMClass",sizeof(buf));
+		}
+
+		e=iface->find_named_element(0,buf,sizeof(buf));
+
+		ifa=e->is_interface();
+	
+		strncpy(buf,"somMToken",sizeof(buf));
+
+		e=iface->find_named_element(0,buf,sizeof(buf));
+
+		token=e->is_type();
+
+		se=new RHBstruct_element(0,"classObject");
+		se->element_type=ifa;
+
+		iface->classData->add(0,se);
+
+		strncpy(buf,"releaseorder",sizeof(buf));
+
+		e=iface->find_named_element(0,buf,sizeof(buf));
+
+		if (e)
+		{
+			int i=0;
+
+			while (e->modifier_data.get(i))
+			{
+				const char *p=e->modifier_data.get(i);
+				i++;
+
+				if (strcmp(p,","))
+				{
+					RHBoperation *op=0;
+					RHBelement *oe;
+
+					strncpy(buf,p,sizeof(buf));
+
+					oe=iface->find_named_element(0,buf,sizeof(buf));
+					if (oe) 
+					{
+						op=oe->is_operation();
+					}
+
+					se=new RHBstruct_element(0,p);
+
+			/*		if (0==strcmp(p,"somClassOfNewClassWithParents"))
+					{
+						__asm int 3;
+					}
+			*/
+					if (is_operation_procedure(op))
+					{
+						RHBtype_def *td;
+						char n[256];
+						strncpy(n,"somTD_",sizeof(n));
+						get_c_name(op,&n[strlen(n)],sizeof(n)-strlen(n));
+						td=new RHBtype_def(0,n);
+						td->alias_for=token;
+						se->element_type=td;
+					}
+					else
+					{
+						se->element_type=token;
+					}
+
+					iface->classData->add(0,se);
+				}
+			}
+		}
+
+		e=iface->children();
+
+		while (e)
+		{
+			RHBoperation *op=e->is_operation();
+
+			if (op)
+			{
+				strncpy(buf,op->id,sizeof(buf));
+
+				if (!iface->classData->find_named_element(0,buf,sizeof(buf)))
+				{
+					printf("%c%s%c, line %d: warning: ",
+							double_quote,
+							op->defined_in->id,
+							double_quote,
+							op->defined_line
+							);
+
+					printf("%c%s%c is not in releaseorder\n",double_quote,op->id,double_quote);
+
+					se=new RHBstruct_element(0,op->id);
+
+					if (is_operation_procedure(op))
+					{
+						RHBtype_def *td;
+						char n[256];
+						strncpy(n,"somTD_",sizeof(n));
+						get_c_name(op,&n[strlen(n)],sizeof(n)-strlen(n));
+						td=new RHBtype_def(0,n);
+						td->alias_for=token;
+						se->element_type=td;
+					}
+					else
+					{
+						se->element_type=token;
+					}
+
+					iface->classData->add(0,se);
+				}
+			}
+
+			e=e->next();
+		}
+	}
+
+	if (!iface->cclassData)
+	{
+		char buf[256];
+		RHBelement *e;
+		RHBstruct_element *se;
+
+		get_c_name(iface,buf,sizeof(buf));
+		strncat(buf,"CClassDataStructure",sizeof(buf));
+
+		iface->cclassData=new RHBstruct(0,buf);
+
+		se=new RHBstruct_element(0,"parentMtab");
+
+		strncpy(buf,/*"somParentMtabStructPtr"*/ "somMethodTabs",sizeof(buf));
+		e=iface->find_named_element(0,buf,sizeof(buf));
+		se->element_type=e->is_type();
+		iface->cclassData->add(0,se);
+
+		se=new RHBstruct_element(0,"instanceDataToken");
+		strncpy(buf,"somDToken",sizeof(buf));
+		e=iface->find_named_element(0,buf,sizeof(buf));
+		se->element_type=e->is_type();
+		iface->cclassData->add(0,se);
+
+		RHBelement_sequence vaops;
+
+		if (get_va_operations(iface,&vaops))
+		{
+			size_t i=0;
+			while (i < vaops.length())
+			{
+				RHBoperation *op=vaops.get(i)->is_operation();
+
+				if (op)
+				{
+					se=new RHBstruct_element(0,op->id);
+					strncpy(buf,"somMethodPtr",sizeof(buf));
+					e=iface->find_named_element(0,buf,sizeof(buf));
+					se->element_type=e->is_type();
+					iface->cclassData->add(0,se);
+				}
+				i++;
+			}
+		}
+	}
+
+	if (!internal)
+	{
+		generate_struct(iface->classData,out,nest,0,0,0);
+		generate_struct(iface->cclassData,out,nest,0,0,0);
+	}
+
+	if (!internal)
+	{
+		char n[256];
+
+		get_c_name(iface,n,sizeof(n));
+
+		dump_nest(out,nest);
+		out_printf(out,"#ifdef %s\n",szSOM_RESOLVE_DATA);
+
+		public_class_data(out,nest+1,iface,"ClassData");
+		
+		dump_nest(out,nest);
+		out_printf(out,"#else /* %s */\n",szSOM_RESOLVE_DATA);
+
+		nest++;
+
+
+#ifdef _DEBUG
+		if (!iface->has_modifier_value("dllname"))
+		{
+			out_printf(out,"/* interface for \"%s\" does not have \"dllname\" modifier */\n",n);
+			out_printf(out,"#define %sClassData   _somC_private_%sClassData\n",n,n);
+		}
+#endif
+
+		dump_nest(out,nest);
+		out_printf(out,"SOMEXTERN \n");
+
+		ifdef_import_export(out,iface,nest);
+		dump_nest(out,nest);
+		out_printf(out,"struct ");
+		out_printf(out,"%sClassDataStructure SOMDLINK %sClassData;\n",n,n);
+
+		nest--;
+		dump_nest(out,nest);
+		out_printf(out,"#endif /* %s */\n",szSOM_RESOLVE_DATA);
+	}
+	
+	if (!internal)
+	{
+		char n[256];
+
+		get_c_name(iface,n,sizeof(n));
+
+		dump_nest(out,nest);
+		out_printf(out,"#ifdef %s\n",szSOM_RESOLVE_DATA);
+
+		public_class_data(out,nest+1,iface,"CClassData");
+		
+		dump_nest(out,nest);
+		out_printf(out,"#else /* %s */\n",szSOM_RESOLVE_DATA);
+
+		nest++;
+
+		dump_nest(out,nest);
+		
+		out_printf(out,"SOMEXTERN \n");
+
+		ifdef_import_export(out,iface,nest);
+		dump_nest(out,nest);
+		
+		out_printf(out,"struct %sCClassDataStructure SOMDLINK ",n);
+
+		out_printf(out,"%sCClassData;\n",n);
+
+		nest--;
+
+		dump_nest(out,nest);
+		out_printf(out,"#endif /* %s */\n",szSOM_RESOLVE_DATA);
+	}
+
+	if (!internal)
+	{
+		char n[256];
+
+		extern_c_begin(out,nest);
+		dump_nest(out,nest);
+		out_printf(out,"extern \n");
+		ifdef_import_export(out,iface,nest);
+		dump_nest(out,nest);
+
+		get_actual_meta_class(iface,n,sizeof(n));
+		if (cplusplus)
+		{
+			out_printf(out,"%s * ",n);
+		}
+		else
+		{
+			out_printf(out,"%s SOMSTAR ",n);
+		}
+
+		get_c_name(iface,n,sizeof(n));
+		out_printf(out,"SOMLINK %sNewClass\n",n);
+
+		dump_nest(out,2+nest);
+		
+		out_printf(out,"(integer4 somtmajorVersion,integer4 somtminorVersion);\n");
+
+		extern_c_end(out,nest);
+
+#if 0
+		if (only_ibm_som)
+		{
+			/* this is IBM SOM 2.1 style */
+			dump_nest(out,nest);
+			out_printf(out,"#ifndef _%s\n",n);
+
+			dump_nest(out,nest+1);
+			out_printf(out,"#define _%s (%sClassData.classObject ? \\\n",n,n);
+
+			dump_nest(out,nest+2);
+			out_printf(out,"%sClassData.classObject : \\\n",n);
+
+			dump_nest(out,nest+3);
+			out_printf(out,"%sNewClass(%s_MajorVersion,%s_MinorVersion))\n",n,n,n);
+			
+			dump_nest(out,nest);
+			out_printf(out,"#endif /* _%s */\n",n);
+		}
+#else
+		{
+			/* this is IBM SOM 3.0 style */
+			dump_nest(out,nest);
+			out_printf(out,"#define _SOMCLASS_%s (%sClassData.classObject)\n",n,n);
+
+			dump_nest(out,nest);
+			out_printf(out,"#ifndef SOMGD_%s\n",n);
+
+			dump_nest(out,nest+1);
+			out_printf(out,"#if (defined(_%s) || defined(__%s))\n",n,n);
+			dump_nest(out,nest+2);
+			out_printf(out,"#undef _%s\n",n);
+			dump_nest(out,nest+2);
+			out_printf(out,"#undef __%s\n",n);
+			dump_nest(out,nest+2);
+			out_printf(out,"#define SOMGD_%s 1\n",n);
+			dump_nest(out,nest+1);
+			out_printf(out,"#else\n");
+			dump_nest(out,nest+2);
+			out_printf(out,"#define _%s _SOMCLASS_%s\n",n,n);
+			dump_nest(out,nest+1);
+			out_printf(out,"#endif /* _%s */\n",n);
+
+			dump_nest(out,nest);
+			out_printf(out,"#endif /* SOMGD_%s */\n",n);
+
+			dump_nest(out,nest);
+			out_printf(out,"#define %s_classObj _SOMCLASS_%s\n",n,n);
+
+			dump_nest(out,nest);
+			out_printf(out,"#define _SOMMTOKEN_%s(method) ((somMToken)(%sClassData.method))\n",n,n);
+		}
+#endif
+
+		if (!cplusplus)
+		{
+#if 0
+			if (only_ibm_som)
+			{
+				/* IBM SOM 2.1 style */
+				dump_nest(out,nest);
+				out_printf(out,"#ifndef %sNew\n",n);
+				dump_nest(out,nest+1);
+				out_printf(out,"#define %sNew() \\\n",n);
+				dump_nest(out,nest+2);
+				out_printf(out,"(SOMClass_somNew(_%s))\n",n);
+				dump_nest(out,nest);
+				out_printf(out,"#endif /* New%s */\n",n);
+			}
+#else
+			/* IBM SOM 3.0 style */
+			{
+
+				dump_nest(out,nest);
+				out_printf(out,"#ifndef %sNew\n",n);
+				dump_nest(out,nest+1);
+				out_printf(out,"#define %sNew() ( _%s ? \\\n",n,n);
+				dump_nest(out,nest+2);
+				out_printf(out,"(SOMClass_somNew(_%s)) : \\\n",n);
+				dump_nest(out,nest+2);
+				out_printf(out,"( %sNewClass( \\\n",n);
+				dump_nest(out,nest+3);
+				out_printf(out,"%s_MajorVersion, \\\n",n);
+				dump_nest(out,nest+3);
+				out_printf(out,"%s_MinorVersion), \\\n",n);
+				dump_nest(out,nest+2);
+				out_printf(out,"SOMClass_somNew(_%s))) \n",n);
+				dump_nest(out,nest);
+				out_printf(out,"#endif /* New%s */\n",n);
+			}
+#endif
+		}
+	}
+}
+
+void RHBheader_emitter::public_class_data(RHBoutput *out,int nest,RHBinterface *iface,const char *dn)
+{
+	char n[256];
+
+	get_c_name(iface,n,sizeof(n));
+
+	dump_nest(out,nest);
+	out_printf(out,"#if defined(%s) || defined(%s_Class_Source)\n",idl_conditional,n);
+
+	nest++;
+
+	dump_nest(out,nest);
+	out_printf(out,"SOMEXTERN struct %s%sStructure _%s%s;\n",n,dn,n,dn);
+
+	dump_nest(out,nest);
+	out_printf(out,"#ifndef %s%s\n",n,dn); 
+
+	dump_nest(out,nest+1);
+	out_printf(out,"#define %s%s    _%s%s\n",n,dn,n,dn); 
+
+	dump_nest(out,nest);
+	out_printf(out,"#endif /* %s%s */\n",n,dn); 
+
+	nest--;
+
+	dump_nest(out,nest);
+	out_printf(out,"#else\n");
+
+	nest++;
+
+	dump_nest(out,nest);
+	out_printf(out,"SOMEXTERN struct %s%sStructure * SOMLINK resolve_%s%s(void);\n",n,dn,n,dn); 
+
+	dump_nest(out,nest);
+	out_printf(out,"#ifndef %s%s\n",n,dn); 
+
+	dump_nest(out,nest+1);
+	out_printf(out,"#define %s%s    (*(resolve_%s%s()))\n",n,dn,n,dn); 
+
+	dump_nest(out,nest);
+	out_printf(out,"#endif /* %s%s */\n",n,dn); 
+
+	nest--;
+
+	dump_nest(out,nest);
+	out_printf(out,"#endif\n"); 
+}
+
+void RHBheader_emitter::extern_c_begin(RHBoutput *out,int nest)
+{
+/*	dump_nest(out,nest);
+	i=sprintf(buf,"#ifdef __cplusplus\n");
+	out->write(buf,i);
+	dump_nest(out,nest+1);
+	i=sprintf(buf,"extern %cC%c {\n",double_quote,double_quote);
+	out->write(buf,i);
+	dump_nest(out,nest);
+	i=sprintf(buf,"#endif\n");
+	out->write(buf,i);*/
+
+	if (cplusplus)
+	{
+		dump_nest(out,nest);
+		out_printf(out,"extern %cC%c {\n",double_quote,double_quote);
+	}
+}
+
+void RHBheader_emitter::extern_c_end(RHBoutput *out,int nest)
+{
+/*	dump_nest(out,nest);
+	i=sprintf(buf,"#ifdef __cplusplus\n");
+	out->write(buf,i);
+	dump_nest(out,nest+1);
+	i=sprintf(buf,"}\n");
+	out->write(buf,i);
+	dump_nest(out,nest);
+	i=sprintf(buf,"#endif\n");
+	out->write(buf,i);*/
+
+	if (cplusplus)
+	{
+		dump_nest(out,nest);
+		out_printf(out,"}\n");
+	}
+}
+
+void RHBheader_emitter::ifdef_import_export(RHBoutput *out,RHBinterface *iface,int nest)
+{
+	if (iface->has_modifier_value("dllname"))
+	{
+		char n[256];
+
+		get_c_name(iface,n,sizeof(n));
+		strncat(n,"_Class_Source",sizeof(n));
+
+		dump_nest(out,nest);
+		out_printf(out,"#if defined(%s) || defined(%s)\n",idl_conditional,n);
+
+		dump_nest(out,nest+1);
+		out_printf(out,"#ifdef SOMDLLEXPORT\n");
+
+		dump_nest(out,2+nest);
+		out_printf(out,"SOMDLLEXPORT\n");
+
+		dump_nest(out,nest+1);
+		out_printf(out,"#endif /* SOMDLLEXPORT */\n");
+
+		dump_nest(out,nest);
+		out_printf(out,"#else /* %s || %s */\n",idl_conditional,n);
+
+		dump_nest(out,nest+1);
+		out_printf(out,"#ifdef SOMDLLIMPORT\n");
+
+		dump_nest(out,2+nest);
+		out_printf(out,"SOMDLLIMPORT\n");
+
+		dump_nest(out,nest+1);
+		out_printf(out,"#endif /* SOMDLLIMPORT */\n");
+
+		dump_nest(out,nest);
+		out_printf(out,"#endif /* %s || %s */\n",idl_conditional,n);
+	}
+}
+
+
+void RHBheader_emitter::generate_sizeof_va_list_param(RHBoutput *out,RHBparameter *param,int nest)
+{
+	char n[256];
+
+	if (!strcmp(param->mode,"in"))
+	{
+		RHBtype *t=unwind_typedef(param->parameter_type);
+
+		if (t)
+		{
+			RHBtype *bt=get_va_type(t,1);
+
+			if (bt)
+			{
+				if (bt->is_base_type())
+				{
+					if (bt->is_base_type()->_floating)
+					{
+						/* for this case, a float needs to stay
+							as a float, and not get promoted */
+						bt=t;
+					}
+				}
+
+				if (bt->is_array() ||
+					bt->is_union() ||
+					bt->is_struct() ||
+					bt->is_pointer() ||
+					bt->is_interface() ||
+					bt->is_sequence() ||
+					bt->is_any() ||
+					parameter_by_reference(param,NULL))
+				{
+					dump_nest(out,nest+1);
+					out_printf(out,"+sizeof(void *)\n");
+				}
+				else
+				{
+					if (bt->is_enum())
+					{
+						get_c_name(bt,n,sizeof(n));
+					}
+					else
+					{
+						strncpy(n,bt->id,sizeof(n));
+
+						while (bt->is_qualified())
+						{
+							bt=bt->is_qualified()->base_type;
+							strncat(n,"_",sizeof(n));
+							strncat(n,bt->id,sizeof(n));
+						}
+
+						if (!strcmp(n,"unsigned_long"))
+						{
+							strncpy(n,"unsigned long",sizeof(n));
+						}
+						else
+						{
+							if (!strcmp(n,"unsigned_short"))
+							{
+								strncpy(n,"unsigned short",sizeof(n));
+							}
+						}
+					}
+
+					dump_nest(out,nest+1);
+					out_printf(out,"+sizeof(%s)\n",n);
+				}
+			}
+		}
+	}
+	else
+	{
+		dump_nest(out,nest+1);
+		out_printf(out,"+sizeof(void *)\n");
+	}
+}
+
+boolean RHBheader_emitter::is_in_floating(RHBparameter *param)
+{
+	if (!strcmp(param->mode,"in"))
+	{
+		RHBtype *t=unwind_typedef(param->parameter_type);
+		if (t)
+		{
+			RHBbase_type *bt=t->is_base_type();
+
+			if (bt)
+			{
+				if (bt->_floating)
+				{
+					return 1;
+				}
+			}
+		}
+	}
+
+	return 0;
+}
+
+static struct
+{
+	const char *name;
+	const char *value;
+} type_table[]={
+	{"boolean","SOMRdRetbyte"},
+	{"char","SOMRdRetbyte"},
+	{"octet","SOMRdRetbyte"},
+	{"short","SOMRdRethalf"},
+	{"unsigned_short","SOMRdRethalf"},
+	{"long","SOMRdRetsimple"},
+	{"unsigned_long","SOMRdRetsimple"},
+	{"unsigned_short","SOMRdRethalf"},
+	{"float","SOMRdRetfloat"},
+	{"double","SOMRdRetdouble"},
+	{"long_double","SOMRdRetlongdouble"},
+	{"void","SOMRdRetsimple"},
+	{"TypeCode","SOMRdRetsimple"},
+	{"Principal","SOMRdRetsimple"}
+};
+
+struct type_size
+{
+	int size;
+	const char *type;
+};
+
+static struct type_size ret32bit[]=
+{
+	{1,"SOMRdRetbyte"},
+	{2,"SOMRdRethalf"},
+	{4,"SOMRdRetsimple"}
+};
+
+static struct type_size ret64bit[]=
+{
+	{1,"SOMRdRetbyte"},
+	{2,"SOMRdRethalf"},
+	{4,"SOMRdRetsimple"},
+	{8,"SOMRdRetsmallaggregate"}
+};
+
+void RHBheader_emitter::type_size_expand(RHBoutput *out,int nest,const char *t,struct type_size *a,size_t n)
+{
+	size_t k=0;
+
+	while (k < n)
+	{
+		dump_nest(out,nest);
+
+		out_printf(out,"((sizeof(%s)==%d) ? %s : \n",t,a->size,a->type);
+
+		a++;
+		k++;
+	}
+
+	dump_nest(out,nest);
+	out_printf(out,"SOMRdRetaggregate");
+	while (k--)
+	{
+		out_printf(out,")");
+	}
+	out_printf(out,"\n");
+}
+
+void RHBheader_emitter::generate_rdsizetype(RHBoutput *out,const char *t,int nest)
+{
+	out_printf(out,"#ifdef SOMRdRetsmallaggregate\n");
+
+	type_size_expand(out,nest+1,t,ret64bit,sizeof(ret64bit)/sizeof(ret64bit[0]));
+
+	dump_nest(out,nest);
+	out_printf(out,"#else\n");
+
+	type_size_expand(out,nest+1,t,ret32bit,sizeof(ret32bit)/sizeof(ret32bit[0]));
+
+	dump_nest(out,nest);
+	out_printf(out,"#endif\n");
+	dump_nest(out,nest);
+}
+
+
+void RHBheader_emitter::generate_somMethodInfo(
+			RHBoutput *out,
+			RHBinterface *iface,
+			RHBoperation *op,
+			int nest,
+			int auto_stub)
+{
+	char n[256];
+
+	if (auto_stub)
+	{
+		int has_floats=0;
+		RHBtype *ret_type=unwind_typedef(op->return_type);
+		RHBelement *elc=op->children();
+
+		/* only do float map if can auto_stub */
+
+		while (elc)
+		{
+			RHBparameter *param=elc->is_parameter();
+			if (param)
+			{
+				if (is_in_floating(param))
+				{
+					has_floats++;
+				}
+			}
+			elc=elc->next();
+		}
+
+		get_c_name(op,n,sizeof(n));
+
+		if (has_floats)
+		{
+			int k=0;
+			RHBelement *el=op->children();
+
+			{
+				char n5[256];
+				snprintf(n5,sizeof(n5),"somFloatMap_%s",n);
+				undoublebar(out,n5);
+			}
+
+			out_printf(out,"static somFloatMap somFloatMap_%s={\n",n); 
+
+			while (el)
+			{
+				RHBparameter *param=el->is_parameter();
+				if (param)
+				{
+					if (is_in_floating(param))
+					{
+						RHBelement *z=op->children(); /* was param->children !! */
+						RHBtype *t=unwind_typedef(param->parameter_type);
+
+						dump_nest(out,nest+2);
+						out_printf(out,"sizeof(SOMObject *)\n");
+
+						if (operation_needs_environment(iface,op))
+						{
+							dump_nest(out,nest+2);
+							out_printf(out,"+sizeof(Environment *)\n");
+						}
+
+						if (operation_needs_context(iface,op))
+						{
+							dump_nest(out,nest+2);
+							out_printf(out,"+sizeof(Context SOMSTAR)\n");
+						}
+
+						while (z && (z!=param))
+						{
+							RHBparameter *p=z->is_parameter();
+							if (p)
+							{
+								generate_sizeof_va_list_param(out,p,nest+1);
+							}
+							z=z->next();
+						}
+
+						if (!strcmp(t->id,"float"))
+						{
+							dump_nest(out,nest+2);
+							out_printf(out,"+SOMFMSingle\n");
+						}
+
+						dump_nest(out,nest+1);
+
+						k++;
+
+						if (k < has_floats)
+						{
+							out_printf(out,",\n");
+						}
+						else
+						{
+							out_printf(out,"+SOMFMLast");
+						}
+					}
+				}
+
+				el=el->next();
+			}
+
+			dump_nest(out,nest+1);
+			out_printf(out,"};\n");
+		}
+
+		{
+			char n2[256];
+			strncpy(n2,"somMethodInfo_",sizeof(n2));
+			strncat(n2,n,sizeof(n2));
+			undoublebar(out,n2);
+		}
+
+		out_printf(out,"static somMethodInfo somMethodInfo_%s={\n",n); 
+
+		dump_nest(out,nest+1);
+
+		if (ret_type)
+		{
+			if (ret_type->is_base_type() || ret_type->is_qualified())
+			{
+				char buf[256];
+				size_t i=0;
+				int k=sizeof(type_table)/sizeof(type_table[0]);
+				strncpy(buf,ret_type->id,sizeof(buf));
+
+				while (ret_type->is_qualified())
+				{
+					ret_type=ret_type->is_qualified()->base_type;
+					strncat(buf,"_",sizeof(buf));
+					strncat(buf,ret_type->id,sizeof(buf));
+				}
+
+				while (k--)
+				{
+					if (!strcmp(type_table[k].name,buf))
+					{
+						i=snprintf(buf,sizeof(buf),"%s",type_table[k].value);
+
+						break;
+					}
+				}
+
+				if (!i)
+				{
+					if (!strcmp(buf,"any"))
+					{
+						generate_rdsizetype(out,buf,nest+1);
+					}
+					else
+					{
+						bomb("internal error - was expecting any");
+			
+						i=strlen(buf);
+						i+=snprintf(buf+i,sizeof(buf)-i," compiler error %s:%d\n",__FILE__,__LINE__);
+					}
+				}
+
+				if (i) 
+				{
+					out_printf(out,"%s",buf);
+				}
+			}
+			else
+			{
+				if (ret_type->is_sequence())
+				{
+					generate_rdsizetype(out,"GENERIC_SEQUENCE",nest+1);
+				}
+				else
+				{
+					if (ret_type->is_union() ||
+						ret_type->is_struct())
+					{
+						char buf[256];
+						get_c_name(ret_type,buf,sizeof(buf));
+						generate_rdsizetype(out,buf,nest);
+					}
+					else
+					{
+						if (ret_type->is_pointer() ||
+							ret_type->is_interface() ||
+							ret_type->is_array() ||
+							ret_type->is_string())
+						{
+							out_printf(out,"SOMRdRetsimple");
+						}
+						else
+						{
+							if (ret_type->is_enum())
+							{
+								out_printf(out,"SOMRdRetsimple");
+							}
+							else
+							{
+								char buf[256];
+								get_c_name(ret_type,buf,sizeof(buf));
+
+								bomb("internal compiler error");
+	
+								int i=strlen(buf);
+								i+=snprintf(buf+i,sizeof(buf)-i," compiler error %s:%d\n",__FILE__,__LINE__);
+
+								out_printf(out,"SOMRdRetsimple");
+							}
+						}
+					}
+				}
+			}
+		}
+		else
+		{
+			out_printf(out,"SOMRdRetsimple");
+		}
+
+		if (has_floats)
+		{
+			out_printf(out,"|SOMRdFloatArgs,\n");
+		}
+		else
+		{
+			out_printf(out,"|SOMRdNoFloatArgs,\n");
+		}
+
+		dump_nest(out,nest+1);
+		out_printf(out,"sizeof(SOMObject SOMSTAR)\n");
+
+		if (operation_needs_environment(iface,op))
+		{
+			dump_nest(out,nest+1);
+			out_printf(out,"+sizeof(Environment *)\n");
+		}
+
+		if (operation_needs_context(iface,op))
+		{
+			dump_nest(out,nest+1);
+			out_printf(out,"+sizeof(Context SOMSTAR)\n");
+		}
+
+		elc=op->children();
+
+		while (elc)
+		{
+			RHBparameter *param=elc->is_parameter();
+			if (param)
+			{
+				generate_sizeof_va_list_param(out,param,nest);
+			}
+
+			elc=elc->next();
+		}
+
+		dump_nest(out,nest+1);
+
+		if (has_floats)
+		{
+			get_c_name(op,n,sizeof(n));
+			out_printf(out,",&somFloatMap_%s};\n",n);
+		}
+		else
+		{
+			out_printf(out,",NULL};\n");
+		}
+	}
+
+	get_c_name(op,n,sizeof(n));
+
+	{
+		char n2[256];
+		strncpy(n2,"somApRdInfo_",sizeof(n2));
+		strncat(n2,n,sizeof(n2));
+		undoublebar(out,n2);
+	}
+
+	out_printf(out,"static somApRdInfo somApRdInfo_%s={\n",n);
+
+	dump_nest(out,nest+1);
+	out_printf(out,"(somMethodPtr)somRD_%s,\n",n);
+
+	if (op_is_varg(op)) 
+	{
+		dump_nest(out,nest+1);
+		out_printf(out,"NULL /* has va_list */,\n");
+	}
+	else
+	{
+		dump_nest(out,nest+1);
+		out_printf(out,"(somMethodPtr)somAP_%s,\n",n);
+	}
+
+	dump_nest(out,nest+1);
+
+	if (auto_stub)
+	{
+		out_printf(out,"&somMethodInfo_%s};\n",n);
+	}
+	else
+	{
+		out_printf(out,"NULL};\n");
+	}
+}
+
+void RHBheader_emitter::call_parent_constructors(RHBoutput *out,RHBinterface *iface,int nest,const char *args)
+{
+	if (!args) args="";
+
+	if (iface->_parents.length())
+	{
+		size_t k=0;
+		while (k < iface->_parents.length())
+		{
+			char n[256];
+			dump_nest(out,nest+2);
+
+			get_c_name(iface->_parents.get(k),n,sizeof(n));
+
+			out_printf(out,"%c %s(%s)\n",
+				(k) ? ',' : ':',
+				n,
+				args);
+
+			k++;
+		}
+	}
+}
+
+void RHBheader_emitter::generate_interface(RHBoutput *out,RHBinterface *iface,int nest)
+{
+	char n[256];
+/*	RHBelement *el;*/
+
+	/* generate as C++ first ... so we know what we're doing */
+
+	/*
+	if (!internal)
+	{
+		generate_versions(out,iface,"MajorVersion","majorversion",nest);
+		generate_versions(out,iface,"MinorVersion","minorversion",nest);
+	}
+	*/
+
+	get_c_name(iface,n,sizeof(n));
+
+	if (cplusplus)
+	{
+		if (!internal)
+		{
+			out_printf(out,"\n");
+
+			if (!iface->_parents.length())
+			{
+				out_printf(out,"#include <somcls.api>\n");
+			}
+
+			dump_nest(out,nest);
+			out_printf(out,"class %s",n);
+
+			if (iface->_parents.length())
+			{
+				long m=0;
+				long l=iface->_parents.length();
+				out_printf(out," : ");
+
+				while (m < l)
+				{
+					RHBelement *el=iface->_parents.get(m);
+
+					get_c_name(el,n,sizeof(n));
+
+					out_printf(out,"public %s",n);
+
+					m++;
+
+					if (m < l)
+					{
+						out_printf(out,", ");
+					}
+				}
+			}
+
+			out_printf(out,"\n");
+
+			dump_nest(out,nest);
+
+			out_printf(out,"{\n");
+
+			get_c_name(iface,n,sizeof(n));
+
+			{
+				/* this constructor is designed to allow MI C++
+				   classes to properly construct themselves */
+
+				const char *mtab=iface->_parents.length() ? "mtab" : "/* mtab */ ";
+
+				/* generate protected parent constructor */
+				dump_nest(out,nest);
+				out_printf(out,"protected:\n");
+
+				dump_nest(out,nest+1);
+				out_printf(out,"%s(somMethodTab & %s)\n",n,mtab);
+
+				call_parent_constructors(out,iface,nest,"mtab");
+
+				dump_nest(out,nest+1);
+				out_printf(out,"{}\n");
+			}
+
+		/*	if (iface->_parents.length()==0)
+			{
+				dump_nest(out,1);
+				i=sprintf(buf,"somMethodTabPtr mtab;\n");
+				out->write(buf,i);
+			}*/
+
+			dump_nest(out,nest);
+			out_printf(out,"public:\n");
+
+			RHBelement *el=iface->children();
+
+			while (el)
+			{
+				RHBoperation *op=el->is_operation();
+
+				if (op)
+				{
+					out_printf(out,"\n");
+					generate_inline_operation(out,iface,op,nest);
+				}
+
+				el=el->next();
+			}
+
+	/*		if (iface->_parents.length()==0)*/
+			{
+				out_printf(out,"\n");
+				dump_nest(out,nest+1);
+				out_printf(out,"inline void operator delete(void *x)\n");
+				dump_nest(out,nest+2);
+				out_printf(out,"{ ((SOMObject *)x)->somFree(); };\n\n");
+			}
+
+#if 0
+			if (iface->_parents.length())
+#endif
+			{
+				char args[256];
+
+				snprintf(args,sizeof(args),"*(%sCClassData.parentMtab->mtab)",n);
+
+				{
+					/* generate new operation */
+					dump_nest(out,nest+1);
+					out_printf(out,"inline void * operator new(size_t /* len */)\n");
+
+					get_c_name(iface,n,sizeof(n));
+					dump_nest(out,nest+1);
+					out_printf(out,"{ if (!%sClassData.classObject)\n",n);
+
+					dump_nest(out,nest+2);
+					out_printf(out,"{ %sNewClass(%s_MajorVersion,%s_MinorVersion); }\n",n,n,n);
+
+					dump_nest(out,nest+2);
+					out_printf(out,"return (void *)SOM_Resolve((SOMObject *)(void *)%sClassData.classObject,\n",n);
+
+					dump_nest(out,nest+3);
+					out_printf(out,"SOMClass,somNewNoInit)((SOMClass *)(void *)%sClassData.classObject);\n",n);
+
+					dump_nest(out,nest+1);
+					out_printf(out,"};\n");
+				}
+
+				{
+					/* generate default constructor */
+					dump_nest(out,nest+1);
+					out_printf(out,"%s()\n",n);
+
+					call_parent_constructors(out,iface,nest,args);
+
+					dump_nest(out,nest+1);
+					out_printf(out,"{ if ((*(void **)(void *)this)==%sCClassData.parentMtab->mtab)\n",n);
+
+					dump_nest(out,nest+2);
+					out_printf(out,"((SOMObject *)(void *)this)->somDefaultInit(0); }\n");
+				}
+
+				{
+					/* generate copy constructor operation */
+					dump_nest(out,nest+1);
+					out_printf(out,"%s(%s *fromObj)\n",n,n);
+
+					call_parent_constructors(out,iface,nest,args);
+
+					dump_nest(out,nest+1);
+					out_printf(out,"{ if ((*(void **)(void *)this)==%sCClassData.parentMtab->mtab)\n",n);
+					dump_nest(out,nest+2);
+					out_printf(out,"((SOMObject *)(void *)this)->somDefaultCopyInit(0,(SOMObject*)(void*)fromObj); }\n");
+				}
+			}
+#if 0
+			else
+			{
+				dump_nest(out,nest+1);
+				i=sprintf(buf,"void * operator new(size_t /* len */);\n\n");
+				out->write(buf,i);
+			}
+#endif
+
+			boolean done_somNew=0;
+
+			if (is_multiple_inherited(iface))
+			{
+				if (iface->_parents.length())
+				{
+					RHBelement_sequence seq;
+
+					determine_inherited(iface,iface,&seq);
+
+					unsigned long i=0;
+
+					while (i < seq.length())
+					{
+						RHBoperation *op;
+
+						op=seq.get(i)->is_operation();
+
+						if (iface->_metaclass_of.length())
+						{
+							char n2[256];
+							get_ir_name(op,n2,sizeof(n2));
+							if (!strcmp(n2,"::SOMClass::somNew"))
+							{
+								done_somNew=1;
+								generate_inline_somNew_operation(out,iface,op,nest);
+
+								op=0;
+							}
+						}
+
+						if (op)
+						{
+							generate_inline_operation(out,iface,op,nest);
+						}
+
+						i++;
+					}
+				}
+			}
+
+			if (!done_somNew)
+			{
+				if (iface->_metaclass_of.length())
+				{
+					/* this probably means that 'somcls.idl' was not included */
+
+					done_somNew=1;
+					generate_inline_somNew_operation(out,iface,0,nest);
+				}
+			}
+
+			dump_nest(out,nest);
+			out_printf(out,"};\n");
+		}
+	}
+
+	if (internal)
+	{
+		generate_class_guard(out,nest,iface,1);
+	}
+
+	{
+		RHBelement *el=iface->children();
+
+		while (el)
+		{
+			RHBoperation *op=el->is_operation();
+
+			if (op)
+			{
+				if (is_operation_procedure(op))
+				{
+					if (!internal)
+					{
+						if (!cplusplus)
+						{
+							generate_macro_operation(out,iface,op,nest);
+						}
+					}
+					else
+					{
+						generate_operation_proto(out,iface,op,nest);
+					}
+				}
+				else
+				{
+					if (!internal)
+					{
+						if (!cplusplus)
+						{
+							generate_macro_operation(out,iface,op,nest);
+						}
+					}
+					else
+					{
+						int do_auto_stubs=op->can_auto_stub();
+
+						generate_somId(out,nest,op,"somMN","somId",0,0);
+						generate_somId(out,nest,op,"somDS","somDI",0 /*1*/,1);
+
+						generate_operation_proto(out,iface,op,nest);
+
+						if (do_auto_stubs)
+						{
+							out_printf(out,"#ifdef SOM_METHOD_STUBS\n");
+							get_c_name(op,n,sizeof(n));
+							out_printf(out,"\t#define somRD_%s   0\n",n);
+							out_printf(out,"\t#define somAP_%s   0\n",n);
+							out_printf(out,"#else /* SOM_METHOD_STUBS */\n");
+						}
+
+						generate_redispatch_stub(out,iface,op,nest);
+
+						if (op) 
+						{
+							generate_apply_stub(out,iface,op,nest);
+						}
+
+
+						if (do_auto_stubs)
+						{
+							out_printf(out,"#endif /* SOM_METHOD_STUBS */\n");
+						}
+
+
+						{
+							out_printf(out,"#ifdef SOM_METHOD_STUBS\n");
+							generate_somMethodInfo(out,iface,op,nest,do_auto_stubs);
+							out_printf(out,"#endif /* SOM_METHOD_STUBS */\n");
+						}
+					}
+				}
+			}
+
+			el=el->next();
+		}
+	}
+
+	/* this should only be done if internal... */
+
+	if (internal)
+	{
+		dump_nest(out,nest);
+		get_c_name(iface,n,sizeof(n));
+		out_printf(out,"#ifndef %sMethodDebug\n",n);
+		dump_nest(out,nest+1);
+		out_printf(out,"#define %sMethodDebug(x,y) SOMMethodDebug(x,y)\n",n);
+		dump_nest(out,nest);
+		out_printf(out,"#endif /* %sMethodDebug */\n",n);
+
+		if (iface->instanceData->children())
+		{
+			dump_nest(out,nest); 
+			out_printf(out,"#ifdef SOM_DATA_THUNKS\n");
+
+			nest++;
+
+			{
+				dump_nest(out,nest);
+				get_c_name(iface,n,sizeof(n));
+				out_printf(out,"#define %sGetData(somSelf) \\\n",n);
+				dump_nest(out,nest+1);
+
+				if (cplusplus)
+				{
+					out_printf(out,"(((%sData * (SOMLINK *)(%s *))",n,n);
+				}
+				else
+				{
+					out_printf(out,"(((%sData * (SOMLINK *)(%s SOMSTAR))",n,n);
+				}
+
+				get_c_name(iface,n,sizeof(n));
+				out_printf(out,"(somMethodPtr)%sCClassData.instanceDataToken)(somSelf))\n",n);
+			}
+
+			nest--;
+			dump_nest(out,nest); 
+			out_printf(out,"#else /* SOM_DATA_THUNKS */\n");
+
+			nest++;
+			{
+				dump_nest(out,nest);
+				get_c_name(iface,n,sizeof(n));
+				out_printf(out,"#define %sGetData(somSelf) \\\n",n);
+				dump_nest(out,nest+1);
+				out_printf(out,"((%sData *) \\\n",n);
+				dump_nest(out,nest+2);
+				out_printf(out,"somDataResolve(");
+				if (cplusplus)
+				{
+					out_printf(out,"(SOMObject *)(void *)");
+				}
+
+				get_c_name(iface,n,sizeof(n));
+				out_printf(out,"somSelf,%sCClassData.instanceDataToken))\n",n);
+			}
+			nest--;
+			dump_nest(out,nest); 
+			out_printf(out,"#endif /* SOM_DATA_THUNKS */\n");
+		}
+		else
+		{
+			dump_nest(out,nest);
+			get_c_name(iface,n,sizeof(n));
+			out_printf(out,"#define %sGetData(somSelf)  ",n);
+			out_printf(out,"((%sData *)0)  /* class has no attributes */\n",n);
+		}
+	}
+
+	if (internal)
+	{
+		RHBelement_sequence seq;
+		unsigned long i=0;
+
+		determine_overrides(iface,iface,&seq);
+
+		while (i < seq.length())
+		{
+			RHBoperation *op=seq.get(i)->is_operation();
+
+			if (op)
+			{
+				if (0==strcmp(op->id,"somDestruct"))
+				{
+					out_printf(out,"/* %s::%s (%s:%d)*/\n",
+							iface->id,op->id,__FILE__,__LINE__);
+				}
+				else
+				{
+					if (0==strcmp(op->id,"somDefaultInit"))
+					{
+						out_printf(out,"/* %s::%s (%s:%d)*/\n",
+								iface->id,op->id,__FILE__,__LINE__);
+					}
+				}
+
+				if (op)
+				{
+					generate_somId(out,nest,op,"somDS","somDI",0/*1*/,1);  /* used for override registration */
+					generate_operation_proto(out,iface,op,nest);
+				}
+			}
+
+			i++;
+		}
+
+		generate_new_class(out,iface,&seq,nest);
+	}
+
+	if (internal)
+	{
+		unsigned long i=0;
+
+		while (i < iface->_parents.length())
+		{
+			RHBinterface *par=iface->_parents.get(i)->is_interface();
+
+			if (par)
+			{
+				RHBelement_sequence seq;
+				unsigned long j=0;
+
+				par->list_all_operations(&seq);
+
+				while (j < seq.length())
+				{
+					generate_parent_macro(out,iface,par,seq.get(j)->is_operation(),nest);
+
+					j++;
+				}
+			}
+
+			i++;
+		}
+
+		generate_dts_macros(out,iface);
+	}
+
+	if (internal)
+	{
+		generate_class_guard(out,nest,iface,0);
+	}
+
+
+	if (!cplusplus)
+	{
+		if (!internal)
+		{
+			if (iface->_parents.length())
+			{
+				RHBelement_sequence dups;
+
+				out_printf(out,"\n#ifndef SOM_DONT_USE_INHERITED_MACROS\n");
+
+				generate_inherited_macros(out,&dups,iface,iface);
+
+				out_printf(out,"#endif /* SOM_DONT_USE_INHERITED_MACROS */\n\n");
+			}
+		}
+	}
+}
+
+void RHBheader_emitter::generate_new_class(RHBoutput *out,RHBinterface *iface,RHBelement_sequence *overrides,int nest)
+{
+	int num_statics=0;
+	int num_procedures=0;
+	int num_va=0;
+	char n[256];
+	long mask;
+	RHBelement_sequence init_entries;
+	int init_op_count=get_init_operations(iface,&init_entries);
+
+	generate_somId(out,nest,iface,"somCN",0,0,1);
+	get_meta_class(iface,n);
+
+	if (n[0])
+	{
+		generate_somId(out,nest,iface->find_named_element(0,n,sizeof(n)),"somMCN",0,0,1);
+	}
+
+	{
+		unsigned long k=0;
+		
+		while (k < iface->_parents.length())
+		{
+			char buf[256];
+			char n2[256];
+
+			RHBelement *el=iface->_parents.get(k);
+
+			get_c_name(iface,n2,sizeof(n2));
+			strncpy(buf,"somPCN_",sizeof(buf));
+			strncat(buf,n2,sizeof(buf));
+
+			generate_somId(out,nest,el,buf,0,0,1);
+
+			k++;
+		}
+	}
+
+	if (iface->_parents.length())
+	{
+		unsigned long k=0;
+
+		get_c_name(iface,n,sizeof(n));
+
+		out_printf(out,"static const somConstId somPC%s[%d]={\n",
+					n,
+					(int)iface->_parents.length());
+
+		while (k < iface->_parents.length())
+		{
+			char m[256];
+
+			get_c_name(iface,m,sizeof(m));
+			RHBelement *el=iface->_parents.get(k);
+
+			get_c_name(el,n,sizeof(n));
+
+			dump_nest(out,1);
+			out_printf(out,"&somPCN_%s_%s",m,n);
+
+			k++;
+
+			if (k!=iface->_parents.length())
+			{
+				out_printf(out,",\n");
+			}
+		}
+
+		out_printf(out,"};\n\n");
+	}
+
+	num_procedures=0;
+	num_statics=0;
+
+	{
+		RHBelement *el=iface->children();
+
+		while (el)
+		{
+			if (el->is_operation())
+			{
+				if (is_operation_procedure(el->is_operation()))
+				{
+					num_procedures++;
+				}
+				else
+				{
+					num_statics++;
+				}
+			}
+
+			el=el->next();
+		}
+	}
+
+	get_ir_name(iface,n,sizeof(n));
+
+	out_printf(out,"/* class %s introduces %d methods, %d procedures and overrides %d */\n",
+				n,num_statics,num_procedures,(int)overrides->length());
+
+	/* generate class data structure */
+
+	out_printf(out,"/* should have %sClassData defined here */\n",n);
+
+	generate_internal_ctrl_macros(out,iface);
+	enum_attributes(out,iface);
+
+	/* static somStaticMethod_t <<classname>>SM */
+	/* static somOverrideMethod_t <<classname>>OM */
+	/* static somStaticClassInfo <<className>>SCI  */
+
+	get_c_name(iface,n,sizeof(n));
+
+	if (num_statics)
+	{
+		int x=num_statics;
+		get_c_name(iface,n,sizeof(n));
+		out_printf(out,"static somStaticMethod_t %sSM[%d]={\n",
+				n,(int)num_statics);
+
+		RHBelement *el=iface->children();
+
+		while (el)
+		{	
+			RHBoperation *op=el->is_operation();
+
+			if (op)
+			{
+				if (!is_operation_procedure(op))
+				{
+					dump_nest(out,2);
+
+					out_printf(out,"{\n");
+
+					/* somMToken *classData */
+					dump_nest(out,3);
+					get_c_name(iface,n,sizeof(n));
+					out_printf(out,"&%sClassData.%s,\n",n,op->id);
+
+					/* somId *methodId */
+					dump_nest(out,3);
+					out_printf(out,"&somId_%s,\n",op->id);
+
+					/* somId *methodDescriptor */
+
+					dump_nest(out,3);
+					get_c_name(op,n,sizeof(n));
+					out_printf(out,"&somDI_%s,\n",n);
+
+					/* somMethodPtr method */
+
+					dump_nest(out,3);
+					get_function_prefix(iface,n,sizeof(n));
+					out_printf(out,"(somMethodPtr)%s%s,\n",n,op->id);
+
+					
+					out_printf(out,"#ifdef SOM_METHOD_STUBS\n");
+
+					{
+								/* indicate that we have the ABI info 
+									technically you can't cast a data pointer
+									to a function pointer, so we go via a size_t...
+									*/
+								dump_nest(out,3);
+								out_printf(out,"(somMethodPtr)-1L,\n");
+
+								dump_nest(out,3);
+								get_c_name(op,n,sizeof(n));
+								out_printf(out,"(somMethodPtr)(size_t)&somApRdInfo_%s\n",n);
+					}
+
+					out_printf(out,"#else /* SOM_METHOD_STUBS */\n");
+
+					{
+								/* somMethodPtr redispatch */
+
+								dump_nest(out,3);
+								get_c_name(op,n,sizeof(n));
+								out_printf(out,"(somMethodPtr)somRD_%s,\n",n);
+
+								/* somMethodPtr apply */
+
+								dump_nest(out,3);
+								if (op_is_varg(op))
+								{
+									out_printf(out,"(somMethodPtr)NULL\n");
+								}
+								else
+								{
+									get_c_name(op,n,sizeof(n));
+									out_printf(out,"(somMethodPtr)somAP_%s\n",n);
+								}
+					}
+
+					out_printf(out,"#endif /* SOM_METHOD_STUBS */\n");
+
+					dump_nest(out,2);
+
+					out_printf(out,"}");
+
+					x--;
+
+					if (x)
+					{
+						out_printf(out,",\n");
+					}
+					else
+					{
+						out_printf(out,"\n");
+					}
+				}
+			}
+			el=el->next();
+		}
+
+		dump_nest(out,1);
+		out_printf(out,"};\n");
+	}
+
+	if (overrides->length())
+	{
+		unsigned long k=0;
+
+		while (k < overrides->length())
+		{
+			RHBoperation *op=overrides->get(k)->is_operation();
+
+			k++;
+	/* this is not needed for overridden methods */
+	/*		generate_somId(out,nest,op,"somMN","somId",0,0); */
+
+			generate_somId(out,nest,op,"somDS","somDI",0 /*1*/,1);
+		}
+
+		get_c_name(iface,n,sizeof(n));
+		out_printf(out,"static somOverrideMethod_t %sOM[%d]={\n",
+				n,(int)overrides->length());
+
+		k=0;
+
+		while (k < overrides->length())
+		{
+			RHBoperation *op=overrides->get(k)->is_operation();
+
+			k++;
+
+			dump_nest(out,2);
+			out_printf(out,"{\n");
+
+			/* somId *methodId */
+
+			dump_nest(out,3);
+
+			char ii[256];
+			get_c_name(op,ii,sizeof(ii));
+			out_printf(out,"&somDI_%s,\n",ii /*op->id*/);
+
+			/* somMethodPtr method */
+
+			dump_nest(out,3);
+			get_function_prefix(iface,n,sizeof(n));
+			out_printf(out,"(somMethodPtr)%s%s\n",n,op->id);
+
+			dump_nest(out,2);
+			out_printf(out,"}");
+
+			if (k==overrides->length())
+			{
+				out_printf(out,"\n");
+			}
+			else
+			{
+				out_printf(out,",\n");
+			}
+		}
+
+		dump_nest(out,1);
+		out_printf(out,"};\n");
+	}
+	/* somProcMethods_t */
+
+	if (num_procedures)
+	{
+		get_c_name(iface,n,sizeof(n));
+
+		out_printf(out,"static somProcMethods_t %sPM[%d]={\n",
+					n,(int)num_procedures);
+
+		RHBelement *el=iface->children();
+
+		int x=num_procedures;
+
+		while (el)
+		{
+			RHBoperation *op=el->is_operation();
+
+			if (op)
+			{
+				if (is_operation_procedure(op))
+				{
+					dump_nest(out,1);
+
+					get_c_name(iface,n,sizeof(n));
+
+					out_printf(out,"{(somMethodPtr*)(void *)&%sClassData.%s,\n",n,op->id);
+
+					dump_nest(out,2);
+
+					get_function_prefix(iface,n,sizeof(n));
+					out_printf(out,"(somMethodPtr)%s%s}\n",n,op->id);
+
+					x--;
+
+					if (x)
+					{
+						dump_nest(out,1);
+						out_printf(out,",\n");
+					}
+				}
+			}
+
+			el=el->next();
+		}
+
+		dump_nest(out,1);
+		out_printf(out,"};\n");
+	}
+
+	if (internal)
+	{
+		RHBelement_sequence vaops;
+
+		num_va=get_va_operations(iface,&vaops);
+
+		if (num_va)
+		{
+			unsigned long k=0;
+
+			while (k < vaops.length())
+			{
+				RHBoperation *op=vaops.get(k)->is_operation();
+				generate_va_stub(out,iface,op,nest,3,"somVA");
+				k++;
+			}
+
+			k=0;
+
+			get_c_name(iface,n,sizeof(n));
+
+			out_printf(out,"static somVarargsFuncs_t %sVF[%d]={\n",n,num_va);
+
+			while (k < vaops.length())
+			{
+				RHBoperation *op=vaops.get(k)->is_operation();
+
+				out_printf(out,"{&%sCClassData.%s,(somMethodPtr)somVA_%s_%s}",
+							n,op->id,n,op->id);
+
+				if (++k < vaops.length())
+				{
+					out_printf(out,",\n");
+				}
+			}
+
+			out_printf(out,"};\n");
+		}
+
+		if (useAlignmentHelper())
+		{
+			if (iface->instanceData->children())
+			{
+				get_c_name(iface,n,sizeof(n));
+				out_printf(out,"struct _somC_%s_dataAlignment { octet _o; %sData _d; };\n",n,n);
+			}
+		}
+	}
+
+	if (get_cif(iface,n,sizeof(n)))
+	{
+		if (cplusplus)
+		{
+			out_printf(out,"static void SOMLINK %s(SOMClass *);\n",n);
+		}
+		else
+		{
+			out_printf(out,"static void SOMLINK %s(SOMClass SOMSTAR);\n",n);
+		}
+	}
+
+	if (overrides && !is_kernel_class(iface))
+	{
+		long k1=overrides->length();
+
+		while (k1--)
+		{
+			RHBoperation *op=overrides->get(k1)->is_operation();
+
+			if (op)
+			{
+				long k2=iface->_parents.length();
+
+				while (k2--)
+				{
+					RHBinterface *par=iface->_parents.get(k2)->is_interface();
+
+					if (par)
+					{
+						generate_parent_resolved(out,iface,par,op,1);
+					}
+				}
+			}
+		}
+	}
+
+	get_c_name(iface,n,sizeof(n));
+
+	if (cplusplus)
+	{
+		extern_c_proto_t extern_c_proto(this,out,nest);
+		out_printf(out,"static void SOMLINK _somC_%s_classInit(SOMClass *);\n",n);
+	}
+	else
+	{
+		out_printf(out,"static void SOMLINK _somC_%s_classInit(SOMClass SOMSTAR);\n",n);
+	}
+
+	if (init_op_count)
+	{
+		get_c_name(iface,n,sizeof(n));
+		out_printf(out,"static somId somINIT%s[%d]={\n",n,init_op_count);
+
+		int k=0;
+		while (k < init_op_count)
+		{
+			RHBelement *ip=init_entries.get(k);
+
+			out_printf(out,"(somId)&somMN_%s",ip->id);
+
+			k++;
+
+			if (k < init_op_count) 
+			{
+				out_printf(out,",\n");
+			}
+		}
+
+		out_printf(out,"};\n");
+	}
+
+	get_c_name(iface,n,sizeof(n));
+	out_printf(out,"static somStaticClassInfo %sSCI={\n",n);
+
+	/* need to generate ... type 2 information only!!! */
+
+	/* unsigned long layoutVersion */
+
+	out_printf(out,"#ifdef SOMSCIVERSION\n");
+	dump_nest(out,2);
+	out_printf(out,"%d,  /* layoutVersion */\n",3);
+	out_printf(out,"#else /* SOMSCIVERSION */\n");
+	dump_nest(out,2);
+	out_printf(out,"%d,  /* layoutVersion */\n",2);
+	out_printf(out,"#endif /* SOMSCIVERSION */\n");
+
+	/* unsigned long numStaticMethod */
+
+	dump_nest(out,2);
+	out_printf(out,"%d, /* numStaticMethod */\n",num_statics);
+
+	/* unsigned long numStaticOverrides */
+
+	dump_nest(out,2);
+	out_printf(out,"%d, /* numStaticOverrides */\n",(int)overrides->length());
+
+	/* unsigned long numNonInternalData */
+
+	dump_nest(out,2);
+	out_printf(out,"%d, /* numNonInternalData */\n",0);
+
+	/* unsigned long numProcMethods */
+
+	dump_nest(out,2);
+	out_printf(out,"%d, /* numProcMethods */\n",(int)num_procedures);
+
+	/* unsigned long numVarargsFuncs */
+
+	dump_nest(out,2);
+	out_printf(out,"%d, /* numVarargsFuncs */\n",num_va);
+
+	/* unsigned long majorVersion */
+
+	dump_nest(out,2);
+	get_c_name(iface,n,sizeof(n));
+	out_printf(out,"%s_MajorVersion,\n",n);
+
+	/* unsigned long minorVersion */
+
+	dump_nest(out,2);
+	get_c_name(iface,n,sizeof(n));
+	out_printf(out,"%s_MinorVersion,\n",n);
+
+	/* unsigned long instanceDataSize */
+
+	dump_nest(out,2);
+	get_c_name(iface,n,sizeof(n));
+	if (iface->instanceData->children())
+	{
+		out_printf(out,"sizeof(%sData), /* instanceDataSize */\n",n);
+	}
+	else
+	{
+		out_printf(out,"0, /* no instanceDataSize */\n");
+	}
+
+	/* unsigned long maxMethods */
+
+	dump_nest(out,2);
+	out_printf(out,"%d, /* maxMethods */\n",num_statics);
+
+	/* unsigned long numParents */
+
+	dump_nest(out,2);
+	out_printf(out,"%d, /* numParents */\n",
+		(int)iface->_parents.length());
+
+	/* somId classId */
+
+	dump_nest(out,2);
+	get_c_name(iface,n,sizeof(n));
+	out_printf(out,"&somCN_%s,\n",n);
+
+	/* somId explicitMetaId */
+
+	dump_nest(out,2);
+	get_meta_class(iface,n);
+
+	if (n[0])
+	{
+		RHBelement *el2=iface->find_named_element(0,n,sizeof(n));
+
+		get_c_name(el2,n,sizeof(n));
+
+		out_printf(out,"&somMCN_%s,\n",n);
+	}
+	else
+	{
+		out_printf(out,"0,\n");
+	}
+
+	/* long implicitParentMeta */
+
+	dump_nest(out,2);
+	out_printf(out,"0, /* implicitParentMeta */\n");
+
+	/* somId *parents */
+
+	dump_nest(out,2);
+	get_c_name(iface,n,sizeof(n));
+
+	if (iface->_parents.length())
+	{
+		out_printf(out,"somPC%s, /* parents */\n",n);
+	}
+	else
+	{
+		out_printf(out,"0, /* no parents */\n");
+	}
+
+	/* somClassDataStructure *cds */
+
+	dump_nest(out,2);
+	get_c_name(iface,n,sizeof(n));
+	out_printf(out,"(somClassDataStructure *)(void *)&%sClassData,\n",n);
+
+	/* somCClassDataStructure *ccds */
+
+	dump_nest(out,2);
+	get_c_name(iface,n,sizeof(n));
+	out_printf(out,"(somCClassDataStructure *)(void *)&%sCClassData,\n",n);
+
+	/* somStaticMethod_t *smt */
+
+	dump_nest(out,2);
+	get_c_name(iface,n,sizeof(n));
+
+	if (num_statics)
+	{
+		out_printf(out,"%sSM,\n",n);
+	}
+	else
+	{
+		out_printf(out,"0,  /* no new methods */\n");
+	}
+
+	/* somOverrideMethod_t *omt */
+
+	dump_nest(out,2);
+	get_c_name(iface,n,sizeof(n));
+
+	if (overrides->length())
+	{
+		out_printf(out,"%sOM,\n",n);
+	}
+	else
+	{
+		out_printf(out,"0,\n");
+	}
+
+	/* char *nitReferenceBase */
+
+	dump_nest(out,2);
+	get_c_name(iface,n,sizeof(n));
+	out_printf(out,"0, /* nitReferenceBase */\n");
+
+	/* somNonInternalData_t *nit */
+
+	dump_nest(out,2);
+	get_c_name(iface,n,sizeof(n));
+	out_printf(out,"0, /* nit */\n");
+
+	/* somProcMethodFuncs_t *pmt */
+
+	dump_nest(out,2);
+	get_c_name(iface,n,sizeof(n));
+
+	if (num_procedures)
+	{
+		out_printf(out,"%sPM, /* %d procedures */\n",n,(int)num_procedures);
+	}
+	else
+	{
+		out_printf(out,"0, /* pmt no procedures*/\n");
+	}
+
+	/* somVarargsFuncs_t *vft */
+
+	dump_nest(out,2);
+	get_c_name(iface,n,sizeof(n));
+	if (num_va)
+	{
+		out_printf(out,"%sVF, /* vft */\n",n);
+	}
+	else
+	{
+		out_printf(out,"0, /* vft */\n");
+	}
+
+	/* somTP_somClassInitFunc *cif */
+
+	dump_nest(out,2);
+
+#if 0
+	if (get_cif(iface,n))
+	{
+		out_printf(out,"%s, /* cif */\n",n);
+	}
+	else
+	{
+		out_printf(out,"0, /* cif */\n");
+	}
+#else
+	out_printf(out,"_somC_%s_classInit,\n",n);
+#endif
+
+	/* type 2 begin */
+
+	/* long dataAlignment */
+
+	dump_nest(out,2);
+	get_c_name(iface,n,sizeof(n));
+
+	if (iface->instanceData->children())
+	{
+		if (useAlignmentHelper())
+		{
+			out_printf(out,"(int)(size_t)&(((struct _somC_%s_dataAlignment *)0)->_d)\n",
+				n);
+		}
+		else
+		{
+			out_printf(out,"(int)(size_t)&(((struct { octet _o; %sData _d; } *)0)->_d)\n",
+				n);
+		}
+	}
+	else
+	{
+		out_printf(out,"0 /* no dataAlignment */\n");
+	}
+
+	{
+		out_printf(out,"#ifdef SOMSCIVERSION\n");
+
+		dump_nest(out,2); out_printf(out,",");
+		/* this is the new init stuff */
+
+		/* directInitClasses not sure what these are */
+
+		dump_nest(out,2); out_printf(out,"-1L,(somId *)0, /* directInitClasses */\n"); 
+
+		/* numMethods */
+		dump_nest(out,2); out_printf(out,"0,(somMethods_t *)0, /* numMethods */\n"); 
+
+		/* protected data offset */
+		dump_nest(out,2); out_printf(out,"0, /* protected data offset */\n");
+
+		dump_nest(out,2); out_printf(out,"0, /* SOMSCIVERSION */\n");
+
+		/* inherited methods */
+		dump_nest(out,2); out_printf(out,"0,(somInheritedMethod_t *)0, /* inherited methods */\n"); 
+
+		/* numClassData entries */
+
+		/* should be count of class data entries excluding the classObject
+		*/
+
+		int count=count_ClassData(iface);
+
+		dump_nest(out,2); out_printf(out,"%d,(somId *)0, /* class data entries */\n",count); 
+
+		/* numMigratedMethods entries */
+		dump_nest(out,2); out_printf(out,"0,(somMigratedMethod_t *)0, /* migrated methods */\n");
+
+		/* numInitializers entries */
+
+		if (init_op_count)
+		{
+			get_c_name(iface,n,sizeof(n));
+			dump_nest(out,2); out_printf(out,"%d,somINIT%s, /* initializers */\n",
+						init_op_count,n);
+		}
+		else
+		{
+			dump_nest(out,2); out_printf(out,"0,(somId *)0, /* initializers */\n");
+		}
+
+		/* somDTSClass entries */
+		dump_nest(out,2); out_printf(out,"0,(somDynamicSCI *)0, /* DTS */\n");
+
+		out_printf(out,"#endif /* SOMSCIVERSION */\n"); 
+	}
+
+	dump_nest(out,1);
+	out_printf(out,"};\n");
+
+	/* now generate the <xxx>NewClass(integer4,integer4) */
+
+	char meta[256];
+	get_actual_meta_class(iface,meta,sizeof(meta));
+	get_c_name(iface,n,sizeof(n));
+
+	if (cplusplus)
+	{
+		out_printf(out,"%s * SOMLINK %sNewClass(\n",meta,n);
+	}
+	else
+	{
+		out_printf(out,"%s SOMSTAR SOMLINK %sNewClass(\n",meta,n);
+	}
+
+	dump_nest(out,1);
+	out_printf(out,"integer4 somtmajorVersion,integer4 somtminorVersion)\n");
+	out_printf(out,"{\n");
+
+	mask=0;
+
+	if (iface->_parents.length())
+	{
+		unsigned long k=0;
+
+		while (k < iface->_parents.length())
+		{
+			dump_nest(out,1);
+
+			get_c_name(iface->_parents.get(k),n,sizeof(n));
+
+			out_printf(out,"if (!%sNewClass(\n",n,sizeof(n));
+
+			dump_nest(out,2);
+			out_printf(out,"%s_MajorVersion,\n",n,sizeof(n));
+
+			dump_nest(out,2);
+			out_printf(out,"%s_MinorVersion))\n",n,sizeof(n));
+
+			dump_nest(out,1);
+			out_printf(out,"{\n");
+
+			dump_nest(out,2);
+			out_printf(out,"return NULL;\n");
+
+			dump_nest(out,1);
+			out_printf(out,"}\n");
+
+			mask<<=1;
+			mask|=1;
+
+			k++;
+		}
+	}
+
+	n[0]=0;
+	get_meta_class(iface,n);
+	if (n[0])
+	{
+		RHBelement *el=iface->find_named_element(0,n,sizeof(n));
+		if (el)
+		{
+			get_c_name(el,n,sizeof(n));
+
+			dump_nest(out,1);
+			out_printf(out,"if (!%sNewClass(\n",n);
+
+			dump_nest(out,2);
+			out_printf(out,"%s_MajorVersion,\n",n);
+
+			dump_nest(out,2);
+			out_printf(out,"%s_MinorVersion))\n",n);
+
+			dump_nest(out,1);
+			out_printf(out,"{\n");
+
+			dump_nest(out,2);
+			out_printf(out,"return NULL;\n");
+
+			dump_nest(out,1);
+			out_printf(out,"}\n");
+		}
+	}
+
+	meta[0]=0;
+
+	get_actual_meta_class(iface,n,sizeof(n));
+
+	if (strcmp(n,"SOMClass"))
+	{
+		if (cplusplus)
+		{
+			snprintf(meta,sizeof(meta),"(%s *)(void *)",n);
+		}
+		else
+		{
+			snprintf(meta,sizeof(meta),"(%s SOMSTAR)(void *)",n);
+		}
+	}
+
+	get_c_name(iface,n,sizeof(n));
+	dump_nest(out,1);
+
+	out_printf(out,"return %ssomBuildClass(0x%lx,&%sSCI,\n",
+				meta,mask,n);
+
+	dump_nest(out,2);
+	out_printf(out,"somtmajorVersion,\n");
+
+	dump_nest(out,2);
+	out_printf(out,"somtminorVersion);\n");
+
+	if (iface->_parents.length())
+	{
+		if (0)
+		{
+			unsigned long k=0;
+
+			while (k < iface->_parents.length())
+			{
+				dump_nest(out,1);
+				get_c_name(iface->_parents.get(k),n,sizeof(n));
+				out_printf(out,"somReleaseClassReference(%s_classObject);\n",n);
+				k++;
+			}
+		}
+	}
+
+/*	dump_nest(out,1);
+	get_c_name(iface,n);
+	i=sprintf(buf,"return %s_classObject;\n",n);
+	out->write(buf,i);
+*/
+	out_printf(out,"}\n");
+
+	if (cplusplus)
+	{
+		out_printf(out,"static void SOMLINK _somC_%s_classInit(SOMClass *somSelf)\n",n);
+	}
+	else
+	{
+		out_printf(out,"static void SOMLINK _somC_%s_classInit(SOMClass SOMSTAR somSelf)\n",n);
+	}
+
+	out_printf(out,"{\n");
+
+	out_printf(out,"/* do parent resolves... */\n");
+
+	if (overrides && !is_kernel_class(iface))
+	{
+		long k1=overrides->length();
+
+		while (k1--)
+		{
+			RHBoperation *op=overrides->get(k1)->is_operation();
+
+			if (op)
+			{
+				long k2=iface->_parents.length();
+
+				while (k2--)
+				{
+					RHBinterface *par=iface->_parents.get(k2)->is_interface();
+
+					if (par)
+					{
+						generate_parent_resolved(out,iface,par,op,2);
+					}
+				}
+			}
+		}
+	}
+
+	out_printf(out,"/* call classinit if defined... */\n"); 
+
+	if (get_cif(iface,n,sizeof(n)))
+	{
+		out_printf(out,"\t%s(somSelf);\n",n);
+	}
+	else
+	{
+		out_printf(out,"\tSOM_IgnoreWarning(somSelf);\n");
+	}
+
+	out_printf(out,"}\n");
+
+	get_c_name(iface,n,sizeof(n));
+
+	if (strcmp(n,"SOMObject") &&
+		strcmp(n,"SOMClass") &&
+		strcmp(n,"SOMClassMgr"))
+	{
+		generate_internal_class_data(out,iface);
+		generate_internal_cclass_data(out,iface);
+	}
+
+	public_class_data_resolve(out,0,iface,"ClassData");
+	public_class_data_resolve(out,0,iface,"CClassData");
+}
+
+void RHBheader_emitter::public_class_data_resolve(RHBoutput *out,int nest,RHBinterface *iface,const char *dn)
+{
+	char n[256];
+	get_c_name(iface,n,sizeof(n));
+	dump_nest(out,nest);
+	out_printf(out,"#ifdef %s\n",szSOM_RESOLVE_DATA);
+	dump_nest(out,nest+1);
+	out_printf(out,"SOMEXTERN struct %s%sStructure * SOMLINK resolve_%s%s(void)\n",n,dn,n,dn);
+
+	dump_nest(out,nest+1);
+	out_printf(out,"{ return &_%s%s; }\n",n,dn);
+
+	dump_nest(out,nest);
+	out_printf(out,"#endif /* %s */\n",szSOM_RESOLVE_DATA);
+}
+
+
+void RHBheader_emitter::enum_attributes(RHBoutput *out,RHBinterface *iface)
+{
+RHBattribute *attr;
+RHBelement *ch;
+
+	ch=iface->children();
+
+	while (ch)
+	{
+		if (ch->is_type())
+		{
+			attr=ch->is_type()->is_attribute();
+
+			if (attr)
+			{
+				generate_internal_attribute(out,iface,attr);
+			}
+		}
+
+		ch=ch->next();
+	}
+}
+
+void RHBheader_emitter::generate_internal_attribute(RHBoutput *out,RHBinterface *iface,RHBattribute *attr)
+{
+char n[256];
+int do_set=0,do_get=0;
+
+	if (!attr->has_modifier_value("nodata"))
+	{
+		if (!attr->has_modifier_value("noset"))
+		{
+			do_set=1;
+		}
+		if (!attr->has_modifier_value("noget"))
+		{
+			do_get=1;
+		}
+	}
+
+	if (!attr->readonly)
+	{
+		if (do_set)
+		{
+			get_c_name(attr,n,sizeof(n));
+			out_printf(out,"/* set for attribute %s */\n",n);
+			gen_set_attribute(out,iface,attr);
+		}
+		else
+		{
+			attr->build_id(n,sizeof(n));
+			out_printf(out,"/* developer must provide set for attribute %s */\n",n);
+		}
+	}
+
+	if (do_get)
+	{
+		gen_get_attribute(out,iface,attr);
+	}
+	else
+	{
+		attr->build_id(n,sizeof(n));
+		out_printf(out,"/* developer must provide get for attribute %s */\n",n);
+	}
+}
+
+void RHBheader_emitter::gen_set_attribute(RHBoutput *out,RHBinterface *iface,RHBattribute *attr)
+{
+char n[256];
+int by_ref=0;
+RHBtype *by_array=NULL;
+
+	get_c_name(iface,n,sizeof(n));
+
+	out_printf(out,"SOM_Scope void");
+
+	get_function_prefix(iface,n,sizeof(n));
+	out_printf(out," SOMLINK %s",n);
+
+	get_c_name(iface,n,sizeof(n));
+	out_printf(out,"_set_%s(",attr->id);
+
+	use_type(out,iface,"somSelf,");
+
+	if (operation_needs_environment(iface,0))
+	{
+		out_printf(out,"Environment *ev,");
+	}
+
+	{
+		char buf[256];
+		RHBparameter *param;
+		RHBelement *el;
+		snprintf(buf,sizeof(buf),"_set_%s",attr->id);
+		el=iface->find_named_element(0,buf,sizeof(buf));
+		param=el->children()->is_type()->is_parameter();
+		by_ref=parameter_by_reference(param,NULL);
+	}
+
+	by_array=get_array_slice(attr->attribute_type);
+
+	if (by_ref)
+	{
+		use_type(out,attr->attribute_type,0);
+		out_printf(out," *value");
+	}
+	else
+	{
+		use_type(out,attr->attribute_type,"value");
+	}
+
+	out_printf(out,")\n{\n");
+
+	if (by_array)
+	{
+		get_c_name(iface,n,sizeof(n));
+		out_printf(out,"%sData *somThis=%sGetData(somSelf);\n",n,n);
+	}
+
+	if (operation_needs_environment(iface,0))
+	{
+		out_printf(out,"SOM_IgnoreWarning(ev);\n");
+	}
+
+	dump_nest(out,1);
+
+	if (by_array)
+	{
+		out_printf(out,"if (value != somThis->%s)\n"
+					"\tmemcpy(somThis->%s,value,sizeof(somThis->%s));\n",
+					attr->id,attr->id,attr->id);
+	}
+	else
+	{
+		if (by_ref)
+		{
+			out_printf(out,"%sGetData(somSelf)->%s=*value;\n",
+				n,attr->id);
+		}
+		else
+		{
+			out_printf(out,"%sGetData(somSelf)->%s=value;\n",
+				n,attr->id);
+		}
+	}
+
+	out_printf(out,"}\n");
+}
+
+void RHBheader_emitter::gen_get_attribute(RHBoutput *out,RHBinterface *iface,RHBattribute *attr)
+{
+char n[256];
+
+	get_c_name(iface,n,sizeof(n));
+
+	out_printf(out,"SOM_Scope ");
+
+	RHBtype *t=get_array_slice(attr->attribute_type);
+	if (t)
+	{
+		use_type(out,t,0);
+
+		out_printf(out,"* ");
+	}
+	else
+	{
+		use_type(out,attr->attribute_type,0);
+	}
+
+	get_function_prefix(iface,n,sizeof(n));
+	out_printf(out," SOMLINK %s",n);
+
+	get_c_name(iface,n,sizeof(n));
+	out_printf(out,"_get_%s(",attr->id);
+
+	use_type(out,iface,"somSelf");
+
+	if (operation_needs_environment(iface,0))
+	{
+		out_printf(out,",Environment *ev");
+	}
+
+	out_printf(out,")\n{\n");
+
+	if (operation_needs_environment(iface,0))
+	{
+		out_printf(out,"SOM_IgnoreWarning(ev);\n");
+	}
+
+	dump_nest(out,1);
+
+	t=get_array_slice(attr->attribute_type);
+
+	if (t)
+	{
+		int i=0;
+		t=attr->attribute_type;
+		while (t)
+		{
+			t=unwind_typedef(t);
+			if (t->is_array())
+			{
+				t=t->is_array()->array_of;
+				i++;
+			}
+			else
+			{
+				break;
+			}
+		}
+		out_printf(out,"return %sGetData(somSelf)->%s",n,attr->id);
+		if (i) i--;
+		while (i--)
+		{
+			out_printf(out,"[0]");
+		}
+		out_printf(out,";\n");
+	}
+	else
+	{
+		out_printf(out,"return %sGetData(somSelf)->%s;\n",
+			n,attr->id);
+	}
+
+	out_printf(out,"}\n");
+}
+
+void RHBheader_emitter::generate_internal_ctrl_macros(RHBoutput * /*out*/,RHBinterface * /*iface */)
+{
+/*	generate_begininit(out,iface,"somDefaultInit");
+	generate_begininit(out,iface,"somDefaultCopyInit");
+	generate_begininit(out,iface,"somDefaultConstCopyInit");
+	generate_begininit(out,iface,"somDefaultVCopyInit");
+	generate_begininit(out,iface,"somDefaultConstVCopyInit");
+	generate_beginassignop(out,iface);
+	generate_begindestruct(out,iface);
+	generate_enddestruct(out,iface);
+	generate_parent_initdestruct(out,iface);*/
+}
+
+boolean RHBheader_emitter::do_som21_macro(RHBinterface *iface,const char *name)
+{
+	if (iface->_parents.length())
+	{
+		return does_override(iface,name);
+	}
+	else
+	{
+		RHBelement *el;
+		char buf[256];
+		strncpy(buf,name,sizeof(buf));
+		el=iface->find_named_element(0,buf,sizeof(buf));
+		if (!el) return 0;
+		if (!el->is_operation()) return 0;
+	}
+
+	return 1;
+}
+
+boolean RHBheader_emitter::does_override(RHBinterface *iface,const char *name)
+{
+	RHBelement *el;
+	char buf[256];
+
+	strncpy(buf,name,sizeof(buf));
+
+	el=iface->find_named_element(0,buf,sizeof(buf));
+
+	if (el)
+	{
+		if (el->has_modifier_value("override"))
+		{
+			return 1;
+		}
+	}
+
+	strncpy(buf,"override",sizeof(buf));
+	el=iface->find_named_element(0,buf,sizeof(buf));
+	if (el)
+	{
+		if (el->has_modifier_value(name))
+		{
+			return 1;
+		}
+	}
+
+	return 0;
+}
+
+#if 0
+void RHBheader_emitter::generate_begininit(
+			RHBoutput *out,
+			RHBinterface *iface,
+			const char *meth_name)
+{
+	char n[256];
+
+	if (do_som21_macro(iface,meth_name))
+	{
+		get_c_name(iface,n);
+		out_printf(out,"#define %s_BeginInitializer_%s \\\n",n,meth_name);
+
+		dump_nest(out,2);
+		i=sprintf(buf,"if (!ctrl) {\\\n");
+		out->write(buf,i);
+		dump_nest(out,3);
+		i=sprintf(buf,"ctrl = &globalCtrl;\\\n");
+		out->write(buf,i);
+		dump_nest(out,3);
+		i=sprintf(buf,"memcpy(ctrl,&(((somParentMtabStructPtr)(void *)%sCClassData.parentMtab)->initCtrl),sizeof(somInitCtrl));\\\n",n);
+		out->write(buf,i);
+		dump_nest(out,2);
+		i=sprintf(buf,"}\\\n");
+		out->write(buf,i);
+
+		dump_nest(out,2);
+		i=sprintf(buf,"myMask = ctrl->mask;\\\n");
+		out->write(buf,i);
+
+		if (iface->instanceData)
+		{
+			if (iface->instanceData->children())
+			{
+				dump_nest(out,2);
+				i=sprintf(buf,"somThis=(%sData *)((char*)somSelf + ctrl->info->dataOffset);\\\n",n);
+				out->write(buf,i);
+			}
+		}
+
+		dump_nest(out,2);
+		i=sprintf(buf,"ctrl->info = (somInitInfo*)(ctrl->infoSize + (char*)(ctrl->info)); \\\n");
+		out->write(buf,i);
+
+		dump_nest(out,2);
+		i=sprintf(buf,"ctrl->mask += 1;\n");
+		out->write(buf,i);
+	}
+}
+#endif
+
+#if 0
+void RHBheader_emitter::generate_beginassignop(
+			RHBoutput *out,
+			RHBinterface *iface)
+{
+	char buf[256];
+	char n[256];
+	int i;
+
+	get_c_name(iface,n);
+	i=sprintf(buf,"#define %s_BeginAssignmentOp \\\n",n);
+	out->write(buf,i);
+
+	dump_nest(out,2);
+	i=sprintf(buf,"if (!ctrl) {\\\n");
+	out->write(buf,i);
+	dump_nest(out,3);
+	i=sprintf(buf,"ctrl = &globalCtrl;\\\n");
+	out->write(buf,i);
+	dump_nest(out,3);
+	i=sprintf(buf,"memcpy(ctrl,&(((somParentMtabStructPtr)(void *)%sCClassData.parentMtab)->assignCtrl),sizeof(somAssignCtrl));\\\n",n);
+	out->write(buf,i);
+	dump_nest(out,2);
+	i=sprintf(buf,"}\\\n");
+	out->write(buf,i);
+
+
+	dump_nest(out,2);
+	i=sprintf(buf,"myMask = ctrl->mask;\\\n");
+	out->write(buf,i);
+
+	if (iface->instanceData)
+	{
+		if (iface->instanceData->children())
+		{
+			dump_nest(out,2);
+			i=sprintf(buf,"somThis=(%sData *)((char*)somSelf + ctrl->info->dataOffset);\\\n",n);
+			out->write(buf,i);
+		}
+	}
+
+	dump_nest(out,2);
+	i=sprintf(buf,"ctrl->info = (somAssignInfo*)(ctrl->infoSize + (char*)(ctrl->info)); \\\n");
+	out->write(buf,i);
+
+	dump_nest(out,2);
+	i=sprintf(buf,"ctrl->mask += 1;\n");
+	out->write(buf,i);
+}
+#endif
+
+#if 0
+void RHBheader_emitter::generate_begindestruct(
+			RHBoutput *out,
+			RHBinterface *iface)
+{
+	char buf[256];
+	char n[256];
+	int i;
+
+	if (do_som21_macro(iface,"somDestruct"))
+	{
+		get_c_name(iface,n);
+		i=sprintf(buf,"#define %s_BeginDestructor \\\n",n);
+		out->write(buf,i);
+
+		dump_nest(out,2);
+		i=sprintf(buf,"if (!ctrl) {\\\n");
+		out->write(buf,i);
+		dump_nest(out,3);
+		i=sprintf(buf,"ctrl = &globalCtrl;\\\n");
+		out->write(buf,i);
+		dump_nest(out,3);
+		i=sprintf(buf,"memcpy(ctrl,&(((somParentMtabStructPtr)(void *)%sCClassData.parentMtab)->destructCtrl),sizeof(somDestructCtrl));\\\n",n);
+		out->write(buf,i);
+		dump_nest(out,2);
+		i=sprintf(buf,"}\\\n");
+		out->write(buf,i);
+
+		if (iface->instanceData)
+		{
+			if (iface->instanceData->children())
+			{
+				dump_nest(out,2);
+				i=sprintf(buf,"somThis=(%sData *)((char*)somSelf + ctrl->info->dataOffset);\\\n",n);
+				out->write(buf,i);
+			}
+		}
+
+		dump_nest(out,2);
+		i=sprintf(buf,"myMask = ctrl->mask;\n");
+		out->write(buf,i);
+	}
+}
+#endif
+
+#if 0
+void RHBheader_emitter::generate_enddestruct(
+			RHBoutput *out,
+			RHBinterface *iface)
+{
+	char buf[256];
+	char n[256];
+	int i;
+	int j;
+	RHBinterface *par;
+
+	if (do_som21_macro(iface,"somDestruct"))
+	{
+
+		get_c_name(iface,n);
+		i=sprintf(buf,"#define %s_EndDestructor \\\n",n);
+		out->write(buf,i);
+
+		dump_nest(out,2);
+		i=sprintf(buf,"ctrl->info = (somDestructInfo*)(ctrl->infoSize + (char*)(ctrl->info)); \\\n");
+		out->write(buf,i);
+		dump_nest(out,2);
+		i=sprintf(buf,"ctrl->mask += 1; \\\n");
+		out->write(buf,i);
+
+		j=0;
+
+		while (j < iface->_parents.length())
+		{
+			char m[256];
+
+			par=iface->_parents.get(j)->is_type()->is_interface();
+
+			dump_nest(out,2);
+			get_c_name(par,m);
+
+			i=sprintf(buf,"%s_DeInit_%s_somDestruct(somSelf,0,ctrl);\\\n",n,m);
+			out->write(buf,i);
+			j++;
+		}
+
+		dump_nest(out,2);
+		i=sprintf(buf,"if (doFree) SOMClass_somDeallocate(%sClassData.classObject, (string)somSelf);\n",n);
+		out->write(buf,i);
+	}
+}
+#endif
+
+#if 0
+void RHBheader_emitter::generate_parent_initdestruct(
+			RHBoutput *out,
+			RHBinterface *iface)
+{
+	RHBinterface *par;
+	int i;
+	char n[256];
+	char buf[256];
+	int j;
+
+	j=0;
+
+	while (j < iface->_parents.length())
+	{
+		par=iface->_parents.get(j)->is_type()->is_interface();
+
+		/* creator */
+
+		if (do_som21_macro(iface,"somDefaultInit"))
+		{
+			get_c_name(iface,n);
+
+			i=sprintf(buf,"#define %s_Init_",n);
+			out->write(buf,i);
+
+			get_c_name(par,n);
+
+			i=sprintf(buf,"%s_somDefaultInit(somSelf,ctrl) \\\n",n);
+			out->write(buf,i);
+
+			dump_nest(out,2);
+
+			i=sprintf(buf,"if (myMask[0]&1) \\\n");
+			out->write(buf,i);
+
+			dump_nest(out,3);
+
+			i=sprintf(buf,"((somTD_SOMObject_somDefaultInit)\\\n");
+			out->write(buf,i);
+
+			dump_nest(out,4);
+
+			i=sprintf(buf,"ctrl->info->defaultInit)\\\n");
+			out->write(buf,i);
+
+			dump_nest(out,5);
+
+			i=sprintf(buf,"(somSelf,ctrl)\n");
+			out->write(buf,i);
+		}
+
+		/* copy creator */
+
+		if (do_som21_macro(iface,"somDefaultCopyInit"))
+		{
+			get_c_name(iface,n);
+
+			i=sprintf(buf,"#define %s_Init_",n);
+			out->write(buf,i);
+
+			get_c_name(par,n);
+
+			i=sprintf(buf,"%s_somDefaultCopyInit(somSelf,ctrl,fromObj) \\\n",n);
+			out->write(buf,i);
+
+			dump_nest(out,2);
+
+			i=sprintf(buf,"if (myMask[0]&1) \\\n");
+			out->write(buf,i);
+
+			dump_nest(out,3);
+
+			i=sprintf(buf,"((somTD_SOMObject_somDefaultCopyInit)\\\n");
+			out->write(buf,i);
+
+			dump_nest(out,4);
+
+			i=sprintf(buf,"ctrl->info->defaultCopyInit)\\\n");
+			out->write(buf,i);
+
+			dump_nest(out,5);
+
+			i=sprintf(buf,"(somSelf,ctrl,fromObj)\n");
+			out->write(buf,i);
+		}
+
+		/* const copy creator */
+
+		if (do_som21_macro(iface,"somDefaultConstCopyInit"))
+		{
+			get_c_name(iface,n);
+
+			i=sprintf(buf,"#define %s_Init_",n);
+			out->write(buf,i);
+
+			get_c_name(par,n);
+
+			i=sprintf(buf,"%s_somDefaultConstCopyInit(somSelf,ctrl,fromObj) \\\n",n);
+			out->write(buf,i);
+
+			dump_nest(out,2);
+
+			i=sprintf(buf,"if (myMask[0]&1) \\\n");
+			out->write(buf,i);
+
+			dump_nest(out,3);
+
+			i=sprintf(buf,"((somTD_SOMObject_somDefaultConstCopyInit)\\\n");
+			out->write(buf,i);
+
+			dump_nest(out,4);
+
+			i=sprintf(buf,"ctrl->info->defaultConstCopyInit)\\\n");
+			out->write(buf,i);
+
+			dump_nest(out,5);
+
+			i=sprintf(buf,"(somSelf,ctrl,fromObj)\n");
+			out->write(buf,i);
+		}
+
+		/* volatile copy creator */
+
+		if (do_som21_macro(iface,"somDefaultVCopyInit"))
+		{
+			get_c_name(iface,n);
+
+			i=sprintf(buf,"#define %s_Init_",n);
+			out->write(buf,i);
+
+			get_c_name(par,n);
+
+			i=sprintf(buf,"%s_somDefaultVCopyInit(somSelf,ctrl,fromObj) \\\n",n);
+			out->write(buf,i);
+
+			dump_nest(out,2);
+
+			i=sprintf(buf,"if (myMask[0]&1) \\\n");
+			out->write(buf,i);
+
+			dump_nest(out,3);
+
+			i=sprintf(buf,"((somTD_SOMObject_somDefaultVCopyInit)\\\n");
+			out->write(buf,i);
+
+			dump_nest(out,4);
+
+			i=sprintf(buf,"ctrl->info->defaultCopyInit)\\\n");
+			out->write(buf,i);
+
+			dump_nest(out,5);
+
+			i=sprintf(buf,"(somSelf,ctrl,fromObj)\n");
+			out->write(buf,i);
+		}
+
+
+		/* volatile const copy creator */
+
+		if (do_som21_macro(iface,"somDefaultConstVCopyInit"))
+		{
+			get_c_name(iface,n);
+
+			i=sprintf(buf,"#define %s_Init_",n);
+			out->write(buf,i);
+
+			get_c_name(par,n);
+
+			i=sprintf(buf,"%s_somDefaultConstVCopyInit(somSelf,ctrl,fromObj) \\\n",n);
+			out->write(buf,i);
+
+			dump_nest(out,2);
+
+			i=sprintf(buf,"if (myMask[0]&1) \\\n");
+			out->write(buf,i);
+
+			dump_nest(out,3);
+
+			i=sprintf(buf,"((somTD_SOMObject_somDefaultConstVCopyInit)\\\n");
+			out->write(buf,i);
+
+			dump_nest(out,4);
+
+			i=sprintf(buf,"ctrl->info->defaultConstCopyInit)\\\n");
+			out->write(buf,i);
+
+			dump_nest(out,5);
+
+			i=sprintf(buf,"(somSelf,ctrl,fromObj)\n");
+			out->write(buf,i);
+		}
+		
+		/* assignment */
+
+		if (do_som21_macro(iface,"somDefaultAssign"))
+		{
+			get_c_name(iface,n);
+
+			i=sprintf(buf,"#define %s_Assign_",n);
+			out->write(buf,i);
+
+			get_c_name(par,n);
+
+			i=sprintf(buf,"%s_somDefaultAssign(somSelf,ctrl,fromObj) \\\n",n);
+			out->write(buf,i);
+
+			dump_nest(out,2);
+
+			i=sprintf(buf,"if (myMask[0]&1) \\\n");
+			out->write(buf,i);
+
+			dump_nest(out,3);
+
+			i=sprintf(buf,"((somTD_SOMObject_somDefaultAssign)\\\n");
+			out->write(buf,i);
+
+			dump_nest(out,4);
+
+			i=sprintf(buf,"ctrl->info->defaultAssign)\\\n");
+			out->write(buf,i);
+
+			dump_nest(out,5);
+
+			i=sprintf(buf,"(somSelf,ctrl,fromObj)\n");
+			out->write(buf,i);
+		}
+
+		/* volatile assignment */
+
+		if (do_som21_macro(iface,"somDefaultVAssign"))
+		{
+			get_c_name(iface,n);
+
+			i=sprintf(buf,"#define %s_Assign_",n);
+			out->write(buf,i);
+
+			get_c_name(par,n);
+
+			i=sprintf(buf,"%s_somDefaultVAssign(somSelf,ctrl,fromObj) \\\n",n);
+			out->write(buf,i);
+
+			dump_nest(out,2);
+
+			i=sprintf(buf,"if (myMask[0]&1) \\\n");
+			out->write(buf,i);
+
+			dump_nest(out,3);
+
+			i=sprintf(buf,"((somTD_SOMObject_somDefaultVAssign)\\\n");
+			out->write(buf,i);
+
+			dump_nest(out,4);
+
+			i=sprintf(buf,"ctrl->info->defaultAssign)\\\n");
+			out->write(buf,i);
+
+			dump_nest(out,5);
+
+			i=sprintf(buf,"(somSelf,ctrl,fromObj)\n");
+			out->write(buf,i);
+		}
+
+		/* const assignment */
+
+		if (do_som21_macro(iface,"somDefaultConstAssign"))
+		{
+			get_c_name(iface,n);
+
+			i=sprintf(buf,"#define %s_Assign_",n);
+			out->write(buf,i);
+
+			get_c_name(par,n);
+
+			i=sprintf(buf,"%s_somDefaultConstAssign(somSelf,ctrl,fromObj) \\\n",n);
+			out->write(buf,i);
+
+			dump_nest(out,2);
+
+			i=sprintf(buf,"if (myMask[0]&1) \\\n");
+			out->write(buf,i);
+
+			dump_nest(out,3);
+
+			i=sprintf(buf,"((somTD_SOMObject_somDefaultConstAssign)\\\n");
+			out->write(buf,i);
+
+			dump_nest(out,4);
+
+			i=sprintf(buf,"ctrl->info->defaultConstAssign)\\\n");
+			out->write(buf,i);
+
+			dump_nest(out,5);
+
+			i=sprintf(buf,"(somSelf,ctrl,fromObj)\n");
+			out->write(buf,i);
+		}
+
+		/* volatile const assignment */
+
+		if (do_som21_macro(iface,"somDefaultConstVAssign"))
+		{
+			get_c_name(iface,n);
+
+			i=sprintf(buf,"#define %s_Assign_",n);
+			out->write(buf,i);
+
+			get_c_name(par,n);
+
+			i=sprintf(buf,"%s_somDefaultConstVAssign(somSelf,ctrl,fromObj) \\\n",n);
+			out->write(buf,i);
+
+			dump_nest(out,2);
+
+			i=sprintf(buf,"if (myMask[0]&1) \\\n");
+			out->write(buf,i);
+
+			dump_nest(out,3);
+
+			i=sprintf(buf,"((somTD_SOMObject_somDefaultConstVAssign)\\\n");
+			out->write(buf,i);
+
+			dump_nest(out,4);
+
+			i=sprintf(buf,"ctrl->info->defaultConstAssign)\\\n");
+			out->write(buf,i);
+
+			dump_nest(out,5);
+
+			i=sprintf(buf,"(somSelf,ctrl,fromObj)\n");
+			out->write(buf,i);
+		}
+
+		/* destructor */
+
+		if (do_som21_macro(iface,"somDestruct"))
+		{
+			get_c_name(iface,n);
+
+			i=sprintf(buf,"#define %s_DeInit_",n);
+			out->write(buf,i);
+
+			get_c_name(par,n);
+
+			i=sprintf(buf,"%s_somDestruct(somSelf,doFree,ctrl) \\\n",n);
+			out->write(buf,i);
+
+			dump_nest(out,2);
+
+			i=sprintf(buf,"if (myMask[0]&1) \\\n");
+			out->write(buf,i);
+
+			dump_nest(out,3);
+
+			i=sprintf(buf,"((somTD_SOMObject_somDestruct)\\\n");
+			out->write(buf,i);
+
+			dump_nest(out,4);
+
+			i=sprintf(buf,"ctrl->info->defaultDestruct)\\\n");
+			out->write(buf,i);
+
+			dump_nest(out,5);
+
+			i=sprintf(buf,"(somSelf,0,ctrl)\n");
+			out->write(buf,i);
+		}
+
+		j++;
+	}
+}
+#endif
+
+void RHBheader_emitter::generate_internal_cclass_data(RHBoutput *out,RHBinterface *iface)
+{
+	char n[256];
+	RHBelement_sequence vaops;
+	int numva=get_va_operations(iface,&vaops);
+
+	get_c_name(iface,n,sizeof(n));
+	out_printf(out,"struct %sCClassDataStructure SOMDLINK %sCClassData",n,n);
+
+	if (numva)
+	{
+		out_printf(out,"={(somMethodTabs)0,(somDToken)0\n");
+	
+		numva=0;
+
+		while (numva < (int)vaops.length())
+		{
+			RHBoperation *op=vaops.get(numva)->is_operation();
+
+			out_printf(out,",(somMethodPtr)somVA_%s_%s\n",n,op->id);
+
+			numva++;
+		}
+
+		out_printf(out,"}");
+	}
+
+	out_printf(out,";\n");
+}
+
+void RHBheader_emitter::generate_internal_class_data(RHBoutput *out,RHBinterface *iface)
+{
+	char n[256];
+	RHBelement *el;
+
+	get_c_name(iface,n,sizeof(n));
+	out_printf(out,"struct %sClassDataStructure SOMDLINK %sClassData={\n",n,n);
+
+	el=iface->classData->children();
+
+	while (el)
+	{
+		char val_done=0;
+
+		dump_nest(out,1);
+
+		out_printf(out,"/* %s */ ",el->id);
+
+		if (strcmp(/*buf*/el->id,"classObject"))
+		{
+			RHBelement *e2=iface->children();
+
+			while (e2)
+			{
+				if (0==strcmp(e2->id,el->id))
+				{
+					RHBoperation *op=e2->is_operation();
+
+					if (op)
+					{
+						if (is_operation_procedure(op))
+						{
+					/*		get_c_name(op,n);
+
+							i=sprintf(buf,"\n");
+							out->write(buf,i);
+							dump_nest(out,2);*/
+
+					/*		i=sprintf(buf,"(somTD_%s)\n",n);
+							out->write(buf,i);
+							dump_nest(out,3);*/
+
+							get_function_prefix(iface,n,sizeof(n));
+
+							out_printf(out,"%s%s",n,op->id);
+
+							val_done=1;
+
+							e2=0;
+						}
+					}
+				}
+
+				if (e2)
+				{
+					e2=e2->next();
+				}
+			}
+		}
+
+
+		if (!val_done)
+		{
+			out_printf(out,"0");
+		}
+
+		el=el->next();
+
+		if (el)
+		{
+			out_printf(out,",\n");
+		}
+	}
+
+	out_printf(out,"};\n");
+}
+
+void RHBheader_emitter::generate_somId(RHBoutput *out,int nest,
+		RHBelement *el,
+		const char *strPrefix,
+		const char *idPrefix,
+		boolean ir_spec,boolean recurse)
+{
+	char str[256];
+	char var[256];
+
+#ifdef _WIN32
+	#ifdef _DEBUG
+		if (ir_spec) bomb("emitting somId for IR");
+	#endif
+#endif
+
+	if (recurse)
+	{
+		get_ir_name(el,str,sizeof(str));
+
+		if (!ir_spec)
+		{
+			char *p=str;
+
+			if (0==memcmp("::",p,2))
+			{
+				while (p[2])
+				{
+					*p=p[2];
+					p++;
+				}
+
+				*p=0;
+			}
+		}
+	}
+	else
+	{
+		strncpy(str,el->id,sizeof(str));
+	}
+
+	if (recurse)
+	{
+		get_c_name(el,var,sizeof(var));
+	}
+	else
+	{
+		strncpy(var,el->id,sizeof(var));
+	}
+
+	{
+		char strName[256];
+
+		snprintf(strName,sizeof(strName),"%s_%s",strPrefix,var);
+
+		begin_generate_static(out,strName,nest);
+		undoublebar(out,strName);
+		dump_nest(out,nest+1);
+
+		out_printf(out,"static const char * %s=",strName);
+		out_printf(out,"%c%s%c;\n",double_quote,str,double_quote);
+		
+		end_generate_static(out,strName,nest);
+	}
+
+	if (idPrefix)
+	{
+		if (*idPrefix)
+		{
+			char idName[256];
+			snprintf(idName,sizeof(idName),"%s_%s",idPrefix,var);
+			begin_generate_static(out,idName,nest);
+			undoublebar(out,idName);
+			dump_nest(out,nest+1);
+			out_printf(out,"static const somConstId %s=",idName);
+			out_printf(out,"&%s_%s;\n",strPrefix,var);
+
+			end_generate_static(out,idName,nest);
+		}
+	}
+}
+
+void RHBheader_emitter::begin_generate_static(RHBoutput *out,const char *name,int nest)
+{
+	dump_nest(out,nest);
+	out_printf(out,"#ifndef static_%s\n",name);
+
+	dump_nest(out,nest+1);
+	out_printf(out,"#define static_%s\n",name);
+}
+
+void RHBheader_emitter::end_generate_static(RHBoutput *out,const char *name,int nest)
+{
+	dump_nest(out,nest);
+	out_printf(out,"#endif /* static_%s */\n",name);
+}
+
+
+void RHBheader_emitter::generate_somTDs(RHBoutput *out,RHBinterface *iface,int nest)
+{
+	RHBelement *e=iface->children();
+
+	while (e)
+	{
+		RHBoperation *op=e->is_operation();
+
+		if (op)
+		{
+			generate_somTD(out,iface,op,nest);
+		}
+
+		e=e->next();
+	}
+
+	if (cplusplus)
+	{
+		RHBelement_sequence seq;
+		unsigned long i=0;
+
+		determine_inherited(iface,iface,&seq);
+
+		while (i < seq.length())
+		{
+			RHBoperation *op=seq.get(i)->is_operation();
+			generate_somTD(out,iface,op,nest);
+			i++;
+		}
+	}
+}
+
+
+RHBtype *RHBheader_emitter::generate_array_slice_typedef(
+	RHBoutput *out,int nest,RHBtype *t,const char *n)
+{
+	t=unwind_typedef(t);
+	RHBarray *td=t->is_array();
+	t=td->array_of;
+
+	dump_nest(out,nest);
+	out_printf(out,"typedef ");
+	use_type(out,t,n);
+	out_printf(out,";\n");
+
+	return t;
+}
+
+RHBtype *RHBheader_emitter::get_array_slice(RHBtype *t)
+{
+	RHBtype *slice=NULL;
+
+	while (t)
+	{
+		if (t->is_typedef())
+		{
+			t=t->is_typedef()->alias_for;
+		}
+		else
+		{
+			RHBarray *array=t->is_array();
+
+			if (array)
+			{
+				t=array->array_of;
+
+				slice=t;
+			}
+			else
+			{
+				break;
+			}
+		}
+	}
+
+	return slice;
+}
+
+void RHBheader_emitter::generate_somTD(RHBoutput *out,RHBinterface *iface,RHBoperation *op,int nest)
+{
+	extern_c_proto_t ext_c_proto(this,out,nest);
+	char somTD_name[256];
+	char somTP_name[256];
+
+	{
+		char buf[256];
+		get_c_name(iface,buf,sizeof(buf));
+		strncpy(somTP_name,"somTP_",sizeof(somTP_name));
+		strncat(somTP_name,buf,sizeof(somTP_name));
+		strncat(somTP_name,"_",sizeof(somTP_name));
+		strncat(somTP_name,op->id,sizeof(somTP_name));
+	}
+
+	{
+		char buf[256];
+		get_c_name(iface,buf,sizeof(buf));
+		strncpy(somTD_name,"somTD_",sizeof(somTD_name));
+		strncat(somTD_name,buf,sizeof(somTD_name));
+		strncat(somTD_name,"_",sizeof(somTD_name));
+		strncat(somTD_name,op->id,sizeof(somTD_name));
+	}
+
+	dump_nest(out,nest);
+	out_printf(out,"#ifdef __IBMC__\n");
+
+	undoublebar(out,somTD_name);
+	undoublebar(out,somTP_name);
+
+	dump_nest(out,nest+1);
+	out_printf(out,"typedef ");
+
+	RHBtype *t=op->return_type;
+
+	if (t)
+	{
+		RHBtype *slice=get_array_slice(t);
+
+		if (slice)
+		{
+			use_type(out,slice,0);
+			out->write("*",1);
+		}
+		else
+		{
+			use_type(out,t,0);
+		}
+	}
+	else
+	{
+		out_printf(out,"void ");
+	}
+
+	out_printf(out,"(%s)",somTP_name);
+	generate_parameter_list(out,iface,op,nest+1,1,0);
+	out_printf(out,";\n");
+
+	dump_nest(out,nest+1);
+	out_printf(out,"#pragma linkage(%s,system)\n",somTP_name);
+
+	dump_nest(out,nest+1);
+
+	out_printf(out,"typedef %s *%s;\n",somTP_name,somTD_name);
+
+	dump_nest(out,nest);
+	out_printf(out,"#else /* __IBMC__ */\n");
+
+	undoublebar(out,somTD_name);
+
+	dump_nest(out,nest+1);
+
+	out_printf(out,"typedef ");
+
+	t=op->return_type;
+	if (t)
+	{
+		RHBtype *slice=get_array_slice(t);
+
+		if (slice)
+		{
+			use_type(out,slice,0);
+			out->write("*",1);
+		}
+		else
+		{
+			use_type(out,t,0);
+		}
+	}
+	else
+	{
+		out_printf(out,"void ");
+	}
+
+	out_printf(out,"(SOMLINK * %s)",somTD_name);
+
+	generate_parameter_list(out,iface,op,nest+1,1,0);
+	out_printf(out,";\n");
+
+	dump_nest(out,nest);
+	out_printf(out,"#endif /* __IBMC__ */\n");
+}
+
+void RHBheader_emitter::generate_parameter_list(
+		RHBoutput *out,
+		RHBinterface *iface,
+		RHBoperation *op,
+		int nesting,
+		boolean include_somSelf,
+		boolean do_const_in)
+{
+	RHBelement *e;
+	boolean first_param=1;
+
+	out_printf(out,"(\n");
+
+	dump_nest(out,nesting+1);
+
+	if (is_operation_noself(op))
+	{
+		include_somSelf=0;
+	}
+
+	if (include_somSelf)
+	{
+		first_param=0;
+
+		if (do_const_in) 
+		{
+			out_printf(out,"const ");
+		}
+
+		use_type(out,iface,"somSelf");
+	}
+
+	if (operation_needs_environment(iface,op))
+	{
+		if (first_param)
+		{
+			first_param=0;
+		}
+		else
+		{
+			out_printf(out,",\n");
+			dump_nest(out,nesting+1);
+		}
+
+		out_printf(out,"Environment *ev");
+	}
+
+	if (operation_needs_context(iface,op))
+	{
+		if (first_param)
+		{
+			first_param=0;
+		}
+		else
+		{
+			out_printf(out,",\n");
+			dump_nest(out,nesting+1);
+		}
+
+		if (do_const_in)
+		{
+			out_printf(out,"const ");
+		}
+
+		if (cplusplus)
+		{
+			out_printf(out,"Context * ctx");
+		}
+		else
+		{
+			out_printf(out,"Context SOMSTAR ctx");
+		}
+	}
+
+	e=op->children();
+
+	while (e)
+	{
+		RHBparameter *param=e->is_parameter();
+
+		if (param)
+		{
+			RHBtype *type=NULL;
+			int by_ref;
+
+			if (first_param)
+			{
+				first_param=0;
+			}
+			else
+			{
+				out_printf(out,",\n");
+				dump_nest(out,nesting+1);
+			}
+
+			out_printf(out,"/* %s */ ",param->mode);
+
+			by_ref=parameter_by_reference(param,NULL /* &type */);
+
+			if (do_const_in && do_const_param(param))
+			{
+				out_printf(out,"const ");
+			}
+
+			if (!type) type=param->parameter_type;
+
+			use_type(out,type,0);
+
+			if (by_ref)
+			{
+				out_printf(out,"*");
+			}
+
+			out_printf(out,"%s",param->id);
+		}
+
+		e=e->next();
+	}
+
+	out_printf(out,")");
+}
+
+boolean RHBheader_emitter::operation_needs_environment(
+		RHBinterface *iface,
+		RHBoperation *op)
+{
+	RHBelement *e;
+	const char *p;
+	char buf[256];
+	strncpy(buf,"callstyle",sizeof(buf));
+
+	if (op)
+	{
+		if (iface != op->parent())
+		{
+			if (op->parent()->is_interface())
+			{
+				iface=op->parent()->is_interface();
+			}
+		}
+	}
+
+	e=iface->find_named_element(0,buf,sizeof(buf));
+	if (!e) return 1;
+	p=e->modifier_data.get(0);
+
+	if (!p) return 1;
+
+	if (strcmp(p,"oidl")) return 1;
+
+	return 0;
+}
+
+boolean RHBheader_emitter::parameter_by_reference(RHBparameter *param,RHBtype **array_of)
+{
+	RHBtype *t=param->parameter_type;
+
+	if (strcmp(param->mode,"in")) 
+	{
+		while (t)
+		{
+			if (t->is_array())
+			{
+				/* special case, an array is already a pointer of
+					sorts */
+
+				if (array_of)
+				{
+					*array_of=t->is_array()->array_of;
+
+					return 1;
+				}
+
+				return 0;
+			}
+
+			if (t->is_typedef())
+			{
+				t=t->is_typedef()->alias_for;
+			}
+			else
+			{
+				break;
+			}
+		}
+
+		return 1;
+	}
+
+	while (t)
+	{
+		if (t->is_base_type()) 
+		{
+			return t->is_base_type()->_in_by_ref;
+		}
+
+		if (t->is_interface()) return 0;
+		if (t->is_enum()) return 0;
+		if (t->is_pointer()) return 0;
+		if (t->is_string()) return 0;
+		if (t->is_array()) 
+		{
+			if (array_of)
+			{
+				*array_of=t->is_array()->array_of;
+
+				return 1;
+			}
+
+			return 0;
+		}
+
+		if (t->is_sequence()) return 1;
+
+		if (0==strcmp(t->id,"somId"))
+		{
+			return 0;
+		}
+
+		if (0==strcmp(t->id,"va_list"))
+		{
+			return 0;
+		}
+
+		if (0==strcmp(t->id,"somToken"))
+		{
+			return 0;
+		}
+
+		if (t->is_typedef())
+		{
+			t=t->is_typedef()->alias_for;
+		}
+		else
+		{
+			if (t->is_qualified())
+			{
+				t=t->is_qualified()->base_type;
+			}
+			else
+			{
+				t=0;
+			}
+		}
+	}
+
+	return 1;
+}
+
+boolean RHBheader_emitter::operation_needs_context(
+		RHBinterface * /*iface*/,
+		RHBoperation *op)
+{
+	if (op->context_list.length()) return 1;
+
+	return 0;
+}
+
+void RHBheader_emitter::least_ambiguous_interface(RHBinterface *iface,const char *iface_name,char *buf,size_t buflen)
+{
+	buf[0]=0;
+
+	if (cplusplus)
+	{
+		if (iface)
+		{
+/*			int i;
+
+			i=iface->_parents.length();
+
+			if (i)
+			{
+				char n[256];
+				RHBinterface *par;
+
+				par=iface->_parents.get(0)->is_interface();
+
+				get_c_name(par,n);
+
+				if (strcmp(n,iface_name))
+				{
+					if (i > 1)
+					{
+						char *p;
+						p=&buf[strlen(buf)];
+						i=sprintf(p,"(%s *)",n);
+						buf=p+i;
+					}
+
+					least_ambiguous_interface(par,n,buf);
+				}
+			}*/
+
+			snprintf(buf,buflen,"(%s *)(void *)",iface_name);
+		}
+	}
+}
+
+void RHBheader_emitter::generate_inline_operation(RHBoutput *out,RHBinterface *iface,RHBoperation *op,int nest)
+{
+	char n[1024];
+	RHBelement *el;
+	boolean is_proc,any_params,is_noself;
+	const char *somSelf;
+	
+	is_noself=is_operation_noself(op);
+	is_proc=is_operation_procedure(op);
+
+	if (is_proc)
+	{
+		somSelf="this";
+	}
+	else
+	{
+		somSelf="this";
+	}
+
+	dump_nest(out,nest+1);
+
+	out_printf(out,"inline ");
+
+	if (is_noself)
+	{
+		out_printf(out,"static ");
+	}
+
+	if (op->return_type)
+	{
+		RHBtype *slice=get_array_slice(op->return_type);
+		if (slice)
+		{
+			use_type(out,slice,0);
+			out_printf(out,"* ");
+		}
+		else
+		{
+			use_type(out,op->return_type,0);
+		}
+	}
+	else
+	{
+		out_printf(out,"void ");
+	}
+
+	if (op_is_varg(op))
+	{
+		char buf[256];
+		get_c_name(op,buf,sizeof(buf));
+		out_printf(out,"%s",buf);
+	}
+	else
+	{
+		out_printf(out,"%s",op->id);
+	}
+
+	generate_parameter_list(out,iface,op,2,0,1);
+
+	out_printf(out,"\n");
+
+	dump_nest(out,nest+1);
+	out_printf(out,"{\n");
+
+	dump_nest(out,nest+2);
+
+	if (operation_has_return(op))
+	{
+		out_printf(out,"return ");
+	}
+
+	if (is_proc)
+	{
+/*		get_c_name(iface,n);*/
+		get_c_name(op->parent(),n,sizeof(n));
+		out_printf(out,"%sClassData.%s\n",n,op->id);
+	}
+	else
+	{
+		get_c_name(iface,n,sizeof(n));
+
+		get_c_name(op->parent(),n,sizeof(n));
+		out_printf(out,"SOM_Resolve((void *)%s,%s,%s)\n",
+						somSelf,n,op->id);
+	}
+
+	dump_nest(out,nest+4);
+
+	if (is_noself)
+	{
+		out_printf(out,"(");
+		any_params=0;
+	}
+	else
+	{
+		get_c_name(op->parent(),n,sizeof(n));
+		out_printf(out,"((%s *)(void *)%s",n,somSelf);
+		any_params=1;
+	}
+
+	if (operation_needs_environment(iface,op))
+	{
+		if (any_params)
+		{
+			out_printf(out,",");
+		}
+		else
+		{
+			any_params=1;
+		}
+		out_printf(out,"ev");
+	}
+
+	if (operation_needs_context(iface,op))
+	{
+		if (any_params)
+		{
+			out_printf(out,",");
+		}
+		else
+		{
+			any_params=1;
+		}
+		out_printf(out,"(Context *)ctx");
+	}
+
+	el=op->children();
+
+	while (el)
+	{
+		RHBparameter *param=el->is_parameter();
+
+		if (param)
+		{
+			if (any_params)
+			{
+				out_printf(out,",");
+			}
+			else
+			{
+				any_params=1;
+			}
+
+			if (do_const_param(param))
+			{
+				RHBtype *array_of=NULL;
+				out_printf(out,"(");
+
+				if (parameter_by_reference(param,&array_of))
+				{
+					if (array_of)
+					{
+						use_type(out,array_of,NULL);
+					}
+					else
+					{
+						use_type(out,param->parameter_type,NULL);
+					}
+
+					out_printf(out," *");
+				}
+				else
+				{
+					use_type(out,param->parameter_type,NULL);
+				}
+
+				out_printf(out,")");
+			}
+
+			out_printf(out,"%s",param->id);
+		}
+
+		el=el->next();
+	}
+
+	out_printf(out,");\n");
+
+	dump_nest(out,nest+1);
+	out_printf(out,"};\n");
+
+	if (op_is_varg(op))
+	{
+		generate_inline_varg_operation(out,iface,op,nest+1);
+	}
+}
+
+boolean RHBheader_emitter::operation_has_return(RHBoperation *op)
+{
+	if (op->return_type)
+	{	
+		char buf[256];
+
+		get_c_name(op->return_type,buf,sizeof(buf));
+
+		if (strcmp(buf,"void")) return 1;
+	}
+
+	return 0;
+}
+
+void RHBheader_emitter::generate_macro_operation(RHBoutput *out,RHBinterface *iface,RHBoperation *op,int nest)
+{
+	char n[256];
+	RHBelement *el;
+
+	get_c_name(op,n,sizeof(n));
+
+	dump_nest(out,nest);
+	out_printf(out,"#ifndef %s\n",n);
+
+	if (is_operation_procedure(op))
+	{
+		dump_nest(out,nest+1);
+		out_printf(out,"#define %s ",n);
+		get_c_name(iface,n,sizeof(n));
+		out_printf(out,"%sClassData.%s\n",n,op->id);
+	}
+	else
+	{
+		dump_nest(out,nest+1);
+		out_printf(out,"#define %s(somSelf",n);
+
+		if (operation_needs_environment(iface,op))
+		{
+			out_printf(out,",ev");
+		}
+
+		if (operation_needs_context(iface,op))
+		{
+			out_printf(out,",ctx");
+		}
+
+		el=op->children();
+
+		while (el)
+		{
+			RHBparameter *param=el->is_parameter();
+
+			if (param)
+			{
+				out_printf(out,",%s",param->id);
+			}
+
+			el=el->next();
+		}
+
+		out_printf(out,") \\\n");
+
+		dump_nest(out,nest+2);
+
+/*		i=sprintf(buf,"((somTD_%s)somResolve(somSelf,",n);
+		out->write(buf,i);
+		get_c_name(iface,n);
+		i=sprintf(buf,"%sClassData.%s)) \\\n",
+				n,op->id);
+*/
+		get_c_name(iface,n,sizeof(n));
+		out_printf(out,"SOM_Resolve(somSelf,%s,%s)  \\\n",
+					n,op->id);
+
+		dump_nest(out,nest+3);
+		out_printf(out,"(somSelf");
+
+		if (operation_needs_environment(iface,op))
+		{
+			out_printf(out,",ev");
+		}
+
+		if (operation_needs_context(iface,op))
+		{
+			out_printf(out,",ctx");
+		}
+
+		el=op->children();
+
+		while (el)
+		{
+			RHBparameter *param=el->is_parameter();
+
+			if (param)
+			{
+				out_printf(out,",%s",param->id);
+			}
+
+			el=el->next();
+		}
+
+		out_printf(out,")\n");
+	}
+
+	/* do the short name form */
+
+	gen_shortname(out,op,"_",nest+1);
+
+	dump_nest(out,nest);
+	get_c_name(op,n,sizeof(n));
+	out_printf(out,"#endif /* %s */\n",n);
+
+	if (op_is_varg(op))
+	{
+		extern_c_begin(out,nest);
+
+		if (nolegacy())
+		{
+			dump_nest(out,nest);
+			out_printf(out,"#ifndef va_%s\n",n);
+			dump_nest(out,nest+1);
+			out_printf(out,"#define va_%s somva_%s\n",n,n);
+			dump_nest(out,nest);
+			out_printf(out,"#endif /* va_%s */\n",n);
+		}
+		else
+		{
+			generate_va_stub(out,iface,op,nest,0,"va");
+		}
+		generate_va_stub(out,iface,op,nest,1,"somva");
+		extern_c_end(out,nest);
+	}
+}
+
+void RHBheader_emitter::gen_shortname(RHBoutput *out,RHBtype *op,const char *lead,int nest)
+{
+	char n[1024];
+
+	if (!op->id)
+	{
+		return;
+	}
+
+	get_c_name(op,n,sizeof(n));
+
+	if (!strcmp(n,op->id)) 
+	{
+		return;
+	}
+
+	if (!lead) lead="";
+
+	dump_nest(out,nest);
+	out_printf(out,"#ifndef SOM_DONT_USE_SHORT_NAMES\n");
+
+	dump_nest(out,nest+1);
+	out_printf(out,"#ifndef SOMGD_%s%s\n",lead,op->id);
+
+	dump_nest(out,nest+2);
+	out_printf(out,"#if defined(%s%s)\n",lead,op->id);
+
+	dump_nest(out,nest+3);
+	out_printf(out,"#undef %s%s\n",lead,op->id);
+
+	dump_nest(out,nest+3);
+	out_printf(out,"#define SOMGD_%s%s\n",lead,op->id);
+
+	dump_nest(out,nest+2);
+	out_printf(out,"#else\n");
+
+	get_c_name(op,n,sizeof(n));
+
+	dump_nest(out,nest+3);
+	out_printf(out,"#define %s%s %s\n",lead,op->id,n);
+
+	dump_nest(out,nest+2);
+	out_printf(out,"#endif\n");
+
+	dump_nest(out,nest+1);
+	out_printf(out,"#endif /* SOMGD_%s%s */\n",lead,op->id);
+
+	dump_nest(out,nest);
+	out_printf(out,"#endif /* SOM_DONT_USE_SHORT_NAMES */\n");
+}
+
+void RHBheader_emitter::generate_inherited_macros(RHBoutput *out,RHBelement_sequence *dups,RHBinterface *iface,RHBinterface *parent)
+{
+	if (parent)
+	{
+		unsigned long i=dups->length();
+
+		while (i--)
+		{
+			if (parent==dups->get(i))
+			{
+				return;
+			}
+		}
+
+		dups->add(parent);
+
+		i=0;
+
+		while (i < parent->_parents.length())
+		{
+			RHBelement *el=parent->_parents.get(i);
+
+			generate_inherited_macros(out,dups,iface,el->is_interface());
+
+			i++;
+		}
+
+		if (parent != iface)
+		{
+			if (iface)
+			{
+				RHBelement *el=parent->children();
+
+				while (el)
+				{
+					RHBoperation *op=el->is_operation();
+
+					if (op)
+					{
+						char buf[256];
+						out_printf(out,"#define ");
+						get_c_name(iface,buf,sizeof(buf));
+						out->write(buf,strlen(buf));
+						out->write("_",1);
+						out->write(op->id,strlen(op->id));
+						out->write(" ",1);
+
+						get_c_name(parent,buf,sizeof(buf));
+						out->write(buf,strlen(buf));
+						out->write("_",1);
+						out->write(op->id,strlen(op->id));
+						out_printf(out,"\n");
+					}
+
+					el=el->next();
+				}
+			}
+		}
+	}
+}
+
+void RHBheader_emitter::generate_redispatch_stub_proto(RHBoutput *out,RHBinterface *iface,RHBoperation *op,int nest)
+{
+	char n[256];
+
+	dump_nest(out,nest);
+	out_printf(out,"static ");
+
+	if (op->return_type)
+	{
+		RHBtype *as=get_array_slice(op->return_type);
+		if (as)
+		{
+			use_type(out,as,0);
+			out->write("* ",2);
+		}
+		else
+		{
+			use_type(out,op->return_type,0);
+		}
+	}
+	else
+	{
+		out_printf(out,"void ");
+	}
+
+	get_c_name(op,n,sizeof(n));
+	out_printf(out,"SOMLINK somRD_%s",n);
+	generate_parameter_list(out,iface,op,2,1,0);
+}
+
+boolean RHBheader_emitter::type_is_sequence(RHBtype *t)
+{
+	if (t)
+	{
+		t=unwind_typedef(t);
+		if (t->is_sequence()) return 1;
+	}
+
+	return 0;
+}
+
+boolean RHBheader_emitter::type_is_any(RHBtype *t)
+{
+	if (t)
+	{
+		char buf[256];
+		t=unwind_typedef(t);
+		get_c_name(t,buf,sizeof(buf));
+		if (!strcmp(buf,"any")) return 1;
+	}
+	return 0;
+}
+
+void RHBheader_emitter::generate_redispatch_stub(RHBoutput *out,RHBinterface *iface,RHBoperation *op,int nest)
+{
+	char n[256];
+	RHBelement *el;
+
+	/*  this has same signature as actual method,
+			but folds it back onto somDispatch */
+
+	{
+		extern_c_proto_t extern_c_proto(this,out,nest);
+
+		strncpy(n,"somRD_",sizeof(n));
+		get_c_name(op,n+strlen(n),sizeof(n)-strlen(n));
+		undoublebar(out,n);
+
+		generate_redispatch_stub_proto(out,iface,op,nest);
+		out_printf(out,";\n");
+	}
+
+	dump_nest(out,nest);
+	out_printf(out,"#ifdef __IBMC__\n");
+	
+	dump_nest(out,nest+1);
+	get_c_name(op,n,sizeof(n));
+	out_printf(out,"#pragma linkage(somRD_%s,system)\n",n);
+
+	dump_nest(out,nest);
+	out_printf(out,"#endif /* __IBMC__ */\n");
+
+	generate_redispatch_stub_proto(out,iface,op,nest);
+
+	out_printf(out,"\n");
+	dump_nest(out,nest);
+	out_printf(out,"{\n");
+
+	RHBtype *slice=NULL;
+
+	if (operation_has_return(op))
+	{
+/*		i=sprintf(buf,"#ifdef _DEBUG\n");
+		out->write(buf,i);
+
+		dump_nest(out,nest+1);
+		use_type(out,op->return_type,"__retVal");
+		if (type_is_sequence(op->return_type))
+		{
+			i=sprintf(buf,"={0x80808080L,0x80808080L,(void *)0x80808080L}");
+			out->write(buf,i);
+		}
+		else
+		{
+			if (type_is_any(op->return_type))
+			{
+				i=sprintf(buf,"={(TypeCode)0x80808080L,(void *)0x80808080L}");
+				out->write(buf,i);
+			}
+		}
+		i=sprintf(buf,";\n");
+		out->write(buf,i);
+
+		i=sprintf(buf,"#else\n");
+		out->write(buf,i);*/
+
+		dump_nest(out,nest+1);
+
+		slice=get_array_slice(op->return_type);
+
+		if (slice)
+		{
+			char retVal_assign[256];
+			snprintf(retVal_assign,sizeof(retVal_assign),"* %s=NULL",retVal_name);
+			use_type(out,slice,retVal_assign);
+		}
+		else
+		{
+			use_type(out,op->return_type,retVal_name);
+
+			if (type_is_sequence(op->return_type))
+			{
+				out_printf(out,"={0,0,NULL}");
+			}
+			else
+			{
+				if (type_is_any(op->return_type))
+				{
+					out_printf(out,"={NULL,NULL}");
+				}
+			}
+		}
+		out_printf(out,";\n");
+
+/*		i=sprintf(buf,"#endif\n");
+		out->write(buf,i);*/
+	}
+	else
+	{
+		dump_nest(out,nest+1);
+		out_printf(out,"somToken %s=NULL; /* actually returns a void */\n",retVal_name);
+	}
+
+	if (!slice)
+	{
+		if (!type_is_any(op->return_type))
+		{
+			if (!type_is_sequence(op->return_type))
+			{
+				generate_init_zero(out,retVal_name,op->return_type,nest,0);
+			}
+		}
+	}
+
+	dump_nest(out,nest+1);
+
+	if (cplusplus)
+	{
+		out_printf(out,"somSelf->somDispatch(");
+	}
+	else
+	{
+		out_printf(out,"somva_SOMObject_somDispatch(somSelf,");
+	}
+
+	if (operation_has_return(op))
+	{
+		out_printf(out,"(somToken *)(void *)&%s,\n",retVal_name);
+	}
+	else
+	{
+		out_printf(out,"&%s,\n",retVal_name);
+	}
+
+	dump_nest(out,nest+2);
+	out_printf(out,"(somId)somId_%s,somSelf",op->id);
+
+	if (operation_needs_environment(iface,op))
+	{
+		out_printf(out,",ev");
+	}
+	if (operation_needs_context(iface,op))
+	{
+		out_printf(out,",ctx");
+	}
+
+	el=op->children();
+
+	while (el)
+	{
+		RHBparameter *param=el->is_parameter();
+
+		if (param)
+		{
+			out_printf(out,",\n");
+
+			dump_nest(out,nest+3);
+
+			if (!parameter_by_reference(param,NULL))
+			{
+				RHBtype *t=get_va_type(param->parameter_type,1);
+
+				if (t != param->parameter_type)
+				{
+					out_printf(out,"(");
+					use_type(out,t,0);
+					out_printf(out,")");
+				}
+			}
+
+			out_printf(out,"%s",param->id);
+		}
+
+		el=el->next();
+	}
+	
+	out_printf(out,");\n");
+
+	if (operation_has_return(op))
+	{
+		out_printf(out,"\n");
+		dump_nest(out,nest+1);
+		out_printf(out,"return %s;\n",retVal_name);
+	}
+
+	dump_nest(out,nest);
+	out_printf(out,"}\n");
+}
+
+int RHBheader_emitter::align_for(long curr,int align)
+{
+	long dx;
+
+	if (align < 2)
+	{
+		return 0;
+	}
+
+	curr+=align;
+
+	dx=curr % align;
+
+	if (dx)
+	{
+		return align-dx;
+	}
+
+	return 0;
+}
+
+void RHBheader_emitter::generate_apply_stub_proto(RHBoutput *out,RHBinterface *iface,RHBoperation *op,int nest)
+{
+	char n[256];
+
+	dump_nest(out,nest);
+	get_c_name(op,n,sizeof(n));
+	out_printf(out,"static void SOMLINK somAP_%s",n);
+
+	out_printf(out,"(\n");
+
+	dump_nest(out,nest+1);
+	use_type(out,iface,"somSelf");
+	out_printf(out,",\n");
+
+	dump_nest(out,nest+1);
+
+	if (op->return_type)
+	{
+		RHBtype *slice=get_array_slice(op->return_type);
+		if (slice)
+		{
+			use_type(out,slice,"*");
+		}
+		else
+		{
+			use_type(out,op->return_type,0);
+		}
+	}
+	else
+	{
+		out_printf(out,"void ");
+
+	}
+	out_printf(out,"*%s,\n",retVal_name);
+
+	dump_nest(out,nest+1);
+
+#ifdef DO_FULL_TYPEDEF
+	out_printf(out,"somTD_%s _somC_methodPtr,\n",n);
+#else
+	out_printf(out,"somMethodPtr _somC_methodPtr,\n");
+#endif
+
+	dump_nest(out,nest+1);
+	out_printf(out,"va_list _somC_ap)");
+}
+
+void RHBheader_emitter::generate_apply_stub(RHBoutput *out,RHBinterface *iface,RHBoperation *op,int nest)
+{
+	/* apply stub has the form...
+
+		void somAP_xxx(obj,void *__retVal,somMethodPtr __methodPtr,va_list __ap),
+	
+	    generated routine should pull each parameter
+			from va_list __ap and 
+			then call __methodPtr with same prototype as somTD_xxx
+	*/
+
+	RHBelement *el;
+	char n[256];
+
+	if (op_is_varg(op)) 
+	{
+		get_c_name(op,n,sizeof(n));
+		dump_nest(out,nest);
+		out_printf(out,"/* somAP_%s() has va_list, ignored */\n",n);
+		return;
+	}
+
+	{
+		extern_c_proto_t extern_c_proto(this,out,nest);
+
+		strncpy(n,"somAP_",sizeof(n));
+		get_c_name(op,n+strlen(n),sizeof(n)-strlen(n));
+		undoublebar(out,n);
+
+		generate_apply_stub_proto(out,iface,op,nest);
+		out_printf(out,";\n");
+	}
+
+	dump_nest(out,nest);
+	out_printf(out,"#ifdef __IBMC__\n");
+
+	dump_nest(out,nest+1);
+	get_c_name(op,n,sizeof(n));
+	out_printf(out,"#pragma linkage(somAP_%s,system)\n",n);
+
+	dump_nest(out,nest);
+	out_printf(out,"#endif /* __IBMC__ */\n");
+
+	generate_apply_stub_proto(out,iface,op,nest);
+
+	out_printf(out,"\n");
+	dump_nest(out,nest);
+	out_printf(out,"{\n");
+
+	if (operation_needs_environment(iface,op))
+	{
+		dump_nest(out,nest+1);
+		out_printf(out,"Environment *ev;\n");
+	}
+
+	if (operation_needs_context(iface,op))
+	{
+		dump_nest(out,nest+1);
+		if (cplusplus)
+		{
+			out_printf(out,"Context * ctx;\n");
+		}
+		else
+		{
+			out_printf(out,"Context SOMSTAR ctx;\n");
+		}
+	}
+
+	el=op->children();
+
+	while (el)
+	{
+		RHBparameter *param=el->is_parameter();
+
+		if (param)
+		{
+			boolean by_ref=0;
+			RHBtype *local_type=NULL;
+			RHBtype *array_of=NULL;
+
+			dump_nest(out,nest+1);
+
+			by_ref=parameter_by_reference(param,&array_of);
+
+			local_type=param->parameter_type;
+
+			if (by_ref)
+			{
+				if (array_of) local_type=array_of;
+			}
+			else
+			{
+				RHBbase_type *x=unwind_typedef(local_type)->is_base_type();
+
+				if (x)
+				{
+					if (x->_floating)
+					{
+						local_type=get_va_type(local_type,1);
+					}
+				}
+			}
+
+			if (get_array_slice(param->parameter_type))
+			{
+				char tdn[256];
+				snprintf(tdn,sizeof(tdn),"_somC_slice_%s_t",param->id);
+				generate_array_slice_typedef(out,0,param->parameter_type,tdn);
+				dump_nest(out,nest+1);
+				out_printf(out,"_somC_slice_%s_t *%s;\n",param->id,param->id);
+			}
+			else
+			{
+				use_type(out,local_type,0);
+
+				if (by_ref)
+				{
+					out->write("*",1);
+				}
+
+				out_printf(out,"%s;\n",param->id);
+			}
+		}
+
+		el=el->next();
+	}
+
+	out_printf(out,"\n");
+
+	dump_nest(out,nest+1);
+	out_printf(out,"somSelf=va_arg(_somC_ap,");
+	use_type(out,iface,0);
+	out_printf(out,");\n");
+
+	if (operation_needs_environment(iface,op))
+	{
+		dump_nest(out,nest+1);
+		out_printf(out,"ev=va_arg(_somC_ap,Environment *);\n");
+	}
+
+	if (operation_needs_context(iface,op))
+	{
+		dump_nest(out,nest+1);
+		if (cplusplus)
+		{
+			out_printf(out,"ctx=va_arg(_somC_ap,Context *);\n");
+		}
+		else
+		{
+			out_printf(out,"ctx=va_arg(_somC_ap,Context SOMSTAR);\n");
+		}
+	}
+
+	el=op->children();
+
+	while (el)
+	{
+		RHBparameter *param=el->is_parameter();
+
+		if (param)
+		{
+			RHBtype *type=NULL;
+
+			dump_nest(out,nest+1);
+
+			out_printf(out,"%s=",param->id);
+
+			int by_ref=parameter_by_reference(param,&type);
+
+			if (get_array_slice(param->parameter_type))
+			{
+				char tdn[256];
+				snprintf(tdn,sizeof(tdn),"_somC_slice_%s_t",param->id);
+				out_printf(out,"va_arg(_somC_ap,%s *)",tdn);
+			}
+			else
+			{
+				if (!type) type=param->parameter_type;
+
+				use_va_arg(out,"_somC_ap",type,by_ref);
+			}
+
+			out_printf(out,";\n");
+		}
+
+		el=el->next();
+	}
+
+	out_printf(out,"\n");
+
+	if (!operation_has_return(op))
+	{
+		dump_nest(out,nest+1);
+		out_printf(out,"SOM_IgnoreWarning(%s);\n\n",retVal_name);
+	}
+
+	dump_nest(out,nest+1);
+
+	if (operation_has_return(op))
+	{
+		out_printf(out,"*%s=",retVal_name);
+	}
+
+#ifdef DO_FULL_TYPEDEF
+	out_printf(out,"_somC_methodPtr(somSelf");
+#else
+	get_c_name(op,n,sizeof(n));
+	out_printf(out,"((somTD_%s)_somC_methodPtr)(somSelf",n);
+#endif
+
+	if (operation_needs_environment(iface,op))
+	{
+		out_printf(out,",ev");
+	}
+
+	if (operation_needs_context(iface,op))
+	{
+		out_printf(out,",ctx");
+	}
+
+	el=op->children();
+
+	while (el)
+	{
+		RHBparameter *param=el->is_parameter();
+
+		if (param)
+		{
+			boolean by_ref=parameter_by_reference(param,NULL);
+
+			out_printf(out,",");
+
+			if (!by_ref)
+			{
+				RHBbase_type *bt=unwind_typedef(param->parameter_type)->is_base_type();
+
+				if (bt)
+				{
+					if (bt->_floating)
+					{
+						char nf[32];
+						get_c_name(bt,nf,sizeof(nf));
+	
+						if (!strcmp(nf,"float"))
+						{
+							out_printf(out,"(%s)",nf);
+						}
+					}
+				}
+			}
+
+			out_printf(out,"%s",param->id);
+		}
+
+		el=el->next();
+	}
+
+	out_printf(out,");\n");
+
+	dump_nest(out,nest);
+	out_printf(out,"}\n\n");
+
+	generated_apply_stubs.add(op);
+}
+
+void RHBheader_emitter::use_va_arg(RHBoutput *out,const char *ap,RHBtype *typ,boolean byRef)
+{
+	/* added to cast so that shorts will be mapped from int etc */
+
+	RHBtype *typ_cast=unwind_typedef(typ);
+	if (!byRef)
+	{
+		if (typ_cast->is_qualified()||typ_cast->is_base_type())
+		{
+			out->write("(",1);
+			if (byRef)
+			{
+				use_type(out,typ,0);
+				out->write("*",1);
+			}
+			else
+			{
+				use_type(out,typ,0);
+			}
+			out->write(")",1);
+		}
+	}
+	/* end of addition */
+
+	out_printf(out,"va_arg(%s,",ap);
+
+	if (byRef)
+	{
+		use_type(out,typ,0);
+		out_printf(out,"*");
+	}
+	else
+	{
+		use_type(out,get_va_type(typ,1),0);
+	}
+
+	out_printf(out,")");
+}
+
+RHBtype *RHBheader_emitter::get_va_type(RHBtype *typ,boolean cast_float)
+{
+	RHBbase_type *bt;
+	RHBtype_def *dt;
+	RHBtype *orig;
+
+	orig=typ;
+
+	while (typ)
+	{
+		if (typ->is_interface())
+		{
+			break;
+		}
+
+		if (typ->is_pointer())
+		{
+			break;
+		}
+
+		dt=typ->is_typedef();
+
+		if (dt)
+		{
+			typ=dt->alias_for;
+		}
+		else
+		{
+			bt=typ->is_base_type();
+
+			if (bt)
+			{
+				if (bt->_va_type)
+				{
+					if (bt->_floating)
+					{
+						if (!cast_float)
+						{
+							return bt;
+						}
+					}
+
+					return bt->_va_type;
+				}
+
+				return orig;
+			}
+			else
+			{
+				if (typ->is_qualified())
+				{
+					/* follow this */
+					typ=typ->is_qualified()->base_type;
+				}
+				else
+				{
+					return orig;
+				}
+			}
+		}
+	}
+
+	return orig;
+}
+
+void RHBheader_emitter::determine_inherited(RHBinterface *iface,RHBinterface *candidates,RHBelement_sequence *seq)
+{
+	if (candidates)
+	{
+		if (candidates != iface)
+		{
+			RHBelement *el=candidates->children();
+
+			while (el)
+			{
+				RHBoperation *op;
+
+				op=el->is_operation();
+
+				if (op)
+				{
+					if (!seq->contains(op))
+					{
+/*						char buf[256];
+						get_c_name(op,buf);
+						printf("adding %s\n",buf);*/
+						seq->add(op);
+					}
+				}
+
+				el=el->next();
+			}
+		}
+
+		unsigned long i=0;
+
+		while (i < candidates->_parents.length())
+		{
+			RHBelement *el;
+
+			el=candidates->_parents.get(i);
+
+			determine_inherited(iface,el->is_interface(),seq);
+
+			i++;
+		}
+	}
+}
+
+void RHBheader_emitter::determine_overrides(
+				RHBinterface *iface,
+				RHBinterface * /* candidates */,
+				RHBelement_sequence *seq)
+{
+	RHBelement *el=iface->children();
+
+	while (el)
+	{
+		RHBinherited_operation *iop=el->is_inherited_operation();
+
+		if (iop)
+		{
+			if (does_override(iface,iop->id))
+			{
+				if (!seq->contains(iop->original))
+				{
+					seq->add(iop->original);
+				}
+			}
+		}
+
+		el=el->next();
+	}
+
+#if 0
+	if (candidates)
+	{
+		if (candidates!=iface)
+		{
+			RHBelement *el=candidates->children();
+
+			while (el)
+			{
+				int yes=0;
+				RHBoperation *op=el->is_operation();
+
+				if (op)
+				{
+					char buf[256];
+					RHBelement *mod;
+
+					strncpy(buf,op->id,sizeof(buf));
+					mod=iface->find_named_element(0,buf,sizeof(buf));
+
+					if (mod)
+					{
+						int i=0;
+
+						while (mod->modifier_data.get(i))
+						{
+							const char *p=mod->modifier_data.get(i);
+							if (0==strcmp(p,"override"))
+							{
+								yes=1;
+								break;
+							}
+
+							i++;
+						}
+					}
+
+					if (!yes)
+					{
+						strncpy(buf,"override",sizeof(buf));
+						mod=iface->find_named_element(0,buf,sizeof(buf));
+						if (mod)
+						{
+							int i;
+
+							i=0;
+
+							while (mod->modifier_data.get(i))
+							{
+								const char *p=mod->modifier_data.get(i);
+								if (0==strcmp(p,op->id))
+								{
+									yes=1;
+									break;
+								}
+
+								i++;
+							}
+						}
+					}
+
+					if (yes)
+					{
+						if (!seq->contains(op))
+						{
+							seq->add(op);
+						}
+					}
+				}
+
+				el=el->next();
+			}
+		}
+	}
+
+	if (iface)
+	{
+		if (candidates)
+		{
+			unsigned long i=0;
+
+			while (i < candidates->_parents.length())
+			{
+				determine_overrides(iface,candidates->_parents.get(i)->is_interface(),seq);
+	
+				i++;
+			}
+		}
+	}
+#endif
+}
+
+void RHBheader_emitter::generate_operation_proto(RHBoutput *out,RHBinterface *iface,RHBoperation *op,int nest)
+{
+	char n[256];
+
+/*	extern_c_begin(out,nest);*/
+
+	/* SOM_Scope macro contains enough scoping */
+
+	{
+		extern_c_proto_t scoping(this,out,nest);
+
+		get_function_prefix(iface,n,sizeof(n));
+		strncat(n,op->id,sizeof(n));
+		undoublebar(out,n);
+
+		dump_nest(out,nest);
+		out_printf(out,"SOM_Scope ");
+
+		if (op->return_type)
+		{
+			RHBtype *s=get_array_slice(op->return_type);
+			if (s)
+			{
+				use_type(out,s,0);
+				out_printf(out,"* ");
+			}
+			else
+			{
+				use_type(out,op->return_type,0);
+			}
+		}
+		else
+		{
+			out_printf(out,"void ");
+		}
+
+		out_printf(out,"SOMLINK ");
+
+		get_function_prefix(iface,n,sizeof(n));
+
+		out_printf(out,"%s%s",n,op->id);
+
+		generate_parameter_list(out,iface,op,0,1,0);
+		out_printf(out,";\n");
+	}
+
+	dump_nest(out,nest);
+	out_printf(out,"#ifdef __IBMC__\n");
+
+	get_function_prefix(iface,n,sizeof(n));
+	dump_nest(out,nest+1);
+	out_printf(out,"#pragma linkage(%s%s,system)\n",n,op->id);
+	dump_nest(out,nest);
+	out_printf(out,"#endif /* __IBMC__ */\n");
+
+/*	extern_c_end(out,nest);*/
+}
+
+void RHBheader_emitter::get_function_prefix(RHBinterface *iface,char *buf,size_t buflen)
+{
+	RHBelement *el;
+	char n[256];
+
+	strncpy(n,"functionprefix",sizeof(n));
+	buf[0]=0;
+
+	el=iface->find_named_element(0,n,sizeof(n));
+
+	if (el)
+	{
+		const char *p=el->modifier_data.get(0);
+
+		if (p)
+		{
+			while (*p)
+			{
+				if (*p!=double_quote)
+				{
+					if (!--buflen) break;
+
+					*buf++ = *p;
+				}
+				p++;
+			}
+
+			*buf=0;
+		}
+	}
+	else
+	{
+		/* 31-3-1999 */
+/*		get_c_name(iface,buf);*/
+		*buf=0;
+	}
+}
+
+boolean RHBheader_emitter::get_actual_meta_class(RHBinterface *iface,char *buf,size_t buflen)
+{
+	if (get_meta_class(iface,buf)) 
+	{
+		RHBelement *el=iface->find_named_element(0,buf,buflen);
+
+		if (el)
+		{
+			get_c_name(el,buf,buflen);
+
+			return 1;
+		}
+	}
+
+	strncpy(buf,"SOMClass",buflen);
+
+	return 0;
+}
+
+RHBinterface *RHBheader_emitter::get_meta_class_interface(RHBinterface *iface)
+{
+	RHBelement *el;
+	char n[256];
+
+	if (!iface) return 0;
+
+	strncpy(n,"metaclass",sizeof(n));
+
+	el=iface->find_named_element(0,n,sizeof(n));
+
+	if (el)
+	{
+		const char *p;
+		char buffer[256];
+		char *buf;
+
+		buf=buffer;
+
+		p=el->modifier_data.get(0);
+
+		if (p)
+		{
+			while (*p)
+			{
+				if (*p!=double_quote)
+				{
+					*buf++ = *p;
+				}
+				p++;
+			}
+
+			*buf=0;
+
+			el=iface->find_named_element(0,buffer,sizeof(buffer));
+
+			if (el)
+			{
+				return el->is_interface();
+			}
+		}
+	}
+
+	unsigned long i=0;
+
+	while (i < iface->_parents.length())
+	{
+		el=iface->_parents.get(i);
+
+		RHBinterface *meta=get_meta_class_interface(el->is_interface());
+
+		if (meta)
+		{
+			return meta;
+		}
+
+		i++;
+	}
+
+	return 0;
+}
+
+boolean RHBheader_emitter::get_meta_class(RHBinterface *iface,char *buf)
+{
+	RHBelement *el;
+	char n[256];
+
+	strncpy(n,"metaclass",sizeof(n));
+	buf[0]=0;
+
+	el=iface->find_named_element(0,n,sizeof(n));
+
+	if (el)
+	{
+		const char *p=el->modifier_data.get(0);
+
+		if (p)
+		{
+			while (*p)
+			{
+				if (*p!=double_quote)
+				{
+					*buf++ = *p;
+				}
+				p++;
+			}
+
+			*buf=0;
+
+			return 1;
+		}
+	}
+
+	unsigned long i=0;
+
+	while (i < iface->_parents.length())
+	{
+		el=iface->_parents.get(i);
+
+		if (get_meta_class(el->is_interface(),buf))
+		{
+			return 1;
+		}
+
+		i++;
+	}
+
+	return 0;
+}
+
+
+void RHBheader_emitter::generate_parent_macro(
+			RHBoutput *out,
+			RHBinterface *iface,
+			RHBinterface *parent,
+			RHBoperation *op,
+			int nest)
+{
+	char buf[256];
+	char n[256];
+
+	get_c_name(op,buf,sizeof(buf));
+
+	if ((!strcmp(buf,"SOMObject_somInit"))||
+		(!strcmp(buf,"SOMObject_somUninit")))
+	{
+			get_c_name(iface,n,sizeof(n));
+			strncat(n,"_parent_",sizeof(n));
+			get_c_name(parent,buf,sizeof(buf));
+			strncat(n,buf,sizeof(n));
+			strncat(n,"_",sizeof(n));
+			strncat(n,op->id,sizeof(n));
+
+			dump_nest(out,nest);
+			out_printf(out,"#ifndef %s\n",n);
+			dump_nest(out,nest+1);
+			out_printf(out,"#define %s(somSelf)\n",n);
+			dump_nest(out,nest);
+			out_printf(out,"#endif /* %s */\n",n);
+	}
+	else
+	{
+		int k=get_parent_index(iface,parent);
+
+		if (is_dts_override(op))
+		{
+			dts_parent_macro(out,iface,k-1,parent,op,nest);
+
+			k=0;
+		}
+
+		if (k)
+		{
+			dump_nest(out,nest);
+			get_c_name(iface,n,sizeof(n));
+			out_printf(out,"#define %s_parent_",n);
+			get_c_name(parent,n,sizeof(n));
+			out_printf(out,"%s_%s",n,op->id);
+			generate_name_only_parameter_list(out,iface,op,0);
+			out_printf(out,"   \\\n");
+
+			dump_nest(out,nest+1);
+
+			if (cplusplus)
+			{
+				get_c_name(iface,n,sizeof(n));
+				strncat(n,"_",sizeof(n));
+				strncat(n,op->id,sizeof(n));
+			}
+			else
+			{
+				get_c_name(op,n,sizeof(n));
+			}
+
+			if (is_kernel_class(iface))
+			{
+				get_function_prefix(parent,n,sizeof(n));
+				out_printf(out,"%s%s",n,op->id);
+			}
+			else
+			{
+				out_printf(out,"((somTD_%s)\\\n",n);
+				dump_nest(out,nest+2);
+				if (generate_parent_resolved(out,iface,parent,op,3))
+				{
+					out_printf(out,")\\\n");
+				}
+				else
+				{
+					get_c_name(iface,n,sizeof(n));
+					out_printf(out,"somParentNumResolve(%sCClassData.parentMtab,\\\n",n);
+					dump_nest(out,nest+3);
+					get_c_name(op->parent(),n,sizeof(n));
+					out_printf(out,"%d,%sClassData.%s))\\\n",k,n,op->id);
+				}
+			}
+			dump_nest(out,nest+4);
+			generate_name_only_parameter_list(out,iface,op,cplusplus);
+			out_printf(out,"\n");
+		}
+	}
+}
+
+int RHBheader_emitter::get_parent_index(RHBinterface *iface,RHBinterface *if2)
+{
+	unsigned long i=0;
+
+	if (iface==if2) return 1;
+
+	while (i < iface->_parents.length())
+	{
+		if (get_parent_index(iface->_parents.get(i)->is_interface(),if2))
+		{
+			return i+1;
+		}
+
+		i++;
+	}
+
+	return 0;
+}
+
+void RHBheader_emitter::generate_name_only_parameter_list(RHBoutput *out,RHBinterface *iface,RHBoperation *op,boolean expand_self)
+{
+	RHBelement *el;
+
+	if (cplusplus && expand_self)
+	{
+		char n[256];
+		get_c_name(iface,n,sizeof(n));
+		out_printf(out,"((%s *)(void *)somSelf",n);
+	}
+	else
+	{
+		out_printf(out,"(somSelf");
+	}
+
+	if (operation_needs_environment(iface,op))
+	{
+		out->write(",ev",3);
+	}
+	if (operation_needs_context(iface,op))
+	{
+		out->write(",ctx",4);
+	}
+	el=op->children();
+
+	while (el)
+	{
+		RHBparameter *param;
+
+		param=el->is_parameter();
+
+		if (param)
+		{
+			out->write(",",1);
+			out->write(param->id,strlen(param->id));
+		}
+
+		el=el->next();
+	}
+
+	out->write(")",1);
+}
+
+
+boolean RHBheader_emitter::has_same_ABI(RHBoperation *op1,RHBoperation *op2)
+{
+	int i=0;
+
+	if (op1==op2) return 1;
+	if (!op1) return 0;
+	if (!op2) return 0;
+
+	if (operation_needs_environment(0,op1)!=operation_needs_environment(0,op2))
+	{
+		return 0;
+	}
+
+	if (operation_needs_context(0,op1)!=operation_needs_context(0,op2))
+	{
+		return 0;
+	}
+
+	if (operation_has_return(op1)!=operation_has_return(op2))
+	{
+		return 0;
+	}
+
+	if (operation_has_return(op1))
+	{
+		if (!same_ABI_type(op1->return_type,op2->return_type))
+		{
+			return 0;
+		}
+	}
+
+	while (1)
+	{
+		RHBtype *t1=0,*t2=0;
+		RHBparameter *param1=op1->get_parameter(i);
+		RHBparameter *param2=op2->get_parameter(i);
+
+		i++;
+
+		if ((!param1)&&(!param2))
+		{
+			break;
+		}
+
+		if (!param1) return 0;
+		if (!param2) return 0;
+
+		int ref1=parameter_by_reference(param1,NULL);
+		int ref2=parameter_by_reference(param2,NULL);
+
+		if (!ref1) 
+		{
+			t1=get_va_type(unwind_typedef(param1->parameter_type),0);
+			ref1=some_ABI_kind_of_pointer(t1);
+		}
+
+		if (!ref2)
+		{
+			t2=get_va_type(unwind_typedef(param2->parameter_type),0);
+			ref2=some_ABI_kind_of_pointer(t2);
+		}
+
+		if (ref1 && ref2)
+		{
+			continue;
+		}
+
+		if (ref1 || ref2)
+		{
+			return 0;
+		}
+
+		if (!same_ABI_type(t1,t2))
+		{
+			return 0;
+		}
+	}
+
+	return 1;
+}
+
+boolean RHBheader_emitter::same_ABI_type(RHBtype *t1,RHBtype *t2)
+{
+	boolean ptr1,ptr2;
+
+	t1=unwind_typedef(t1);
+	t2=unwind_typedef(t2);
+
+	if (t1==t2) return 1;
+
+	ptr1=some_ABI_kind_of_pointer(t1);
+	ptr2=some_ABI_kind_of_pointer(t2);
+
+	if (ptr1 && ptr2) return 1;
+
+	if (ptr1) return 0;
+	if (ptr2) return 0;
+
+	if (t1->is_sequence())
+	{
+		if (t2->is_sequence())
+		{
+			return 1;
+		}
+	}
+
+	if (t1->is_any())
+	{
+		if (t2->is_any())
+		{
+			return 1;
+		}
+	}
+
+	RHBbase_type *b1,*b2;
+
+	b1=t1->is_base_type();
+	b2=t2->is_base_type();
+
+	if (b1 && b2)
+	{
+		if (b1->_floating != b2->_floating) return 0;
+	}
+
+	if (b1)
+	{
+		if (b1->_floating) 
+		{
+			return 0;
+		}
+	}
+
+	if (b2)
+	{
+		if (b2->_floating) 
+		{
+			return 0;
+		}
+	}
+
+/*
+	won't do this check because this depends on this compiler
+	knowing the alignments and sizes for the target platform,
+	which we cant do if if we want to use the same headers on 
+	Intel,PowerPC, DEC Alpha and AS400
+
+
+	if (t1->_get_length()== t2->_get_length())
+	{
+		if (t1->_get_length())
+		{
+			if (t1->_get_alignment()==t2->_get_alignment())
+			{
+				if (t1->_get_alignment())
+				{
+					return 1;
+				}
+			}
+		}
+	}
+*/
+	return 0;
+}
+
+boolean RHBheader_emitter::some_ABI_kind_of_pointer(RHBtype *t)
+{
+	if (t->is_interface()) return 1;
+	if (t->is_pointer()) return 1;
+	if (t->is_string()) return 1;
+	if (t->is_TypeCode()) return 1;
+
+	return 0;
+}
+
+void RHBheader_emitter::generate_versions(RHBoutput *out,RHBinterface *iface,const char *ext,const char *mod_name,int nest)
+{
+	RHBelement *el;
+	const char *p;
+	char n[256];
+	char buf[256];
+
+	strncpy(buf,mod_name,sizeof(buf));
+	el=iface->find_named_element(0,buf,sizeof(buf));
+
+	p=0;
+
+	if (el)
+	{
+		p=el->modifier_data.get(0);
+	}
+
+	if (!p) p="0";
+
+	dump_nest(out,nest);
+	get_c_name(iface,n,sizeof(n));
+
+	out_printf(out,"#ifndef %s_%s\n",n,ext);
+	dump_nest(out,nest+1);
+	out_printf(out,"#define %s_%s   %s\n",n,ext,p);
+	dump_nest(out,nest);
+	out_printf(out,"#endif /* %s_%s */\n",n,ext);
+}
+
+boolean RHBheader_emitter::will_generate_static(const char *p)
+{
+	int i;
+
+	i=0;
+
+	while (generated_statics.get(i))
+	{
+		const char *q=generated_statics.get(i);
+		if (0==strcmp(p,q))
+		{
+			return 0;
+		}
+
+		i++;
+	}
+
+	generated_statics.add(p);
+
+	return 1;
+}
+
+boolean RHBheader_emitter::is_operation_noself(RHBoperation *op)
+{
+	const char *noself="noself";
+
+	if (op)
+	{
+		int i=0;
+
+		RHBelement *el=op->children();
+
+		while (el)
+		{
+			if (!strcmp(el->id,noself))
+			{
+				RHBmodifier *mod=el->is_modifier();
+
+				if (mod) return 1;
+			}
+
+			el=el->next();
+		}
+
+		while (i < op->modifier_data.length())
+		{
+			const char *p=op->modifier_data.get(i);
+
+			if (!strcmp(p,noself))
+			{
+				return 1;
+			}
+
+			i++;
+		}
+	}
+
+	return 0;
+}
+
+boolean RHBheader_emitter::is_operation_procedure(RHBoperation *op)
+{
+	const char *modname="procedure";
+
+	if (op)
+	{
+		int i=0;
+
+		RHBelement *el=op->children();
+
+		while (el)
+		{
+			if (!strcmp(el->id,modname))
+			{
+				RHBmodifier *mod=el->is_modifier();
+
+				if (mod) return 1;
+			}
+
+			el=el->next();
+		}
+
+		while (i < op->modifier_data.length())
+		{
+			const char *p=op->modifier_data.get(i);
+
+			if (!strcmp(p,modname))
+			{
+				return 1;
+			}
+
+			i++;
+		}
+	}
+
+	return 0;
+}
+
+#ifdef _PLATFORM_MACINTOSH_
+void RHBheader_emitter::align_begin(RHBoutput *out,boolean user_data,int nest)
+#else
+void RHBheader_emitter::align_begin(RHBoutput *,boolean,int)
+#endif
+{
+#ifdef _PLATFORM_MACINTOSH_
+	char buf[256];
+	int i;
+	dump_nest(out,nest);
+	i=sprintf(buf,"#ifdef _PLATFORM_MACINTOSH_\n");
+	out->write(buf,i);
+
+	dump_nest(out,nest+1);
+	i=sprintf(buf,"#if powerc\n");
+	out->write(buf,i);
+
+	dump_nest(out,nest+2);
+	if (user_data)
+	{
+		i=sprintf(buf,"#pragma options align=mac68k\n");
+	}
+	else
+	{
+		i=sprintf(buf,"#pragma options align=power\n");
+	}
+
+	out->write(buf,i);
+
+	dump_nest(out,nest+1);
+	i=sprintf(buf,"#endif /* powerc */\n");
+	out->write(buf,i);
+
+	dump_nest(out,nest);
+	i=sprintf(buf,"#endif /* _PLATFORM_MACINTOSH_ */\n");
+	out->write(buf,i);
+#endif
+}
+
+#ifdef _PLATFORM_MACINTOSH_
+void RHBheader_emitter::align_end(RHBoutput *out,boolean user_data,int nest)
+#else
+void RHBheader_emitter::align_end(RHBoutput *,boolean,int)
+#endif
+{
+#ifdef _PLATFORM_MACINTOSH_
+	char buf[256];
+	int i;
+
+	dump_nest(out,nest);
+	i=sprintf(buf,"#ifdef _PLATFORM_MACINTOSH_\n");
+	out->write(buf,i);
+
+	dump_nest(out,nest+1);
+	i=sprintf(buf,"#if powerc\n");
+	out->write(buf,i);
+
+	dump_nest(out,nest+2);
+	i=sprintf(buf,"#pragma options align=reset\n");
+	out->write(buf,i);
+
+	dump_nest(out,nest+1);
+	i=sprintf(buf,"#endif /* powerc */\n");
+	out->write(buf,i);
+
+	dump_nest(out,nest);
+	i=sprintf(buf,"#endif /* _PLATFORM_MACINTOSH_ */\n");
+	out->write(buf,i);
+#endif
+}
+
+int RHBheader_emitter::is_unsigned(RHBtype *typ)
+{
+	while (typ->is_typedef())
+	{
+		typ=typ->is_typedef()->alias_for;
+	}
+
+	RHBqualified_type *q=typ->is_qualified();
+
+	if (q)
+	{
+		if (!strcmp(q->id,"unsigned"))
+		{
+			return 1;
+		}
+	}
+
+	if (typ->is_enum()) 
+	{
+		return 1;
+	}
+
+	return 0;
+}
+
+int RHBheader_emitter::is_long(RHBtype *t)
+{
+	while (t)
+	{
+		RHBtype_def *td=t->is_typedef();
+		if (td)
+		{
+			t=td->alias_for;
+		}
+		else
+		{
+			RHBqualified_type *qt=t->is_qualified();
+
+			if (qt)
+			{
+				t=qt->base_type;
+			}
+			else
+			{
+				RHBbase_type *bt=t->is_base_type();
+
+				if (bt)
+				{
+					if (!strcmp(bt->id,"long"))
+					{
+						return 1;
+					}
+				}
+
+				if (t->is_enum())
+				{
+					return 1;
+				}
+
+				return 0;
+			}
+		}
+	}
+
+	return 0;
+}
+
+void RHBheader_emitter::generate_constant(RHBoutput *out,RHBconstant *cn,int nest)
+{
+	char n[256];
+
+	if (cn->is_const_TypeCode())
+	{
+		dump_nest(out,nest);
+		get_c_name(cn,n,sizeof(n));
+		out_printf(out,"/* TypeCode constant %s not emitted */\n",n);
+
+		return;
+	}
+
+	dump_nest(out,nest);
+	get_c_name(cn,n,sizeof(n));
+	out_printf(out,"#ifndef %s\n",n);
+	dump_nest(out,nest+1);
+	out_printf(out,"#define %s   ",n);
+
+	if (cn->is_numeric())
+	{
+		char extra[3]={0,0,0};
+		char L=0;
+
+		if (is_long(cn->constant_type))
+		{
+			L='L';
+		}
+
+		if (is_unsigned(cn->constant_type))
+		{
+			extra[0]='U';
+			extra[1]=L;
+
+			out_printf(out,"%lu%s\n",(unsigned long)cn->numeric_value(),extra);
+		}
+		else
+		{
+			extra[0]=L;
+			out_printf(out,"%ld%s\n",(long)cn->numeric_value(),extra);
+		}
+	}
+	else
+	{
+		if (cn->value_string)
+		{
+			out_printf(out,"\042%s\042\n",cn->value_string);
+		}
+		else
+		{
+			out_printf(out,"NULL\n");
+		}
+	}
+
+	gen_shortname(out,cn,0,nest+1);
+
+	dump_nest(out,nest);
+	get_c_name(cn,n,sizeof(n));
+	out_printf(out,"#endif /* %s */\n",n);
+}
+
+void RHBheader_emitter::generate_class_guard(RHBoutput *out,int nest,RHBinterface *iface,boolean how)
+{
+	if (internal)
+	{
+		char n[256];
+
+		dump_nest(out,nest);
+
+		get_c_name(iface,n,sizeof(n));
+
+		if (how)
+		{
+			out_printf(out,"#ifdef %s_Class_Source\n",n);
+		}
+		else
+		{
+			out_printf(out,"#endif /* %s_Class_Source */\n",n);
+		}
+	}
+}
+
+void RHBheader_emitter::generate_passthru(RHBoutput *out,RHBinterface *iface,const char *which)
+{
+	int i=0;
+	RHBelement *el;
+	int j=0;
+
+	el=0;
+	while (iface->passthru_list.get(i))
+	{
+		el=iface->passthru_list.get(i);
+		if (0==strcmp(which,el->id))
+		{
+			break;
+		}
+
+		i++;
+		el=0;
+	}
+
+	if (!el) return;
+
+	while (j < el->modifier_data.length())
+	{
+		const char *p=el->modifier_data.get(j);
+
+		if (p)
+		{
+			if (*p==double_quote)
+			{
+				p++;
+			}
+
+			i=strlen(p);
+
+			if (i)
+			{
+				if (p[i-1]==double_quote)
+				{
+					i--;
+				}
+			}
+
+			out->write(p,i);
+			out_printf(out,"\n");
+		}
+
+		j++;
+	}
+
+}
+
+void RHBheader_emitter::generate_init_zero(
+		RHBoutput *out,const char *name,RHBtype *typ,int nest,
+		unsigned long /*initial_value*/)
+{
+/*	int i;
+	char buf[256];*/
+	char n[256];
+
+	if (!typ) return;
+
+	while (typ->is_typedef())
+	{
+		typ=typ->is_typedef()->alias_for;
+
+		get_ir_name(typ,n,sizeof(n));
+
+		if (!strcmp(n,"::SOMFOREIGN"))
+		{
+			return;
+		}
+	}
+
+	while (typ->is_qualified())
+	{
+		typ=typ->is_qualified()->base_type;
+	}
+
+	get_c_name(typ,n,sizeof(n));
+
+	if (!strcmp(n,"void")) return;
+
+	out_printf(out,"#ifdef _DEBUG\n");
+
+	dump_nest(out,nest+1);
+	out_printf(out,"memset(&%s,0xCC,sizeof(%s));\n",
+			name,name);
+
+	out_printf(out,"#endif /* _DEBUG */\n");
+
+#if 0
+	if (!strcmp(n,"any"))
+	{
+		dump_nest(out,nest+1);
+		i=sprintf(buf,"%s._type=(TypeCode)%ld;\n",name,initial_value);
+		out->write(buf,i);
+		dump_nest(out,nest+1);
+		i=sprintf(buf,"%s._value=(void *)%ld;\n",name,initial_value);
+		out->write(buf,i);
+		typ=0;
+	}
+
+	if (!strcmp(n,"float"))
+	{
+		dump_nest(out,nest+1);
+		i=sprintf(buf,"%s=(float)0.0;\n",name);
+		out->write(buf,i);
+		typ=0;
+	}
+
+	if (!strcmp(n,"double"))
+	{
+		dump_nest(out,nest+1);
+		i=sprintf(buf,"%s=(double)0.0;\n",name);
+		out->write(buf,i);
+		typ=0;
+	}
+
+/*	if (!strcmp(n,"TypeCode"))
+	{
+		dump_nest(out,1);
+		i=sprintf(buf,"%s=TC_void;\n",name);
+		out->write(buf,i);
+		typ=0;
+	}
+*/
+	if (typ)
+	{
+		if (typ->is_sequence())
+		{
+			dump_nest(out,nest+1);
+			i=sprintf(buf,"%s._length=%ld;\n",name,initial_value);
+			out->write(buf,i);
+			dump_nest(out,nest+1);
+			i=sprintf(buf,"%s._maximum=%ld;\n",name,initial_value);
+			out->write(buf,i);
+			dump_nest(out,nest+1);
+			i=sprintf(buf,"%s._buffer=%ld;\n",name,initial_value);
+			out->write(buf,i);
+			typ=0;
+		}
+	}
+
+	if (typ)
+	{
+		if (typ->is_union() || typ->is_struct() || typ->is_array())
+		{
+			dump_nest(out,nest+1);
+			i=sprintf(buf,"memset(&%s,%d,sizeof(%s));\n",name,(int)(unsigned char)initial_value,name);
+			out->write(buf,i);
+			typ=0;
+		}
+	}
+
+	if (typ)
+	{
+/*		if (typ->is_interface())
+		{
+			dump_nest(out,nest+1);
+			i=sprintf(buf,"%s=(%s SOMSTAR)%ld;\n",
+						name,n,initial_value);
+			out->write(buf,i);
+		}
+		else*/
+		{
+			if (!initial_value)
+			{
+				if (typ->is_base_type())
+				{
+					dump_nest(out,nest+1);
+					i=sprintf(buf,"%s=%ld;\n",name,initial_value);
+					out->write(buf,i);
+					typ=0;
+				}
+			}
+			
+		    if (typ)
+			{
+				dump_nest(out,nest+1);
+				i=sprintf(buf,"%s=(",name);
+				out->write(buf,i);
+				use_type(out,typ,0);
+				i=sprintf(buf,")%ld;\n",initial_value);
+				out->write(buf,i);
+			}
+		}
+	}
+
+	i=sprintf(buf,"\n");
+	out->write(buf,i);
+
+	i=sprintf(buf,"#endif /* _DEBUG */\n");
+	out->write(buf,i);
+#endif
+}
+
+
+boolean RHBheader_emitter::op_is_varg(RHBoperation *op)
+{
+	char buf[256];
+
+	if (!op) return 0;
+
+	RHBelement *el=op->children();
+	
+	RHBparameter *last_param=NULL;
+
+	if (!el) return 0;
+
+	while (el)
+	{
+		if (el->is_parameter())
+		{
+			last_param=el->is_parameter();
+		}
+
+		el=el->next();
+	}
+
+	if (!last_param) 
+	{
+		return 0;
+	}
+
+	if (strcmp(last_param->id,"ap"))
+	{
+		return 0;
+	}
+
+	get_c_name(last_param->parameter_type,buf,sizeof(buf));
+
+	if (strcmp(buf,"va_list"))
+	{
+		return 0;
+	}
+
+/*	get_c_name(op,buf);
+
+	printf("%s is varg op\n",buf);
+*/
+	return 1;
+}
+
+RHBelement *RHBheader_emitter::generate_va_proto(RHBoutput *out,RHBinterface *iface,RHBoperation *op,int nest,int flag,const char *prefix)
+{
+	char n[256];
+	RHBtype *t;
+	RHBelement *el;
+	RHBelement *penultimate=0;
+	const char *linkage=flag ? "SOMLINK" : "";
+
+	get_c_name(iface,n,sizeof(n));
+
+	t=op->return_type;
+
+	if (t)
+	{
+		use_type(out,t,0);
+	}
+	else
+	{
+		out_printf(out,"void ");
+	}
+
+	out_printf(out,"%s %s_%s_%s",linkage,prefix,n,op->id);
+
+	get_c_name(iface,n,sizeof(n));
+	out_printf(out,"(%s SOMSTAR somSelf,",n);
+
+	if (operation_needs_environment(iface,op))
+	{
+		out_printf(out,"Environment *ev,");
+	}
+
+	if (operation_needs_context(iface,op))
+	{
+		out_printf(out,"Context SOMSTAR ctx,");
+	}
+
+	out_printf(out,"\n");
+
+	el=op->children();
+
+	while (el->next())
+	{
+		RHBparameter *param=el->is_parameter();
+
+		if (param)
+		{
+			RHBelement *e2=NULL;
+			RHBparameter *another=NULL;
+
+			e2=param->next();
+
+			while (e2)
+			{
+				if (e2->is_parameter())
+				{
+					another=e2->is_parameter();
+				}
+
+				e2=e2->next();
+			}
+
+			if (!another) break;
+
+			penultimate=param;
+
+			dump_nest(out,nest+2);
+
+			use_type(out,param->parameter_type,0);
+
+			if (parameter_by_reference(param,NULL))
+			{
+				out_printf(out,"*");
+			}
+
+			out_printf(out,"%s,\n",param->id);
+		}
+
+		el=el->next();
+	}
+
+	dump_nest(out,nest+2);
+	out_printf(out,"...)");
+
+	return penultimate;
+}
+
+void RHBheader_emitter::generate_va_stub(RHBoutput *out,RHBinterface *iface,RHBoperation *op,int nest,int flags,const char *prefix)
+{
+	char n[256];
+	RHBelement *el;
+	RHBelement *penultimate;
+	int do_macros=(flags & 2) ? 0 : 1;
+
+	flags&=~2;
+
+	if (!prefix)
+	{
+		prefix=flags ? "somva" : "va";
+	}
+
+	get_c_name(iface,n,sizeof(n));
+
+	if (do_macros)
+	{
+		dump_nest(out,nest);
+		out_printf(out,"#ifdef %s_VA_EXTERN\n",n);
+
+		/* need to prototype the va function when it is not static... */
+
+		dump_nest(out,nest+1);
+		out_printf(out,"SOMEXTERN\n");
+
+		if (iface->has_modifier_value("dllname"))
+		{
+			get_c_name(iface,n,sizeof(n));
+dump_nest(out,nest+1);
+			out_printf(out,"#ifdef %s_VA_STUBS\n",n);
+dump_nest(out,nest+2);
+			out_printf(out,"#ifdef SOMDLLEXPORT\n");
+dump_nest(out,nest+3);
+			out_printf(out,"SOMDLLEXPORT\n");
+dump_nest(out,nest+2);
+			out_printf(out,"#endif /* SOMDLLEXPORT */\n");
+dump_nest(out,nest+1);
+			out_printf(out,"#else\n");
+			ifdef_import_export(out,iface,nest+2);
+dump_nest(out,nest+1);
+			out_printf(out,"#endif /* %s_VA_STUBS */\n",n);
+		}
+
+		dump_nest(out,nest+1);
+
+		generate_va_proto(out,iface,op,nest,flags,prefix);
+		
+		out_printf(out,";\n");
+
+		dump_nest(out,nest);
+		out_printf(out,"#endif\n");
+	}
+
+	int final_endif=0;
+
+	if (do_macros)
+	{
+		final_endif=1;
+		dump_nest(out,nest);
+		get_c_name(iface,n,sizeof(n));
+		out_printf(out,"#if (defined(%s_VA_STUBS)||!defined(%s_VA_EXTERN))\n",
+				n,n);
+	}
+
+	if (do_macros)
+	{
+		dump_nest(out,nest+1);
+
+		get_c_name(iface,n,sizeof(n));
+		out_printf(out,"#ifdef %s_VA_EXTERN\n",n);
+
+		dump_nest(out,nest+2);
+		out_printf(out,"SOMEXTERN\n");
+
+		dump_nest(out,nest+1);
+		out_printf(out,"#else\n");
+	}
+
+	dump_nest(out,nest+2);
+	out_printf(out,"static\n");
+
+	if (do_macros)
+	{
+		dump_nest(out,nest+1);
+		out_printf(out,"#endif\n");
+	}
+
+	dump_nest(out,nest+1);
+
+	penultimate=generate_va_proto(out,iface,op,nest+1,flags,prefix);
+
+	out_printf(out,"\n");
+
+	get_c_name(iface,n,sizeof(n));
+
+/*	if (do_macros)
+	{
+		get_c_name(iface,n,sizeof(n));
+		dump_nest(out,nest);
+		out_printf(out,"#if (defined(%s_VA_STUBS)||!defined(%s_VA_EXTERN))\n",
+				n,n);
+	}
+*/
+	dump_nest(out,nest+1);
+	out_printf(out,"{\n");
+
+	if (operation_has_return(op))
+	{
+		dump_nest(out,nest+2);
+		use_type(out,op->return_type,"__result");
+		out_printf(out,";\n");
+	}
+
+	dump_nest(out,nest+2);
+	out_printf(out,"va_list ap;\n");
+
+	dump_nest(out,nest+2);
+	out_printf(out,"va_start(ap,%s);\n",penultimate->id);
+
+	dump_nest(out,nest+2);
+	if (operation_has_return(op))
+	{
+		out_printf(out,"__result=");
+	}
+
+/*	i=sprintf(buf,"((somTD_%s_%s)somResolve\n",n,op->id);
+	out->write(buf,i);
+
+	get_c_name(op->parent(),n);
+	dump_nest(out,nest+2);
+	i=sprintf(buf,"(somSelf,%sClassData.%s))\n",n,op->id);
+	out->write(buf,i);
+*/
+	get_c_name(op->parent(),n,sizeof(n));
+	out_printf(out,"SOM_Resolve(somSelf,%s,%s)\n",n,op->id);
+
+	dump_nest(out,nest+4);
+	out_printf(out,"(somSelf,");
+
+	if (operation_needs_environment(iface,op))
+	{
+		out_printf(out,"ev,");
+	}
+
+	if (operation_needs_context(iface,op))
+	{
+		out_printf(out,"ctx,");
+	}
+
+	el=op->children();
+
+	while (el->next())
+	{
+		if (el->is_parameter())
+		{
+			out_printf(out,"%s,",el->id);
+		}
+
+		if (el==penultimate) break;
+
+		el=el->next();
+	}
+
+	out_printf(out,"ap);\n");
+
+	dump_nest(out,nest+2);
+	out_printf(out,"va_end(ap);\n");
+
+	if (operation_has_return(op))
+	{
+		dump_nest(out,nest+2);
+		out_printf(out,"return __result;\n");
+	}
+
+	dump_nest(out,nest+1);
+	out_printf(out,"}\n");
+
+/*	if (do_macros)
+	{
+		dump_nest(out,nest);
+		out_printf(out,"#else\n");
+
+		dump_nest(out,nest);
+		out_printf(out,";\n");
+
+		dump_nest(out,nest);
+		out_printf(out,"#endif\n");
+	}*/
+
+	if (final_endif)
+	{
+		dump_nest(out,nest);
+		out_printf(out,"#endif\n");
+	}
+}
+
+void RHBheader_emitter::generate_inline_varg_operation(RHBoutput *out,RHBinterface *iface,RHBoperation *op,int nest)
+{
+	char n[256];
+	RHBtype *t;
+	RHBelement *el;
+	RHBelement *ap=NULL;
+	RHBelement *penult=NULL;
+
+	const char *result_name="_somC_result";
+
+	el=op->children();
+
+	while (el)
+	{
+		if (el->is_parameter())
+		{
+			ap=el->is_parameter();
+		}
+
+		el=el->next();
+	}
+
+	el=op->children();
+
+	while (el)
+	{
+		if (el->is_parameter())
+		{
+			if (el==ap) break;
+
+			penult=el;
+		}
+
+		el=el->next();
+	}
+
+	get_c_name(op,n,sizeof(n));
+/*	i=sprintf(buf,"\n",n);
+	out->write(buf,i);*/
+
+	dump_nest(out,nest);
+	out_printf(out,"inline ");
+	t=op->return_type;
+	if (t)
+	{
+		use_type(out,t,0);
+	}
+	else
+	{
+		out_printf(out,"void ");
+	}
+
+	out_printf(out,"%s(",op->id);
+
+	if (operation_needs_environment(iface,op))
+	{
+		out_printf(out,"Environment *ev,");
+	}
+
+	if (operation_needs_context(iface,op))
+	{
+		out_printf(out,"Context * ctx,");
+	}
+
+	out_printf(out,"\n");
+
+	el=op->children();
+
+	while (el)
+	{
+		RHBparameter *param=el->is_parameter();
+
+		if (param)
+		{
+			dump_nest(out,nest+2);
+
+			use_type(out,param->parameter_type,0);
+
+			if (parameter_by_reference(param,NULL))
+			{
+				out_printf(out,"*");
+			}
+
+			out_printf(out,"%s,\n",param->id);
+
+			if (param==penult) break;
+		}
+
+		el=el->next();
+	}
+
+	dump_nest(out,nest+2);
+	out_printf(out,"...)\n");
+
+	dump_nest(out,nest);
+	out_printf(out,"{\n");
+
+	if (operation_has_return(op))
+	{
+		dump_nest(out,nest+1);
+		use_type(out,op->return_type,result_name);
+		out_printf(out,";\n");
+	}
+
+	dump_nest(out,nest+1);
+	out_printf(out,"va_list ap;\n");
+
+	dump_nest(out,nest+1);
+	out_printf(out,"va_start(ap,%s);\n",penult->id);
+
+	dump_nest(out,nest+1);
+	if (operation_has_return(op))
+	{
+		out_printf(out,"%s=",result_name);
+	}
+
+/*	get_c_name(iface,n);
+	i=sprintf(buf,"((somTD_%s_%s)somResolve\n",n,op->id);
+	out->write(buf,i);
+
+	get_c_name(op->parent(),n);
+	dump_nest(out,nest+2);
+	i=sprintf(buf,"((SOMObject *)(void *)this,%sClassData.%s))\n",n,op->id);
+	out->write(buf,i);
+*/
+	get_c_name(op->parent(),n,sizeof(n));
+	out_printf(out,"SOM_Resolve(this,%s,%s)\n",n,op->id);
+
+/*	get_c_name(iface,n);*/
+	get_c_name(op->parent(),n,sizeof(n));
+	dump_nest(out,nest+3);
+	out_printf(out,"((%s *)(void *)this,",n);
+
+	if (operation_needs_environment(iface,op))
+	{
+		out_printf(out,"ev,");
+	}
+
+	if (operation_needs_context(iface,op))
+	{
+		out_printf(out,"ctx,");
+	}
+
+	el=op->children();
+
+	while (el)
+	{
+		if (el->is_parameter())
+		{
+			out_printf(out,"%s,",el->id);
+			if (el==penult) break;
+		}
+
+		el=el->next();
+	}
+
+	out_printf(out,"ap);\n");
+
+	dump_nest(out,nest+1);
+	out_printf(out,"va_end(ap);\n");
+
+	if (operation_has_return(op))
+	{
+		dump_nest(out,nest+1);
+		out_printf(out,"return %s;\n",result_name);
+	}
+
+	dump_nest(out,nest);
+	out_printf(out,"};\n");
+}
+
+void RHBheader_emitter::generate_inline_somNew_operation(RHBoutput *out,RHBinterface *iface,RHBoperation * /*op */,int nest)
+{
+	char n[256];
+	RHBinterface *base=find_highest_common_parent(&iface->_metaclass_of);
+
+	nest++;
+
+	if (base)
+	{
+		get_c_name(base,n,sizeof(n));
+	}
+	else
+	{
+		strncpy(n,"SOMObject",sizeof(n));
+	}
+
+	dump_nest(out,nest);
+	out_printf(out,"inline %s * somNew()\n",n);
+
+	dump_nest(out,nest);
+	out_printf(out,"{\n");
+
+	dump_nest(out,nest+1);
+	out_printf(out,"return (%s *)(void *)SOM_Resolve(this,SOMClass,somNew)\n",n);
+
+	dump_nest(out,nest+2);
+	out_printf(out,"((SOMClass *)(void *)this);\n");
+
+	dump_nest(out,nest);
+	out_printf(out,"}\n");
+}
+
+RHBinterface *RHBheader_emitter::find_highest_common_parent(RHBelement_sequence *seq)
+{
+	RHBinterface *ret=seq->get(0)->is_interface();
+	size_t i=seq->length();
+
+	while (i--)
+	{
+		RHBinterface *iface=seq->get(i)->is_interface();
+
+		if (!iface->is_subclass_of(ret))
+		{
+			unsigned long j=0;
+
+			while (j < iface->_parents.length())
+			{
+				i=0;
+
+				ret=iface->_parents.get(j)->is_interface();
+
+				while (i < seq->length())
+				{
+					i++;
+
+					if (!seq->get(i)->is_interface()->is_subclass_of(ret))
+					{
+						ret=0;
+						i=seq->length();
+					}
+				}
+
+				j++;
+
+				if (ret) j=iface->_parents.length();
+			}
+
+			i=seq->length();
+		}
+	}
+
+	return ret;
+}
+
+boolean RHBheader_emitter::is_multiple_inherited(RHBinterface *iface)
+{
+	if (iface)
+	{
+		switch (iface->_parents.length())
+		{
+		case 0:
+			return 0;
+		case 1:
+			return is_multiple_inherited(iface->_parents.get(0)->is_interface());
+		default:
+			return 1;
+		}
+	}
+
+	return 0;
+}
+
+void RHBheader_emitter::generate_name_lookups(RHBoutput *out,RHBinterface *iface,int nest)
+{
+	RHBelement *e=iface->children();
+
+	while (e)
+	{
+		RHBoperation *op=e->is_operation();
+
+		if (op)
+		{
+			generate_name_lookup(out,iface,op,nest);
+		}
+
+		e=e->next();
+	}
+
+	if (cplusplus)
+	{
+		RHBelement_sequence seq;
+		unsigned long i=0;
+
+		determine_inherited(iface,iface,&seq);
+
+		while (i < seq.length())
+		{
+			RHBoperation *op=seq.get(i)->is_operation();
+			generate_name_lookup(out,iface,op,nest);
+			i++;
+		}
+	}
+}
+
+void RHBheader_emitter::generate_name_lookup(RHBoutput *out,RHBinterface *iface,RHBoperation *op,int nest)
+{
+	if (op->has_modifier_value("namelookup"))
+	{
+		char n[256];
+
+		dump_nest(out,nest);
+		get_c_name(iface,n,sizeof(n));
+		out_printf(out,"#ifndef %s_lookup_%s\n",
+				n,op->id);
+
+		dump_nest(out,nest+1);
+		out_printf(out,"#define %s_lookup_%s",n,op->id);
+
+		generate_name_only_parameter_list(out,iface,op,0);
+
+		get_c_name(iface,n,sizeof(n));
+		if (cplusplus)
+		{
+			out_printf(out,
+				" ((somTD_%s_%s)somResolveByName((SOMObject *)(void *)somSelf,%c%s%c))",
+				n,op->id,double_quote,op->id,double_quote);
+		}
+		else
+		{
+			out_printf(out,
+				" ((somTD_%s_%s)somResolveByName(somSelf,%c%s%c))",
+				n,op->id,double_quote,op->id,double_quote);
+		}
+
+		generate_name_only_parameter_list(out,iface,op,0);
+
+		out_printf(out,"\n");
+		
+		dump_nest(out,nest+1);
+		out_printf(out,"#ifndef lookup_%s\n",op->id);
+
+		get_c_name(iface,n,sizeof(n));
+		dump_nest(out,nest+2);
+		out_printf(out,"#define lookup_%s %s_lookup_%s\n",
+					op->id,n,op->id);
+
+		dump_nest(out,nest+1);
+		out_printf(out,"#endif /* lookup_%s */\n",op->id);
+
+		dump_nest(out,nest);
+		out_printf(out,"#endif /* %s_lookup_%s */\n",n,op->id);
+	}
+}
+
+void RHBheader_emitter::gen_shortname_sequence(RHBoutput *out,RHBtype *type,int nest)
+{
+	char n[256];
+
+	get_c_name(type,n,sizeof(n));
+
+	if (!type->id) return;
+	if (!n[0]) return;
+
+	if (!strcmp(n,type->id))
+	{
+		return;
+	}
+
+	dump_nest(out,nest);
+	out_printf(out,"#ifndef SOM_DONT_USE_SHORT_NAMES\n");
+
+	dump_nest(out,nest+1);
+	out_printf(out,"#ifndef _IDL_SEQUENCE_%s_defined\n",type->id);
+
+	dump_nest(out,nest+2);
+	out_printf(out,"#define _IDL_SEQUENCE_%s_defined\n",type->id);
+
+
+	dump_nest(out,nest+2);
+	out_printf(out,"#define _IDL_SEQUENCE_%s _IDL_SEQUENCE_%s\n",
+				type->id,n);
+
+	dump_nest(out,nest+1);
+	out_printf(out,"#endif /* _IDL_SEQUENCE_%s_defined */\n",type->id);
+
+	dump_nest(out,nest);
+	out_printf(out,"#endif /* SOM_DONT_USE_SHORT_NAMES */\n");
+}
+
+int RHBheader_emitter::get_cif(RHBinterface *iface,char *buf,size_t buflen)
+{
+	RHBelement *el;
+	char n[256];
+
+	strncpy(n,"classinit",sizeof(n));
+	buf[0]=0;
+
+	el=iface->find_named_element(0,n,sizeof(n));
+
+	if (el)
+	{
+		const char *p=el->modifier_data.get(0);
+		char cif[256]={0};
+		char *q=cif;
+
+		if (p)
+		{
+			while (*p)
+			{
+				if (*p!=double_quote)
+				{
+					*q++ = *p;
+				}
+				p++;
+			}
+
+			*q=0;
+		}
+
+		get_function_prefix(iface,buf,buflen);
+		strncat(buf,cif,buflen);
+
+		return 1;
+	}
+
+	*buf=0;
+
+	return 0;
+}
+
+boolean RHBheader_emitter::is_derived_from(RHBinterface *iface,RHBinterface *base)
+{
+	if (base)
+	{
+		unsigned long i=0;
+
+		if (base==iface) return 1;
+
+		while (i < iface->_parents.length())
+		{
+			if (is_derived_from(iface->_parents.get(i)->is_interface(),base))
+			{
+				return 1;
+			}
+
+			i++;
+		}
+	}
+
+	return 0;
+}
+
+int RHBheader_emitter::generate_parent_resolved(RHBoutput *out,
+												RHBinterface *iface,
+												RHBinterface *parent,
+												RHBoperation *op,
+												int mode)
+{
+	int retVal=0;
+
+	if (iface 
+		&& parent 
+		&& op 
+		&& 
+		strcmp(op->id,"somInit") && 
+		strcmp(op->id,"somUninit") &&
+		strcmp(op->id,"somDestruct"))
+	{
+		if (!op->has_modifier_value("init"))
+		{
+			if (does_override(iface,op->id))
+			{
+				if (is_derived_from(parent,op->parent()->is_interface()))
+				{
+					retVal=get_parent_index(iface,parent);
+
+					if (retVal)
+					{
+						char tokenName[1024];
+						char name[256],parent_name[256];
+
+						get_c_name(iface,name,sizeof(name));
+						get_c_name(parent,parent_name,sizeof(parent_name));
+
+						snprintf(tokenName,sizeof(tokenName),"_somC_%s_parent_%s_%s_resolved",
+									name,parent_name,op->id);
+
+						switch (mode)
+						{
+						case 1:
+							out_printf(out,"static somMethodPtr %s; /* %d */\n",tokenName,retVal);
+							break;
+						case 2:
+							get_c_name(op->parent(),parent_name,sizeof(parent_name));
+							out_printf(out,"\t%s=somParentNumResolve(%sCClassData.parentMtab,%d,%sClassData.%s);\n",
+									tokenName,
+									name,
+									retVal,
+									parent_name,
+									op->id);
+							break;
+						case 3:
+							out_printf(out,"%s",tokenName);
+							break;
+						default:
+							retVal=0;
+							break;
+						}
+					}
+				}
+			}
+		}
+	}
+
+	return retVal;
+}
+
+int RHBheader_emitter::is_kernel_class(RHBinterface *k)
+{
+	char buf[256];
+	get_c_name(k,buf,sizeof(buf));
+	if (strcmp(buf,"SOMObject")&&
+		strcmp(buf,"SOMClass")&&
+		strcmp(buf,"SOMClassMgr"))
+	{
+		return 0;
+	}
+	return 1;
+}
+
+int RHBheader_emitter::count_ClassData(RHBinterface *p)
+{
+	int count=0;
+
+	if (p)
+	{
+		if (p->classData)
+		{
+			RHBelement *el=p->classData->children();
+
+			while (el)
+			{
+				if (strcmp(el->id,"classObject"))
+				{
+					count++;
+				}
+
+				el=el->next();
+			}
+		}
+	}
+
+	return count;
+}
+
+int RHBheader_emitter::get_init_operations(RHBinterface *iface,RHBelement_sequence *seq)
+{
+	RHBelement *el=iface->classData->children();
+
+	while (el)
+	{
+		RHBelement *e2=iface->children();
+
+		while (e2)
+		{
+			if (!strcmp(e2->id,el->id))
+			{
+				RHBoperation *op=e2->is_operation();
+
+				if (op)
+				{
+					if (op->has_modifier_value("init"))
+					{
+						seq->add(op);
+					}
+				}
+			}
+
+			e2=e2->next();
+		}
+
+		el=el->next();
+	}
+
+	return seq->length();
+}
+
+int RHBheader_emitter::get_va_operations(RHBinterface *iface,RHBelement_sequence *seq)
+{
+	char buf[256];
+
+	strncpy(buf,"releaseorder",sizeof(buf));
+
+	RHBelement *e=iface->find_named_element(0,buf,sizeof(buf));
+
+	if (e)
+	{
+		int i=0;
+
+		while (e->modifier_data.get(i))
+		{
+			const char *p=e->modifier_data.get(i);
+			i++;
+
+			if (strcmp(p,","))
+			{
+				RHBelement *oe;
+
+				strncpy(buf,p,sizeof(buf));
+
+				oe=iface->find_named_element(0,buf,sizeof(buf));
+
+				if (oe) 
+				{
+					RHBoperation *op=oe->is_operation();
+
+					if (op && op_is_varg(op))
+					{
+						seq->add(op);
+					}
+				}
+			}
+		}
+	}
+
+	return seq->length();
+}
+
+typedef enum
+{
+	dts_destructor,dts_constructor,dts_assignment
+} dts_override_type;
+
+struct dts_override
+{
+	dts_override_type dts_type;
+	const char *name;
+	const char *initType;
+	const char *member;
+	const char *structInfo;
+	const char *macro;
+	const char *mtab;
+	const char *structCtrl;
+};
+
+static struct dts_override dts_overrides[]={
+	{dts_destructor,
+		"somDestruct","Destructor","defaultDestruct",
+		"somDestructInfo","DeInit","destructCtrl","somDestructCtrl"},
+	{dts_constructor,
+		"somDefaultInit","Initializer","defaultInit",
+		"somInitInfo","Init","initCtrl","somInitCtrl"},
+	{dts_assignment,
+		"somDefaultAssign","AssignmentOp","defaultNCArgAssign",
+		"somAssignInfo","Assign","assignCtrl","somAssignCtrl"},
+	{dts_assignment,
+		"somDefaultConstAssign","AssignmentOp","defaultConstAssign",
+		"somAssignInfo","Assign","assignCtrl","somAssignCtrl"}
+};
+
+struct dts_override * RHBheader_emitter::is_dts_override(RHBoperation *op)
+{
+	int i=sizeof(dts_overrides)/sizeof(dts_overrides[0]);
+	struct dts_override *s=dts_overrides;
+	while (i--)
+	{
+		if (!strcmp(s->name,op->id)) return s;
+		s++;
+	}
+	return 0;
+}
+
+void RHBheader_emitter::write_macro_args(RHBoutput *out,RHBoperation *op,int include_somSelf)
+{	
+	if (include_somSelf) 
+	{
+		out_printf(out,"(somSelf");
+	}
+
+	if (operation_needs_environment(op->parent()->is_interface(),op))
+	{
+		out_printf(out,",ev");
+	}
+
+	if (operation_needs_context(op->parent()->is_interface(),op))
+	{
+		out_printf(out,",ctx");
+	}
+
+	RHBelement *el=op->children();
+
+	while (el)
+	{
+		RHBparameter *param=el->is_parameter();
+
+		if (param)
+		{
+			out_printf(out,",%s",param->id);
+		}
+
+		el=el->next();
+	}
+
+	out_printf(out,")");
+}
+
+void RHBheader_emitter::dts_parent_macro(RHBoutput *out,RHBinterface *iface,int num,RHBinterface *parent,RHBoperation *op,int /* nest */)
+{
+	struct dts_override *dts=is_dts_override(op);
+	char n[256],m[256],o[256],objcls[256];
+	int parent_is_SOMObject;
+	const char *somstar=cplusplus ? "*" : "SOMSTAR";
+
+	get_c_name(iface,n,sizeof(n));
+	get_c_name(parent,m,sizeof(m));
+	get_c_name(op,o,sizeof(o));
+	get_c_name(op->parent(),objcls,sizeof(objcls));
+
+	parent_is_SOMObject=strcmp(m,"SOMObject") ? 0 : 1;
+
+#if 0
+	if (parent_is_SOMObject)
+	{
+		out_printf(out,"/* special case SOMObject */ \\\n");
+	}
+#endif
+
+	{
+		int parent_count=iface->_parents.length();
+		out_printf(out,"#define %s_%s_%s_%s",n,dts->macro,m,op->id);
+		write_macro_args(out,op,1);
+		out_printf(out,"\\\n");
+
+		if (dts->dts_type==dts_destructor)
+		{
+			/* destructor in reverse order */
+			out_printf(out,"if (myMask[%d]&1) {\\\n",(parent_count-num-1));
+		}
+		else
+		{
+			out_printf(out,"if (myMask[%d]&1) {\\\n",num);
+		}
+
+#ifdef _DEBUG
+		out_printf(out,
+			"SOM_Assert(ctrl->info->cls==%sClassData.classObject,SOM_Fatal); \\\n",
+			m);
+#endif
+
+		if (parent_is_SOMObject)
+		{
+			out_printf(out,"ctrl->info=(%s *)(ctrl->infoSize+(char *)ctrl->info); \\\n",dts->structInfo);
+		}
+		else
+		{
+			out_printf(out,"((somTD_%s)ctrl->info->%s) \\\n",
+						o,dts->member);
+
+			if (cplusplus)
+			{
+				out_printf(out,"(((%s %s)(void *)somSelf)",objcls,somstar);
+			}
+			else
+			{
+				out_printf(out,"(somSelf");
+			}
+
+			write_macro_args(out,op,0);
+			out_printf(out,"; \\\n");
+		}
+		out_printf(out,"}\n");
+	}
+}
+
+static void union_of_dts_ops(RHBheader_emitter *emitter,RHBinterface *iface,RHBelement_sequence *seq)
+{
+	int i=iface->_parents.length();
+	while (i--)
+	{
+		union_of_dts_ops(emitter,iface->_parents.get(i)->is_interface(),seq);
+	}
+	RHBelement *el=iface->children();
+	while (el)
+	{
+		RHBoperation *op=el->is_operation();
+
+		if (op)
+		{
+			if (emitter->is_dts_override(op))
+			{
+				i=seq->length();
+				while (i--)
+				{
+					if (seq->get(i)==op)
+					{
+						break;
+					}
+				}
+				if (i < 0)
+				{
+					seq->add(op);
+				}
+			}
+		}
+
+		el=el->next();
+	}
+}
+
+void RHBheader_emitter::generate_dts_macros(RHBoutput *out,RHBinterface *iface)
+{
+RHBelement_sequence seq;
+const int num_parents=iface->_parents.length();
+int done_destructor=0,done_assignment=0;
+
+	union_of_dts_ops(this,iface,&seq);
+
+	int it=seq.length();
+
+	while (it--)
+	{
+		RHBoperation *op=seq.get(it)->is_operation();
+
+		if (op)
+		{
+			if (does_override(iface,op->id))
+			{
+				struct dts_override *dts=is_dts_override(op);
+
+				if (dts)
+				{
+					switch (dts->dts_type)
+					{
+					case dts_destructor:
+						if (done_destructor)
+						{
+							dts=NULL;
+						}
+						else
+						{
+							done_destructor=1;
+						}
+						break;
+					case dts_assignment:
+						if (done_assignment)
+						{
+							dts=NULL;
+						}
+						else
+						{
+							done_assignment=1;
+						}
+						break;
+					default:
+						break;
+					}
+				}
+
+				if (dts)
+				{
+					out_printf(out,"/* special macros for %s */\n",op->id);
+					char n[256];
+					char macro_name[1024]={0};
+
+					get_c_name(iface,n,sizeof(n));
+
+					switch (dts->dts_type)
+					{
+					case dts_destructor:
+					case dts_assignment:
+						snprintf(macro_name,sizeof(macro_name),"%s_Begin%s",
+								n,
+								dts->initType);
+						break;
+					default:
+						snprintf(macro_name,sizeof(macro_name),"%s_Begin%s_%s",
+								n,
+								dts->initType,op->id);
+						break;
+					}
+
+					out_printf(out,"#ifndef %s\n",macro_name); 
+					out_printf(out,"#define %s \\\n",macro_name); 
+
+
+					{
+						out_printf(out,"if (!ctrl) { \\\n"); 
+						out_printf(out,"ctrl=&globalCtrl; \\\n"); 
+						out_printf(out,
+							"memcpy(ctrl,&(((somParentMtabStructPtr)(void *)%sCClassData.parentMtab)->%s),sizeof(%s)); \\\n",
+							n,dts->mtab,dts->structCtrl);
+						out_printf(out,"} \\\n"); 
+#ifdef _DEBUG
+						if (dts->dts_type==dts_destructor)
+						{
+/*							i=sprintf(buf,"somPrintf(\"%s_BeginDestructor\\n\"); \\\n",n);
+							out->write(buf,i);*/
+						}
+						out_printf(out,"SOM_Assert(ctrl->info->cls==%sClassData.classObject,SOM_Fatal); \\\n",n);
+#endif
+						if (iface->instanceData && iface->instanceData->children())
+						{
+							out_printf(out,"somThis=(%sData*)(((char *)somSelf)+ctrl->info->dataOffset); \\\n",n);
+#ifdef _DEBUG
+							out_printf(out,"SOM_Assert(somThis==%sGetData(somSelf),SOM_Fatal); \\\n",n);
+#endif
+						}
+
+						if (dts->dts_type==dts_destructor)
+						{
+							out_printf(out,"myMask=ctrl->mask; \n");
+						}
+						else
+						{
+							out_printf(out,"myMask=ctrl->mask; \\\n");
+
+							if (num_parents)
+							{
+								out_printf(out,"ctrl->mask+=%d; \\\n",num_parents);
+							}
+
+							out_printf(out,"ctrl->info=(%s *)(ctrl->infoSize+(char*)(ctrl->info));\n",
+									dts->structInfo);
+						}
+					}
+
+					if (dts->dts_type==dts_destructor)
+					{
+						out_printf(out,"#define %s_EndDestructor \\\n",n);
+#ifdef _DEBUG
+/*						i=sprintf(buf,"somPrintf(\"%s_EndDestructor\\n\"); \\\n",n);
+						out->write(buf,i);*/
+#endif
+						out_printf(out,"ctrl->info=(%s *)(ctrl->infoSize+(char *)ctrl->info); \\\n",
+								dts->structInfo);
+						if (num_parents)
+						{
+							out_printf(out,"ctrl->mask+=%d; \\\n",num_parents);
+						}
+
+						int k=num_parents;
+						while (k--)
+						{
+							RHBinterface *parent=iface->_parents.get(k)->is_interface();
+							char m[256];
+							get_c_name(parent,m,sizeof(m));
+							out_printf(out,"%s_%s_%s_%s(somSelf,0,ctrl); \\\n",n,dts->macro,m,op->id);
+						}
+
+						if (cplusplus)
+						{
+							out_printf(out,
+								"if (doFree) (*((somMethodTabPtr *)(void *)somSelf))->classObject->somDeallocate((somToken)(void *)somSelf);\n");
+						}
+						else
+						{
+							out_printf(out,
+								"if (doFree) SOMClass_somDeallocate(somSelf->mtab->classObject,somSelf);\n");
+						}
+					}
+
+					out_printf(out,"#endif /* %s */\n",macro_name); 
+
+				}
+			}
+		}
+	}
+}
+
+void RHBheader_emitter::undoublebar(RHBoutput *out,const char *n)
+{
+	if (cplusplus)
+	{
+		int x=strlen(n);
+		int do_dd=0;
+
+		if (x > 2)
+		{
+			const char *p=n;
+
+			x-=2;
+
+			while (x--)
+			{
+				if ((*p++)=='_')
+				{
+					if (*p=='_')
+					{
+						do_dd=1;
+
+						break;
+					}
+				}
+			}
+		}
+
+		if (do_dd)
+		{
+			char buf[1024];
+			char *p=buf;
+			const char *q=n;
+
+			while (*q)
+			{
+				if (*q=='_')
+				{
+					*p++=*q++;
+					if (*q=='_')
+					{
+						*p++='s';
+						*p++='o';
+						*p++='m';
+						*p++='C';
+					}
+				}
+				else
+				{
+					*p++=*q++;
+				}
+			}
+
+			*p=0;
+
+			if (strcmp(buf,n))
+			{
+				const char *gm="SOM_AVOID_DOUBLE_UNDERSCORES";
+				out_printf(out,"#ifdef %s\n",gm);
+				out_printf(out,"\t#ifdef %s\n",n);
+				out_printf(out,"\t\t#error %s already defined\n",n);
+				out_printf(out,"\t#else /* %s */\n",n);
+				out_printf(out,"\t\t#define %s %s\n",n,buf);
+				out_printf(out,"\t#endif /* %s */\n",n);
+				out_printf(out,"#endif /* %s */\n",gm);
+			}
+		}
+	}
+}
+
+boolean RHBheader_emitter::do_const_param(RHBparameter *param)
+{
+	if (cplusplus && param)
+	{
+#if 0
+		if (strcmp(param->mode,"in")) return 0;
+
+		RHBtype *typ=unwind_typedef(param->parameter_type);
+		if (!typ) return 0;
+
+		typ=unwind_typedef(typ);
+
+		if (typ->is_pointer()) return 0;
+		if (typ->is_array()) return 0;
+
+		if (parameter_by_reference(param,NULL)) return 1;
+		if (typ->is_struct()) return 1;
+		if (typ->is_union()) return 1;
+		if (some_ABI_kind_of_pointer(typ)) return 1;
+		if (type_is_any(typ)) return 1;
+#endif
+	}
+
+	return 0;
+}
+
diff -urN somfree\somipc2\src\rhbscpp.cpp newsomfree3\somipc2\src\rhbscpp.cpp
--- somfree\somipc2\src\rhbscpp.cpp	Thu Jan 01 07:00:00 1970
+++ newsomfree3\somipc2\src\rhbscpp.cpp	Sat Mar 16 14:09:27 2024
@@ -0,0 +1,744 @@
+/**************************************************************************
+ *
+ *  Copyright 1998-2010, Roger Brown
+ *
+ *  This file is part of Roger Brown's Toolkit.
+ *
+ *  This program is free software: you can redistribute it and/or modify it
+ *  under the terms of the GNU Lesser General Public License as published by the
+ *  Free Software Foundation, either version 3 of the License, or (at your
+ *  option) any later version.
+ * 
+ *  This program is distributed in the hope that it will be useful, but WITHOUT
+ *  ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ *  FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for
+ *  more details.
+ *
+ *  You should have received a copy of the GNU Lesser General Public License
+ *  along with this program.  If not, see <http://www.gnu.org/licenses/>
+ *
+ */
+ 
+/* 
+ * $Id: rhbscpp.cpp 2 2013-01-10 05:54:51Z somtoolkit $
+ */
+
+#include <rhbopt.h>
+/* pre-processor */
+
+#include <stdio.h>
+#include <string.h>
+#include <stdlib.h>
+
+#include <rhbsc.h>
+
+RHBStream::RHBStream()
+{
+}
+
+RHBStream::~RHBStream()
+{
+}
+
+RHBFile::RHBFile(int _argc,char **_argv,FILE *fpIn) :
+argc(_argc),
+argv(_argv),
+fp(NULL)
+{
+	un_got=0;
+	filename[0]=0;
+	line_number=1;
+
+	if (argc)
+	{
+		const char *name=*argv++;
+		argc--;
+
+		fp=fopen(name,"r");
+
+		if (fp)
+		{
+			strncpy(filename,name,sizeof(filename));
+		}
+		else
+		{
+			fprintf(stderr,"failed to open \"%s\"\n",name);
+			exit(1);
+		}
+	}
+	else
+	{
+		fp=fpIn;
+	}
+
+	incl=0;
+
+#ifdef _WIN32
+	if (!fp) bomb("missing file");
+#endif
+
+/*	if (fp) printf("--%s--\n",name);*/
+}
+
+RHBPreprocessor::RHBPreprocessor()
+{
+	scope=0;
+	error_count=0;
+	emit_root=RHBshould_emit_default;
+	lText=0;
+	stream_level=0;
+	in_text=0;
+	includes=new RHBinclude_list(this,"include");
+}
+
+int RHBPreprocessor::get_next_token(char *buf)
+{
+	char c;
+
+	while (currStream())
+	{
+		c=currStream()->get_char();
+
+		if (lText)
+		{
+			if (isalnum(c) || (c=='_'))
+			{
+				text[lText]=c;
+				lText++;
+			}
+			else
+			{
+				currStream()->un_get(c);
+				break;
+			}
+		}
+		else
+		{
+			if (isalnum(c) || (c=='_'))
+			{
+				text[lText]=c;
+				lText++;
+			}
+			else
+			{
+				if ((c=='*')||
+					(c==';')||
+					(c==':')||
+					(c==',')||
+					(c=='.')||
+					(c=='=')||
+					(c=='{')||
+					(c=='}')||
+					(c=='[')||
+					(c==']')||
+					(c=='>')||
+					(c=='<')||
+					(c=='(')||
+					(c==')')||
+					(c=='+')||
+					(c=='&')||
+					(c=='|')||
+					(c=='!')||
+					(c=='-'))
+				{
+					text[lText]=c;
+					lText++;
+
+					if (c==':') /* this was a change!! */
+					{
+						c=currStream()->get_char();
+
+						if (c==':')
+						{
+							text[lText]=c;
+							lText++;
+						}
+						else
+						{
+							currStream()->un_get(c);
+						}
+					}
+
+					break;
+				}
+				else
+				{
+					if (c=='#')
+					{
+						/* need special case here */
+
+						text[lText++]=c;
+					}
+					else
+					{
+						if (c=='\\')
+						{
+							if (in_text)
+							{
+								text[lText++]=c;
+							}
+							else
+							{
+								do
+								{
+									c=currStream()->get_char();
+
+								} while ((c!=0)&&(c!='\n')&&(c!='\r'));
+
+								currStream()->un_get(c);
+							}
+						}
+						else
+						{
+							if ((c==0x22)||(c==0x27))
+							{
+								int escape=0;
+
+								text[lText++]=c;
+
+								in_text++;
+
+								do
+								{
+									char d=currStream()->get_char();
+
+									if (!escape)
+									{
+										if (d=='\\')
+										{
+											escape=1;
+										}
+										else
+										{
+											if (d==c)
+											{
+												in_text--;
+											}
+
+											text[lText++]=d;
+										}
+									}
+									else
+									{
+										escape=0;
+										text[lText++]=d;
+									}
+
+
+								} while (in_text);
+
+								break;
+							}
+							else
+							{
+								if ((c=='/')&&(currStream()))
+								{
+									char c2=currStream()->get_char();
+
+									if (c2=='/')
+									{
+										while (currStream())
+										{
+											c=currStream()->get_char();
+
+											if ((c=='\r')||(c=='\n')) break;
+										}
+									}
+									else
+									{
+										currStream()->un_get(c2);
+
+										text[lText]=c;
+										lText++;
+
+										break;
+									}
+								}
+								else
+								{
+									if ((c==' ')||
+										(c=='\t')||
+										(c=='\r')||
+										(c=='\n')||
+										(c==0))
+									{
+									}
+									else
+									{
+#ifdef _WIN32
+										bomb("unexpected character");
+#endif
+										fprintf(stderr,"unexpected character %d\n",c);
+										exit(1);
+									}
+								}
+							}
+						}
+					}
+				}
+			}
+		}
+	}
+
+	memcpy(buf,text,lText);
+	buf[lText]=0;
+
+	int l=(int)lText;
+	lText=0;
+
+	return l;
+}
+
+char RHBFile::get_char()
+{
+	if (un_got)
+	{
+		char c=un_got;
+
+		un_got=0;
+#ifdef DEBUG_PP
+		printf("[%c]",c);
+#endif
+		return c;
+	}
+
+	while (fp)
+	{
+		char c=0;
+
+		if (fread(&c,1,1,fp))
+		{
+			if ((c=='\n')||(c=='\r'))
+			{
+				line_number++;
+			}
+
+#ifdef DEBUG_PP
+			printf("%c",c);
+
+			if (c=='|')
+			{
+				printf("<|>");
+			}
+#endif
+
+			return c;
+		}
+	
+		if (fp!=stdin)
+		{
+			fclose(fp);
+		}
+
+		fp=0;
+
+		if (argc)
+		{
+			const char *name=*argv++;
+			argc--;
+			fp=fopen(name,"r");
+
+			if (fp)
+			{
+				strncpy(filename,name,sizeof(filename));
+			}
+			else
+			{
+				fprintf(stderr,"failed to open \"%s\"\n",name);
+				exit(1);
+			}
+		}
+	}
+
+	return 0;
+}
+
+void RHBFile::un_get(char c)
+{
+	un_got=c;
+}
+
+int RHBFile::is_eof()
+{
+	if (un_got) return 0;
+	if (fp) return 0;
+	return 1;
+}
+
+char RHBPreprocessor::get_non_whitespace()
+{
+	char c;
+
+	c=currStream()->get_char();
+
+	switch (c)
+	{
+		case '\r':
+		case '\n':
+		case '\t':
+		case ' ':
+			c=0;
+	}
+		
+	return c;
+}
+
+int RHBPreprocessor::get_token(char *buf,size_t buflen)
+{
+	char b[1024]={0};
+#ifdef _WIN32
+	if (buflen==sizeof(buf))
+	{
+		bomb("maximum buffer size");
+	}
+#endif
+
+	buf[0]=0;
+
+	do
+	{
+		long l=get_next_token(b);
+
+		if (!l)
+		{
+			return 0;
+		}
+
+		if (b[0]!='#')
+		{
+			strncpy(buf,b,buflen);
+
+			return (int)l;
+		}
+		else
+		{
+			char *p=&b[1];
+
+			if ((!strcmp(p,"line")) || !*p)
+			{
+				char linenumber[256]={0};
+				char filename[1024]={0};
+				char optarg[64]={0};
+				char *fp=NULL;
+				int argc=0;
+				char quote=0;
+
+				b[0]=0;
+
+				/* filename within quotes,
+				   if has <> when make filename empty 
+				   only up to end of line */
+
+				while (currStream())
+				{
+					int c=currStream()->get_char();
+
+					if (c==EOF) break;
+
+					if ((c=='\r')||(c=='\n'))
+					{
+						break;
+					}
+
+					if (quote)
+					{
+						if (c==quote)
+						{
+							quote=0;
+							*fp=0;
+							fp=NULL;
+						}
+						else
+						{
+							*fp++=c;
+						}
+					}
+					else
+					{
+						if ((c=='\t')||(c==' '))
+						{
+							if (fp)
+							{
+								*fp=0;
+								fp=NULL;
+							}
+						}
+						else
+						{
+							if (fp)
+							{
+								*fp++=c;
+							}
+							else
+							{
+								switch (argc)
+								{
+								case 0: 
+									fp=linenumber; 
+									break;
+								case 1: 
+									fp=filename; 
+									break;
+								case 2: 
+									fp=optarg; 
+									break;
+								default: 
+									break;
+								}
+
+								argc++;
+
+								if (fp)
+								{
+									if ((c=='\"')||(c=='\''))
+									{
+										quote=c;
+									}
+									else
+									{
+										*fp++=c;
+									}
+								}
+							}
+						}
+					}
+				}
+
+				if (fp) 
+				{
+					*fp++=0;
+				}
+
+				switch (filename[0]) 
+				{
+				case '<':
+					filename[0]=0;
+					break;
+				case 0:
+					if (currStream())
+					{
+						RHBFile *f2=currStream()->is_file();
+						if (f2)
+						{
+							const char *p=f2->_get_filename();
+							if (p)
+							{
+								strncpy(filename,p,sizeof(filename));
+							}
+						}
+					}
+					break;
+				default:
+					break;
+				}
+
+				if (argc > 1)
+				{
+#ifdef _WIN32
+					char *p=filename;
+
+					while (*p)
+					{
+						if (*p=='~') 
+						{
+							bomb("tilde found");
+							break;
+						}
+						p++;
+					}
+
+/*					fprintf(stderr,"#### line \"%s\" file \"%s\" opt=\"%s\" ####\n",
+							linenumber,
+							filename,
+							optarg);*/
+#endif
+
+					RHBinclude_file *current=NULL;
+
+					if (currStream())
+					{
+						current=currStream()->File();
+					}
+
+					RHBinclude_file *f=includes->included(this,filename,current);
+
+					if (currStream())
+					{
+						RHBFile *f2=currStream()->is_file();
+
+						if (f2)
+						{
+							f2->incl=f;
+							f2->update_file_line(filename,atol(linenumber));
+						}
+					}
+				}
+				else
+				{
+#ifdef _WIN32
+					fprintf(stderr,"#### line \"%s\" ####\n",linenumber);
+#endif
+					if (currStream())
+					{
+						RHBFile *f2=currStream()->is_file();
+
+						if (f2)
+						{
+							f2->update_file_line(NULL,atol(linenumber));
+						}
+					}
+				}
+			}
+			else
+			{
+				if (!strcmp(p,"pragma"))
+				{
+					strncpy(buf,b,buflen);
+
+					return (int)l;
+				}
+				else
+				{
+					while (currStream())
+					{
+						int c=currStream()->get_char();
+
+						if (c==EOF) break;
+
+						if ((c=='\r')||(c=='\n'))
+						{
+							break;
+						}
+					}
+				}
+			}
+		}
+
+	} while (this);
+
+	return 0;
+}
+
+void RHBPreprocessor::pragma_clear()
+{
+	while (currStream())
+	{
+		int c=currStream()->get_char();
+
+		if (c==EOF) break;
+
+		if ((c=='\r')||(c=='\n'))
+		{
+			break;
+		}
+	}
+}
+
+void RHBPreprocessor::err(const char *x,const char *y)
+{
+	error_count++;
+	if (stream_level)
+	{
+		streamStack[stream_level-1]->print_identity(stderr);
+	}
+	fprintf(stderr,"Error, '%s' near '%s'\n",x,y);
+
+#ifdef _WIN32
+	bomb("error");
+#endif
+
+	exit(1);
+}
+
+int RHBFile::GetLine()
+{
+	return line_number;
+}
+
+int RHBStream::GetLine()
+{
+	return 0;
+}
+
+RHBStream * RHBPreprocessor::currStream()
+{
+	while (stream_level)
+	{
+		RHBStream *s=streamStack[stream_level-1];
+
+		if (!s->is_eof()) return s;
+		
+		stream_level--;
+
+		streamStack[stream_level]=NULL;
+	}
+
+	return 0;
+}
+
+
+void RHBPreprocessor::push_stream(RHBStream *str)
+{
+	streamStack[stream_level]=str;
+	stream_level++;
+}
+
+void RHBFile::print_identity(FILE *z)
+{
+	fprintf(z,"file \042%s\042; line %d\n",filename,line_number);
+}
+
+int RHBPreprocessor::CurrentLine()
+{
+	int i=stream_level;
+
+	while (i--)
+	{
+		if (streamStack[i]->File())
+		{
+			int j=streamStack[i]->GetLine();
+
+			if (j) return j;
+		}
+	}
+
+	return 0;
+}
+
+RHBinclude_file * RHBPreprocessor::CurrentFile()
+{
+	int i=stream_level;
+
+	while (i--)
+	{
+		RHBinclude_file *f=streamStack[i]->File();
+
+		if (f) return f;
+	}
+
+	return 0;
+}
+
+RHBinclude_file * RHBFile::File()
+{
+	return incl;
+}
+
+RHBFile *RHBFile::is_file()
+{
+	return this;
+}
+
+void RHBFile::update_file_line(const char *f,int n)
+{
+	if (f)
+	{
+		strncpy(filename,f,sizeof(filename));
+	}
+
+	if (n>0)
+	{
+		line_number=n;
+	}
+}
+
diff -urN somfree\somipc2\src\rhbscsome.cpp newsomfree3\somipc2\src\rhbscsome.cpp
--- somfree\somipc2\src\rhbscsome.cpp	Thu Jan 01 07:00:00 1970
+++ newsomfree3\somipc2\src\rhbscsome.cpp	Sat Mar 16 14:09:27 2024
@@ -0,0 +1,9496 @@
+/**************************************************************************
+ *
+ *  Copyright 1998-2010, Roger Brown
+ *  Copyright 2017-2018 Yuri Prokushev
+ *
+ *  This file is part of osFree project.
+ *
+ *  This program is free software: you can redistribute it and/or modify it
+ *  under the terms of the GNU Lesser General Public License as published by the
+ *  Free Software Foundation, either version 3 of the License, or (at your
+ *  option) any later version.
+ * 
+ *  This program is distributed in the hope that it will be useful, but WITHOUT
+ *  ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ *  FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for
+ *  more details.
+ *
+ *  You should have received a copy of the GNU Lesser General Public License
+ *  along with this program.  If not, see <http://www.gnu.org/licenses/>
+ *
+ */
+ 
+#include <rhbopt.h>
+/* IDL compiler */
+
+#include <stdio.h>
+#include <string.h>
+#include <stdlib.h>
+
+#include <rhbsc.h>
+
+#include <windows.h>
+
+#define SYMBOLS_FILE   "test.efw"
+
+//FILE *emit(char *file, Entry * cls, Stab * stab);
+typedef FILE * (CALLBACK * EMITFUNC)(char *file, Entry * cls, Stab * stab);
+typedef FILE * (CALLBACK * SOMLINK EMITSLFUNC)(char *file, Entry * cls, Stab * stab);
+
+static const char retVal_name[]="_somC_retVal";
+static const char extern_C_static[]="SOM_EXTERN_C_STATIC";
+const char *RHBsome_emitter::szSOM_RESOLVE_DATA="SOM_RESOLVE_DATA";
+#if 0
+class extern_c_proto_t
+{
+	RHBsome_emitter *emit;
+	RHBoutput *out;
+	int nest;
+public:
+	extern_c_proto_t(RHBsome_emitter *e,RHBoutput *o,int n) :
+	  emit(e),
+	  out(o),
+	  nest(n)
+	{
+		if (emit->cplusplus)
+		{
+			emit->out_printf(out,"#ifdef %s\n",extern_C_static);
+			emit->extern_c_begin(out,nest);
+			emit->out_printf(out,"#endif\n");
+		}
+	}
+	~extern_c_proto_t()
+	{
+		if (emit->cplusplus)
+		{
+			emit->out_printf(out,"#ifdef %s\n",extern_C_static);
+			emit->extern_c_end(out,nest);
+			emit->out_printf(out,"#endif\n");
+		}
+	}
+};
+#endif
+/* main emitter */
+
+RHBsome_emitter::RHBsome_emitter(RHBrepository *rr)
+: RHBemitter(rr)
+{
+}
+
+void RHBsome_emitter::preflight_macros_from_idl_filename(const char *f)
+{
+	char *p=idl_filestem;
+	char buf[256];
+
+	idl_name=f;
+
+	strncpy(buf,f,sizeof(buf));
+
+	f=&buf[strlen(buf)];
+
+	while (f > buf)
+	{
+		f--;
+
+		if ((*f==':') || (*f=='\\') || (*f=='/'))
+		{
+			f++;
+			break;
+		}
+	}
+
+	strncpy(idl_filestem,f,sizeof(idl_filestem));
+	p=idl_filestem;
+
+	while (*p)
+	{
+		if (*p=='.')
+		{
+			*p=0;
+		}
+		else
+		{
+			p++;
+		}
+	}
+
+	snprintf(idl_conditional,sizeof(idl_conditional),"SOM_Module_%s_Source",idl_filestem);
+	snprintf(file_guard,sizeof(file_guard),"SOM_Module_%s_Header_",idl_filestem);
+}
+
+// 
+boolean RHBsome_emitter::generate(RHBoutput *out,const char *f, const char *emitter_name)
+{
+  HINSTANCE handle;
+  EMITFUNC emit;
+  EMITSLFUNC emitSL;
+  char buf[1024] = "";
+
+  strcat(buf, "emit");
+  strncat(buf, emitter_name, sizeof(buf));
+
+  handle=LoadLibrary((LPCSTR)&buf);
+  if (!handle) {
+    fprintf(stderr, "Unknown emitter %s\n", buf/*emitter_name*/);
+    exit(EXIT_FAILURE);
+  } else {
+    emitSL = (EMITSLFUNC)GetProcAddress(handle, "emitSL");  
+    if (!emitSL)  
+    {  
+      emit = (EMITFUNC)GetProcAddress(handle, "emit");  
+      if (!emit)  
+      {  
+        printf("No emit function\n");
+      }
+    }
+  }
+  
+  printf("Emitter loaded\n");
+  // TODO ─юсртшЄ№ яюффхЁцъє ьюфєыхщ
+  
+  RHBmodule *mod=GetRepository();
+  RHBelement *e=mod->children();
+
+
+  while (e)
+  {
+    RHBinterface *iface=e->is_interface();
+    if (iface) 
+    {
+      if (ShouldEmit(iface))
+      {
+        Entry es;
+        es.name=iface->id;
+        es.type=SOMTClassE;
+        es.data=iface;
+        es.filestem=idl_filestem;
+
+	printf("Call emitter %s\n", buf);
+        if (emitSL)
+	{
+		FILE *fh=emitSL((char *)f, &es, NULL);
+	} else {
+	        FILE *fh=emit((char *)f, &es, NULL);
+	}
+	printf("Exit emitter\n");
+      }
+    }
+		e=e->next();
+  }
+
+  FreeLibrary(handle);
+
+  return 0;
+}
+
+
+#if 0
+
+void RHBsome_emitter::generate_passthrus(RHBoutput *out,
+			RHBelement *root,int nest)
+{
+	RHBelement *p=root->children();
+
+	while (p)
+	{
+		if (ShouldEmit(p))
+		{
+			RHBinterface *iface=p->is_interface();
+
+			if (iface)
+			{
+				if (cplusplus)
+				{
+					if (internal)
+					{
+						generate_passthru(out,iface,"C_xih");
+					}
+					else
+					{
+						generate_passthru(out,iface,"C_xh");
+					}
+				}
+				else
+				{
+					if (internal)
+					{
+						generate_passthru(out,iface,"C_ih");
+					}
+					else
+					{
+						generate_passthru(out,iface,"C_h");
+					}
+				}
+			}
+		}
+
+		generate_passthrus(out,p,nest);
+
+		p=p->next();
+	}
+}
+
+#endif
+
+#if 0
+void RHBsome_emitter::generate_module(RHBoutput *out,RHBmodule *mod,int nest)
+{
+	if (!internal)
+	{
+		generate_class_protos(out,mod,nest);
+	}
+
+	generate_types(out,mod,nest);
+
+	generate_classes(out,mod,nest,0);
+	generate_modules(out,mod,nest+1);
+}
+#endif
+
+#if 0
+void RHBsome_emitter::generate_headers(RHBoutput *out,int nest)
+{
+	RHBinclude_list *g=GetRepository()->_pp.includes;
+
+	RHBelement *e=g->children();
+
+	if (out)
+	{
+		if (!internal)
+		{
+			dump_nest(out,nest);
+
+			if (cplusplus)
+			{
+				out_printf(out,"#include <som.xh>\n");
+			}
+			else
+			{
+				out_printf(out,"#include <som.h>\n");
+			}
+		}
+	}
+
+	if (testonly)
+	{
+		out_printf(out,"/* this is only a test */\n");
+	}
+	else
+	{
+		while (e)
+		{
+			RHBinclude_file *i=e->is_include_file();
+
+			if (i)
+			{
+				if (i->defined_in 
+					&& i->defined_in->id 
+#if 0
+					/* emit only immediate children */
+					&& !strcmp(i->defined_in->id,idl_name)
+#endif
+					)
+				{
+					if (i->id && i->id[0] && strcmp(i->id,"-"))
+					{
+						char fn[256];
+						char *p;
+
+						strncpy(fn,i->id,sizeof(fn));
+
+						p=&fn[strlen(fn)];
+
+						while (p > fn)
+						{
+							p--;
+
+							if (*p=='.')
+							{
+								p++;
+								if (cplusplus)
+								{
+									strncpy(p,"xh",fn+sizeof(fn)-p);
+								}
+								else
+								{
+									strncpy(p,"h",fn+sizeof(fn)-p);
+								}
+
+								p=fn;
+							}
+						}
+
+						if (i->included_during==GetRepository())
+						{
+							if (!internal)
+							{
+								dump_nest(out,nest);
+								out_printf(out,"#include <%s>\n",fn);
+							}
+						}
+						else
+						{
+							if (!internal)
+							{
+								dump_nest(out,nest);
+								out_printf(out,"/* #include <%s> */\n",fn);
+							}
+						}
+					}
+				}
+			}
+
+			e=e->next();
+		}
+
+		if (internal)
+		{
+			char fn[256];
+			char *p;
+
+			strncpy(fn,idl_name,sizeof(fn));
+
+			p=&fn[strlen(fn)];
+
+			while (p > fn)
+			{
+				p--;
+
+				if (*p=='.')
+				{
+					p++;
+					if (cplusplus)
+					{
+						strncpy(p,"xh",fn+sizeof(fn)-p);
+					}
+					else
+					{
+						strncpy(p,"h",fn+sizeof(fn)-p);
+					}
+
+					p=fn;
+				}
+			}
+
+			dump_nest(out,nest);
+			out_printf(out,"#include <%s>\n",short_file_name(fn));
+		}
+	}
+}
+
+void RHBsome_emitter::generate_class_protos(RHBoutput *out,RHBmodule *mod,int nest)
+{
+	RHBelement *e;
+
+	e=mod->children();
+
+	while (e)
+	{
+		RHBinterface *iface;
+
+		iface=e->is_interface();
+
+		if (iface)
+		{
+			/* generates class prototypes for
+			classes that have either been defined
+			in this IDL file, or contain no
+			definition in any other IDL file */
+
+
+			if (ShouldEmit(iface))
+			{
+/*				if (!iface->instanceData)*/
+				{
+					generate_class_proto(out,iface,nest);
+				}
+			}
+/*			else
+			{
+				char buf[256];
+				get_ir_name(iface,buf);
+				printf("%s prototype not being emitted\n",buf);
+			}*/
+		}
+
+		e=e->next();
+	}
+}
+
+void RHBsome_emitter::generate_types(RHBoutput *out,RHBelement *mod,int nest)
+{
+	RHBelement *e;
+
+	if (internal) 
+	{
+		return;
+	}
+
+	e=mod->children();
+
+	while (e)
+	{
+		RHBtype *t=0;
+
+		if (ShouldEmit(e))
+		{
+			RHBtype *is_foreign=0;
+			RHBtype *tt=e->is_type();
+			if (tt)
+			{
+				RHBtype_def *d=tt->is_typedef();
+
+	/*			printf("%s\n",e->id);
+
+				if (!strcmp(e->id,"sockaddr"))
+				{
+					__asm int 3;
+				}
+*/
+				if (d)
+				{
+					is_foreign=is_SOMFOREIGN(d->alias_for);
+				}
+			}
+
+			if (!is_foreign)
+			{
+				t=e->is_type();
+			}
+		}
+
+		if (t)
+		{
+			RHBstruct *s;
+			RHBtype_def *td;
+			RHBenum *en;
+			RHBunion *u;
+
+			if (!generated_types.contains(t))
+			{
+				int did_generate=1;
+
+				s=t->is_struct();
+
+				if (s)
+				{
+					generate_struct(s,out,nest,0,1,0);
+				}
+				else
+				{
+					td=t->is_typedef();
+
+					if (td)
+					{
+						generate_typedef(td,out,nest);
+					}
+					else
+					{
+						en=t->is_enum();
+
+						if (en)
+						{
+							generate_enum(en,out,nest);
+						}
+						else
+						{
+							u=t->is_union();
+
+							if (u)
+							{
+								generate_union(u,out,0,1);
+							}
+							else
+							{
+								RHBexception *ex;
+
+								ex=t->is_exception();
+
+								if (ex)
+								{
+									generate_exception(ex,out,0,0);
+								}
+								else
+								{
+									RHBconstant *cn;
+
+									cn=t->is_constant();
+
+									if (cn)
+									{
+										generate_constant(out,cn,0);
+									}
+									else
+									{
+										did_generate=0;
+									}
+								}
+							}
+						}
+					}
+				}
+
+				if (did_generate)
+				{
+					if (!generated_types.contains(t))
+					{
+						generated_types.add(t);
+					}
+
+					if (!internal)
+					{
+						gen_typecode_macro(out,t,nest);
+					}
+				}
+			}
+		}
+
+		e=e->next();
+	}
+}
+
+void RHBsome_emitter::gen_typecode_macro(RHBoutput *out,RHBtype *type,int nest)
+{
+	if (gen_tc_macros)
+	{
+		char n[256];
+
+		if (type->is_constant())
+		{
+			return;
+		}
+
+		if (type->is_exception())
+		{
+			return;
+		}
+
+		dump_nest(out,nest);
+
+		out_printf(out,"#ifdef SOM_TypeCodeNew\n");
+
+		dump_nest(out,nest+1);
+		get_c_name(type,n,sizeof(n));
+		out_printf(out,"#define TypeCodeNew_%s()  \\\n",n);
+
+		gen_typecode_inner(out,type,nest+3);
+		out_printf(out,"\n");
+
+		dump_nest(out,nest);
+		out_printf(out,"#endif /* SOM_TypeCodeNew */\n");
+	}
+}
+
+void RHBsome_emitter::gen_typecode_inner(RHBoutput *out,RHBtype *type,int nest)
+{
+	char n[256];
+	int end_with_null=0;
+
+	while (type->is_typedef())
+	{
+		type=type->is_typedef()->alias_for;
+	}
+
+	dump_nest(out,nest);
+	nest++;
+
+	out_printf(out,"TypeCodeNew(");
+
+	if (type->is_sequence())
+	{
+		out_printf(out,"tk_sequence,\\\n");
+
+		gen_typecode_inner(out,type->is_sequence()->sequence_of,nest);
+		RHBvalue *val=type->is_sequence()->length;
+		long m=0;
+		if (val)
+		{
+			m=val->numeric_value();
+		}
+		out_printf(out,",%ld",m);
+	}
+	else
+	{
+		if (type->is_pointer())
+		{
+			out_printf(out,"tk_pointer,\\\n");
+			gen_typecode_inner(out,type->is_pointer()->pointer_to,nest);
+		}
+		else
+		{
+			if (type->is_interface())
+			{
+				out_printf(out,"tk_objref,");
+				get_ir_name(type,n,sizeof(n));
+				out_printf(out,"%c%s%c",double_quote,n,double_quote);
+			}
+			else
+			{
+				if (type->is_struct())
+				{
+					RHBelement *e=type->children();
+					out_printf(out,"tk_struct,");
+					get_ir_name(type,n,sizeof(n));
+					out_printf(out,"%c%s%c",double_quote,n,double_quote);
+					while (e)
+					{
+						RHBtype *t2=e->is_type();
+						if (t2)
+						{
+							RHBstruct_element *el=t2->is_struct_element();
+							if (el)
+							{
+								out_printf(out,",\\\n");
+								dump_nest(out,nest);
+								out_printf(out,"%c%s%c,\\\n",double_quote,el->id,double_quote);
+								gen_typecode_inner(out,el->element_type,nest+1);
+							}
+						}
+						e=e->next();
+					}
+					end_with_null=1;
+				}
+				else
+				{
+					if (type->is_base_type())
+					{
+						RHBbase_type *bt=type->is_base_type();
+
+						out_printf(out,"tk_%s",bt->id);
+					}
+					else
+					{
+						if (type->is_string())
+						{
+							RHBvalue *val=0;
+							RHBtype *t=type->is_string()->length;
+
+							if (t)
+							{
+								val=t->is_value();
+							}
+							long m=0;
+							if (val)
+							{
+								m=val->numeric_value();
+							}
+							out_printf(out,"tk_string,%ld",m);
+						}
+						else
+						{
+							if (type->is_enum())
+							{
+								RHBelement *e;
+								out_printf(out,"tk_enum");
+								get_ir_name(type,n,sizeof(n));
+								out_printf(out,",%c%s%c",double_quote,n,double_quote);
+								e=type->children();
+								while (e)
+								{
+									out_printf(out,",\\\n");
+									dump_nest(out,nest);
+									out_printf(out,"%c%s%c",double_quote,e->id,double_quote);
+									e=e->next();
+								}
+								end_with_null=1;
+							}
+							else
+							{
+								if (type->is_array())
+								{
+									out_printf(out,"tk_array,\\\n");
+									gen_typecode_inner(out,type->is_array()->array_of,nest);
+									RHBvalue *val=type->is_array()->elements;
+									long m=0;
+									if (val)
+									{
+										m=val->numeric_value();
+									}
+									out_printf(out,",%ld",m);
+								}
+								else
+								{
+									if (type->is_constant())
+									{
+										bomb("is_constant");
+									}
+									else
+									{
+										if (type->is_qualified())
+										{
+											RHBtype *bt;
+											bt=type->is_qualified()->base_type;
+											if (!strcmp(bt->id,"long"))
+											{
+												out_printf(out,"tk_ulong");
+											}
+											else
+											{
+												out_printf(out,"tk_ushort");
+											}
+										}
+										else
+										{
+											printf("error %s\n",type->classname());
+											bomb("error");
+										}
+									}
+								}
+							}
+						}
+					}
+				}
+			}
+		}
+	}
+
+	if (end_with_null)
+	{
+		out_printf(out,",NULL");
+	}
+
+	out_printf(out,")");
+}
+
+void RHBsome_emitter::generate_classes(RHBoutput *out,RHBmodule *mod,int nest,int apiOnlyFlag)
+{
+	RHBelement *e=mod->children();
+
+	while (e)
+	{
+		RHBinterface *iface=e->is_interface();
+
+		if (iface)
+		{
+			if (ShouldEmit(iface))
+			{
+        fprintf(stderr, "1\n");
+
+				generate_class(out,iface,nest,apiOnlyFlag);
+			}
+		}
+
+		e=e->next();
+	}
+}
+
+void RHBsome_emitter::generate_modules(RHBoutput *out,RHBmodule *mod,int nest)
+{
+	RHBelement *e;
+
+	e=mod->children();
+
+	while (e)
+	{
+		RHBmodule *c;
+
+		c=e->is_module();
+
+		if (c)
+		{
+			generate_module(out,c,nest);
+		}
+
+		e=e->next();
+	}
+}
+
+void RHBsome_emitter::generate_class_proto(RHBoutput *out,RHBinterface *iface,int nest)
+{
+	char n[256];
+
+	get_c_name(iface,n,sizeof(n));
+
+	if (!cplusplus)
+	{
+		if (strcmp(n,"SOMObject"))
+		{
+			boolean is_false=0;
+
+			if (only_ibm_som && is_false)
+			{
+				dump_nest(out,nest);
+				out_printf(out,"#ifndef %s\n",n);
+				dump_nest(out,nest+1);
+				out_printf(out,"#define %s SOMObject\n",n);
+				dump_nest(out,nest);
+				out_printf(out,"#endif /* %s */\n",n);
+			}
+			else
+			{
+				dump_nest(out,nest);
+				out_printf(out,"#ifndef _IDL_%s_defined\n",n);
+				dump_nest(out,nest+1);
+				out_printf(out,"#define _IDL_%s_defined\n",n);
+				dump_nest(out,nest+1);
+				out_printf(out,"typedef SOMObject %s;\n",n);
+				dump_nest(out,nest);
+				out_printf(out,"#endif /* _IDL_%s_defined */\n",n);
+			}
+		}
+	}
+
+	if (cplusplus)
+	{
+		if (strcmp(n,"SOMObject"))
+		{
+			dump_nest(out,nest);
+			out_printf(out,"class %s;\n",n);
+		}
+	}
+
+	generate_sequence(out,iface,nest);
+}
+
+void RHBsome_emitter::generate_enum(RHBenum *en,RHBoutput *out,int nest)
+{
+	char n[256];
+	RHBelement *el;
+
+	get_c_name(en,n,sizeof(n));
+
+	dump_nest(out,nest);
+	out_printf(out,"#ifndef %s_defined\n",n);
+	dump_nest(out,nest+1);
+	out_printf(out,"#define %s_defined\n",n);
+
+	dump_nest(out,nest+1);
+	out_printf(out,"typedef unsigned long %s;\n",n);
+
+	el=en->children();
+
+	while (el)
+	{
+		RHBtype *t=el->is_type();
+		if (t)
+		{
+			RHBvalue *val=t->is_value();
+
+			if (val)
+			{
+				long m=val->numeric_value();
+
+				if (0)
+				{
+					get_c_name(val,n,sizeof(n));
+					out_printf(out,"/* #define %s %ldUL */\n",n,m);
+				}
+
+				get_c_name(en->parent(),n,sizeof(n));
+
+				dump_nest(out,nest+1);
+
+				if (n[0]) strncat(n,"_",sizeof(n));
+
+				out_printf(out,"#ifndef %s%s\n",n,el->id);
+
+				dump_nest(out,nest+2);
+				out_printf(out,"#define %s%s %ldUL\n",n,el->id,m);
+
+				dump_nest(out,nest+1);
+				out_printf(out,"#endif /* %s%s */\n",n,el->id);
+			}
+		}
+		el=el->next();
+	}
+
+	gen_shortname(out,en,0,nest+1);
+
+	get_c_name(en,n,sizeof(n));
+
+	dump_nest(out,nest);
+	out_printf(out,"#endif /* %s_defined */\n",n);
+}
+
+void RHBsome_emitter::generate_typedef(RHBtype_def *td,RHBoutput *out,int nest)
+{
+	char n[256];
+
+/*	if (!nest) 
+	{
+		printf("blah\n");
+	}
+*/
+	if (td->alias_for->is_sequence())
+	{
+		generate_sequence(out,td->alias_for->is_sequence()->sequence_of,nest);
+	}
+
+	get_c_name(td,n,sizeof(n));
+
+	dump_nest(out,nest);
+
+	out_printf(out,"typedef ");
+
+	use_type(out,td->alias_for,n);
+
+	out_printf(out,";\n");
+
+	generate_sequence(out,td,nest);
+}
+
+void RHBsome_emitter::generate_exception(RHBexception *s,RHBoutput *out,int nesting,const char *alias_name)
+{
+	char c_name[256];
+	RHBelement *el;
+
+	get_c_name(s,c_name,sizeof(c_name));
+
+	out_printf(out,"#define ex_%s   ",c_name);
+
+	{
+		char ir_name[256];
+		get_ir_name(s,ir_name,sizeof(ir_name));
+		out_printf(out,"%c%s%c\n",double_quote,ir_name,double_quote);
+	}
+
+	if (strcmp(c_name,s->id))
+	{
+		out_printf(out,"#ifndef SOM_DONT_USE_SHORT_NAMES\n");
+		out_printf(out,"#ifndef SOMTGD_ex_%s\n",s->id);
+
+		out_printf(out,"#ifndef ex_%s\n",s->id);
+
+		out_printf(out,"#define ex_%s  ex_%s\n",s->id,c_name);
+
+		out_printf(out,"#else\n");
+
+		out_printf(out,"#define SOMTGD_ex_%s\n",s->id);
+		out_printf(out,"#undef ex_%s\n",s->id);
+
+		out_printf(out,"#endif /* ex_%s */\n",s->id);
+
+		out_printf(out,"#endif /* SOMTGD_ex_%s */\n",s->id);
+
+		out_printf(out,"#endif /* SOM_DONT_USE_SHORT_NAMES */\n");
+	}
+
+	dump_nest(out,nesting);
+
+	if (alias_name)
+	{
+		out_printf(out,"typedef struct %s",alias_name);
+	}
+	else
+	{
+		out_printf(out,"typedef struct %s",c_name);
+	}
+
+	if (s->children())
+	{
+		out_printf(out,"\n");
+		dump_nest(out,nesting);
+		out_printf(out,"{\n");
+
+		el=s->children();
+
+		while (el)
+		{
+			RHBtype *t=el->is_type();
+
+			if (t)
+			{
+				RHBstruct_element *se=t->is_struct_element();
+
+				if (se)
+				{
+					generate_struct_element(se,out,nesting+1);
+				}
+			}
+
+			el=el->next();
+		}
+
+		dump_nest(out,nesting);
+		out_printf(out,"} ");
+	}
+	else
+	{
+		out_printf(out," ");
+	}
+
+	if (alias_name)
+	{
+		out_printf(out,"%s;\n",alias_name);
+	}
+	else
+	{
+		out_printf(out,"%s;\n",c_name);
+	}
+
+	gen_shortname(out,s,0,nesting);
+}
+
+void RHBsome_emitter::generate_struct(
+			RHBstruct *s,
+			RHBoutput *out,
+			int nest,
+			const char *alias_name,
+			boolean user_data,
+			boolean instanceData)
+{
+	char n[256];
+	RHBelement *el;
+
+	align_begin(out,user_data,nest);
+
+	get_c_name(s,n,sizeof(n));
+
+	dump_nest(out,nest);
+
+	if (alias_name)
+	{
+		out_printf(out,"typedef struct %s",alias_name);
+	}
+	else
+	{
+		out_printf(out,"typedef struct %s",n);
+	}
+
+	if (s->children())
+	{
+		out_printf(out,"\n");
+
+		dump_nest(out,nest);
+		out_printf(out,"{\n");
+
+		el=s->children();
+
+		while (el)
+		{
+			RHBtype *t=el->is_type();
+
+			if (t)
+			{
+				RHBstruct_element *se=t->is_struct_element();
+
+				if (se)
+				{
+					generate_struct_element(se,out,nest+1);
+				}
+			}
+
+			el=el->next();
+		}
+
+		dump_nest(out,nest);
+		out_printf(out,"} ");
+	}
+	else
+	{
+		out_printf(out," ");
+	}
+
+	if (alias_name)
+	{
+		out_printf(out,"%s;\n",alias_name);
+	}
+	else
+	{
+		out_printf(out,"%s;\n",n);
+	}
+
+	align_end(out,user_data,nest);
+
+	if (!instanceData)
+	{
+		if (user_data) 
+		{
+			generate_sequence(out,s,nest);
+		}
+
+		gen_shortname(out,s,0,nest);
+
+		if (user_data)
+		{
+			gen_shortname_sequence(out,s,nest);
+		}
+	}
+}
+
+void RHBsome_emitter::generate_class(RHBoutput *out,RHBinterface *iface,int nest,int apiOnlyFlag)
+{
+	int doCloseAPI=0;
+
+	if (!ShouldEmit(iface))
+	{
+		return;
+	}
+
+	if (iface->instanceData)
+	{
+		if (internal)
+		{
+			dump_nest(out,nest);
+			out_printf(out,"#ifndef SOM_Scope\n");
+			dump_nest(out,nest+1);
+			out_printf(out,"#define SOM_Scope static\n");
+			dump_nest(out,nest);
+			
+			out_printf(out,"#endif /* SOM_Scope */\n");
+
+		}
+	}
+
+	if (iface->instanceData && cplusplus && !internal)
+	{
+		char n[256];
+		get_c_name(iface,n,sizeof(n));
+		out_printf(out,"#ifndef %s_API\n",n);
+		out_printf(out,"#define %s_API\n",n);
+
+		doCloseAPI=1;
+	}
+
+	generate_types(out,iface,nest);
+
+	if (iface->instanceData && !generated_types.contains(iface))
+	{
+		size_t i=0;
+
+		while (i < iface->_parents.length())
+		{
+			RHBelement *el=iface->_parents.get(i);
+
+			if (el)
+			{
+				RHBinterface *par=el->is_interface();
+
+				if (!generated_types.contains(par))
+				{
+				/*	char buf[256];
+					get_ir_name(par,buf);*/
+					generate_class(out,par,nest,apiOnlyFlag);
+				}
+			}
+
+			i++;
+		}
+
+		generated_types.add(iface);
+
+		if (!internal)
+		{
+			generate_somTDs(out,iface,nest);
+		}
+
+		if (!internal)
+		{
+			generate_name_lookups(out,iface,nest);
+		}
+
+		if (!internal)
+		{
+			generate_versions(out,iface,"MajorVersion","majorversion",nest);
+			generate_versions(out,iface,"MinorVersion","minorversion",nest);
+		}
+
+		generate_class_data(out,iface,nest);
+
+
+		if (doCloseAPI)
+		{
+			char n[256];
+			get_c_name(iface,n,sizeof(n));
+			out_printf(out,"#endif /* %s_API */\n",n);
+
+			doCloseAPI=0;
+		}
+
+		if (!apiOnlyFlag)
+		{
+			if (internal)
+			{
+				generate_instance_data(out,iface,nest);
+			}
+
+			generate_interface(out,iface,nest);
+
+			if (cplusplus)
+			{
+				if (internal)
+				{
+					generate_passthru(out,iface,"C_xih_after");
+				}
+				else
+				{
+					generate_passthru(out,iface,"C_xh_after");
+				}
+			}
+			else
+			{
+				if (internal)
+				{
+					generate_passthru(out,iface,"C_ih_after");
+				}
+				else
+				{
+					generate_passthru(out,iface,"C_h_after");
+				}
+			}
+		}
+	}
+
+	if (doCloseAPI)
+	{
+		char n[256];
+		get_c_name(iface,n,sizeof(n));
+		out_printf(out,"#endif /* %s_API */\n",n);
+
+		doCloseAPI=0;
+	}
+}
+
+void RHBsome_emitter::generate_struct_element(RHBstruct_element *el,RHBoutput *out,int nest)
+{
+	dump_nest(out,nest);
+
+	use_type(out,el->element_type,el->id);
+
+	out->write(";\n",2);
+}
+
+void RHBsome_emitter::init_type(RHBoutput *out,RHBtype *typ_init)
+{
+	RHBstruct *st=typ_init->is_struct();
+
+	if (st)
+	{
+		RHBelement *el=st->children();
+
+		out_printf(out,"{");
+
+		while (el)
+		{
+			RHBtype *typ=el->is_type();
+
+			if (typ)
+			{
+				RHBstruct_element *se=typ->is_struct_element();
+				if (se)
+				{
+					init_type(out,se->element_type);
+				}
+			}
+
+			el=el->next();
+
+			if (el)
+			{
+				out_printf(out,",");
+			}
+		}
+
+		out_printf(out,"}");
+	}
+	else
+	{
+		RHBsequence_type *seq=typ_init->is_sequence();
+		if (seq)
+		{
+			out_printf(out,"{0,0,NULL}");
+		}
+		else
+		{
+			RHBtype_def *td=typ_init->is_typedef();
+
+			if (td)
+			{
+				init_type(out,td->alias_for);
+			}
+			else
+			{
+				RHBany_type *at=typ_init->is_any();
+				if (at)
+				{
+					out_printf(out,"{NULL,NULL}");
+				}
+				else
+				{
+					if (typ_init->is_interface()
+						||
+						typ_init->is_string()
+						||
+						typ_init->is_TypeCode())
+					{
+						out_printf(out,"NULL");
+					}
+					else
+					{
+						RHBarray *ar=typ_init->is_array();
+						if (ar)
+						{
+							long val=ar->elements->numeric_value();
+							while (val--)
+							{
+								init_type(out,ar->array_of);
+
+								if (val)
+								{
+									out_printf(out,",");
+								}
+							}
+						}
+						else
+						{
+							out_printf(out,"0");
+						}
+					}
+				}
+			}
+		}
+	}
+}
+
+void RHBsome_emitter::use_type(RHBoutput *out,RHBtype *typ,const char *name)
+{	
+	RHBarray *ar=typ->is_array();;
+
+	if (ar)
+	{
+		long val=ar->elements->numeric_value();
+		char valstr[32];
+		snprintf(valstr,sizeof(valstr),"[%ld]",val);
+		int i=strlen(valstr);
+		int k=name ? strlen(name) : 0;
+		char *n2=new char[i+1+k];
+		n2[i+k]=0;
+		if (k)
+		{
+			memcpy(n2,name,k);
+		}
+		memcpy(n2+k,valstr,i);
+
+		use_type(out,ar->array_of,n2);
+
+/*		out_printf(out,"[%ld]",val);*/
+
+		delete n2;
+
+		return;
+	}
+
+	RHBinterface *iface=typ->is_interface();
+
+	if (iface)
+	{
+		char n[256];
+
+		get_c_name(typ,n,sizeof(n));
+
+		if (cplusplus)
+		{
+			out_printf(out,"%s * ",n);
+		}
+		else
+		{
+			out_printf(out,"%s SOMSTAR ",n);
+		}
+	}
+	else
+	{
+		RHBpointer_type *ptr=typ->is_pointer();
+
+		if (ptr)
+		{
+			use_type(out,ptr->pointer_to,0);
+			out_printf(out,"*");
+		}
+		else
+		{
+			RHBstring_type * str;
+
+			str=typ->is_string();
+
+			if (str)
+			{
+				/* hmm */
+				out_printf(out,"%s ",get_corbastring());
+			}
+			else
+			{
+				RHBqualified_type *qual=typ->is_qualified();
+
+				if (qual)
+				{
+					out_printf(out,"%s ",qual->id);
+					use_type(out,qual->base_type,0);
+				}
+				else
+				{
+					char n[256];
+					RHBstruct *st=typ->is_struct();
+
+					if (st)
+					{
+						get_c_name(st,n,sizeof(n)); /* did say 'struct %s '*/
+						out_printf(out,"%s ",n);
+					}
+					else
+					{
+						RHBunion *u=typ->is_union();
+
+						if (u)
+						{
+							get_c_name(u,n,sizeof(n));
+							out_printf(out,"%s ",n);
+						}
+						else
+						{
+							RHBsequence_type *seq=typ->is_sequence();
+
+							if (seq)
+							{
+								get_sequence_name(seq,n,sizeof(n));
+
+								out_printf(out,"%s ",n);
+							}
+							else
+							{
+								get_c_name(typ,n,sizeof(n));
+		
+								if (!n[0])
+								{
+									snprintf(n,sizeof(n),"<<%s>> ",typ->classname());
+								}
+
+								if (0==strcmp(n,"Istring"))
+								{
+									bomb("Istring");
+								}
+
+								out_printf(out,"%s ",n);
+							}
+						}
+					}
+				}
+			}
+		}
+	}
+
+	if (name) 
+	{
+		out_printf(out,"%s",name);
+	}
+}
+
+void RHBsome_emitter::get_sequence_name(RHBsequence_type *seq,char *name,size_t len)
+{
+	char buf[256];
+
+	if (seq==seq->sequence_of)
+	{
+		bomb("get_sequence_name");
+	}
+
+	get_most_primitive_name(seq->sequence_of,buf,sizeof(buf));
+
+	snprintf(name,len,"_IDL_SEQUENCE_%s",buf);
+}
+
+RHBtype * RHBsome_emitter::get_most_primitive_name(RHBtype *typ,char *name,size_t namelen)
+{
+	RHBqualified_type *qual;
+
+	*name=0;
+
+	while (typ->is_typedef())
+	{
+		RHBtype_def *td=typ->is_typedef();
+
+		if (td->alias_for->is_pointer())
+		{
+			break;
+		}
+
+		if (td->alias_for->is_sequence())
+		{
+			break;
+		}
+
+		if (td->alias_for->is_array())
+		{
+			break;
+		}
+
+		char buf[256];
+
+		get_c_name(td->alias_for,buf,sizeof(buf));
+
+		if (0==strcmp(buf,"SOMFOREIGN"))
+		{
+			break;
+		}
+
+		typ=td->alias_for;
+	}
+
+	qual=typ->is_qualified();
+
+	if (qual)
+	{
+		if (0==strcmp(qual->id,"unsigned"))
+		{
+			strncpy(name,"u",namelen);
+
+			get_c_name(qual->base_type,&name[1],namelen-1);
+		}
+		else
+		{
+			get_c_name(qual->base_type,name,namelen);
+		}
+	}
+	else
+	{
+		RHBsequence_type *s=typ->is_sequence();
+
+		if (s)
+		{
+			get_sequence_name(s,name,namelen);
+		}
+		else
+		{
+			if (typ->is_string())
+			{
+				strncpy(name,get_corbastring(),namelen);
+			}
+			else
+			{
+				get_c_name(typ,name,namelen);
+			}
+		}
+	}
+
+	return typ;
+}
+
+void RHBsome_emitter::generate_sequence(RHBoutput *out,RHBtype *typ,int nest)
+{
+	char n[256];
+
+	if (!typ) return;
+
+	typ=get_most_primitive_name(typ,n,sizeof(n));
+
+	if (n[0])
+	{
+		int i=0;
+
+		while (sequences.get(i))
+		{
+			const char *p=sequences.get(i);
+			if (0==strcmp(p,n))
+			{
+				return;
+			}
+
+			i++;
+		}
+
+		sequences.add(n);
+
+		dump_nest(out,nest);
+		out_printf(out,"#ifndef _IDL_SEQUENCE_%s_defined\n",n);
+		dump_nest(out,nest+1);
+		out_printf(out,"#define _IDL_SEQUENCE_%s_defined\n",n);
+
+		dump_nest(out,nest+1);
+
+		if (typ->is_interface() 
+				|| typ->is_pointer() 
+				|| typ->is_qualified() 
+				|| typ->is_array() 
+				|| typ->is_sequence())
+		{
+			out_printf(out,"SOM_SEQUENCE_TYPEDEF_NAME(");
+
+			use_type(out,typ,0);
+
+			out_printf(out,",sequence(%s));\n",n);
+		}
+		else
+		{
+			out_printf(out,"SOM_SEQUENCE_TYPEDEF(%s);\n",n);
+		}
+
+		dump_nest(out,nest);
+		
+		out_printf(out,"#endif /* _IDL_SEQUENCE_%s_defined */\n",n);
+	}
+}
+
+void RHBsome_emitter::generate_union(RHBunion *u,RHBoutput *out,int nesting,boolean user_data)
+{
+	char n[256];
+
+	align_begin(out,user_data,nesting);
+
+	get_c_name(u,n,sizeof(n));
+
+	dump_nest(out,nesting);
+
+	out_printf(out,"typedef struct %s ",n);
+
+	if (u->elements.length())
+	{
+		unsigned long index=0;
+		out->write("\n",1);
+
+		dump_nest(out,nesting);
+
+		out_printf(out,"{\n");
+
+		dump_nest(out,nesting+1);
+
+		use_type(out,u->switch_type,"_d");
+
+		out_printf(out,";\n");
+
+		dump_nest(out,nesting+1);
+
+		out_printf(out,"union\n");
+
+		dump_nest(out,nesting+1);
+
+		out_printf(out,"{\n");
+
+		while (index < u->elements.length())
+		{
+			RHBelement *el=u->elements.get(index);
+			RHBtype *t=el->is_type();
+
+			if (t)
+			{
+				RHBunion_element *e=t->is_union_element();
+
+				if (e)
+				{
+					dump_nest(out,nesting+2);
+					use_type(out,e->element_type,e->id);
+					out_printf(out,";\n");
+				}
+			}
+
+			index++;
+		}
+
+		dump_nest(out,nesting+1);
+		out_printf(out,"} _u;\n");
+		dump_nest(out,nesting);
+		out_printf(out,"} ");
+	}
+
+	out_printf(out,"%s;\n",n);
+
+	align_end(out,user_data,nesting);
+}
+
+void RHBsome_emitter::generate_instance_data(RHBoutput *out,RHBinterface *iface,int nest)
+{
+	if (internal)
+	{
+		generate_class_guard(out,nest,iface,1);
+
+		if (iface->instanceData)
+		{
+			char n[256];
+
+			get_c_name(iface,n,sizeof(n));
+
+			strncat(n,"Data",sizeof(n));
+
+			if (iface->instanceData->children())
+			{
+				RHBelement *el;
+
+				generate_struct(iface->instanceData,out,nest+1,n,1,1);
+
+				el=iface->instanceData->children();
+
+				while (el)
+				{
+					dump_nest(out,nest);
+					out_printf(out,"#ifndef _%s\n",el->id);
+					dump_nest(out,nest+1);
+					out_printf(out,"#define _%s  (somThis->%s)\n",
+							el->id,el->id);
+					dump_nest(out,nest);
+					out_printf(out,"#endif /* _%s */\n",el->id);
+					el=el->next();
+				}
+			}
+			else
+			{
+				dump_nest(out,nest+1);
+				out_printf(out,"typedef void %s;\n",n);
+			}
+		}
+		generate_class_guard(out,nest,iface,0);
+	}
+}
+
+void RHBsome_emitter::generate_class_data(RHBoutput *out,RHBinterface *iface,int nest)
+{
+	if (!iface->classData)
+	{
+		char buf[256];
+		RHBelement *e;
+		RHBinterface *ifa;
+		RHBstruct_element *se;
+		RHBtype *token;
+
+		get_c_name(iface,buf,sizeof(buf));
+		strncat(buf,"ClassDataStructure",sizeof(buf));
+		iface->classData=new RHBstruct(0,buf);
+
+		buf[0]=0;
+
+		get_meta_class(iface,buf);
+
+		if (!buf[0])
+		{
+			strncpy(buf,"SOMClass",sizeof(buf));
+		}
+
+		e=iface->find_named_element(0,buf,sizeof(buf));
+
+		ifa=e->is_interface();
+	
+		strncpy(buf,"somMToken",sizeof(buf));
+
+		e=iface->find_named_element(0,buf,sizeof(buf));
+
+		token=e->is_type();
+
+		se=new RHBstruct_element(0,"classObject");
+		se->element_type=ifa;
+
+		iface->classData->add(0,se);
+
+		strncpy(buf,"releaseorder",sizeof(buf));
+
+		e=iface->find_named_element(0,buf,sizeof(buf));
+
+		if (e)
+		{
+			int i=0;
+
+			while (e->modifier_data.get(i))
+			{
+				const char *p=e->modifier_data.get(i);
+				i++;
+
+				if (strcmp(p,","))
+				{
+					RHBoperation *op=0;
+					RHBelement *oe;
+
+					strncpy(buf,p,sizeof(buf));
+
+					oe=iface->find_named_element(0,buf,sizeof(buf));
+					if (oe) 
+					{
+						op=oe->is_operation();
+					}
+
+					se=new RHBstruct_element(0,p);
+
+			/*		if (0==strcmp(p,"somClassOfNewClassWithParents"))
+					{
+						__asm int 3;
+					}
+			*/
+					if (is_operation_procedure(op))
+					{
+						RHBtype_def *td;
+						char n[256];
+						strncpy(n,"somTD_",sizeof(n));
+						get_c_name(op,&n[strlen(n)],sizeof(n)-strlen(n));
+						td=new RHBtype_def(0,n);
+						td->alias_for=token;
+						se->element_type=td;
+					}
+					else
+					{
+						se->element_type=token;
+					}
+
+					iface->classData->add(0,se);
+				}
+			}
+		}
+
+		e=iface->children();
+
+		while (e)
+		{
+			RHBoperation *op=e->is_operation();
+
+			if (op)
+			{
+				strncpy(buf,op->id,sizeof(buf));
+
+				if (!iface->classData->find_named_element(0,buf,sizeof(buf)))
+				{
+					printf("%c%s%c, line %d: warning: ",
+							double_quote,
+							op->defined_in->id,
+							double_quote,
+							op->defined_line
+							);
+
+					printf("%c%s%c is not in releaseorder\n",double_quote,op->id,double_quote);
+
+					se=new RHBstruct_element(0,op->id);
+
+					if (is_operation_procedure(op))
+					{
+						RHBtype_def *td;
+						char n[256];
+						strncpy(n,"somTD_",sizeof(n));
+						get_c_name(op,&n[strlen(n)],sizeof(n)-strlen(n));
+						td=new RHBtype_def(0,n);
+						td->alias_for=token;
+						se->element_type=td;
+					}
+					else
+					{
+						se->element_type=token;
+					}
+
+					iface->classData->add(0,se);
+				}
+			}
+
+			e=e->next();
+		}
+	}
+
+	if (!iface->cclassData)
+	{
+		char buf[256];
+		RHBelement *e;
+		RHBstruct_element *se;
+
+		get_c_name(iface,buf,sizeof(buf));
+		strncat(buf,"CClassDataStructure",sizeof(buf));
+
+		iface->cclassData=new RHBstruct(0,buf);
+
+		se=new RHBstruct_element(0,"parentMtab");
+
+		strncpy(buf,/*"somParentMtabStructPtr"*/ "somMethodTabs",sizeof(buf));
+		e=iface->find_named_element(0,buf,sizeof(buf));
+		se->element_type=e->is_type();
+		iface->cclassData->add(0,se);
+
+		se=new RHBstruct_element(0,"instanceDataToken");
+		strncpy(buf,"somDToken",sizeof(buf));
+		e=iface->find_named_element(0,buf,sizeof(buf));
+		se->element_type=e->is_type();
+		iface->cclassData->add(0,se);
+
+		RHBelement_sequence vaops;
+
+		if (get_va_operations(iface,&vaops))
+		{
+			size_t i=0;
+			while (i < vaops.length())
+			{
+				RHBoperation *op=vaops.get(i)->is_operation();
+
+				if (op)
+				{
+					se=new RHBstruct_element(0,op->id);
+					strncpy(buf,"somMethodPtr",sizeof(buf));
+					e=iface->find_named_element(0,buf,sizeof(buf));
+					se->element_type=e->is_type();
+					iface->cclassData->add(0,se);
+				}
+				i++;
+			}
+		}
+	}
+
+	if (!internal)
+	{
+		generate_struct(iface->classData,out,nest,0,0,0);
+		generate_struct(iface->cclassData,out,nest,0,0,0);
+	}
+
+	if (!internal)
+	{
+		char n[256];
+
+		get_c_name(iface,n,sizeof(n));
+
+		dump_nest(out,nest);
+		out_printf(out,"#ifdef %s\n",szSOM_RESOLVE_DATA);
+
+		public_class_data(out,nest+1,iface,"ClassData");
+		
+		dump_nest(out,nest);
+		out_printf(out,"#else /* %s */\n",szSOM_RESOLVE_DATA);
+
+		nest++;
+
+
+#ifdef _DEBUG
+		if (!iface->has_modifier_value("dllname"))
+		{
+			out_printf(out,"/* interface for \"%s\" does not have \"dllname\" modifier */\n",n);
+			out_printf(out,"#define %sClassData   _somC_private_%sClassData\n",n,n);
+		}
+#endif
+
+		dump_nest(out,nest);
+		out_printf(out,"SOMEXTERN \n");
+
+		ifdef_import_export(out,iface,nest);
+		dump_nest(out,nest);
+		out_printf(out,"struct ");
+		out_printf(out,"%sClassDataStructure SOMDLINK %sClassData;\n",n,n);
+
+		nest--;
+		dump_nest(out,nest);
+		out_printf(out,"#endif /* %s */\n",szSOM_RESOLVE_DATA);
+	}
+	
+	if (!internal)
+	{
+		char n[256];
+
+		get_c_name(iface,n,sizeof(n));
+
+		dump_nest(out,nest);
+		out_printf(out,"#ifdef %s\n",szSOM_RESOLVE_DATA);
+
+		public_class_data(out,nest+1,iface,"CClassData");
+		
+		dump_nest(out,nest);
+		out_printf(out,"#else /* %s */\n",szSOM_RESOLVE_DATA);
+
+		nest++;
+
+		dump_nest(out,nest);
+		
+		out_printf(out,"SOMEXTERN \n");
+
+		ifdef_import_export(out,iface,nest);
+		dump_nest(out,nest);
+		
+		out_printf(out,"struct %sCClassDataStructure SOMDLINK ",n);
+
+		out_printf(out,"%sCClassData;\n",n);
+
+		nest--;
+
+		dump_nest(out,nest);
+		out_printf(out,"#endif /* %s */\n",szSOM_RESOLVE_DATA);
+	}
+
+	if (!internal)
+	{
+		char n[256];
+
+		extern_c_begin(out,nest);
+		dump_nest(out,nest);
+		out_printf(out,"extern \n");
+		ifdef_import_export(out,iface,nest);
+		dump_nest(out,nest);
+
+		get_actual_meta_class(iface,n,sizeof(n));
+		if (cplusplus)
+		{
+			out_printf(out,"%s * ",n);
+		}
+		else
+		{
+			out_printf(out,"%s SOMSTAR ",n);
+		}
+
+		get_c_name(iface,n,sizeof(n));
+		out_printf(out,"SOMLINK %sNewClass\n",n);
+
+		dump_nest(out,2+nest);
+		
+		out_printf(out,"(integer4 somtmajorVersion,integer4 somtminorVersion);\n");
+
+		extern_c_end(out,nest);
+
+#if 0
+		if (only_ibm_som)
+		{
+			/* this is IBM SOM 2.1 style */
+			dump_nest(out,nest);
+			out_printf(out,"#ifndef _%s\n",n);
+
+			dump_nest(out,nest+1);
+			out_printf(out,"#define _%s (%sClassData.classObject ? \\\n",n,n);
+
+			dump_nest(out,nest+2);
+			out_printf(out,"%sClassData.classObject : \\\n",n);
+
+			dump_nest(out,nest+3);
+			out_printf(out,"%sNewClass(%s_MajorVersion,%s_MinorVersion))\n",n,n,n);
+			
+			dump_nest(out,nest);
+			out_printf(out,"#endif /* _%s */\n",n);
+		}
+#else
+		{
+			/* this is IBM SOM 3.0 style */
+			dump_nest(out,nest);
+			out_printf(out,"#define _SOMCLASS_%s (%sClassData.classObject)\n",n,n);
+
+			dump_nest(out,nest);
+			out_printf(out,"#ifndef SOMGD_%s\n",n);
+
+			dump_nest(out,nest+1);
+			out_printf(out,"#if (defined(_%s) || defined(__%s))\n",n,n);
+			dump_nest(out,nest+2);
+			out_printf(out,"#undef _%s\n",n);
+			dump_nest(out,nest+2);
+			out_printf(out,"#undef __%s\n",n);
+			dump_nest(out,nest+2);
+			out_printf(out,"#define SOMGD_%s 1\n",n);
+			dump_nest(out,nest+1);
+			out_printf(out,"#else\n");
+			dump_nest(out,nest+2);
+			out_printf(out,"#define _%s _SOMCLASS_%s\n",n,n);
+			dump_nest(out,nest+1);
+			out_printf(out,"#endif /* _%s */\n",n);
+
+			dump_nest(out,nest);
+			out_printf(out,"#endif /* SOMGD_%s */\n",n);
+
+			dump_nest(out,nest);
+			out_printf(out,"#define %s_classObj _SOMCLASS_%s\n",n,n);
+
+			dump_nest(out,nest);
+			out_printf(out,"#define _SOMMTOKEN_%s(method) ((somMToken)(%sClassData.method))\n",n,n);
+		}
+#endif
+
+		if (!cplusplus)
+		{
+#if 0
+			if (only_ibm_som)
+			{
+				/* IBM SOM 2.1 style */
+				dump_nest(out,nest);
+				out_printf(out,"#ifndef %sNew\n",n);
+				dump_nest(out,nest+1);
+				out_printf(out,"#define %sNew() \\\n",n);
+				dump_nest(out,nest+2);
+				out_printf(out,"(SOMClass_somNew(_%s))\n",n);
+				dump_nest(out,nest);
+				out_printf(out,"#endif /* New%s */\n",n);
+			}
+#else
+			/* IBM SOM 3.0 style */
+			{
+
+				dump_nest(out,nest);
+				out_printf(out,"#ifndef %sNew\n",n);
+				dump_nest(out,nest+1);
+				out_printf(out,"#define %sNew() ( _%s ? \\\n",n,n);
+				dump_nest(out,nest+2);
+				out_printf(out,"(SOMClass_somNew(_%s)) : \\\n",n);
+				dump_nest(out,nest+2);
+				out_printf(out,"( %sNewClass( \\\n",n);
+				dump_nest(out,nest+3);
+				out_printf(out,"%s_MajorVersion, \\\n",n);
+				dump_nest(out,nest+3);
+				out_printf(out,"%s_MinorVersion), \\\n",n);
+				dump_nest(out,nest+2);
+				out_printf(out,"SOMClass_somNew(_%s))) \n",n);
+				dump_nest(out,nest);
+				out_printf(out,"#endif /* New%s */\n",n);
+			}
+#endif
+		}
+	}
+}
+
+void RHBsome_emitter::public_class_data(RHBoutput *out,int nest,RHBinterface *iface,const char *dn)
+{
+	char n[256];
+
+	get_c_name(iface,n,sizeof(n));
+
+	dump_nest(out,nest);
+	out_printf(out,"#if defined(%s) || defined(%s_Class_Source)\n",idl_conditional,n);
+
+	nest++;
+
+	dump_nest(out,nest);
+	out_printf(out,"SOMEXTERN struct %s%sStructure _%s%s;\n",n,dn,n,dn);
+
+	dump_nest(out,nest);
+	out_printf(out,"#ifndef %s%s\n",n,dn); 
+
+	dump_nest(out,nest+1);
+	out_printf(out,"#define %s%s    _%s%s\n",n,dn,n,dn); 
+
+	dump_nest(out,nest);
+	out_printf(out,"#endif /* %s%s */\n",n,dn); 
+
+	nest--;
+
+	dump_nest(out,nest);
+	out_printf(out,"#else\n");
+
+	nest++;
+
+	dump_nest(out,nest);
+	out_printf(out,"SOMEXTERN struct %s%sStructure * SOMLINK resolve_%s%s(void);\n",n,dn,n,dn); 
+
+	dump_nest(out,nest);
+	out_printf(out,"#ifndef %s%s\n",n,dn); 
+
+	dump_nest(out,nest+1);
+	out_printf(out,"#define %s%s    (*(resolve_%s%s()))\n",n,dn,n,dn); 
+
+	dump_nest(out,nest);
+	out_printf(out,"#endif /* %s%s */\n",n,dn); 
+
+	nest--;
+
+	dump_nest(out,nest);
+	out_printf(out,"#endif\n"); 
+}
+
+void RHBsome_emitter::extern_c_begin(RHBoutput *out,int nest)
+{
+/*	dump_nest(out,nest);
+	i=sprintf(buf,"#ifdef __cplusplus\n");
+	out->write(buf,i);
+	dump_nest(out,nest+1);
+	i=sprintf(buf,"extern %cC%c {\n",double_quote,double_quote);
+	out->write(buf,i);
+	dump_nest(out,nest);
+	i=sprintf(buf,"#endif\n");
+	out->write(buf,i);*/
+
+	if (cplusplus)
+	{
+		dump_nest(out,nest);
+		out_printf(out,"extern %cC%c {\n",double_quote,double_quote);
+	}
+}
+
+void RHBsome_emitter::extern_c_end(RHBoutput *out,int nest)
+{
+/*	dump_nest(out,nest);
+	i=sprintf(buf,"#ifdef __cplusplus\n");
+	out->write(buf,i);
+	dump_nest(out,nest+1);
+	i=sprintf(buf,"}\n");
+	out->write(buf,i);
+	dump_nest(out,nest);
+	i=sprintf(buf,"#endif\n");
+	out->write(buf,i);*/
+
+	if (cplusplus)
+	{
+		dump_nest(out,nest);
+		out_printf(out,"}\n");
+	}
+}
+
+void RHBsome_emitter::ifdef_import_export(RHBoutput *out,RHBinterface *iface,int nest)
+{
+	if (iface->has_modifier_value("dllname"))
+	{
+		char n[256];
+
+		get_c_name(iface,n,sizeof(n));
+		strncat(n,"_Class_Source",sizeof(n));
+
+		dump_nest(out,nest);
+		out_printf(out,"#if defined(%s) || defined(%s)\n",idl_conditional,n);
+
+		dump_nest(out,nest+1);
+		out_printf(out,"#ifdef SOMDLLEXPORT\n");
+
+		dump_nest(out,2+nest);
+		out_printf(out,"SOMDLLEXPORT\n");
+
+		dump_nest(out,nest+1);
+		out_printf(out,"#endif /* SOMDLLEXPORT */\n");
+
+		dump_nest(out,nest);
+		out_printf(out,"#else /* %s || %s */\n",idl_conditional,n);
+
+		dump_nest(out,nest+1);
+		out_printf(out,"#ifdef SOMDLLIMPORT\n");
+
+		dump_nest(out,2+nest);
+		out_printf(out,"SOMDLLIMPORT\n");
+
+		dump_nest(out,nest+1);
+		out_printf(out,"#endif /* SOMDLLIMPORT */\n");
+
+		dump_nest(out,nest);
+		out_printf(out,"#endif /* %s || %s */\n",idl_conditional,n);
+	}
+}
+
+
+void RHBsome_emitter::generate_sizeof_va_list_param(RHBoutput *out,RHBparameter *param,int nest)
+{
+	char n[256];
+
+	if (!strcmp(param->mode,"in"))
+	{
+		RHBtype *t=unwind_typedef(param->parameter_type);
+
+		if (t)
+		{
+			RHBtype *bt=get_va_type(t,1);
+
+			if (bt)
+			{
+				if (bt->is_base_type())
+				{
+					if (bt->is_base_type()->_floating)
+					{
+						/* for this case, a float needs to stay
+							as a float, and not get promoted */
+						bt=t;
+					}
+				}
+
+				if (bt->is_array() ||
+					bt->is_union() ||
+					bt->is_struct() ||
+					bt->is_pointer() ||
+					bt->is_interface() ||
+					bt->is_sequence() ||
+					bt->is_any() ||
+					parameter_by_reference(param,NULL))
+				{
+					dump_nest(out,nest+1);
+					out_printf(out,"+sizeof(void *)\n");
+				}
+				else
+				{
+					if (bt->is_enum())
+					{
+						get_c_name(bt,n,sizeof(n));
+					}
+					else
+					{
+						strncpy(n,bt->id,sizeof(n));
+
+						while (bt->is_qualified())
+						{
+							bt=bt->is_qualified()->base_type;
+							strncat(n,"_",sizeof(n));
+							strncat(n,bt->id,sizeof(n));
+						}
+
+						if (!strcmp(n,"unsigned_long"))
+						{
+							strncpy(n,"unsigned long",sizeof(n));
+						}
+						else
+						{
+							if (!strcmp(n,"unsigned_short"))
+							{
+								strncpy(n,"unsigned short",sizeof(n));
+							}
+						}
+					}
+
+					dump_nest(out,nest+1);
+					out_printf(out,"+sizeof(%s)\n",n);
+				}
+			}
+		}
+	}
+	else
+	{
+		dump_nest(out,nest+1);
+		out_printf(out,"+sizeof(void *)\n");
+	}
+}
+
+boolean RHBsome_emitter::is_in_floating(RHBparameter *param)
+{
+	if (!strcmp(param->mode,"in"))
+	{
+		RHBtype *t=unwind_typedef(param->parameter_type);
+		if (t)
+		{
+			RHBbase_type *bt=t->is_base_type();
+
+			if (bt)
+			{
+				if (bt->_floating)
+				{
+					return 1;
+				}
+			}
+		}
+	}
+
+	return 0;
+}
+
+static struct
+{
+	const char *name;
+	const char *value;
+} type_table[]={
+	{"boolean","SOMRdRetbyte"},
+	{"char","SOMRdRetbyte"},
+	{"octet","SOMRdRetbyte"},
+	{"short","SOMRdRethalf"},
+	{"unsigned_short","SOMRdRethalf"},
+	{"long","SOMRdRetsimple"},
+	{"unsigned_long","SOMRdRetsimple"},
+	{"unsigned_short","SOMRdRethalf"},
+	{"float","SOMRdRetfloat"},
+	{"double","SOMRdRetdouble"},
+	{"long_double","SOMRdRetlongdouble"},
+	{"void","SOMRdRetsimple"},
+	{"TypeCode","SOMRdRetsimple"},
+	{"Principal","SOMRdRetsimple"}
+};
+
+struct type_size
+{
+	int size;
+	const char *type;
+};
+
+static struct type_size ret32bit[]=
+{
+	{1,"SOMRdRetbyte"},
+	{2,"SOMRdRethalf"},
+	{4,"SOMRdRetsimple"}
+};
+
+static struct type_size ret64bit[]=
+{
+	{1,"SOMRdRetbyte"},
+	{2,"SOMRdRethalf"},
+	{4,"SOMRdRetsimple"},
+	{8,"SOMRdRetsmallaggregate"}
+};
+
+void RHBsome_emitter::type_size_expand(RHBoutput *out,int nest,const char *t,struct type_size *a,size_t n)
+{
+	size_t k=0;
+
+	while (k < n)
+	{
+		dump_nest(out,nest);
+
+		out_printf(out,"((sizeof(%s)==%d) ? %s : \n",t,a->size,a->type);
+
+		a++;
+		k++;
+	}
+
+	dump_nest(out,nest);
+	out_printf(out,"SOMRdRetaggregate");
+	while (k--)
+	{
+		out_printf(out,")");
+	}
+	out_printf(out,"\n");
+}
+
+void RHBsome_emitter::generate_rdsizetype(RHBoutput *out,const char *t,int nest)
+{
+	out_printf(out,"#ifdef SOMRdRetsmallaggregate\n");
+
+	type_size_expand(out,nest+1,t,ret64bit,sizeof(ret64bit)/sizeof(ret64bit[0]));
+
+	dump_nest(out,nest);
+	out_printf(out,"#else\n");
+
+	type_size_expand(out,nest+1,t,ret32bit,sizeof(ret32bit)/sizeof(ret32bit[0]));
+
+	dump_nest(out,nest);
+	out_printf(out,"#endif\n");
+	dump_nest(out,nest);
+}
+
+
+void RHBsome_emitter::generate_somMethodInfo(
+			RHBoutput *out,
+			RHBinterface *iface,
+			RHBoperation *op,
+			int nest,
+			int auto_stub)
+{
+	char n[256];
+
+	if (auto_stub)
+	{
+		int has_floats=0;
+		RHBtype *ret_type=unwind_typedef(op->return_type);
+		RHBelement *elc=op->children();
+
+		/* only do float map if can auto_stub */
+
+		while (elc)
+		{
+			RHBparameter *param=elc->is_parameter();
+			if (param)
+			{
+				if (is_in_floating(param))
+				{
+					has_floats++;
+				}
+			}
+			elc=elc->next();
+		}
+
+		get_c_name(op,n,sizeof(n));
+
+		if (has_floats)
+		{
+			int k=0;
+			RHBelement *el=op->children();
+
+			{
+				char n5[256];
+				snprintf(n5,sizeof(n5),"somFloatMap_%s",n);
+				undoublebar(out,n5);
+			}
+
+			out_printf(out,"static somFloatMap somFloatMap_%s={\n",n); 
+
+			while (el)
+			{
+				RHBparameter *param=el->is_parameter();
+				if (param)
+				{
+					if (is_in_floating(param))
+					{
+						RHBelement *z=op->children(); /* was param->children !! */
+						RHBtype *t=unwind_typedef(param->parameter_type);
+
+						dump_nest(out,nest+2);
+						out_printf(out,"sizeof(SOMObject *)\n");
+
+						if (operation_needs_environment(iface,op))
+						{
+							dump_nest(out,nest+2);
+							out_printf(out,"+sizeof(Environment *)\n");
+						}
+
+						if (operation_needs_context(iface,op))
+						{
+							dump_nest(out,nest+2);
+							out_printf(out,"+sizeof(Context SOMSTAR)\n");
+						}
+
+						while (z && (z!=param))
+						{
+							RHBparameter *p=z->is_parameter();
+							if (p)
+							{
+								generate_sizeof_va_list_param(out,p,nest+1);
+							}
+							z=z->next();
+						}
+
+						if (!strcmp(t->id,"float"))
+						{
+							dump_nest(out,nest+2);
+							out_printf(out,"+SOMFMSingle\n");
+						}
+
+						dump_nest(out,nest+1);
+
+						k++;
+
+						if (k < has_floats)
+						{
+							out_printf(out,",\n");
+						}
+						else
+						{
+							out_printf(out,"+SOMFMLast");
+						}
+					}
+				}
+
+				el=el->next();
+			}
+
+			dump_nest(out,nest+1);
+			out_printf(out,"};\n");
+		}
+
+		{
+			char n2[256];
+			strncpy(n2,"somMethodInfo_",sizeof(n2));
+			strncat(n2,n,sizeof(n2));
+			undoublebar(out,n2);
+		}
+
+		out_printf(out,"static somMethodInfo somMethodInfo_%s={\n",n); 
+
+		dump_nest(out,nest+1);
+
+		if (ret_type)
+		{
+			if (ret_type->is_base_type() || ret_type->is_qualified())
+			{
+				char buf[256];
+				size_t i=0;
+				int k=sizeof(type_table)/sizeof(type_table[0]);
+				strncpy(buf,ret_type->id,sizeof(buf));
+
+				while (ret_type->is_qualified())
+				{
+					ret_type=ret_type->is_qualified()->base_type;
+					strncat(buf,"_",sizeof(buf));
+					strncat(buf,ret_type->id,sizeof(buf));
+				}
+
+				while (k--)
+				{
+					if (!strcmp(type_table[k].name,buf))
+					{
+						i=snprintf(buf,sizeof(buf),"%s",type_table[k].value);
+
+						break;
+					}
+				}
+
+				if (!i)
+				{
+					if (!strcmp(buf,"any"))
+					{
+						generate_rdsizetype(out,buf,nest+1);
+					}
+					else
+					{
+						bomb("internal error - was expecting any");
+			
+						i=strlen(buf);
+						i+=snprintf(buf+i,sizeof(buf)-i," compiler error %s:%d\n",__FILE__,__LINE__);
+					}
+				}
+
+				if (i) 
+				{
+					out_printf(out,"%s",buf);
+				}
+			}
+			else
+			{
+				if (ret_type->is_sequence())
+				{
+					generate_rdsizetype(out,"GENERIC_SEQUENCE",nest+1);
+				}
+				else
+				{
+					if (ret_type->is_union() ||
+						ret_type->is_struct())
+					{
+						char buf[256];
+						get_c_name(ret_type,buf,sizeof(buf));
+						generate_rdsizetype(out,buf,nest);
+					}
+					else
+					{
+						if (ret_type->is_pointer() ||
+							ret_type->is_interface() ||
+							ret_type->is_array() ||
+							ret_type->is_string())
+						{
+							out_printf(out,"SOMRdRetsimple");
+						}
+						else
+						{
+							if (ret_type->is_enum())
+							{
+								out_printf(out,"SOMRdRetsimple");
+							}
+							else
+							{
+								char buf[256];
+								get_c_name(ret_type,buf,sizeof(buf));
+
+								bomb("internal compiler error");
+	
+								int i=strlen(buf);
+								i+=snprintf(buf+i,sizeof(buf)-i," compiler error %s:%d\n",__FILE__,__LINE__);
+
+								out_printf(out,"SOMRdRetsimple");
+							}
+						}
+					}
+				}
+			}
+		}
+		else
+		{
+			out_printf(out,"SOMRdRetsimple");
+		}
+
+		if (has_floats)
+		{
+			out_printf(out,"|SOMRdFloatArgs,\n");
+		}
+		else
+		{
+			out_printf(out,"|SOMRdNoFloatArgs,\n");
+		}
+
+		dump_nest(out,nest+1);
+		out_printf(out,"sizeof(SOMObject SOMSTAR)\n");
+
+		if (operation_needs_environment(iface,op))
+		{
+			dump_nest(out,nest+1);
+			out_printf(out,"+sizeof(Environment *)\n");
+		}
+
+		if (operation_needs_context(iface,op))
+		{
+			dump_nest(out,nest+1);
+			out_printf(out,"+sizeof(Context SOMSTAR)\n");
+		}
+
+		elc=op->children();
+
+		while (elc)
+		{
+			RHBparameter *param=elc->is_parameter();
+			if (param)
+			{
+				generate_sizeof_va_list_param(out,param,nest);
+			}
+
+			elc=elc->next();
+		}
+
+		dump_nest(out,nest+1);
+
+		if (has_floats)
+		{
+			get_c_name(op,n,sizeof(n));
+			out_printf(out,",&somFloatMap_%s};\n",n);
+		}
+		else
+		{
+			out_printf(out,",NULL};\n");
+		}
+	}
+
+	get_c_name(op,n,sizeof(n));
+
+	{
+		char n2[256];
+		strncpy(n2,"somApRdInfo_",sizeof(n2));
+		strncat(n2,n,sizeof(n2));
+		undoublebar(out,n2);
+	}
+
+	out_printf(out,"static somApRdInfo somApRdInfo_%s={\n",n);
+
+	dump_nest(out,nest+1);
+	out_printf(out,"(somMethodPtr)somRD_%s,\n",n);
+
+	if (op_is_varg(op)) 
+	{
+		dump_nest(out,nest+1);
+		out_printf(out,"NULL /* has va_list */,\n");
+	}
+	else
+	{
+		dump_nest(out,nest+1);
+		out_printf(out,"(somMethodPtr)somAP_%s,\n",n);
+	}
+
+	dump_nest(out,nest+1);
+
+	if (auto_stub)
+	{
+		out_printf(out,"&somMethodInfo_%s};\n",n);
+	}
+	else
+	{
+		out_printf(out,"NULL};\n");
+	}
+}
+
+void RHBsome_emitter::call_parent_constructors(RHBoutput *out,RHBinterface *iface,int nest,const char *args)
+{
+	if (!args) args="";
+
+	if (iface->_parents.length())
+	{
+		size_t k=0;
+		while (k < iface->_parents.length())
+		{
+			char n[256];
+			dump_nest(out,nest+2);
+
+			get_c_name(iface->_parents.get(k),n,sizeof(n));
+
+			out_printf(out,"%c %s(%s)\n",
+				(k) ? ',' : ':',
+				n,
+				args);
+
+			k++;
+		}
+	}
+}
+
+/*
+ *  Create ClassEntryC object.
+ */
+void RHBsome_emitter::generate_interface(RHBoutput *out,RHBinterface *iface,int nest)
+{
+	char n[256];
+
+/*	RHBelement *el;*/
+
+	/* generate as C++ first ... so we know what we're doing */
+
+	/*
+	if (!internal)
+	{
+		generate_versions(out,iface,"MajorVersion","majorversion",nest);
+		generate_versions(out,iface,"MinorVersion","minorversion",nest);
+	}
+	*/
+
+	get_c_name(iface,n,sizeof(n));
+
+	if (cplusplus)
+	{
+		if (!internal)
+		{
+			out_printf(out,"\n");
+
+			if (!iface->_parents.length())
+			{
+				out_printf(out,"#include <somcls.api>\n");
+			}
+
+			dump_nest(out,nest);
+			out_printf(out,"class %s",n);
+
+			if (iface->_parents.length())
+			{
+				long m=0;
+				long l=iface->_parents.length();
+				out_printf(out," : ");
+
+				while (m < l)
+				{
+					RHBelement *el=iface->_parents.get(m);
+
+					get_c_name(el,n,sizeof(n));
+
+					out_printf(out,"public %s",n);
+
+					m++;
+
+					if (m < l)
+					{
+						out_printf(out,", ");
+					}
+				}
+			}
+
+			out_printf(out,"\n");
+
+			dump_nest(out,nest);
+
+			out_printf(out,"{\n");
+
+			get_c_name(iface,n,sizeof(n));
+
+			{
+				/* this constructor is designed to allow MI C++
+				   classes to properly construct themselves */
+
+				const char *mtab=iface->_parents.length() ? "mtab" : "/* mtab */ ";
+
+				/* generate protected parent constructor */
+				dump_nest(out,nest);
+				out_printf(out,"protected:\n");
+
+				dump_nest(out,nest+1);
+				out_printf(out,"%s(somMethodTab & %s)\n",n,mtab);
+
+				call_parent_constructors(out,iface,nest,"mtab");
+
+				dump_nest(out,nest+1);
+				out_printf(out,"{}\n");
+			}
+
+		/*	if (iface->_parents.length()==0)
+			{
+				dump_nest(out,1);
+				i=sprintf(buf,"somMethodTabPtr mtab;\n");
+				out->write(buf,i);
+			}*/
+
+			dump_nest(out,nest);
+			out_printf(out,"public:\n");
+
+			RHBelement *el=iface->children();
+
+			while (el)
+			{
+				RHBoperation *op=el->is_operation();
+
+				if (op)
+				{
+					out_printf(out,"\n");
+					generate_inline_operation(out,iface,op,nest);
+				}
+
+				el=el->next();
+			}
+
+	/*		if (iface->_parents.length()==0)*/
+			{
+				out_printf(out,"\n");
+				dump_nest(out,nest+1);
+				out_printf(out,"inline void operator delete(void *x)\n");
+				dump_nest(out,nest+2);
+				out_printf(out,"{ ((SOMObject *)x)->somFree(); };\n\n");
+			}
+
+#if 0
+			if (iface->_parents.length())
+#endif
+			{
+				char args[256];
+
+				snprintf(args,sizeof(args),"*(%sCClassData.parentMtab->mtab)",n);
+
+				{
+					/* generate new operation */
+					dump_nest(out,nest+1);
+					out_printf(out,"inline void * operator new(size_t /* len */)\n");
+
+					get_c_name(iface,n,sizeof(n));
+					dump_nest(out,nest+1);
+					out_printf(out,"{ if (!%sClassData.classObject)\n",n);
+
+					dump_nest(out,nest+2);
+					out_printf(out,"{ %sNewClass(%s_MajorVersion,%s_MinorVersion); }\n",n,n,n);
+
+					dump_nest(out,nest+2);
+					out_printf(out,"return (void *)SOM_Resolve((SOMObject *)(void *)%sClassData.classObject,\n",n);
+
+					dump_nest(out,nest+3);
+					out_printf(out,"SOMClass,somNewNoInit)((SOMClass *)(void *)%sClassData.classObject);\n",n);
+
+					dump_nest(out,nest+1);
+					out_printf(out,"};\n");
+				}
+
+				{
+					/* generate default constructor */
+					dump_nest(out,nest+1);
+					out_printf(out,"%s()\n",n);
+
+					call_parent_constructors(out,iface,nest,args);
+
+					dump_nest(out,nest+1);
+					out_printf(out,"{ if ((*(void **)(void *)this)==%sCClassData.parentMtab->mtab)\n",n);
+
+					dump_nest(out,nest+2);
+					out_printf(out,"((SOMObject *)(void *)this)->somDefaultInit(0); }\n");
+				}
+
+				{
+					/* generate copy constructor operation */
+					dump_nest(out,nest+1);
+					out_printf(out,"%s(%s *fromObj)\n",n,n);
+
+					call_parent_constructors(out,iface,nest,args);
+
+					dump_nest(out,nest+1);
+					out_printf(out,"{ if ((*(void **)(void *)this)==%sCClassData.parentMtab->mtab)\n",n);
+					dump_nest(out,nest+2);
+					out_printf(out,"((SOMObject *)(void *)this)->somDefaultCopyInit(0,(SOMObject*)(void*)fromObj); }\n");
+				}
+			}
+#if 0
+			else
+			{
+				dump_nest(out,nest+1);
+				i=sprintf(buf,"void * operator new(size_t /* len */);\n\n");
+				out->write(buf,i);
+			}
+#endif
+
+			boolean done_somNew=0;
+
+			if (is_multiple_inherited(iface))
+			{
+				if (iface->_parents.length())
+				{
+					RHBelement_sequence seq;
+
+					determine_inherited(iface,iface,&seq);
+
+					unsigned long i=0;
+
+					while (i < seq.length())
+					{
+						RHBoperation *op;
+
+						op=seq.get(i)->is_operation();
+
+						if (iface->_metaclass_of.length())
+						{
+							char n2[256];
+							get_ir_name(op,n2,sizeof(n2));
+							if (!strcmp(n2,"::SOMClass::somNew"))
+							{
+								done_somNew=1;
+								generate_inline_somNew_operation(out,iface,op,nest);
+
+								op=0;
+							}
+						}
+
+						if (op)
+						{
+							generate_inline_operation(out,iface,op,nest);
+						}
+
+						i++;
+					}
+				}
+			}
+
+			if (!done_somNew)
+			{
+				if (iface->_metaclass_of.length())
+				{
+					/* this probably means that 'somcls.idl' was not included */
+
+					done_somNew=1;
+					generate_inline_somNew_operation(out,iface,0,nest);
+				}
+			}
+
+			dump_nest(out,nest);
+			out_printf(out,"};\n");
+		}
+	}
+
+	if (internal)
+	{
+		generate_class_guard(out,nest,iface,1);
+	}
+
+	{
+		RHBelement *el=iface->children();
+
+		while (el)
+		{
+			RHBoperation *op=el->is_operation();
+
+			if (op)
+			{
+				if (is_operation_procedure(op))
+				{
+					if (!internal)
+					{
+						if (!cplusplus)
+						{
+							generate_macro_operation(out,iface,op,nest);
+						}
+					}
+					else
+					{
+						generate_operation_proto(out,iface,op,nest);
+					}
+				}
+				else
+				{
+					if (!internal)
+					{
+						if (!cplusplus)
+						{
+							generate_macro_operation(out,iface,op,nest);
+						}
+					}
+					else
+					{
+						int do_auto_stubs=op->can_auto_stub();
+
+						generate_somId(out,nest,op,"somMN","somId",0,0);
+						generate_somId(out,nest,op,"somDS","somDI",0 /*1*/,1);
+
+						generate_operation_proto(out,iface,op,nest);
+
+						if (do_auto_stubs)
+						{
+							out_printf(out,"#ifdef SOM_METHOD_STUBS\n");
+							get_c_name(op,n,sizeof(n));
+							out_printf(out,"\t#define somRD_%s   0\n",n);
+							out_printf(out,"\t#define somAP_%s   0\n",n);
+							out_printf(out,"#else /* SOM_METHOD_STUBS */\n");
+						}
+
+						generate_redispatch_stub(out,iface,op,nest);
+
+						if (op) 
+						{
+							generate_apply_stub(out,iface,op,nest);
+						}
+
+
+						if (do_auto_stubs)
+						{
+							out_printf(out,"#endif /* SOM_METHOD_STUBS */\n");
+						}
+
+
+						{
+							out_printf(out,"#ifdef SOM_METHOD_STUBS\n");
+							generate_somMethodInfo(out,iface,op,nest,do_auto_stubs);
+							out_printf(out,"#endif /* SOM_METHOD_STUBS */\n");
+						}
+					}
+				}
+			}
+
+			el=el->next();
+		}
+	}
+
+	/* this should only be done if internal... */
+
+	if (internal)
+	{
+		dump_nest(out,nest);
+		get_c_name(iface,n,sizeof(n));
+		out_printf(out,"#ifndef %sMethodDebug\n",n);
+		dump_nest(out,nest+1);
+		out_printf(out,"#define %sMethodDebug(x,y)\n",n);
+		dump_nest(out,nest);
+		out_printf(out,"#endif /* %sMethodDebug */\n",n);
+
+		if (iface->instanceData->children())
+		{
+			dump_nest(out,nest); 
+			out_printf(out,"#ifdef SOM_DATA_THUNKS\n");
+
+			nest++;
+
+			{
+				dump_nest(out,nest);
+				get_c_name(iface,n,sizeof(n));
+				out_printf(out,"#define %sGetData(somSelf) \\\n",n);
+				dump_nest(out,nest+1);
+
+				if (cplusplus)
+				{
+					out_printf(out,"(((%sData * (SOMLINK *)(%s *))",n,n);
+				}
+				else
+				{
+					out_printf(out,"(((%sData * (SOMLINK *)(%s SOMSTAR))",n,n);
+				}
+
+				get_c_name(iface,n,sizeof(n));
+				out_printf(out,"(somMethodPtr)%sCClassData.instanceDataToken)(somSelf))\n",n);
+			}
+
+			nest--;
+			dump_nest(out,nest); 
+			out_printf(out,"#else /* SOM_DATA_THUNKS */\n");
+
+			nest++;
+			{
+				dump_nest(out,nest);
+				get_c_name(iface,n,sizeof(n));
+				out_printf(out,"#define %sGetData(somSelf) \\\n",n);
+				dump_nest(out,nest+1);
+				out_printf(out,"((%sData *) \\\n",n);
+				dump_nest(out,nest+2);
+				out_printf(out,"somDataResolve(");
+				if (cplusplus)
+				{
+					out_printf(out,"(SOMObject *)(void *)");
+				}
+
+				get_c_name(iface,n,sizeof(n));
+				out_printf(out,"somSelf,%sCClassData.instanceDataToken))\n",n);
+			}
+			nest--;
+			dump_nest(out,nest); 
+			out_printf(out,"#endif /* SOM_DATA_THUNKS */\n");
+		}
+		else
+		{
+			dump_nest(out,nest);
+			get_c_name(iface,n,sizeof(n));
+			out_printf(out,"#define %sGetData(somSelf)  ",n);
+			out_printf(out,"((%sData *)0)  /* class has no attributes */\n",n);
+		}
+	}
+
+	if (internal)
+	{
+		RHBelement_sequence seq;
+		unsigned long i=0;
+
+		determine_overrides(iface,iface,&seq);
+
+		while (i < seq.length())
+		{
+			RHBoperation *op=seq.get(i)->is_operation();
+
+			if (op)
+			{
+				if (0==strcmp(op->id,"somDestruct"))
+				{
+					out_printf(out,"/* %s::%s (%s:%d)*/\n",
+							iface->id,op->id,__FILE__,__LINE__);
+				}
+				else
+				{
+					if (0==strcmp(op->id,"somDefaultInit"))
+					{
+						out_printf(out,"/* %s::%s (%s:%d)*/\n",
+								iface->id,op->id,__FILE__,__LINE__);
+					}
+				}
+
+				if (op)
+				{
+					generate_somId(out,nest,op,"somDS","somDI",0/*1*/,1);  /* used for override registration */
+					generate_operation_proto(out,iface,op,nest);
+				}
+			}
+
+			i++;
+		}
+
+		generate_new_class(out,iface,&seq,nest);
+	}
+
+	if (internal)
+	{
+		unsigned long i=0;
+
+		while (i < iface->_parents.length())
+		{
+			RHBinterface *par=iface->_parents.get(i)->is_interface();
+
+			if (par)
+			{
+				RHBelement_sequence seq;
+				unsigned long j=0;
+
+				par->list_all_operations(&seq);
+
+				while (j < seq.length())
+				{
+					generate_parent_macro(out,iface,par,seq.get(j)->is_operation(),nest);
+
+					j++;
+				}
+			}
+
+			i++;
+		}
+
+		generate_dts_macros(out,iface);
+	}
+
+	if (internal)
+	{
+		generate_class_guard(out,nest,iface,0);
+	}
+
+
+	if (!cplusplus)
+	{
+		if (!internal)
+		{
+			if (iface->_parents.length())
+			{
+				RHBelement_sequence dups;
+
+				out_printf(out,"\n#ifndef SOM_DONT_USE_INHERITED_MACROS\n");
+
+				generate_inherited_macros(out,&dups,iface,iface);
+
+				out_printf(out,"#endif /* SOM_DONT_USE_INHERITED_MACROS */\n\n");
+			}
+		}
+	}
+}
+
+void RHBsome_emitter::generate_new_class(RHBoutput *out,RHBinterface *iface,RHBelement_sequence *overrides,int nest)
+{
+	int num_statics=0;
+	int num_procedures=0;
+	int num_va=0;
+	char n[256];
+	long mask;
+	RHBelement_sequence init_entries;
+	int init_op_count=get_init_operations(iface,&init_entries);
+
+	generate_somId(out,nest,iface,"somCN",0,0,1);
+	get_meta_class(iface,n);
+
+	if (n[0])
+	{
+		generate_somId(out,nest,iface->find_named_element(0,n,sizeof(n)),"somMCN",0,0,1);
+	}
+
+	{
+		unsigned long k=0;
+		
+		while (k < iface->_parents.length())
+		{
+			char buf[256];
+			char n2[256];
+
+			RHBelement *el=iface->_parents.get(k);
+
+			get_c_name(iface,n2,sizeof(n2));
+			strncpy(buf,"somPCN_",sizeof(buf));
+			strncat(buf,n2,sizeof(buf));
+
+			generate_somId(out,nest,el,buf,0,0,1);
+
+			k++;
+		}
+	}
+
+	if (iface->_parents.length())
+	{
+		unsigned long k=0;
+
+		get_c_name(iface,n,sizeof(n));
+
+		out_printf(out,"static const somConstId somPC%s[%d]={\n",
+					n,
+					(int)iface->_parents.length());
+
+		while (k < iface->_parents.length())
+		{
+			char m[256];
+
+			get_c_name(iface,m,sizeof(m));
+			RHBelement *el=iface->_parents.get(k);
+
+			get_c_name(el,n,sizeof(n));
+
+			dump_nest(out,1);
+			out_printf(out,"&somPCN_%s_%s",m,n);
+
+			k++;
+
+			if (k!=iface->_parents.length())
+			{
+				out_printf(out,",\n");
+			}
+		}
+
+		out_printf(out,"};\n\n");
+	}
+
+	num_procedures=0;
+	num_statics=0;
+
+	{
+		RHBelement *el=iface->children();
+
+		while (el)
+		{
+			if (el->is_operation())
+			{
+				if (is_operation_procedure(el->is_operation()))
+				{
+					num_procedures++;
+				}
+				else
+				{
+					num_statics++;
+				}
+			}
+
+			el=el->next();
+		}
+	}
+
+	get_ir_name(iface,n,sizeof(n));
+
+	out_printf(out,"/* class %s introduces %d methods, %d procedures and overrides %d */\n",
+				n,num_statics,num_procedures,(int)overrides->length());
+
+	/* generate class data structure */
+
+	out_printf(out,"/* should have %sClassData defined here */\n",n);
+
+	generate_internal_ctrl_macros(out,iface);
+	enum_attributes(out,iface);
+
+	/* static somStaticMethod_t <<classname>>SM */
+	/* static somOverrideMethod_t <<classname>>OM */
+	/* static somStaticClassInfo <<className>>SCI  */
+
+	get_c_name(iface,n,sizeof(n));
+
+	if (num_statics)
+	{
+		int x=num_statics;
+		get_c_name(iface,n,sizeof(n));
+		out_printf(out,"static somStaticMethod_t %sSM[%d]={\n",
+				n,(int)num_statics);
+
+		RHBelement *el=iface->children();
+
+		while (el)
+		{	
+			RHBoperation *op=el->is_operation();
+
+			if (op)
+			{
+				if (!is_operation_procedure(op))
+				{
+					dump_nest(out,2);
+
+					out_printf(out,"{\n");
+
+					/* somMToken *classData */
+					dump_nest(out,3);
+					get_c_name(iface,n,sizeof(n));
+					out_printf(out,"&%sClassData.%s,\n",n,op->id);
+
+					/* somId *methodId */
+					dump_nest(out,3);
+					out_printf(out,"&somId_%s,\n",op->id);
+
+					/* somId *methodDescriptor */
+
+					dump_nest(out,3);
+					get_c_name(op,n,sizeof(n));
+					out_printf(out,"&somDI_%s,\n",n);
+
+					/* somMethodPtr method */
+
+					dump_nest(out,3);
+					get_function_prefix(iface,n,sizeof(n));
+					out_printf(out,"(somMethodPtr)%s%s,\n",n,op->id);
+
+					
+					out_printf(out,"#ifdef SOM_METHOD_STUBS\n");
+
+					{
+								/* indicate that we have the ABI info 
+									technically you can't cast a data pointer
+									to a function pointer, so we go via a size_t...
+									*/
+								dump_nest(out,3);
+								out_printf(out,"(somMethodPtr)-1L,\n");
+
+								dump_nest(out,3);
+								get_c_name(op,n,sizeof(n));
+								out_printf(out,"(somMethodPtr)(size_t)&somApRdInfo_%s\n",n);
+					}
+
+					out_printf(out,"#else /* SOM_METHOD_STUBS */\n");
+
+					{
+								/* somMethodPtr redispatch */
+
+								dump_nest(out,3);
+								get_c_name(op,n,sizeof(n));
+								out_printf(out,"(somMethodPtr)somRD_%s,\n",n);
+
+								/* somMethodPtr apply */
+
+								dump_nest(out,3);
+								if (op_is_varg(op))
+								{
+									out_printf(out,"(somMethodPtr)NULL\n");
+								}
+								else
+								{
+									get_c_name(op,n,sizeof(n));
+									out_printf(out,"(somMethodPtr)somAP_%s\n",n);
+								}
+					}
+
+					out_printf(out,"#endif /* SOM_METHOD_STUBS */\n");
+
+					dump_nest(out,2);
+
+					out_printf(out,"}");
+
+					x--;
+
+					if (x)
+					{
+						out_printf(out,",\n");
+					}
+					else
+					{
+						out_printf(out,"\n");
+					}
+				}
+			}
+			el=el->next();
+		}
+
+		dump_nest(out,1);
+		out_printf(out,"};\n");
+	}
+
+	if (overrides->length())
+	{
+		unsigned long k=0;
+
+		while (k < overrides->length())
+		{
+			RHBoperation *op=overrides->get(k)->is_operation();
+
+			k++;
+	/* this is not needed for overridden methods */
+	/*		generate_somId(out,nest,op,"somMN","somId",0,0); */
+
+			generate_somId(out,nest,op,"somDS","somDI",0 /*1*/,1);
+		}
+
+		get_c_name(iface,n,sizeof(n));
+		out_printf(out,"static somOverrideMethod_t %sOM[%d]={\n",
+				n,(int)overrides->length());
+
+		k=0;
+
+		while (k < overrides->length())
+		{
+			RHBoperation *op=overrides->get(k)->is_operation();
+
+			k++;
+
+			dump_nest(out,2);
+			out_printf(out,"{\n");
+
+			/* somId *methodId */
+
+			dump_nest(out,3);
+
+			char ii[256];
+			get_c_name(op,ii,sizeof(ii));
+			out_printf(out,"&somDI_%s,\n",ii /*op->id*/);
+
+			/* somMethodPtr method */
+
+			dump_nest(out,3);
+			get_function_prefix(iface,n,sizeof(n));
+			out_printf(out,"(somMethodPtr)%s%s\n",n,op->id);
+
+			dump_nest(out,2);
+			out_printf(out,"}");
+
+			if (k==overrides->length())
+			{
+				out_printf(out,"\n");
+			}
+			else
+			{
+				out_printf(out,",\n");
+			}
+		}
+
+		dump_nest(out,1);
+		out_printf(out,"};\n");
+	}
+	/* somProcMethods_t */
+
+	if (num_procedures)
+	{
+		get_c_name(iface,n,sizeof(n));
+
+		out_printf(out,"static somProcMethods_t %sPM[%d]={\n",
+					n,(int)num_procedures);
+
+		RHBelement *el=iface->children();
+
+		int x=num_procedures;
+
+		while (el)
+		{
+			RHBoperation *op=el->is_operation();
+
+			if (op)
+			{
+				if (is_operation_procedure(op))
+				{
+					dump_nest(out,1);
+
+					get_c_name(iface,n,sizeof(n));
+
+					out_printf(out,"{(somMethodPtr*)(void *)&%sClassData.%s,\n",n,op->id);
+
+					dump_nest(out,2);
+
+					get_function_prefix(iface,n,sizeof(n));
+					out_printf(out,"(somMethodPtr)%s%s}\n",n,op->id);
+
+					x--;
+
+					if (x)
+					{
+						dump_nest(out,1);
+						out_printf(out,",\n");
+					}
+				}
+			}
+
+			el=el->next();
+		}
+
+		dump_nest(out,1);
+		out_printf(out,"};\n");
+	}
+
+	if (internal)
+	{
+		RHBelement_sequence vaops;
+
+		num_va=get_va_operations(iface,&vaops);
+
+		if (num_va)
+		{
+			unsigned long k=0;
+
+			while (k < vaops.length())
+			{
+				RHBoperation *op=vaops.get(k)->is_operation();
+				generate_va_stub(out,iface,op,nest,3,"somVA");
+				k++;
+			}
+
+			k=0;
+
+			get_c_name(iface,n,sizeof(n));
+
+			out_printf(out,"static somVarargsFuncs_t %sVF[%d]={\n",n,num_va);
+
+			while (k < vaops.length())
+			{
+				RHBoperation *op=vaops.get(k)->is_operation();
+
+				out_printf(out,"{&%sCClassData.%s,(somMethodPtr)somVA_%s_%s}",
+							n,op->id,n,op->id);
+
+				if (++k < vaops.length())
+				{
+					out_printf(out,",\n");
+				}
+			}
+
+			out_printf(out,"};\n");
+		}
+
+		if (useAlignmentHelper())
+		{
+			if (iface->instanceData->children())
+			{
+				get_c_name(iface,n,sizeof(n));
+				out_printf(out,"struct _somC_%s_dataAlignment { octet _o; %sData _d; };\n",n,n);
+			}
+		}
+	}
+
+	if (get_cif(iface,n,sizeof(n)))
+	{
+		if (cplusplus)
+		{
+			out_printf(out,"static void SOMLINK %s(SOMClass *);\n",n);
+		}
+		else
+		{
+			out_printf(out,"static void SOMLINK %s(SOMClass SOMSTAR);\n",n);
+		}
+	}
+
+	if (overrides && !is_kernel_class(iface))
+	{
+		long k1=overrides->length();
+
+		while (k1--)
+		{
+			RHBoperation *op=overrides->get(k1)->is_operation();
+
+			if (op)
+			{
+				long k2=iface->_parents.length();
+
+				while (k2--)
+				{
+					RHBinterface *par=iface->_parents.get(k2)->is_interface();
+
+					if (par)
+					{
+						generate_parent_resolved(out,iface,par,op,1);
+					}
+				}
+			}
+		}
+	}
+
+	get_c_name(iface,n,sizeof(n));
+
+	if (cplusplus)
+	{
+		extern_c_proto_t extern_c_proto(this,out,nest);
+		out_printf(out,"static void SOMLINK _somC_%s_classInit(SOMClass *);\n",n);
+	}
+	else
+	{
+		out_printf(out,"static void SOMLINK _somC_%s_classInit(SOMClass SOMSTAR);\n",n);
+	}
+
+	if (init_op_count)
+	{
+		get_c_name(iface,n,sizeof(n));
+		out_printf(out,"static somId somINIT%s[%d]={\n",n,init_op_count);
+
+		int k=0;
+		while (k < init_op_count)
+		{
+			RHBelement *ip=init_entries.get(k);
+
+			out_printf(out,"(somId)&somMN_%s",ip->id);
+
+			k++;
+
+			if (k < init_op_count) 
+			{
+				out_printf(out,",\n");
+			}
+		}
+
+		out_printf(out,"};\n");
+	}
+
+	get_c_name(iface,n,sizeof(n));
+	out_printf(out,"static somStaticClassInfo %sSCI={\n",n);
+
+	/* need to generate ... type 2 information only!!! */
+
+	/* unsigned long layoutVersion */
+
+	out_printf(out,"#ifdef SOMSCIVERSION\n");
+	dump_nest(out,2);
+	out_printf(out,"%d,  /* layoutVersion */\n",3);
+	out_printf(out,"#else /* SOMSCIVERSION */\n");
+	dump_nest(out,2);
+	out_printf(out,"%d,  /* layoutVersion */\n",2);
+	out_printf(out,"#endif /* SOMSCIVERSION */\n");
+
+	/* unsigned long numStaticMethod */
+
+	dump_nest(out,2);
+	out_printf(out,"%d, /* numStaticMethod */\n",num_statics);
+
+	/* unsigned long numStaticOverrides */
+
+	dump_nest(out,2);
+	out_printf(out,"%d, /* numStaticOverrides */\n",(int)overrides->length());
+
+	/* unsigned long numNonInternalData */
+
+	dump_nest(out,2);
+	out_printf(out,"%d, /* numNonInternalData */\n",0);
+
+	/* unsigned long numProcMethods */
+
+	dump_nest(out,2);
+	out_printf(out,"%d, /* numProcMethods */\n",(int)num_procedures);
+
+	/* unsigned long numVarargsFuncs */
+
+	dump_nest(out,2);
+	out_printf(out,"%d, /* numVarargsFuncs */\n",num_va);
+
+	/* unsigned long majorVersion */
+
+	dump_nest(out,2);
+	get_c_name(iface,n,sizeof(n));
+	out_printf(out,"%s_MajorVersion,\n",n);
+
+	/* unsigned long minorVersion */
+
+	dump_nest(out,2);
+	get_c_name(iface,n,sizeof(n));
+	out_printf(out,"%s_MinorVersion,\n",n);
+
+	/* unsigned long instanceDataSize */
+
+	dump_nest(out,2);
+	get_c_name(iface,n,sizeof(n));
+	if (iface->instanceData->children())
+	{
+		out_printf(out,"sizeof(%sData), /* instanceDataSize */\n",n);
+	}
+	else
+	{
+		out_printf(out,"0, /* no instanceDataSize */\n");
+	}
+
+	/* unsigned long maxMethods */
+
+	dump_nest(out,2);
+	out_printf(out,"%d, /* maxMethods */\n",num_statics);
+
+	/* unsigned long numParents */
+
+	dump_nest(out,2);
+	out_printf(out,"%d, /* numParents */\n",
+		(int)iface->_parents.length());
+
+	/* somId classId */
+
+	dump_nest(out,2);
+	get_c_name(iface,n,sizeof(n));
+	out_printf(out,"&somCN_%s,\n",n);
+
+	/* somId explicitMetaId */
+
+	dump_nest(out,2);
+	get_meta_class(iface,n);
+
+	if (n[0])
+	{
+		RHBelement *el2=iface->find_named_element(0,n,sizeof(n));
+
+		get_c_name(el2,n,sizeof(n));
+
+		out_printf(out,"&somMCN_%s,\n",n);
+	}
+	else
+	{
+		out_printf(out,"0,\n");
+	}
+
+	/* long implicitParentMeta */
+
+	dump_nest(out,2);
+	out_printf(out,"0, /* implicitParentMeta */\n");
+
+	/* somId *parents */
+
+	dump_nest(out,2);
+	get_c_name(iface,n,sizeof(n));
+
+	if (iface->_parents.length())
+	{
+		out_printf(out,"somPC%s, /* parents */\n",n);
+	}
+	else
+	{
+		out_printf(out,"0, /* no parents */\n");
+	}
+
+	/* somClassDataStructure *cds */
+
+	dump_nest(out,2);
+	get_c_name(iface,n,sizeof(n));
+	out_printf(out,"(somClassDataStructure *)(void *)&%sClassData,\n",n);
+
+	/* somCClassDataStructure *ccds */
+
+	dump_nest(out,2);
+	get_c_name(iface,n,sizeof(n));
+	out_printf(out,"(somCClassDataStructure *)(void *)&%sCClassData,\n",n);
+
+	/* somStaticMethod_t *smt */
+
+	dump_nest(out,2);
+	get_c_name(iface,n,sizeof(n));
+
+	if (num_statics)
+	{
+		out_printf(out,"%sSM,\n",n);
+	}
+	else
+	{
+		out_printf(out,"0,  /* no new methods */\n");
+	}
+
+	/* somOverrideMethod_t *omt */
+
+	dump_nest(out,2);
+	get_c_name(iface,n,sizeof(n));
+
+	if (overrides->length())
+	{
+		out_printf(out,"%sOM,\n",n);
+	}
+	else
+	{
+		out_printf(out,"0,\n");
+	}
+
+	/* char *nitReferenceBase */
+
+	dump_nest(out,2);
+	get_c_name(iface,n,sizeof(n));
+	out_printf(out,"0, /* nitReferenceBase */\n");
+
+	/* somNonInternalData_t *nit */
+
+	dump_nest(out,2);
+	get_c_name(iface,n,sizeof(n));
+	out_printf(out,"0, /* nit */\n");
+
+	/* somProcMethodFuncs_t *pmt */
+
+	dump_nest(out,2);
+	get_c_name(iface,n,sizeof(n));
+
+	if (num_procedures)
+	{
+		out_printf(out,"%sPM, /* %d procedures */\n",n,(int)num_procedures);
+	}
+	else
+	{
+		out_printf(out,"0, /* pmt no procedures*/\n");
+	}
+
+	/* somVarargsFuncs_t *vft */
+
+	dump_nest(out,2);
+	get_c_name(iface,n,sizeof(n));
+	if (num_va)
+	{
+		out_printf(out,"%sVF, /* vft */\n",n);
+	}
+	else
+	{
+		out_printf(out,"0, /* vft */\n");
+	}
+
+	/* somTP_somClassInitFunc *cif */
+
+	dump_nest(out,2);
+
+#if 0
+	if (get_cif(iface,n))
+	{
+		out_printf(out,"%s, /* cif */\n",n);
+	}
+	else
+	{
+		out_printf(out,"0, /* cif */\n");
+	}
+#else
+	out_printf(out,"_somC_%s_classInit,\n",n);
+#endif
+
+	/* type 2 begin */
+
+	/* long dataAlignment */
+
+	dump_nest(out,2);
+	get_c_name(iface,n,sizeof(n));
+
+	if (iface->instanceData->children())
+	{
+		if (useAlignmentHelper())
+		{
+			out_printf(out,"(int)(size_t)&(((struct _somC_%s_dataAlignment *)0)->_d)\n",
+				n);
+		}
+		else
+		{
+			out_printf(out,"(int)(size_t)&(((struct { octet _o; %sData _d; } *)0)->_d)\n",
+				n);
+		}
+	}
+	else
+	{
+		out_printf(out,"0 /* no dataAlignment */\n");
+	}
+
+	{
+		out_printf(out,"#ifdef SOMSCIVERSION\n");
+
+		dump_nest(out,2); out_printf(out,",");
+		/* this is the new init stuff */
+
+		/* directInitClasses not sure what these are */
+
+		dump_nest(out,2); out_printf(out,"-1L,(somId *)0, /* directInitClasses */\n"); 
+
+		/* numMethods */
+		dump_nest(out,2); out_printf(out,"0,(somMethods_t *)0, /* numMethods */\n"); 
+
+		/* protected data offset */
+		dump_nest(out,2); out_printf(out,"0, /* protected data offset */\n");
+
+		dump_nest(out,2); out_printf(out,"0, /* SOMSCIVERSION */\n");
+
+		/* inherited methods */
+		dump_nest(out,2); out_printf(out,"0,(somInheritedMethod_t *)0, /* inherited methods */\n"); 
+
+		/* numClassData entries */
+
+		/* should be count of class data entries excluding the classObject
+		*/
+
+		int count=count_ClassData(iface);
+
+		dump_nest(out,2); out_printf(out,"%d,(somId *)0, /* class data entries */\n",count); 
+
+		/* numMigratedMethods entries */
+		dump_nest(out,2); out_printf(out,"0,(somMigratedMethod_t *)0, /* migrated methods */\n");
+
+		/* numInitializers entries */
+
+		if (init_op_count)
+		{
+			get_c_name(iface,n,sizeof(n));
+			dump_nest(out,2); out_printf(out,"%d,somINIT%s, /* initializers */\n",
+						init_op_count,n);
+		}
+		else
+		{
+			dump_nest(out,2); out_printf(out,"0,(somId *)0, /* initializers */\n");
+		}
+
+		/* somDTSClass entries */
+		dump_nest(out,2); out_printf(out,"0,(somDynamicSCI *)0, /* DTS */\n");
+
+		out_printf(out,"#endif /* SOMSCIVERSION */\n"); 
+	}
+
+	dump_nest(out,1);
+	out_printf(out,"};\n");
+
+	/* now generate the <xxx>NewClass(integer4,integer4) */
+
+	char meta[256];
+	get_actual_meta_class(iface,meta,sizeof(meta));
+	get_c_name(iface,n,sizeof(n));
+
+	if (cplusplus)
+	{
+		out_printf(out,"%s * SOMLINK %sNewClass(\n",meta,n);
+	}
+	else
+	{
+		out_printf(out,"%s SOMSTAR SOMLINK %sNewClass(\n",meta,n);
+	}
+
+	dump_nest(out,1);
+	out_printf(out,"integer4 somtmajorVersion,integer4 somtminorVersion)\n");
+	out_printf(out,"{\n");
+
+	mask=0;
+
+	if (iface->_parents.length())
+	{
+		unsigned long k=0;
+
+		while (k < iface->_parents.length())
+		{
+			dump_nest(out,1);
+
+			get_c_name(iface->_parents.get(k),n,sizeof(n));
+
+			out_printf(out,"if (!%sNewClass(\n",n,sizeof(n));
+
+			dump_nest(out,2);
+			out_printf(out,"%s_MajorVersion,\n",n,sizeof(n));
+
+			dump_nest(out,2);
+			out_printf(out,"%s_MinorVersion))\n",n,sizeof(n));
+
+			dump_nest(out,1);
+			out_printf(out,"{\n");
+
+			dump_nest(out,2);
+			out_printf(out,"return NULL;\n");
+
+			dump_nest(out,1);
+			out_printf(out,"}\n");
+
+			mask<<=1;
+			mask|=1;
+
+			k++;
+		}
+	}
+
+	n[0]=0;
+	get_meta_class(iface,n);
+	if (n[0])
+	{
+		RHBelement *el=iface->find_named_element(0,n,sizeof(n));
+		if (el)
+		{
+			get_c_name(el,n,sizeof(n));
+
+			dump_nest(out,1);
+			out_printf(out,"if (!%sNewClass(\n",n);
+
+			dump_nest(out,2);
+			out_printf(out,"%s_MajorVersion,\n",n);
+
+			dump_nest(out,2);
+			out_printf(out,"%s_MinorVersion))\n",n);
+
+			dump_nest(out,1);
+			out_printf(out,"{\n");
+
+			dump_nest(out,2);
+			out_printf(out,"return NULL;\n");
+
+			dump_nest(out,1);
+			out_printf(out,"}\n");
+		}
+	}
+
+	meta[0]=0;
+
+	get_actual_meta_class(iface,n,sizeof(n));
+
+	if (strcmp(n,"SOMClass"))
+	{
+		if (cplusplus)
+		{
+			snprintf(meta,sizeof(meta),"(%s *)(void *)",n);
+		}
+		else
+		{
+			snprintf(meta,sizeof(meta),"(%s SOMSTAR)(void *)",n);
+		}
+	}
+
+	get_c_name(iface,n,sizeof(n));
+	dump_nest(out,1);
+
+	out_printf(out,"return %ssomBuildClass(0x%lx,&%sSCI,\n",
+				meta,mask,n);
+
+	dump_nest(out,2);
+	out_printf(out,"somtmajorVersion,\n");
+
+	dump_nest(out,2);
+	out_printf(out,"somtminorVersion);\n");
+
+	if (iface->_parents.length())
+	{
+		if (0)
+		{
+			unsigned long k=0;
+
+			while (k < iface->_parents.length())
+			{
+				dump_nest(out,1);
+				get_c_name(iface->_parents.get(k),n,sizeof(n));
+				out_printf(out,"somReleaseClassReference(%s_classObject);\n",n);
+				k++;
+			}
+		}
+	}
+
+/*	dump_nest(out,1);
+	get_c_name(iface,n);
+	i=sprintf(buf,"return %s_classObject;\n",n);
+	out->write(buf,i);
+*/
+	out_printf(out,"}\n");
+
+	if (cplusplus)
+	{
+		out_printf(out,"static void SOMLINK _somC_%s_classInit(SOMClass *somSelf)\n",n);
+	}
+	else
+	{
+		out_printf(out,"static void SOMLINK _somC_%s_classInit(SOMClass SOMSTAR somSelf)\n",n);
+	}
+
+	out_printf(out,"{\n");
+
+	out_printf(out,"/* do parent resolves... */\n");
+
+	if (overrides && !is_kernel_class(iface))
+	{
+		long k1=overrides->length();
+
+		while (k1--)
+		{
+			RHBoperation *op=overrides->get(k1)->is_operation();
+
+			if (op)
+			{
+				long k2=iface->_parents.length();
+
+				while (k2--)
+				{
+					RHBinterface *par=iface->_parents.get(k2)->is_interface();
+
+					if (par)
+					{
+						generate_parent_resolved(out,iface,par,op,2);
+					}
+				}
+			}
+		}
+	}
+
+	out_printf(out,"/* call classinit if defined... */\n"); 
+
+	if (get_cif(iface,n,sizeof(n)))
+	{
+		out_printf(out,"\t%s(somSelf);\n",n);
+	}
+	else
+	{
+		out_printf(out,"\tSOM_IgnoreWarning(somSelf);\n");
+	}
+
+	out_printf(out,"}\n");
+
+	get_c_name(iface,n,sizeof(n));
+
+	if (strcmp(n,"SOMObject") &&
+		strcmp(n,"SOMClass") &&
+		strcmp(n,"SOMClassMgr"))
+	{
+		generate_internal_class_data(out,iface);
+		generate_internal_cclass_data(out,iface);
+	}
+
+	public_class_data_resolve(out,0,iface,"ClassData");
+	public_class_data_resolve(out,0,iface,"CClassData");
+}
+
+void RHBsome_emitter::public_class_data_resolve(RHBoutput *out,int nest,RHBinterface *iface,const char *dn)
+{
+	char n[256];
+	get_c_name(iface,n,sizeof(n));
+	dump_nest(out,nest);
+	out_printf(out,"#ifdef %s\n",szSOM_RESOLVE_DATA);
+	dump_nest(out,nest+1);
+	out_printf(out,"SOMEXTERN struct %s%sStructure * SOMLINK resolve_%s%s(void)\n",n,dn,n,dn);
+
+	dump_nest(out,nest+1);
+	out_printf(out,"{ return &_%s%s; }\n",n,dn);
+
+	dump_nest(out,nest);
+	out_printf(out,"#endif /* %s */\n",szSOM_RESOLVE_DATA);
+}
+
+
+void RHBsome_emitter::enum_attributes(RHBoutput *out,RHBinterface *iface)
+{
+RHBattribute *attr;
+RHBelement *ch;
+
+	ch=iface->children();
+
+	while (ch)
+	{
+		if (ch->is_type())
+		{
+			attr=ch->is_type()->is_attribute();
+
+			if (attr)
+			{
+				generate_internal_attribute(out,iface,attr);
+			}
+		}
+
+		ch=ch->next();
+	}
+}
+
+void RHBsome_emitter::generate_internal_attribute(RHBoutput *out,RHBinterface *iface,RHBattribute *attr)
+{
+char n[256];
+int do_set=0,do_get=0;
+
+	if (!attr->has_modifier_value("nodata"))
+	{
+		if (!attr->has_modifier_value("noset"))
+		{
+			do_set=1;
+		}
+		if (!attr->has_modifier_value("noget"))
+		{
+			do_get=1;
+		}
+	}
+
+	if (!attr->readonly)
+	{
+		if (do_set)
+		{
+			get_c_name(attr,n,sizeof(n));
+			out_printf(out,"/* set for attribute %s */\n",n);
+			gen_set_attribute(out,iface,attr);
+		}
+		else
+		{
+			attr->build_id(n,sizeof(n));
+			out_printf(out,"/* developer must provide set for attribute %s */\n",n);
+		}
+	}
+
+	if (do_get)
+	{
+		gen_get_attribute(out,iface,attr);
+	}
+	else
+	{
+		attr->build_id(n,sizeof(n));
+		out_printf(out,"/* developer must provide get for attribute %s */\n",n);
+	}
+}
+
+void RHBsome_emitter::gen_set_attribute(RHBoutput *out,RHBinterface *iface,RHBattribute *attr)
+{
+char n[256];
+int by_ref=0;
+RHBtype *by_array=NULL;
+
+	get_c_name(iface,n,sizeof(n));
+
+	out_printf(out,"SOM_Scope void");
+
+	get_function_prefix(iface,n,sizeof(n));
+	out_printf(out," SOMLINK %s",n);
+
+	get_c_name(iface,n,sizeof(n));
+	out_printf(out,"_set_%s(",attr->id);
+
+	use_type(out,iface,"somSelf,");
+
+	if (operation_needs_environment(iface,0))
+	{
+		out_printf(out,"Environment *ev,");
+	}
+
+	{
+		char buf[256];
+		RHBparameter *param;
+		RHBelement *el;
+		snprintf(buf,sizeof(buf),"_set_%s",attr->id);
+		el=iface->find_named_element(0,buf,sizeof(buf));
+		param=el->children()->is_type()->is_parameter();
+		by_ref=parameter_by_reference(param,NULL);
+	}
+
+	by_array=get_array_slice(attr->attribute_type);
+
+	if (by_ref)
+	{
+		use_type(out,attr->attribute_type,0);
+		out_printf(out," *value");
+	}
+	else
+	{
+		use_type(out,attr->attribute_type,"value");
+	}
+
+	out_printf(out,")\n{\n");
+
+	if (by_array)
+	{
+		get_c_name(iface,n,sizeof(n));
+		out_printf(out,"%sData *somThis=%sGetData(somSelf);\n",n,n);
+	}
+
+	if (operation_needs_environment(iface,0))
+	{
+		out_printf(out,"SOM_IgnoreWarning(ev);\n");
+	}
+
+	dump_nest(out,1);
+
+	if (by_array)
+	{
+		out_printf(out,"if (value != somThis->%s)\n"
+					"\tmemcpy(somThis->%s,value,sizeof(somThis->%s));\n",
+					attr->id,attr->id,attr->id);
+	}
+	else
+	{
+		if (by_ref)
+		{
+			out_printf(out,"%sGetData(somSelf)->%s=*value;\n",
+				n,attr->id);
+		}
+		else
+		{
+			out_printf(out,"%sGetData(somSelf)->%s=value;\n",
+				n,attr->id);
+		}
+	}
+
+	out_printf(out,"}\n");
+}
+
+void RHBsome_emitter::gen_get_attribute(RHBoutput *out,RHBinterface *iface,RHBattribute *attr)
+{
+char n[256];
+
+	get_c_name(iface,n,sizeof(n));
+
+	out_printf(out,"SOM_Scope ");
+
+	RHBtype *t=get_array_slice(attr->attribute_type);
+	if (t)
+	{
+		use_type(out,t,0);
+
+		out_printf(out,"* ");
+	}
+	else
+	{
+		use_type(out,attr->attribute_type,0);
+	}
+
+	get_function_prefix(iface,n,sizeof(n));
+	out_printf(out," SOMLINK %s",n);
+
+	get_c_name(iface,n,sizeof(n));
+	out_printf(out,"_get_%s(",attr->id);
+
+	use_type(out,iface,"somSelf");
+
+	if (operation_needs_environment(iface,0))
+	{
+		out_printf(out,",Environment *ev");
+	}
+
+	out_printf(out,")\n{\n");
+
+	if (operation_needs_environment(iface,0))
+	{
+		out_printf(out,"SOM_IgnoreWarning(ev);\n");
+	}
+
+	dump_nest(out,1);
+
+	t=get_array_slice(attr->attribute_type);
+
+	if (t)
+	{
+		int i=0;
+		t=attr->attribute_type;
+		while (t)
+		{
+			t=unwind_typedef(t);
+			if (t->is_array())
+			{
+				t=t->is_array()->array_of;
+				i++;
+			}
+			else
+			{
+				break;
+			}
+		}
+		out_printf(out,"return %sGetData(somSelf)->%s",n,attr->id);
+		if (i) i--;
+		while (i--)
+		{
+			out_printf(out,"[0]");
+		}
+		out_printf(out,";\n");
+	}
+	else
+	{
+		out_printf(out,"return %sGetData(somSelf)->%s;\n",
+			n,attr->id);
+	}
+
+	out_printf(out,"}\n");
+}
+
+void RHBsome_emitter::generate_internal_ctrl_macros(RHBoutput * /*out*/,RHBinterface * /*iface */)
+{
+/*	generate_begininit(out,iface,"somDefaultInit");
+	generate_begininit(out,iface,"somDefaultCopyInit");
+	generate_begininit(out,iface,"somDefaultConstCopyInit");
+	generate_begininit(out,iface,"somDefaultVCopyInit");
+	generate_begininit(out,iface,"somDefaultConstVCopyInit");
+	generate_beginassignop(out,iface);
+	generate_begindestruct(out,iface);
+	generate_enddestruct(out,iface);
+	generate_parent_initdestruct(out,iface);*/
+}
+
+boolean RHBsome_emitter::do_som21_macro(RHBinterface *iface,const char *name)
+{
+	if (iface->_parents.length())
+	{
+		return does_override(iface,name);
+	}
+	else
+	{
+		RHBelement *el;
+		char buf[256];
+		strncpy(buf,name,sizeof(buf));
+		el=iface->find_named_element(0,buf,sizeof(buf));
+		if (!el) return 0;
+		if (!el->is_operation()) return 0;
+	}
+
+	return 1;
+}
+
+boolean RHBsome_emitter::does_override(RHBinterface *iface,const char *name)
+{
+	RHBelement *el;
+	char buf[256];
+
+	strncpy(buf,name,sizeof(buf));
+
+	el=iface->find_named_element(0,buf,sizeof(buf));
+
+	if (el)
+	{
+		if (el->has_modifier_value("override"))
+		{
+			return 1;
+		}
+	}
+
+	strncpy(buf,"override",sizeof(buf));
+	el=iface->find_named_element(0,buf,sizeof(buf));
+	if (el)
+	{
+		if (el->has_modifier_value(name))
+		{
+			return 1;
+		}
+	}
+
+	return 0;
+}
+#endif
+
+#if 0
+void RHBsome_emitter::generate_begininit(
+			RHBoutput *out,
+			RHBinterface *iface,
+			const char *meth_name)
+{
+	char n[256];
+
+	if (do_som21_macro(iface,meth_name))
+	{
+		get_c_name(iface,n);
+		out_printf(out,"#define %s_BeginInitializer_%s \\\n",n,meth_name);
+
+		dump_nest(out,2);
+		i=sprintf(buf,"if (!ctrl) {\\\n");
+		out->write(buf,i);
+		dump_nest(out,3);
+		i=sprintf(buf,"ctrl = &globalCtrl;\\\n");
+		out->write(buf,i);
+		dump_nest(out,3);
+		i=sprintf(buf,"memcpy(ctrl,&(((somParentMtabStructPtr)(void *)%sCClassData.parentMtab)->initCtrl),sizeof(somInitCtrl));\\\n",n);
+		out->write(buf,i);
+		dump_nest(out,2);
+		i=sprintf(buf,"}\\\n");
+		out->write(buf,i);
+
+		dump_nest(out,2);
+		i=sprintf(buf,"myMask = ctrl->mask;\\\n");
+		out->write(buf,i);
+
+		if (iface->instanceData)
+		{
+			if (iface->instanceData->children())
+			{
+				dump_nest(out,2);
+				i=sprintf(buf,"somThis=(%sData *)((char*)somSelf + ctrl->info->dataOffset);\\\n",n);
+				out->write(buf,i);
+			}
+		}
+
+		dump_nest(out,2);
+		i=sprintf(buf,"ctrl->info = (somInitInfo*)(ctrl->infoSize + (char*)(ctrl->info)); \\\n");
+		out->write(buf,i);
+
+		dump_nest(out,2);
+		i=sprintf(buf,"ctrl->mask += 1;\n");
+		out->write(buf,i);
+	}
+}
+#endif
+
+#if 0
+void RHBsome_emitter::generate_beginassignop(
+			RHBoutput *out,
+			RHBinterface *iface)
+{
+	char buf[256];
+	char n[256];
+	int i;
+
+	get_c_name(iface,n);
+	i=sprintf(buf,"#define %s_BeginAssignmentOp \\\n",n);
+	out->write(buf,i);
+
+	dump_nest(out,2);
+	i=sprintf(buf,"if (!ctrl) {\\\n");
+	out->write(buf,i);
+	dump_nest(out,3);
+	i=sprintf(buf,"ctrl = &globalCtrl;\\\n");
+	out->write(buf,i);
+	dump_nest(out,3);
+	i=sprintf(buf,"memcpy(ctrl,&(((somParentMtabStructPtr)(void *)%sCClassData.parentMtab)->assignCtrl),sizeof(somAssignCtrl));\\\n",n);
+	out->write(buf,i);
+	dump_nest(out,2);
+	i=sprintf(buf,"}\\\n");
+	out->write(buf,i);
+
+
+	dump_nest(out,2);
+	i=sprintf(buf,"myMask = ctrl->mask;\\\n");
+	out->write(buf,i);
+
+	if (iface->instanceData)
+	{
+		if (iface->instanceData->children())
+		{
+			dump_nest(out,2);
+			i=sprintf(buf,"somThis=(%sData *)((char*)somSelf + ctrl->info->dataOffset);\\\n",n);
+			out->write(buf,i);
+		}
+	}
+
+	dump_nest(out,2);
+	i=sprintf(buf,"ctrl->info = (somAssignInfo*)(ctrl->infoSize + (char*)(ctrl->info)); \\\n");
+	out->write(buf,i);
+
+	dump_nest(out,2);
+	i=sprintf(buf,"ctrl->mask += 1;\n");
+	out->write(buf,i);
+}
+#endif
+
+#if 0
+void RHBsome_emitter::generate_begindestruct(
+			RHBoutput *out,
+			RHBinterface *iface)
+{
+	char buf[256];
+	char n[256];
+	int i;
+
+	if (do_som21_macro(iface,"somDestruct"))
+	{
+		get_c_name(iface,n);
+		i=sprintf(buf,"#define %s_BeginDestructor \\\n",n);
+		out->write(buf,i);
+
+		dump_nest(out,2);
+		i=sprintf(buf,"if (!ctrl) {\\\n");
+		out->write(buf,i);
+		dump_nest(out,3);
+		i=sprintf(buf,"ctrl = &globalCtrl;\\\n");
+		out->write(buf,i);
+		dump_nest(out,3);
+		i=sprintf(buf,"memcpy(ctrl,&(((somParentMtabStructPtr)(void *)%sCClassData.parentMtab)->destructCtrl),sizeof(somDestructCtrl));\\\n",n);
+		out->write(buf,i);
+		dump_nest(out,2);
+		i=sprintf(buf,"}\\\n");
+		out->write(buf,i);
+
+		if (iface->instanceData)
+		{
+			if (iface->instanceData->children())
+			{
+				dump_nest(out,2);
+				i=sprintf(buf,"somThis=(%sData *)((char*)somSelf + ctrl->info->dataOffset);\\\n",n);
+				out->write(buf,i);
+			}
+		}
+
+		dump_nest(out,2);
+		i=sprintf(buf,"myMask = ctrl->mask;\n");
+		out->write(buf,i);
+	}
+}
+#endif
+
+#if 0
+void RHBsome_emitter::generate_enddestruct(
+			RHBoutput *out,
+			RHBinterface *iface)
+{
+	char buf[256];
+	char n[256];
+	int i;
+	int j;
+	RHBinterface *par;
+
+	if (do_som21_macro(iface,"somDestruct"))
+	{
+
+		get_c_name(iface,n);
+		i=sprintf(buf,"#define %s_EndDestructor \\\n",n);
+		out->write(buf,i);
+
+		dump_nest(out,2);
+		i=sprintf(buf,"ctrl->info = (somDestructInfo*)(ctrl->infoSize + (char*)(ctrl->info)); \\\n");
+		out->write(buf,i);
+		dump_nest(out,2);
+		i=sprintf(buf,"ctrl->mask += 1; \\\n");
+		out->write(buf,i);
+
+		j=0;
+
+		while (j < iface->_parents.length())
+		{
+			char m[256];
+
+			par=iface->_parents.get(j)->is_type()->is_interface();
+
+			dump_nest(out,2);
+			get_c_name(par,m);
+
+			i=sprintf(buf,"%s_DeInit_%s_somDestruct(somSelf,0,ctrl);\\\n",n,m);
+			out->write(buf,i);
+			j++;
+		}
+
+		dump_nest(out,2);
+		i=sprintf(buf,"if (doFree) SOMClass_somDeallocate(%sClassData.classObject, (string)somSelf);\n",n);
+		out->write(buf,i);
+	}
+}
+#endif
+
+#if 0
+void RHBsome_emitter::generate_parent_initdestruct(
+			RHBoutput *out,
+			RHBinterface *iface)
+{
+	RHBinterface *par;
+	int i;
+	char n[256];
+	char buf[256];
+	int j;
+
+	j=0;
+
+	while (j < iface->_parents.length())
+	{
+		par=iface->_parents.get(j)->is_type()->is_interface();
+
+		/* creator */
+
+		if (do_som21_macro(iface,"somDefaultInit"))
+		{
+			get_c_name(iface,n);
+
+			i=sprintf(buf,"#define %s_Init_",n);
+			out->write(buf,i);
+
+			get_c_name(par,n);
+
+			i=sprintf(buf,"%s_somDefaultInit(somSelf,ctrl) \\\n",n);
+			out->write(buf,i);
+
+			dump_nest(out,2);
+
+			i=sprintf(buf,"if (myMask[0]&1) \\\n");
+			out->write(buf,i);
+
+			dump_nest(out,3);
+
+			i=sprintf(buf,"((somTD_SOMObject_somDefaultInit)\\\n");
+			out->write(buf,i);
+
+			dump_nest(out,4);
+
+			i=sprintf(buf,"ctrl->info->defaultInit)\\\n");
+			out->write(buf,i);
+
+			dump_nest(out,5);
+
+			i=sprintf(buf,"(somSelf,ctrl)\n");
+			out->write(buf,i);
+		}
+
+		/* copy creator */
+
+		if (do_som21_macro(iface,"somDefaultCopyInit"))
+		{
+			get_c_name(iface,n);
+
+			i=sprintf(buf,"#define %s_Init_",n);
+			out->write(buf,i);
+
+			get_c_name(par,n);
+
+			i=sprintf(buf,"%s_somDefaultCopyInit(somSelf,ctrl,fromObj) \\\n",n);
+			out->write(buf,i);
+
+			dump_nest(out,2);
+
+			i=sprintf(buf,"if (myMask[0]&1) \\\n");
+			out->write(buf,i);
+
+			dump_nest(out,3);
+
+			i=sprintf(buf,"((somTD_SOMObject_somDefaultCopyInit)\\\n");
+			out->write(buf,i);
+
+			dump_nest(out,4);
+
+			i=sprintf(buf,"ctrl->info->defaultCopyInit)\\\n");
+			out->write(buf,i);
+
+			dump_nest(out,5);
+
+			i=sprintf(buf,"(somSelf,ctrl,fromObj)\n");
+			out->write(buf,i);
+		}
+
+		/* const copy creator */
+
+		if (do_som21_macro(iface,"somDefaultConstCopyInit"))
+		{
+			get_c_name(iface,n);
+
+			i=sprintf(buf,"#define %s_Init_",n);
+			out->write(buf,i);
+
+			get_c_name(par,n);
+
+			i=sprintf(buf,"%s_somDefaultConstCopyInit(somSelf,ctrl,fromObj) \\\n",n);
+			out->write(buf,i);
+
+			dump_nest(out,2);
+
+			i=sprintf(buf,"if (myMask[0]&1) \\\n");
+			out->write(buf,i);
+
+			dump_nest(out,3);
+
+			i=sprintf(buf,"((somTD_SOMObject_somDefaultConstCopyInit)\\\n");
+			out->write(buf,i);
+
+			dump_nest(out,4);
+
+			i=sprintf(buf,"ctrl->info->defaultConstCopyInit)\\\n");
+			out->write(buf,i);
+
+			dump_nest(out,5);
+
+			i=sprintf(buf,"(somSelf,ctrl,fromObj)\n");
+			out->write(buf,i);
+		}
+
+		/* volatile copy creator */
+
+		if (do_som21_macro(iface,"somDefaultVCopyInit"))
+		{
+			get_c_name(iface,n);
+
+			i=sprintf(buf,"#define %s_Init_",n);
+			out->write(buf,i);
+
+			get_c_name(par,n);
+
+			i=sprintf(buf,"%s_somDefaultVCopyInit(somSelf,ctrl,fromObj) \\\n",n);
+			out->write(buf,i);
+
+			dump_nest(out,2);
+
+			i=sprintf(buf,"if (myMask[0]&1) \\\n");
+			out->write(buf,i);
+
+			dump_nest(out,3);
+
+			i=sprintf(buf,"((somTD_SOMObject_somDefaultVCopyInit)\\\n");
+			out->write(buf,i);
+
+			dump_nest(out,4);
+
+			i=sprintf(buf,"ctrl->info->defaultCopyInit)\\\n");
+			out->write(buf,i);
+
+			dump_nest(out,5);
+
+			i=sprintf(buf,"(somSelf,ctrl,fromObj)\n");
+			out->write(buf,i);
+		}
+
+
+		/* volatile const copy creator */
+
+		if (do_som21_macro(iface,"somDefaultConstVCopyInit"))
+		{
+			get_c_name(iface,n);
+
+			i=sprintf(buf,"#define %s_Init_",n);
+			out->write(buf,i);
+
+			get_c_name(par,n);
+
+			i=sprintf(buf,"%s_somDefaultConstVCopyInit(somSelf,ctrl,fromObj) \\\n",n);
+			out->write(buf,i);
+
+			dump_nest(out,2);
+
+			i=sprintf(buf,"if (myMask[0]&1) \\\n");
+			out->write(buf,i);
+
+			dump_nest(out,3);
+
+			i=sprintf(buf,"((somTD_SOMObject_somDefaultConstVCopyInit)\\\n");
+			out->write(buf,i);
+
+			dump_nest(out,4);
+
+			i=sprintf(buf,"ctrl->info->defaultConstCopyInit)\\\n");
+			out->write(buf,i);
+
+			dump_nest(out,5);
+
+			i=sprintf(buf,"(somSelf,ctrl,fromObj)\n");
+			out->write(buf,i);
+		}
+		
+		/* assignment */
+
+		if (do_som21_macro(iface,"somDefaultAssign"))
+		{
+			get_c_name(iface,n);
+
+			i=sprintf(buf,"#define %s_Assign_",n);
+			out->write(buf,i);
+
+			get_c_name(par,n);
+
+			i=sprintf(buf,"%s_somDefaultAssign(somSelf,ctrl,fromObj) \\\n",n);
+			out->write(buf,i);
+
+			dump_nest(out,2);
+
+			i=sprintf(buf,"if (myMask[0]&1) \\\n");
+			out->write(buf,i);
+
+			dump_nest(out,3);
+
+			i=sprintf(buf,"((somTD_SOMObject_somDefaultAssign)\\\n");
+			out->write(buf,i);
+
+			dump_nest(out,4);
+
+			i=sprintf(buf,"ctrl->info->defaultAssign)\\\n");
+			out->write(buf,i);
+
+			dump_nest(out,5);
+
+			i=sprintf(buf,"(somSelf,ctrl,fromObj)\n");
+			out->write(buf,i);
+		}
+
+		/* volatile assignment */
+
+		if (do_som21_macro(iface,"somDefaultVAssign"))
+		{
+			get_c_name(iface,n);
+
+			i=sprintf(buf,"#define %s_Assign_",n);
+			out->write(buf,i);
+
+			get_c_name(par,n);
+
+			i=sprintf(buf,"%s_somDefaultVAssign(somSelf,ctrl,fromObj) \\\n",n);
+			out->write(buf,i);
+
+			dump_nest(out,2);
+
+			i=sprintf(buf,"if (myMask[0]&1) \\\n");
+			out->write(buf,i);
+
+			dump_nest(out,3);
+
+			i=sprintf(buf,"((somTD_SOMObject_somDefaultVAssign)\\\n");
+			out->write(buf,i);
+
+			dump_nest(out,4);
+
+			i=sprintf(buf,"ctrl->info->defaultAssign)\\\n");
+			out->write(buf,i);
+
+			dump_nest(out,5);
+
+			i=sprintf(buf,"(somSelf,ctrl,fromObj)\n");
+			out->write(buf,i);
+		}
+
+		/* const assignment */
+
+		if (do_som21_macro(iface,"somDefaultConstAssign"))
+		{
+			get_c_name(iface,n);
+
+			i=sprintf(buf,"#define %s_Assign_",n);
+			out->write(buf,i);
+
+			get_c_name(par,n);
+
+			i=sprintf(buf,"%s_somDefaultConstAssign(somSelf,ctrl,fromObj) \\\n",n);
+			out->write(buf,i);
+
+			dump_nest(out,2);
+
+			i=sprintf(buf,"if (myMask[0]&1) \\\n");
+			out->write(buf,i);
+
+			dump_nest(out,3);
+
+			i=sprintf(buf,"((somTD_SOMObject_somDefaultConstAssign)\\\n");
+			out->write(buf,i);
+
+			dump_nest(out,4);
+
+			i=sprintf(buf,"ctrl->info->defaultConstAssign)\\\n");
+			out->write(buf,i);
+
+			dump_nest(out,5);
+
+			i=sprintf(buf,"(somSelf,ctrl,fromObj)\n");
+			out->write(buf,i);
+		}
+
+		/* volatile const assignment */
+
+		if (do_som21_macro(iface,"somDefaultConstVAssign"))
+		{
+			get_c_name(iface,n);
+
+			i=sprintf(buf,"#define %s_Assign_",n);
+			out->write(buf,i);
+
+			get_c_name(par,n);
+
+			i=sprintf(buf,"%s_somDefaultConstVAssign(somSelf,ctrl,fromObj) \\\n",n);
+			out->write(buf,i);
+
+			dump_nest(out,2);
+
+			i=sprintf(buf,"if (myMask[0]&1) \\\n");
+			out->write(buf,i);
+
+			dump_nest(out,3);
+
+			i=sprintf(buf,"((somTD_SOMObject_somDefaultConstVAssign)\\\n");
+			out->write(buf,i);
+
+			dump_nest(out,4);
+
+			i=sprintf(buf,"ctrl->info->defaultConstAssign)\\\n");
+			out->write(buf,i);
+
+			dump_nest(out,5);
+
+			i=sprintf(buf,"(somSelf,ctrl,fromObj)\n");
+			out->write(buf,i);
+		}
+
+		/* destructor */
+
+		if (do_som21_macro(iface,"somDestruct"))
+		{
+			get_c_name(iface,n);
+
+			i=sprintf(buf,"#define %s_DeInit_",n);
+			out->write(buf,i);
+
+			get_c_name(par,n);
+
+			i=sprintf(buf,"%s_somDestruct(somSelf,doFree,ctrl) \\\n",n);
+			out->write(buf,i);
+
+			dump_nest(out,2);
+
+			i=sprintf(buf,"if (myMask[0]&1) \\\n");
+			out->write(buf,i);
+
+			dump_nest(out,3);
+
+			i=sprintf(buf,"((somTD_SOMObject_somDestruct)\\\n");
+			out->write(buf,i);
+
+			dump_nest(out,4);
+
+			i=sprintf(buf,"ctrl->info->defaultDestruct)\\\n");
+			out->write(buf,i);
+
+			dump_nest(out,5);
+
+			i=sprintf(buf,"(somSelf,0,ctrl)\n");
+			out->write(buf,i);
+		}
+
+		j++;
+	}
+}
+#endif
+
+#if 0
+void RHBsome_emitter::generate_internal_cclass_data(RHBoutput *out,RHBinterface *iface)
+{
+	char n[256];
+	RHBelement_sequence vaops;
+	int numva=get_va_operations(iface,&vaops);
+
+	get_c_name(iface,n,sizeof(n));
+	out_printf(out,"struct %sCClassDataStructure SOMDLINK %sCClassData",n,n);
+
+	if (numva)
+	{
+		out_printf(out,"={(somMethodTabs)0,(somDToken)0\n");
+	
+		numva=0;
+
+		while (numva < (int)vaops.length())
+		{
+			RHBoperation *op=vaops.get(numva)->is_operation();
+
+			out_printf(out,",(somMethodPtr)somVA_%s_%s\n",n,op->id);
+
+			numva++;
+		}
+
+		out_printf(out,"}");
+	}
+
+	out_printf(out,";\n");
+}
+
+void RHBsome_emitter::generate_internal_class_data(RHBoutput *out,RHBinterface *iface)
+{
+	char n[256];
+	RHBelement *el;
+
+	get_c_name(iface,n,sizeof(n));
+	out_printf(out,"struct %sClassDataStructure SOMDLINK %sClassData={\n",n,n);
+
+	el=iface->classData->children();
+
+	while (el)
+	{
+		char val_done=0;
+
+		dump_nest(out,1);
+
+		out_printf(out,"/* %s */ ",el->id);
+
+		if (strcmp(/*buf*/el->id,"classObject"))
+		{
+			RHBelement *e2=iface->children();
+
+			while (e2)
+			{
+				if (0==strcmp(e2->id,el->id))
+				{
+					RHBoperation *op=e2->is_operation();
+
+					if (op)
+					{
+						if (is_operation_procedure(op))
+						{
+					/*		get_c_name(op,n);
+
+							i=sprintf(buf,"\n");
+							out->write(buf,i);
+							dump_nest(out,2);*/
+
+					/*		i=sprintf(buf,"(somTD_%s)\n",n);
+							out->write(buf,i);
+							dump_nest(out,3);*/
+
+							get_function_prefix(iface,n,sizeof(n));
+
+							out_printf(out,"%s%s",n,op->id);
+
+							val_done=1;
+
+							e2=0;
+						}
+					}
+				}
+
+				if (e2)
+				{
+					e2=e2->next();
+				}
+			}
+		}
+
+
+		if (!val_done)
+		{
+			out_printf(out,"0");
+		}
+
+		el=el->next();
+
+		if (el)
+		{
+			out_printf(out,",\n");
+		}
+	}
+
+	out_printf(out,"};\n");
+}
+
+void RHBsome_emitter::generate_somId(RHBoutput *out,int nest,
+		RHBelement *el,
+		const char *strPrefix,
+		const char *idPrefix,
+		boolean ir_spec,boolean recurse)
+{
+	char str[256];
+	char var[256];
+
+#ifdef _WIN32
+	#ifdef _DEBUG
+		if (ir_spec) bomb("emitting somId for IR");
+	#endif
+#endif
+
+	if (recurse)
+	{
+		get_ir_name(el,str,sizeof(str));
+
+		if (!ir_spec)
+		{
+			char *p=str;
+
+			if (0==memcmp("::",p,2))
+			{
+				while (p[2])
+				{
+					*p=p[2];
+					p++;
+				}
+
+				*p=0;
+			}
+		}
+	}
+	else
+	{
+		strncpy(str,el->id,sizeof(str));
+	}
+
+	if (recurse)
+	{
+		get_c_name(el,var,sizeof(var));
+	}
+	else
+	{
+		strncpy(var,el->id,sizeof(var));
+	}
+
+	{
+		char strName[256];
+
+		snprintf(strName,sizeof(strName),"%s_%s",strPrefix,var);
+
+		begin_generate_static(out,strName,nest);
+		undoublebar(out,strName);
+		dump_nest(out,nest+1);
+
+		out_printf(out,"static const char * %s=",strName);
+		out_printf(out,"%c%s%c;\n",double_quote,str,double_quote);
+		
+		end_generate_static(out,strName,nest);
+	}
+
+	if (idPrefix)
+	{
+		if (*idPrefix)
+		{
+			char idName[256];
+			snprintf(idName,sizeof(idName),"%s_%s",idPrefix,var);
+			begin_generate_static(out,idName,nest);
+			undoublebar(out,idName);
+			dump_nest(out,nest+1);
+			out_printf(out,"static const somConstId %s=",idName);
+			out_printf(out,"&%s_%s;\n",strPrefix,var);
+
+			end_generate_static(out,idName,nest);
+		}
+	}
+}
+
+void RHBsome_emitter::begin_generate_static(RHBoutput *out,const char *name,int nest)
+{
+	dump_nest(out,nest);
+	out_printf(out,"#ifndef static_%s\n",name);
+
+	dump_nest(out,nest+1);
+	out_printf(out,"#define static_%s\n",name);
+}
+
+void RHBsome_emitter::end_generate_static(RHBoutput *out,const char *name,int nest)
+{
+	dump_nest(out,nest);
+	out_printf(out,"#endif /* static_%s */\n",name);
+}
+
+
+void RHBsome_emitter::generate_somTDs(RHBoutput *out,RHBinterface *iface,int nest)
+{
+	RHBelement *e=iface->children();
+
+	while (e)
+	{
+		RHBoperation *op=e->is_operation();
+
+		if (op)
+		{
+			generate_somTD(out,iface,op,nest);
+		}
+
+		e=e->next();
+	}
+
+	if (cplusplus)
+	{
+		RHBelement_sequence seq;
+		unsigned long i=0;
+
+		determine_inherited(iface,iface,&seq);
+
+		while (i < seq.length())
+		{
+			RHBoperation *op=seq.get(i)->is_operation();
+			generate_somTD(out,iface,op,nest);
+			i++;
+		}
+	}
+}
+
+
+RHBtype *RHBsome_emitter::generate_array_slice_typedef(
+	RHBoutput *out,int nest,RHBtype *t,const char *n)
+{
+	t=unwind_typedef(t);
+	RHBarray *td=t->is_array();
+	t=td->array_of;
+
+	dump_nest(out,nest);
+	out_printf(out,"typedef ");
+	use_type(out,t,n);
+	out_printf(out,";\n");
+
+	return t;
+}
+
+RHBtype *RHBsome_emitter::get_array_slice(RHBtype *t)
+{
+	RHBtype *slice=NULL;
+
+	while (t)
+	{
+		if (t->is_typedef())
+		{
+			t=t->is_typedef()->alias_for;
+		}
+		else
+		{
+			RHBarray *array=t->is_array();
+
+			if (array)
+			{
+				t=array->array_of;
+
+				slice=t;
+			}
+			else
+			{
+				break;
+			}
+		}
+	}
+
+	return slice;
+}
+
+void RHBsome_emitter::generate_somTD(RHBoutput *out,RHBinterface *iface,RHBoperation *op,int nest)
+{
+	extern_c_proto_t ext_c_proto(this,out,nest);
+	char somTD_name[256];
+	char somTP_name[256];
+
+	{
+		char buf[256];
+		get_c_name(iface,buf,sizeof(buf));
+		strncpy(somTP_name,"somTP_",sizeof(somTP_name));
+		strncat(somTP_name,buf,sizeof(somTP_name));
+		strncat(somTP_name,"_",sizeof(somTP_name));
+		strncat(somTP_name,op->id,sizeof(somTP_name));
+	}
+
+	{
+		char buf[256];
+		get_c_name(iface,buf,sizeof(buf));
+		strncpy(somTD_name,"somTD_",sizeof(somTD_name));
+		strncat(somTD_name,buf,sizeof(somTD_name));
+		strncat(somTD_name,"_",sizeof(somTD_name));
+		strncat(somTD_name,op->id,sizeof(somTD_name));
+	}
+
+	dump_nest(out,nest);
+	out_printf(out,"#ifdef __IBMC__\n");
+
+	undoublebar(out,somTD_name);
+	undoublebar(out,somTP_name);
+
+	dump_nest(out,nest+1);
+	out_printf(out,"typedef ");
+
+	RHBtype *t=op->return_type;
+
+	if (t)
+	{
+		RHBtype *slice=get_array_slice(t);
+
+		if (slice)
+		{
+			use_type(out,slice,0);
+			out->write("*",1);
+		}
+		else
+		{
+			use_type(out,t,0);
+		}
+	}
+	else
+	{
+		out_printf(out,"void ");
+	}
+
+	out_printf(out,"(%s)",somTP_name);
+	generate_parameter_list(out,iface,op,nest+1,1,0);
+	out_printf(out,";\n");
+
+	dump_nest(out,nest+1);
+	out_printf(out,"#pragma linkage(%s,system)\n",somTP_name);
+
+	dump_nest(out,nest+1);
+
+	out_printf(out,"typedef %s *%s;\n",somTP_name,somTD_name);
+
+	dump_nest(out,nest);
+	out_printf(out,"#else /* __IBMC__ */\n");
+
+	undoublebar(out,somTD_name);
+
+	dump_nest(out,nest+1);
+
+	out_printf(out,"typedef ");
+
+	t=op->return_type;
+	if (t)
+	{
+		RHBtype *slice=get_array_slice(t);
+
+		if (slice)
+		{
+			use_type(out,slice,0);
+			out->write("*",1);
+		}
+		else
+		{
+			use_type(out,t,0);
+		}
+	}
+	else
+	{
+		out_printf(out,"void ");
+	}
+
+	out_printf(out,"(SOMLINK * %s)",somTD_name);
+
+	generate_parameter_list(out,iface,op,nest+1,1,0);
+	out_printf(out,";\n");
+
+	dump_nest(out,nest);
+	out_printf(out,"#endif /* __IBMC__ */\n");
+}
+
+void RHBsome_emitter::generate_parameter_list(
+		RHBoutput *out,
+		RHBinterface *iface,
+		RHBoperation *op,
+		int nesting,
+		boolean include_somSelf,
+		boolean do_const_in)
+{
+	RHBelement *e;
+	boolean first_param=1;
+
+	out_printf(out,"(\n");
+
+	dump_nest(out,nesting+1);
+
+	if (is_operation_noself(op))
+	{
+		include_somSelf=0;
+	}
+
+	if (include_somSelf)
+	{
+		first_param=0;
+
+		if (do_const_in) 
+		{
+			out_printf(out,"const ");
+		}
+
+		use_type(out,iface,"somSelf");
+	}
+
+	if (operation_needs_environment(iface,op))
+	{
+		if (first_param)
+		{
+			first_param=0;
+		}
+		else
+		{
+			out_printf(out,",\n");
+			dump_nest(out,nesting+1);
+		}
+
+		out_printf(out,"Environment *ev");
+	}
+
+	if (operation_needs_context(iface,op))
+	{
+		if (first_param)
+		{
+			first_param=0;
+		}
+		else
+		{
+			out_printf(out,",\n");
+			dump_nest(out,nesting+1);
+		}
+
+		if (do_const_in)
+		{
+			out_printf(out,"const ");
+		}
+
+		if (cplusplus)
+		{
+			out_printf(out,"Context * ctx");
+		}
+		else
+		{
+			out_printf(out,"Context SOMSTAR ctx");
+		}
+	}
+
+	e=op->children();
+
+	while (e)
+	{
+		RHBparameter *param=e->is_parameter();
+
+		if (param)
+		{
+			RHBtype *type=NULL;
+			int by_ref;
+
+			if (first_param)
+			{
+				first_param=0;
+			}
+			else
+			{
+				out_printf(out,",\n");
+				dump_nest(out,nesting+1);
+			}
+
+			out_printf(out,"/* %s */ ",param->mode);
+
+			by_ref=parameter_by_reference(param,NULL /* &type */);
+
+			if (do_const_in && do_const_param(param))
+			{
+				out_printf(out,"const ");
+			}
+
+			if (!type) type=param->parameter_type;
+
+			use_type(out,type,0);
+
+			if (by_ref)
+			{
+				out_printf(out,"*");
+			}
+
+			out_printf(out,"%s",param->id);
+		}
+
+		e=e->next();
+	}
+
+	out_printf(out,")");
+}
+
+boolean RHBsome_emitter::operation_needs_environment(
+		RHBinterface *iface,
+		RHBoperation *op)
+{
+	RHBelement *e;
+	const char *p;
+	char buf[256];
+	strncpy(buf,"callstyle",sizeof(buf));
+
+	if (op)
+	{
+		if (iface != op->parent())
+		{
+			if (op->parent()->is_interface())
+			{
+				iface=op->parent()->is_interface();
+			}
+		}
+	}
+
+	e=iface->find_named_element(0,buf,sizeof(buf));
+	if (!e) return 1;
+	p=e->modifier_data.get(0);
+
+	if (!p) return 1;
+
+	if (strcmp(p,"oidl")) return 1;
+
+	return 0;
+}
+
+boolean RHBsome_emitter::parameter_by_reference(RHBparameter *param,RHBtype **array_of)
+{
+	RHBtype *t=param->parameter_type;
+
+	if (strcmp(param->mode,"in")) 
+	{
+		while (t)
+		{
+			if (t->is_array())
+			{
+				/* special case, an array is already a pointer of
+					sorts */
+
+				if (array_of)
+				{
+					*array_of=t->is_array()->array_of;
+
+					return 1;
+				}
+
+				return 0;
+			}
+
+			if (t->is_typedef())
+			{
+				t=t->is_typedef()->alias_for;
+			}
+			else
+			{
+				break;
+			}
+		}
+
+		return 1;
+	}
+
+	while (t)
+	{
+		if (t->is_base_type()) 
+		{
+			return t->is_base_type()->_in_by_ref;
+		}
+
+		if (t->is_interface()) return 0;
+		if (t->is_enum()) return 0;
+		if (t->is_pointer()) return 0;
+		if (t->is_string()) return 0;
+		if (t->is_array()) 
+		{
+			if (array_of)
+			{
+				*array_of=t->is_array()->array_of;
+
+				return 1;
+			}
+
+			return 0;
+		}
+
+		if (t->is_sequence()) return 1;
+
+		if (0==strcmp(t->id,"somId"))
+		{
+			return 0;
+		}
+
+		if (0==strcmp(t->id,"va_list"))
+		{
+			return 0;
+		}
+
+		if (0==strcmp(t->id,"somToken"))
+		{
+			return 0;
+		}
+
+		if (t->is_typedef())
+		{
+			t=t->is_typedef()->alias_for;
+		}
+		else
+		{
+			if (t->is_qualified())
+			{
+				t=t->is_qualified()->base_type;
+			}
+			else
+			{
+				t=0;
+			}
+		}
+	}
+
+	return 1;
+}
+
+boolean RHBsome_emitter::operation_needs_context(
+		RHBinterface * /*iface*/,
+		RHBoperation *op)
+{
+	if (op->context_list.length()) return 1;
+
+	return 0;
+}
+
+void RHBsome_emitter::least_ambiguous_interface(RHBinterface *iface,const char *iface_name,char *buf,size_t buflen)
+{
+	buf[0]=0;
+
+	if (cplusplus)
+	{
+		if (iface)
+		{
+/*			int i;
+
+			i=iface->_parents.length();
+
+			if (i)
+			{
+				char n[256];
+				RHBinterface *par;
+
+				par=iface->_parents.get(0)->is_interface();
+
+				get_c_name(par,n);
+
+				if (strcmp(n,iface_name))
+				{
+					if (i > 1)
+					{
+						char *p;
+						p=&buf[strlen(buf)];
+						i=sprintf(p,"(%s *)",n);
+						buf=p+i;
+					}
+
+					least_ambiguous_interface(par,n,buf);
+				}
+			}*/
+
+			snprintf(buf,buflen,"(%s *)(void *)",iface_name);
+		}
+	}
+}
+
+void RHBsome_emitter::generate_inline_operation(RHBoutput *out,RHBinterface *iface,RHBoperation *op,int nest)
+{
+	char n[1024];
+	RHBelement *el;
+	boolean is_proc,any_params,is_noself;
+	const char *somSelf;
+	
+	is_noself=is_operation_noself(op);
+	is_proc=is_operation_procedure(op);
+
+	if (is_proc)
+	{
+		somSelf="this";
+	}
+	else
+	{
+		somSelf="this";
+	}
+
+	dump_nest(out,nest+1);
+
+	out_printf(out,"inline ");
+
+	if (is_noself)
+	{
+		out_printf(out,"static ");
+	}
+
+	if (op->return_type)
+	{
+		RHBtype *slice=get_array_slice(op->return_type);
+		if (slice)
+		{
+			use_type(out,slice,0);
+			out_printf(out,"* ");
+		}
+		else
+		{
+			use_type(out,op->return_type,0);
+		}
+	}
+	else
+	{
+		out_printf(out,"void ");
+	}
+
+	if (op_is_varg(op))
+	{
+		char buf[256];
+		get_c_name(op,buf,sizeof(buf));
+		out_printf(out,"%s",buf);
+	}
+	else
+	{
+		out_printf(out,"%s",op->id);
+	}
+
+	generate_parameter_list(out,iface,op,2,0,1);
+
+	out_printf(out,"\n");
+
+	dump_nest(out,nest+1);
+	out_printf(out,"{\n");
+
+	dump_nest(out,nest+2);
+
+	if (operation_has_return(op))
+	{
+		out_printf(out,"return ");
+	}
+
+	if (is_proc)
+	{
+/*		get_c_name(iface,n);*/
+		get_c_name(op->parent(),n,sizeof(n));
+		out_printf(out,"%sClassData.%s\n",n,op->id);
+	}
+	else
+	{
+		get_c_name(iface,n,sizeof(n));
+
+		get_c_name(op->parent(),n,sizeof(n));
+		out_printf(out,"SOM_Resolve((void *)%s,%s,%s)\n",
+						somSelf,n,op->id);
+	}
+
+	dump_nest(out,nest+4);
+
+	if (is_noself)
+	{
+		out_printf(out,"(");
+		any_params=0;
+	}
+	else
+	{
+		get_c_name(op->parent(),n,sizeof(n));
+		out_printf(out,"((%s *)(void *)%s",n,somSelf);
+		any_params=1;
+	}
+
+	if (operation_needs_environment(iface,op))
+	{
+		if (any_params)
+		{
+			out_printf(out,",");
+		}
+		else
+		{
+			any_params=1;
+		}
+		out_printf(out,"ev");
+	}
+
+	if (operation_needs_context(iface,op))
+	{
+		if (any_params)
+		{
+			out_printf(out,",");
+		}
+		else
+		{
+			any_params=1;
+		}
+		out_printf(out,"(Context *)ctx");
+	}
+
+	el=op->children();
+
+	while (el)
+	{
+		RHBparameter *param=el->is_parameter();
+
+		if (param)
+		{
+			if (any_params)
+			{
+				out_printf(out,",");
+			}
+			else
+			{
+				any_params=1;
+			}
+
+			if (do_const_param(param))
+			{
+				RHBtype *array_of=NULL;
+				out_printf(out,"(");
+
+				if (parameter_by_reference(param,&array_of))
+				{
+					if (array_of)
+					{
+						use_type(out,array_of,NULL);
+					}
+					else
+					{
+						use_type(out,param->parameter_type,NULL);
+					}
+
+					out_printf(out," *");
+				}
+				else
+				{
+					use_type(out,param->parameter_type,NULL);
+				}
+
+				out_printf(out,")");
+			}
+
+			out_printf(out,"%s",param->id);
+		}
+
+		el=el->next();
+	}
+
+	out_printf(out,");\n");
+
+	dump_nest(out,nest+1);
+	out_printf(out,"};\n");
+
+	if (op_is_varg(op))
+	{
+		generate_inline_varg_operation(out,iface,op,nest+1);
+	}
+}
+
+boolean RHBsome_emitter::operation_has_return(RHBoperation *op)
+{
+	if (op->return_type)
+	{	
+		char buf[256];
+
+		get_c_name(op->return_type,buf,sizeof(buf));
+
+		if (strcmp(buf,"void")) return 1;
+	}
+
+	return 0;
+}
+
+void RHBsome_emitter::generate_macro_operation(RHBoutput *out,RHBinterface *iface,RHBoperation *op,int nest)
+{
+	char n[256];
+	RHBelement *el;
+
+	get_c_name(op,n,sizeof(n));
+
+	dump_nest(out,nest);
+	out_printf(out,"#ifndef %s\n",n);
+
+	if (is_operation_procedure(op))
+	{
+		dump_nest(out,nest+1);
+		out_printf(out,"#define %s ",n);
+		get_c_name(iface,n,sizeof(n));
+		out_printf(out,"%sClassData.%s\n",n,op->id);
+	}
+	else
+	{
+		dump_nest(out,nest+1);
+		out_printf(out,"#define %s(somSelf",n);
+
+		if (operation_needs_environment(iface,op))
+		{
+			out_printf(out,",ev");
+		}
+
+		if (operation_needs_context(iface,op))
+		{
+			out_printf(out,",ctx");
+		}
+
+		el=op->children();
+
+		while (el)
+		{
+			RHBparameter *param=el->is_parameter();
+
+			if (param)
+			{
+				out_printf(out,",%s",param->id);
+			}
+
+			el=el->next();
+		}
+
+		out_printf(out,") \\\n");
+
+		dump_nest(out,nest+2);
+
+/*		i=sprintf(buf,"((somTD_%s)somResolve(somSelf,",n);
+		out->write(buf,i);
+		get_c_name(iface,n);
+		i=sprintf(buf,"%sClassData.%s)) \\\n",
+				n,op->id);
+*/
+		get_c_name(iface,n,sizeof(n));
+		out_printf(out,"SOM_Resolve(somSelf,%s,%s)  \\\n",
+					n,op->id);
+
+		dump_nest(out,nest+3);
+		out_printf(out,"(somSelf");
+
+		if (operation_needs_environment(iface,op))
+		{
+			out_printf(out,",ev");
+		}
+
+		if (operation_needs_context(iface,op))
+		{
+			out_printf(out,",ctx");
+		}
+
+		el=op->children();
+
+		while (el)
+		{
+			RHBparameter *param=el->is_parameter();
+
+			if (param)
+			{
+				out_printf(out,",%s",param->id);
+			}
+
+			el=el->next();
+		}
+
+		out_printf(out,")\n");
+	}
+
+	/* do the short name form */
+
+	gen_shortname(out,op,"_",nest+1);
+
+	dump_nest(out,nest);
+	get_c_name(op,n,sizeof(n));
+	out_printf(out,"#endif /* %s */\n",n);
+
+	if (op_is_varg(op))
+	{
+		extern_c_begin(out,nest);
+
+		if (nolegacy())
+		{
+			dump_nest(out,nest);
+			out_printf(out,"#ifndef va_%s\n",n);
+			dump_nest(out,nest+1);
+			out_printf(out,"#define va_%s somva_%s\n",n,n);
+			dump_nest(out,nest);
+			out_printf(out,"#endif /* va_%s */\n",n);
+		}
+		else
+		{
+			generate_va_stub(out,iface,op,nest,0,"va");
+		}
+		generate_va_stub(out,iface,op,nest,1,"somva");
+		extern_c_end(out,nest);
+	}
+}
+
+void RHBsome_emitter::gen_shortname(RHBoutput *out,RHBtype *op,const char *lead,int nest)
+{
+	char n[1024];
+
+	if (!op->id)
+	{
+		return;
+	}
+
+	get_c_name(op,n,sizeof(n));
+
+	if (!strcmp(n,op->id)) 
+	{
+		return;
+	}
+
+	if (!lead) lead="";
+
+	dump_nest(out,nest);
+	out_printf(out,"#ifndef SOM_DONT_USE_SHORT_NAMES\n");
+
+	dump_nest(out,nest+1);
+	out_printf(out,"#ifndef SOMGD_%s%s\n",lead,op->id);
+
+	dump_nest(out,nest+2);
+	out_printf(out,"#if defined(%s%s)\n",lead,op->id);
+
+	dump_nest(out,nest+3);
+	out_printf(out,"#undef %s%s\n",lead,op->id);
+
+	dump_nest(out,nest+3);
+	out_printf(out,"#define SOMGD_%s%s\n",lead,op->id);
+
+	dump_nest(out,nest+2);
+	out_printf(out,"#else\n");
+
+	get_c_name(op,n,sizeof(n));
+
+	dump_nest(out,nest+3);
+	out_printf(out,"#define %s%s %s\n",lead,op->id,n);
+
+	dump_nest(out,nest+2);
+	out_printf(out,"#endif\n");
+
+	dump_nest(out,nest+1);
+	out_printf(out,"#endif /* SOMGD_%s%s */\n",lead,op->id);
+
+	dump_nest(out,nest);
+	out_printf(out,"#endif /* SOM_DONT_USE_SHORT_NAMES */\n");
+}
+
+void RHBsome_emitter::generate_inherited_macros(RHBoutput *out,RHBelement_sequence *dups,RHBinterface *iface,RHBinterface *parent)
+{
+	if (parent)
+	{
+		unsigned long i=dups->length();
+
+		while (i--)
+		{
+			if (parent==dups->get(i))
+			{
+				return;
+			}
+		}
+
+		dups->add(parent);
+
+		i=0;
+
+		while (i < parent->_parents.length())
+		{
+			RHBelement *el=parent->_parents.get(i);
+
+			generate_inherited_macros(out,dups,iface,el->is_interface());
+
+			i++;
+		}
+
+		if (parent != iface)
+		{
+			if (iface)
+			{
+				RHBelement *el=parent->children();
+
+				while (el)
+				{
+					RHBoperation *op=el->is_operation();
+
+					if (op)
+					{
+						char buf[256];
+						out_printf(out,"#define ");
+						get_c_name(iface,buf,sizeof(buf));
+						out->write(buf,strlen(buf));
+						out->write("_",1);
+						out->write(op->id,strlen(op->id));
+						out->write(" ",1);
+
+						get_c_name(parent,buf,sizeof(buf));
+						out->write(buf,strlen(buf));
+						out->write("_",1);
+						out->write(op->id,strlen(op->id));
+						out_printf(out,"\n");
+					}
+
+					el=el->next();
+				}
+			}
+		}
+	}
+}
+
+void RHBsome_emitter::generate_redispatch_stub_proto(RHBoutput *out,RHBinterface *iface,RHBoperation *op,int nest)
+{
+	char n[256];
+
+	dump_nest(out,nest);
+	out_printf(out,"static ");
+
+	if (op->return_type)
+	{
+		RHBtype *as=get_array_slice(op->return_type);
+		if (as)
+		{
+			use_type(out,as,0);
+			out->write("* ",2);
+		}
+		else
+		{
+			use_type(out,op->return_type,0);
+		}
+	}
+	else
+	{
+		out_printf(out,"void ");
+	}
+
+	get_c_name(op,n,sizeof(n));
+	out_printf(out,"SOMLINK somRD_%s",n);
+	generate_parameter_list(out,iface,op,2,1,0);
+}
+
+boolean RHBsome_emitter::type_is_sequence(RHBtype *t)
+{
+	if (t)
+	{
+		t=unwind_typedef(t);
+		if (t->is_sequence()) return 1;
+	}
+
+	return 0;
+}
+
+boolean RHBsome_emitter::type_is_any(RHBtype *t)
+{
+	if (t)
+	{
+		char buf[256];
+		t=unwind_typedef(t);
+		get_c_name(t,buf,sizeof(buf));
+		if (!strcmp(buf,"any")) return 1;
+	}
+	return 0;
+}
+
+void RHBsome_emitter::generate_redispatch_stub(RHBoutput *out,RHBinterface *iface,RHBoperation *op,int nest)
+{
+	char n[256];
+	RHBelement *el;
+
+	/*  this has same signature as actual method,
+			but folds it back onto somDispatch */
+
+	{
+		extern_c_proto_t extern_c_proto(this,out,nest);
+
+		strncpy(n,"somRD_",sizeof(n));
+		get_c_name(op,n+strlen(n),sizeof(n)-strlen(n));
+		undoublebar(out,n);
+
+		generate_redispatch_stub_proto(out,iface,op,nest);
+		out_printf(out,";\n");
+	}
+
+	dump_nest(out,nest);
+	out_printf(out,"#ifdef __IBMC__\n");
+	
+	dump_nest(out,nest+1);
+	get_c_name(op,n,sizeof(n));
+	out_printf(out,"#pragma linkage(somRD_%s,system)\n",n);
+
+	dump_nest(out,nest);
+	out_printf(out,"#endif /* __IBMC__ */\n");
+
+	generate_redispatch_stub_proto(out,iface,op,nest);
+
+	out_printf(out,"\n");
+	dump_nest(out,nest);
+	out_printf(out,"{\n");
+
+	RHBtype *slice=NULL;
+
+	if (operation_has_return(op))
+	{
+/*		i=sprintf(buf,"#ifdef _DEBUG\n");
+		out->write(buf,i);
+
+		dump_nest(out,nest+1);
+		use_type(out,op->return_type,"__retVal");
+		if (type_is_sequence(op->return_type))
+		{
+			i=sprintf(buf,"={0x80808080L,0x80808080L,(void *)0x80808080L}");
+			out->write(buf,i);
+		}
+		else
+		{
+			if (type_is_any(op->return_type))
+			{
+				i=sprintf(buf,"={(TypeCode)0x80808080L,(void *)0x80808080L}");
+				out->write(buf,i);
+			}
+		}
+		i=sprintf(buf,";\n");
+		out->write(buf,i);
+
+		i=sprintf(buf,"#else\n");
+		out->write(buf,i);*/
+
+		dump_nest(out,nest+1);
+
+		slice=get_array_slice(op->return_type);
+
+		if (slice)
+		{
+			char retVal_assign[256];
+			snprintf(retVal_assign,sizeof(retVal_assign),"* %s=NULL",retVal_name);
+			use_type(out,slice,retVal_assign);
+		}
+		else
+		{
+			use_type(out,op->return_type,retVal_name);
+
+			if (type_is_sequence(op->return_type))
+			{
+				out_printf(out,"={0,0,NULL}");
+			}
+			else
+			{
+				if (type_is_any(op->return_type))
+				{
+					out_printf(out,"={NULL,NULL}");
+				}
+			}
+		}
+		out_printf(out,";\n");
+
+/*		i=sprintf(buf,"#endif\n");
+		out->write(buf,i);*/
+	}
+	else
+	{
+		dump_nest(out,nest+1);
+		out_printf(out,"somToken %s=NULL; /* actually returns a void */\n",retVal_name);
+	}
+
+	if (!slice)
+	{
+		if (!type_is_any(op->return_type))
+		{
+			if (!type_is_sequence(op->return_type))
+			{
+				generate_init_zero(out,retVal_name,op->return_type,nest,0);
+			}
+		}
+	}
+
+	dump_nest(out,nest+1);
+
+	if (cplusplus)
+	{
+		out_printf(out,"somSelf->somDispatch(");
+	}
+	else
+	{
+		out_printf(out,"somva_SOMObject_somDispatch(somSelf,");
+	}
+
+	if (operation_has_return(op))
+	{
+		out_printf(out,"(somToken *)(void *)&%s,\n",retVal_name);
+	}
+	else
+	{
+		out_printf(out,"&%s,\n",retVal_name);
+	}
+
+	dump_nest(out,nest+2);
+	out_printf(out,"(somId)somId_%s,somSelf",op->id);
+
+	if (operation_needs_environment(iface,op))
+	{
+		out_printf(out,",ev");
+	}
+	if (operation_needs_context(iface,op))
+	{
+		out_printf(out,",ctx");
+	}
+
+	el=op->children();
+
+	while (el)
+	{
+		RHBparameter *param=el->is_parameter();
+
+		if (param)
+		{
+			out_printf(out,",\n");
+
+			dump_nest(out,nest+3);
+
+			if (!parameter_by_reference(param,NULL))
+			{
+				RHBtype *t=get_va_type(param->parameter_type,1);
+
+				if (t != param->parameter_type)
+				{
+					out_printf(out,"(");
+					use_type(out,t,0);
+					out_printf(out,")");
+				}
+			}
+
+			out_printf(out,"%s",param->id);
+		}
+
+		el=el->next();
+	}
+	
+	out_printf(out,");\n");
+
+	if (operation_has_return(op))
+	{
+		out_printf(out,"\n");
+		dump_nest(out,nest+1);
+		out_printf(out,"return %s;\n",retVal_name);
+	}
+
+	dump_nest(out,nest);
+	out_printf(out,"}\n");
+}
+
+int RHBsome_emitter::align_for(long curr,int align)
+{
+	long dx;
+
+	if (align < 2)
+	{
+		return 0;
+	}
+
+	curr+=align;
+
+	dx=curr % align;
+
+	if (dx)
+	{
+		return align-dx;
+	}
+
+	return 0;
+}
+
+void RHBsome_emitter::generate_apply_stub_proto(RHBoutput *out,RHBinterface *iface,RHBoperation *op,int nest)
+{
+	char n[256];
+
+	dump_nest(out,nest);
+	get_c_name(op,n,sizeof(n));
+	out_printf(out,"static void SOMLINK somAP_%s",n);
+
+	out_printf(out,"(\n");
+
+	dump_nest(out,nest+1);
+	use_type(out,iface,"somSelf");
+	out_printf(out,",\n");
+
+	dump_nest(out,nest+1);
+
+	if (op->return_type)
+	{
+		RHBtype *slice=get_array_slice(op->return_type);
+		if (slice)
+		{
+			use_type(out,slice,"*");
+		}
+		else
+		{
+			use_type(out,op->return_type,0);
+		}
+	}
+	else
+	{
+		out_printf(out,"void ");
+
+	}
+	out_printf(out,"*%s,\n",retVal_name);
+
+	dump_nest(out,nest+1);
+
+#ifdef DO_FULL_TYPEDEF
+	out_printf(out,"somTD_%s _somC_methodPtr,\n",n);
+#else
+	out_printf(out,"somMethodPtr _somC_methodPtr,\n");
+#endif
+
+	dump_nest(out,nest+1);
+	out_printf(out,"va_list _somC_ap)");
+}
+
+void RHBsome_emitter::generate_apply_stub(RHBoutput *out,RHBinterface *iface,RHBoperation *op,int nest)
+{
+	/* apply stub has the form...
+
+		void somAP_xxx(obj,void *__retVal,somMethodPtr __methodPtr,va_list __ap),
+	
+	    generated routine should pull each parameter
+			from va_list __ap and 
+			then call __methodPtr with same prototype as somTD_xxx
+	*/
+
+	RHBelement *el;
+	char n[256];
+
+	if (op_is_varg(op)) 
+	{
+		get_c_name(op,n,sizeof(n));
+		dump_nest(out,nest);
+		out_printf(out,"/* somAP_%s() has va_list, ignored */\n",n);
+		return;
+	}
+
+	{
+		extern_c_proto_t extern_c_proto(this,out,nest);
+
+		strncpy(n,"somAP_",sizeof(n));
+		get_c_name(op,n+strlen(n),sizeof(n)-strlen(n));
+		undoublebar(out,n);
+
+		generate_apply_stub_proto(out,iface,op,nest);
+		out_printf(out,";\n");
+	}
+
+	dump_nest(out,nest);
+	out_printf(out,"#ifdef __IBMC__\n");
+
+	dump_nest(out,nest+1);
+	get_c_name(op,n,sizeof(n));
+	out_printf(out,"#pragma linkage(somAP_%s,system)\n",n);
+
+	dump_nest(out,nest);
+	out_printf(out,"#endif /* __IBMC__ */\n");
+
+	generate_apply_stub_proto(out,iface,op,nest);
+
+	out_printf(out,"\n");
+	dump_nest(out,nest);
+	out_printf(out,"{\n");
+
+	if (operation_needs_environment(iface,op))
+	{
+		dump_nest(out,nest+1);
+		out_printf(out,"Environment *ev;\n");
+	}
+
+	if (operation_needs_context(iface,op))
+	{
+		dump_nest(out,nest+1);
+		if (cplusplus)
+		{
+			out_printf(out,"Context * ctx;\n");
+		}
+		else
+		{
+			out_printf(out,"Context SOMSTAR ctx;\n");
+		}
+	}
+
+	el=op->children();
+
+	while (el)
+	{
+		RHBparameter *param=el->is_parameter();
+
+		if (param)
+		{
+			boolean by_ref=0;
+			RHBtype *local_type=NULL;
+			RHBtype *array_of=NULL;
+
+			dump_nest(out,nest+1);
+
+			by_ref=parameter_by_reference(param,&array_of);
+
+			local_type=param->parameter_type;
+
+			if (by_ref)
+			{
+				if (array_of) local_type=array_of;
+			}
+			else
+			{
+				RHBbase_type *x=unwind_typedef(local_type)->is_base_type();
+
+				if (x)
+				{
+					if (x->_floating)
+					{
+						local_type=get_va_type(local_type,1);
+					}
+				}
+			}
+
+			if (get_array_slice(param->parameter_type))
+			{
+				char tdn[256];
+				snprintf(tdn,sizeof(tdn),"_somC_slice_%s_t",param->id);
+				generate_array_slice_typedef(out,0,param->parameter_type,tdn);
+				dump_nest(out,nest+1);
+				out_printf(out,"_somC_slice_%s_t *%s;\n",param->id,param->id);
+			}
+			else
+			{
+				use_type(out,local_type,0);
+
+				if (by_ref)
+				{
+					out->write("*",1);
+				}
+
+				out_printf(out,"%s;\n",param->id);
+			}
+		}
+
+		el=el->next();
+	}
+
+	out_printf(out,"\n");
+
+	dump_nest(out,nest+1);
+	out_printf(out,"somSelf=va_arg(_somC_ap,");
+	use_type(out,iface,0);
+	out_printf(out,");\n");
+
+	if (operation_needs_environment(iface,op))
+	{
+		dump_nest(out,nest+1);
+		out_printf(out,"ev=va_arg(_somC_ap,Environment *);\n");
+	}
+
+	if (operation_needs_context(iface,op))
+	{
+		dump_nest(out,nest+1);
+		if (cplusplus)
+		{
+			out_printf(out,"ctx=va_arg(_somC_ap,Context *);\n");
+		}
+		else
+		{
+			out_printf(out,"ctx=va_arg(_somC_ap,Context SOMSTAR);\n");
+		}
+	}
+
+	el=op->children();
+
+	while (el)
+	{
+		RHBparameter *param=el->is_parameter();
+
+		if (param)
+		{
+			RHBtype *type=NULL;
+
+			dump_nest(out,nest+1);
+
+			out_printf(out,"%s=",param->id);
+
+			int by_ref=parameter_by_reference(param,&type);
+
+			if (get_array_slice(param->parameter_type))
+			{
+				char tdn[256];
+				snprintf(tdn,sizeof(tdn),"_somC_slice_%s_t",param->id);
+				out_printf(out,"va_arg(_somC_ap,%s *)",tdn);
+			}
+			else
+			{
+				if (!type) type=param->parameter_type;
+
+				use_va_arg(out,"_somC_ap",type,by_ref);
+			}
+
+			out_printf(out,";\n");
+		}
+
+		el=el->next();
+	}
+
+	out_printf(out,"\n");
+
+	if (!operation_has_return(op))
+	{
+		dump_nest(out,nest+1);
+		out_printf(out,"SOM_IgnoreWarning(%s);\n\n",retVal_name);
+	}
+
+	dump_nest(out,nest+1);
+
+	if (operation_has_return(op))
+	{
+		out_printf(out,"*%s=",retVal_name);
+	}
+
+#ifdef DO_FULL_TYPEDEF
+	out_printf(out,"_somC_methodPtr(somSelf");
+#else
+	get_c_name(op,n,sizeof(n));
+	out_printf(out,"((somTD_%s)_somC_methodPtr)(somSelf",n);
+#endif
+
+	if (operation_needs_environment(iface,op))
+	{
+		out_printf(out,",ev");
+	}
+
+	if (operation_needs_context(iface,op))
+	{
+		out_printf(out,",ctx");
+	}
+
+	el=op->children();
+
+	while (el)
+	{
+		RHBparameter *param=el->is_parameter();
+
+		if (param)
+		{
+			boolean by_ref=parameter_by_reference(param,NULL);
+
+			out_printf(out,",");
+
+			if (!by_ref)
+			{
+				RHBbase_type *bt=unwind_typedef(param->parameter_type)->is_base_type();
+
+				if (bt)
+				{
+					if (bt->_floating)
+					{
+						char nf[32];
+						get_c_name(bt,nf,sizeof(nf));
+	
+						if (!strcmp(nf,"float"))
+						{
+							out_printf(out,"(%s)",nf);
+						}
+					}
+				}
+			}
+
+			out_printf(out,"%s",param->id);
+		}
+
+		el=el->next();
+	}
+
+	out_printf(out,");\n");
+
+	dump_nest(out,nest);
+	out_printf(out,"}\n\n");
+
+	generated_apply_stubs.add(op);
+}
+
+void RHBsome_emitter::use_va_arg(RHBoutput *out,const char *ap,RHBtype *typ,boolean byRef)
+{
+	/* added to cast so that shorts will be mapped from int etc */
+
+	RHBtype *typ_cast=unwind_typedef(typ);
+	if (!byRef)
+	{
+		if (typ_cast->is_qualified()||typ_cast->is_base_type())
+		{
+			out->write("(",1);
+			if (byRef)
+			{
+				use_type(out,typ,0);
+				out->write("*",1);
+			}
+			else
+			{
+				use_type(out,typ,0);
+			}
+			out->write(")",1);
+		}
+	}
+	/* end of addition */
+
+	out_printf(out,"va_arg(%s,",ap);
+
+	if (byRef)
+	{
+		use_type(out,typ,0);
+		out_printf(out,"*");
+	}
+	else
+	{
+		use_type(out,get_va_type(typ,1),0);
+	}
+
+	out_printf(out,")");
+}
+
+RHBtype *RHBsome_emitter::get_va_type(RHBtype *typ,boolean cast_float)
+{
+	RHBbase_type *bt;
+	RHBtype_def *dt;
+	RHBtype *orig;
+
+	orig=typ;
+
+	while (typ)
+	{
+		if (typ->is_interface())
+		{
+			break;
+		}
+
+		if (typ->is_pointer())
+		{
+			break;
+		}
+
+		dt=typ->is_typedef();
+
+		if (dt)
+		{
+			typ=dt->alias_for;
+		}
+		else
+		{
+			bt=typ->is_base_type();
+
+			if (bt)
+			{
+				if (bt->_va_type)
+				{
+					if (bt->_floating)
+					{
+						if (!cast_float)
+						{
+							return bt;
+						}
+					}
+
+					return bt->_va_type;
+				}
+
+				return orig;
+			}
+			else
+			{
+				if (typ->is_qualified())
+				{
+					/* follow this */
+					typ=typ->is_qualified()->base_type;
+				}
+				else
+				{
+					return orig;
+				}
+			}
+		}
+	}
+
+	return orig;
+}
+
+void RHBsome_emitter::determine_inherited(RHBinterface *iface,RHBinterface *candidates,RHBelement_sequence *seq)
+{
+	if (candidates)
+	{
+		if (candidates != iface)
+		{
+			RHBelement *el=candidates->children();
+
+			while (el)
+			{
+				RHBoperation *op;
+
+				op=el->is_operation();
+
+				if (op)
+				{
+					if (!seq->contains(op))
+					{
+/*						char buf[256];
+						get_c_name(op,buf);
+						printf("adding %s\n",buf);*/
+						seq->add(op);
+					}
+				}
+
+				el=el->next();
+			}
+		}
+
+		unsigned long i=0;
+
+		while (i < candidates->_parents.length())
+		{
+			RHBelement *el;
+
+			el=candidates->_parents.get(i);
+
+			determine_inherited(iface,el->is_interface(),seq);
+
+			i++;
+		}
+	}
+}
+
+void RHBsome_emitter::determine_overrides(
+				RHBinterface *iface,
+				RHBinterface * /* candidates */,
+				RHBelement_sequence *seq)
+{
+	RHBelement *el=iface->children();
+
+	while (el)
+	{
+		RHBinherited_operation *iop=el->is_inherited_operation();
+
+		if (iop)
+		{
+			if (does_override(iface,iop->id))
+			{
+				if (!seq->contains(iop->original))
+				{
+					seq->add(iop->original);
+				}
+			}
+		}
+
+		el=el->next();
+	}
+
+#if 0
+	if (candidates)
+	{
+		if (candidates!=iface)
+		{
+			RHBelement *el=candidates->children();
+
+			while (el)
+			{
+				int yes=0;
+				RHBoperation *op=el->is_operation();
+
+				if (op)
+				{
+					char buf[256];
+					RHBelement *mod;
+
+					strncpy(buf,op->id,sizeof(buf));
+					mod=iface->find_named_element(0,buf,sizeof(buf));
+
+					if (mod)
+					{
+						int i=0;
+
+						while (mod->modifier_data.get(i))
+						{
+							const char *p=mod->modifier_data.get(i);
+							if (0==strcmp(p,"override"))
+							{
+								yes=1;
+								break;
+							}
+
+							i++;
+						}
+					}
+
+					if (!yes)
+					{
+						strncpy(buf,"override",sizeof(buf));
+						mod=iface->find_named_element(0,buf,sizeof(buf));
+						if (mod)
+						{
+							int i;
+
+							i=0;
+
+							while (mod->modifier_data.get(i))
+							{
+								const char *p=mod->modifier_data.get(i);
+								if (0==strcmp(p,op->id))
+								{
+									yes=1;
+									break;
+								}
+
+								i++;
+							}
+						}
+					}
+
+					if (yes)
+					{
+						if (!seq->contains(op))
+						{
+							seq->add(op);
+						}
+					}
+				}
+
+				el=el->next();
+			}
+		}
+	}
+
+	if (iface)
+	{
+		if (candidates)
+		{
+			unsigned long i=0;
+
+			while (i < candidates->_parents.length())
+			{
+				determine_overrides(iface,candidates->_parents.get(i)->is_interface(),seq);
+	
+				i++;
+			}
+		}
+	}
+#endif
+}
+
+void RHBsome_emitter::generate_operation_proto(RHBoutput *out,RHBinterface *iface,RHBoperation *op,int nest)
+{
+	char n[256];
+
+/*	extern_c_begin(out,nest);*/
+
+	/* SOM_Scope macro contains enough scoping */
+
+	{
+		extern_c_proto_t scoping(this,out,nest);
+
+		get_function_prefix(iface,n,sizeof(n));
+		strncat(n,op->id,sizeof(n));
+		undoublebar(out,n);
+
+		dump_nest(out,nest);
+		out_printf(out,"SOM_Scope ");
+
+		if (op->return_type)
+		{
+			RHBtype *s=get_array_slice(op->return_type);
+			if (s)
+			{
+				use_type(out,s,0);
+				out_printf(out,"* ");
+			}
+			else
+			{
+				use_type(out,op->return_type,0);
+			}
+		}
+		else
+		{
+			out_printf(out,"void ");
+		}
+
+		out_printf(out,"SOMLINK ");
+
+		get_function_prefix(iface,n,sizeof(n));
+
+		out_printf(out,"%s%s",n,op->id);
+
+		generate_parameter_list(out,iface,op,0,1,0);
+		out_printf(out,";\n");
+	}
+
+	dump_nest(out,nest);
+	out_printf(out,"#ifdef __IBMC__\n");
+
+	get_function_prefix(iface,n,sizeof(n));
+	dump_nest(out,nest+1);
+	out_printf(out,"#pragma linkage(%s%s,system)\n",n,op->id);
+	dump_nest(out,nest);
+	out_printf(out,"#endif /* __IBMC__ */\n");
+
+/*	extern_c_end(out,nest);*/
+}
+
+void RHBsome_emitter::get_function_prefix(RHBinterface *iface,char *buf,size_t buflen)
+{
+	RHBelement *el;
+	char n[256];
+
+	strncpy(n,"functionprefix",sizeof(n));
+	buf[0]=0;
+
+	el=iface->find_named_element(0,n,sizeof(n));
+
+	if (el)
+	{
+		const char *p=el->modifier_data.get(0);
+
+		if (p)
+		{
+			while (*p)
+			{
+				if (*p!=double_quote)
+				{
+					if (!--buflen) break;
+
+					*buf++ = *p;
+				}
+				p++;
+			}
+
+			*buf=0;
+		}
+	}
+	else
+	{
+		/* 31-3-1999 */
+/*		get_c_name(iface,buf);*/
+		*buf=0;
+	}
+}
+
+boolean RHBsome_emitter::get_actual_meta_class(RHBinterface *iface,char *buf,size_t buflen)
+{
+	if (get_meta_class(iface,buf)) 
+	{
+		RHBelement *el=iface->find_named_element(0,buf,buflen);
+
+		if (el)
+		{
+			get_c_name(el,buf,buflen);
+
+			return 1;
+		}
+	}
+
+	strncpy(buf,"SOMClass",buflen);
+
+	return 0;
+}
+
+RHBinterface *RHBsome_emitter::get_meta_class_interface(RHBinterface *iface)
+{
+	RHBelement *el;
+	char n[256];
+
+	if (!iface) return 0;
+
+	strncpy(n,"metaclass",sizeof(n));
+
+	el=iface->find_named_element(0,n,sizeof(n));
+
+	if (el)
+	{
+		const char *p;
+		char buffer[256];
+		char *buf;
+
+		buf=buffer;
+
+		p=el->modifier_data.get(0);
+
+		if (p)
+		{
+			while (*p)
+			{
+				if (*p!=double_quote)
+				{
+					*buf++ = *p;
+				}
+				p++;
+			}
+
+			*buf=0;
+
+			el=iface->find_named_element(0,buffer,sizeof(buffer));
+
+			if (el)
+			{
+				return el->is_interface();
+			}
+		}
+	}
+
+	unsigned long i=0;
+
+	while (i < iface->_parents.length())
+	{
+		el=iface->_parents.get(i);
+
+		RHBinterface *meta=get_meta_class_interface(el->is_interface());
+
+		if (meta)
+		{
+			return meta;
+		}
+
+		i++;
+	}
+
+	return 0;
+}
+
+boolean RHBsome_emitter::get_meta_class(RHBinterface *iface,char *buf)
+{
+	RHBelement *el;
+	char n[256];
+
+	strncpy(n,"metaclass",sizeof(n));
+	buf[0]=0;
+
+	el=iface->find_named_element(0,n,sizeof(n));
+
+	if (el)
+	{
+		const char *p=el->modifier_data.get(0);
+
+		if (p)
+		{
+			while (*p)
+			{
+				if (*p!=double_quote)
+				{
+					*buf++ = *p;
+				}
+				p++;
+			}
+
+			*buf=0;
+
+			return 1;
+		}
+	}
+
+	unsigned long i=0;
+
+	while (i < iface->_parents.length())
+	{
+		el=iface->_parents.get(i);
+
+		if (get_meta_class(el->is_interface(),buf))
+		{
+			return 1;
+		}
+
+		i++;
+	}
+
+	return 0;
+}
+
+
+void RHBsome_emitter::generate_parent_macro(
+			RHBoutput *out,
+			RHBinterface *iface,
+			RHBinterface *parent,
+			RHBoperation *op,
+			int nest)
+{
+	char buf[256];
+	char n[256];
+
+	get_c_name(op,buf,sizeof(buf));
+
+	if ((!strcmp(buf,"SOMObject_somInit"))||
+		(!strcmp(buf,"SOMObject_somUninit")))
+	{
+			get_c_name(iface,n,sizeof(n));
+			strncat(n,"_parent_",sizeof(n));
+			get_c_name(parent,buf,sizeof(buf));
+			strncat(n,buf,sizeof(n));
+			strncat(n,"_",sizeof(n));
+			strncat(n,op->id,sizeof(n));
+
+			dump_nest(out,nest);
+			out_printf(out,"#ifndef %s\n",n);
+			dump_nest(out,nest+1);
+			out_printf(out,"#define %s(somSelf)\n",n);
+			dump_nest(out,nest);
+			out_printf(out,"#endif /* %s */\n",n);
+	}
+	else
+	{
+		int k=get_parent_index(iface,parent);
+
+		if (is_dts_override(op))
+		{
+			dts_parent_macro(out,iface,k-1,parent,op,nest);
+
+			k=0;
+		}
+
+		if (k)
+		{
+			dump_nest(out,nest);
+			get_c_name(iface,n,sizeof(n));
+			out_printf(out,"#define %s_parent_",n);
+			get_c_name(parent,n,sizeof(n));
+			out_printf(out,"%s_%s",n,op->id);
+			generate_name_only_parameter_list(out,iface,op,0);
+			out_printf(out,"   \\\n");
+
+			dump_nest(out,nest+1);
+
+			if (cplusplus)
+			{
+				get_c_name(iface,n,sizeof(n));
+				strncat(n,"_",sizeof(n));
+				strncat(n,op->id,sizeof(n));
+			}
+			else
+			{
+				get_c_name(op,n,sizeof(n));
+			}
+
+			if (is_kernel_class(iface))
+			{
+				get_function_prefix(parent,n,sizeof(n));
+				out_printf(out,"%s%s",n,op->id);
+			}
+			else
+			{
+				out_printf(out,"((somTD_%s)\\\n",n);
+				dump_nest(out,nest+2);
+				if (generate_parent_resolved(out,iface,parent,op,3))
+				{
+					out_printf(out,")\\\n");
+				}
+				else
+				{
+					get_c_name(iface,n,sizeof(n));
+					out_printf(out,"somParentNumResolve(%sCClassData.parentMtab,\\\n",n);
+					dump_nest(out,nest+3);
+					get_c_name(op->parent(),n,sizeof(n));
+					out_printf(out,"%d,%sClassData.%s))\\\n",k,n,op->id);
+				}
+			}
+			dump_nest(out,nest+4);
+			generate_name_only_parameter_list(out,iface,op,cplusplus);
+			out_printf(out,"\n");
+		}
+	}
+}
+
+int RHBsome_emitter::get_parent_index(RHBinterface *iface,RHBinterface *if2)
+{
+	unsigned long i=0;
+
+	if (iface==if2) return 1;
+
+	while (i < iface->_parents.length())
+	{
+		if (get_parent_index(iface->_parents.get(i)->is_interface(),if2))
+		{
+			return i+1;
+		}
+
+		i++;
+	}
+
+	return 0;
+}
+
+void RHBsome_emitter::generate_name_only_parameter_list(RHBoutput *out,RHBinterface *iface,RHBoperation *op,boolean expand_self)
+{
+	RHBelement *el;
+
+	if (cplusplus && expand_self)
+	{
+		char n[256];
+		get_c_name(iface,n,sizeof(n));
+		out_printf(out,"((%s *)(void *)somSelf",n);
+	}
+	else
+	{
+		out_printf(out,"(somSelf");
+	}
+
+	if (operation_needs_environment(iface,op))
+	{
+		out->write(",ev",3);
+	}
+	if (operation_needs_context(iface,op))
+	{
+		out->write(",ctx",4);
+	}
+	el=op->children();
+
+	while (el)
+	{
+		RHBparameter *param;
+
+		param=el->is_parameter();
+
+		if (param)
+		{
+			out->write(",",1);
+			out->write(param->id,strlen(param->id));
+		}
+
+		el=el->next();
+	}
+
+	out->write(")",1);
+}
+
+
+boolean RHBsome_emitter::has_same_ABI(RHBoperation *op1,RHBoperation *op2)
+{
+	int i=0;
+
+	if (op1==op2) return 1;
+	if (!op1) return 0;
+	if (!op2) return 0;
+
+	if (operation_needs_environment(0,op1)!=operation_needs_environment(0,op2))
+	{
+		return 0;
+	}
+
+	if (operation_needs_context(0,op1)!=operation_needs_context(0,op2))
+	{
+		return 0;
+	}
+
+	if (operation_has_return(op1)!=operation_has_return(op2))
+	{
+		return 0;
+	}
+
+	if (operation_has_return(op1))
+	{
+		if (!same_ABI_type(op1->return_type,op2->return_type))
+		{
+			return 0;
+		}
+	}
+
+	while (1)
+	{
+		RHBtype *t1=0,*t2=0;
+		RHBparameter *param1=op1->get_parameter(i);
+		RHBparameter *param2=op2->get_parameter(i);
+
+		i++;
+
+		if ((!param1)&&(!param2))
+		{
+			break;
+		}
+
+		if (!param1) return 0;
+		if (!param2) return 0;
+
+		int ref1=parameter_by_reference(param1,NULL);
+		int ref2=parameter_by_reference(param2,NULL);
+
+		if (!ref1) 
+		{
+			t1=get_va_type(unwind_typedef(param1->parameter_type),0);
+			ref1=some_ABI_kind_of_pointer(t1);
+		}
+
+		if (!ref2)
+		{
+			t2=get_va_type(unwind_typedef(param2->parameter_type),0);
+			ref2=some_ABI_kind_of_pointer(t2);
+		}
+
+		if (ref1 && ref2)
+		{
+			continue;
+		}
+
+		if (ref1 || ref2)
+		{
+			return 0;
+		}
+
+		if (!same_ABI_type(t1,t2))
+		{
+			return 0;
+		}
+	}
+
+	return 1;
+}
+
+boolean RHBsome_emitter::same_ABI_type(RHBtype *t1,RHBtype *t2)
+{
+	boolean ptr1,ptr2;
+
+	t1=unwind_typedef(t1);
+	t2=unwind_typedef(t2);
+
+	if (t1==t2) return 1;
+
+	ptr1=some_ABI_kind_of_pointer(t1);
+	ptr2=some_ABI_kind_of_pointer(t2);
+
+	if (ptr1 && ptr2) return 1;
+
+	if (ptr1) return 0;
+	if (ptr2) return 0;
+
+	if (t1->is_sequence())
+	{
+		if (t2->is_sequence())
+		{
+			return 1;
+		}
+	}
+
+	if (t1->is_any())
+	{
+		if (t2->is_any())
+		{
+			return 1;
+		}
+	}
+
+	RHBbase_type *b1,*b2;
+
+	b1=t1->is_base_type();
+	b2=t2->is_base_type();
+
+	if (b1 && b2)
+	{
+		if (b1->_floating != b2->_floating) return 0;
+	}
+
+	if (b1)
+	{
+		if (b1->_floating) 
+		{
+			return 0;
+		}
+	}
+
+	if (b2)
+	{
+		if (b2->_floating) 
+		{
+			return 0;
+		}
+	}
+
+/*
+	won't do this check because this depends on this compiler
+	knowing the alignments and sizes for the target platform,
+	which we cant do if if we want to use the same headers on 
+	Intel,PowerPC, DEC Alpha and AS400
+
+
+	if (t1->_get_length()== t2->_get_length())
+	{
+		if (t1->_get_length())
+		{
+			if (t1->_get_alignment()==t2->_get_alignment())
+			{
+				if (t1->_get_alignment())
+				{
+					return 1;
+				}
+			}
+		}
+	}
+*/
+	return 0;
+}
+
+boolean RHBsome_emitter::some_ABI_kind_of_pointer(RHBtype *t)
+{
+	if (t->is_interface()) return 1;
+	if (t->is_pointer()) return 1;
+	if (t->is_string()) return 1;
+	if (t->is_TypeCode()) return 1;
+
+	return 0;
+}
+
+void RHBsome_emitter::generate_versions(RHBoutput *out,RHBinterface *iface,const char *ext,const char *mod_name,int nest)
+{
+	RHBelement *el;
+	const char *p;
+	char n[256];
+	char buf[256];
+
+	strncpy(buf,mod_name,sizeof(buf));
+	el=iface->find_named_element(0,buf,sizeof(buf));
+
+	p=0;
+
+	if (el)
+	{
+		p=el->modifier_data.get(0);
+	}
+
+	if (!p) p="0";
+
+	dump_nest(out,nest);
+	get_c_name(iface,n,sizeof(n));
+
+	out_printf(out,"#ifndef %s_%s\n",n,ext);
+	dump_nest(out,nest+1);
+	out_printf(out,"#define %s_%s   %s\n",n,ext,p);
+	dump_nest(out,nest);
+	out_printf(out,"#endif /* %s_%s */\n",n,ext);
+}
+
+boolean RHBsome_emitter::will_generate_static(const char *p)
+{
+	int i;
+
+	i=0;
+
+	while (generated_statics.get(i))
+	{
+		const char *q=generated_statics.get(i);
+		if (0==strcmp(p,q))
+		{
+			return 0;
+		}
+
+		i++;
+	}
+
+	generated_statics.add(p);
+
+	return 1;
+}
+
+boolean RHBsome_emitter::is_operation_noself(RHBoperation *op)
+{
+	const char *noself="noself";
+
+	if (op)
+	{
+		int i=0;
+
+		RHBelement *el=op->children();
+
+		while (el)
+		{
+			if (!strcmp(el->id,noself))
+			{
+				RHBmodifier *mod=el->is_modifier();
+
+				if (mod) return 1;
+			}
+
+			el=el->next();
+		}
+
+		while (i < op->modifier_data.length())
+		{
+			const char *p=op->modifier_data.get(i);
+
+			if (!strcmp(p,noself))
+			{
+				return 1;
+			}
+
+			i++;
+		}
+	}
+
+	return 0;
+}
+
+boolean RHBsome_emitter::is_operation_procedure(RHBoperation *op)
+{
+	const char *modname="procedure";
+
+	if (op)
+	{
+		int i=0;
+
+		RHBelement *el=op->children();
+
+		while (el)
+		{
+			if (!strcmp(el->id,modname))
+			{
+				RHBmodifier *mod=el->is_modifier();
+
+				if (mod) return 1;
+			}
+
+			el=el->next();
+		}
+
+		while (i < op->modifier_data.length())
+		{
+			const char *p=op->modifier_data.get(i);
+
+			if (!strcmp(p,modname))
+			{
+				return 1;
+			}
+
+			i++;
+		}
+	}
+
+	return 0;
+}
+
+#ifdef _PLATFORM_MACINTOSH_
+void RHBsome_emitter::align_begin(RHBoutput *out,boolean user_data,int nest)
+#else
+void RHBsome_emitter::align_begin(RHBoutput *,boolean,int)
+#endif
+{
+#ifdef _PLATFORM_MACINTOSH_
+	char buf[256];
+	int i;
+	dump_nest(out,nest);
+	i=sprintf(buf,"#ifdef _PLATFORM_MACINTOSH_\n");
+	out->write(buf,i);
+
+	dump_nest(out,nest+1);
+	i=sprintf(buf,"#if powerc\n");
+	out->write(buf,i);
+
+	dump_nest(out,nest+2);
+	if (user_data)
+	{
+		i=sprintf(buf,"#pragma options align=mac68k\n");
+	}
+	else
+	{
+		i=sprintf(buf,"#pragma options align=power\n");
+	}
+
+	out->write(buf,i);
+
+	dump_nest(out,nest+1);
+	i=sprintf(buf,"#endif /* powerc */\n");
+	out->write(buf,i);
+
+	dump_nest(out,nest);
+	i=sprintf(buf,"#endif /* _PLATFORM_MACINTOSH_ */\n");
+	out->write(buf,i);
+#endif
+}
+
+#ifdef _PLATFORM_MACINTOSH_
+void RHBsome_emitter::align_end(RHBoutput *out,boolean user_data,int nest)
+#else
+void RHBsome_emitter::align_end(RHBoutput *,boolean,int)
+#endif
+{
+#ifdef _PLATFORM_MACINTOSH_
+	char buf[256];
+	int i;
+
+	dump_nest(out,nest);
+	i=sprintf(buf,"#ifdef _PLATFORM_MACINTOSH_\n");
+	out->write(buf,i);
+
+	dump_nest(out,nest+1);
+	i=sprintf(buf,"#if powerc\n");
+	out->write(buf,i);
+
+	dump_nest(out,nest+2);
+	i=sprintf(buf,"#pragma options align=reset\n");
+	out->write(buf,i);
+
+	dump_nest(out,nest+1);
+	i=sprintf(buf,"#endif /* powerc */\n");
+	out->write(buf,i);
+
+	dump_nest(out,nest);
+	i=sprintf(buf,"#endif /* _PLATFORM_MACINTOSH_ */\n");
+	out->write(buf,i);
+#endif
+}
+
+int RHBsome_emitter::is_unsigned(RHBtype *typ)
+{
+	while (typ->is_typedef())
+	{
+		typ=typ->is_typedef()->alias_for;
+	}
+
+	RHBqualified_type *q=typ->is_qualified();
+
+	if (q)
+	{
+		if (!strcmp(q->id,"unsigned"))
+		{
+			return 1;
+		}
+	}
+
+	if (typ->is_enum()) 
+	{
+		return 1;
+	}
+
+	return 0;
+}
+
+int RHBsome_emitter::is_long(RHBtype *t)
+{
+	while (t)
+	{
+		RHBtype_def *td=t->is_typedef();
+		if (td)
+		{
+			t=td->alias_for;
+		}
+		else
+		{
+			RHBqualified_type *qt=t->is_qualified();
+
+			if (qt)
+			{
+				t=qt->base_type;
+			}
+			else
+			{
+				RHBbase_type *bt=t->is_base_type();
+
+				if (bt)
+				{
+					if (!strcmp(bt->id,"long"))
+					{
+						return 1;
+					}
+				}
+
+				if (t->is_enum())
+				{
+					return 1;
+				}
+
+				return 0;
+			}
+		}
+	}
+
+	return 0;
+}
+
+void RHBsome_emitter::generate_constant(RHBoutput *out,RHBconstant *cn,int nest)
+{
+	char n[256];
+
+	if (cn->is_const_TypeCode())
+	{
+		dump_nest(out,nest);
+		get_c_name(cn,n,sizeof(n));
+		out_printf(out,"/* TypeCode constant %s not emitted */\n",n);
+
+		return;
+	}
+
+	dump_nest(out,nest);
+	get_c_name(cn,n,sizeof(n));
+	out_printf(out,"#ifndef %s\n",n);
+	dump_nest(out,nest+1);
+	out_printf(out,"#define %s   ",n);
+
+	if (cn->is_numeric())
+	{
+		char extra[3]={0,0,0};
+		char L=0;
+
+		if (is_long(cn->constant_type))
+		{
+			L='L';
+		}
+
+		if (is_unsigned(cn->constant_type))
+		{
+			extra[0]='U';
+			extra[1]=L;
+
+			out_printf(out,"%lu%s\n",(unsigned long)cn->numeric_value(),extra);
+		}
+		else
+		{
+			extra[0]=L;
+			out_printf(out,"%ld%s\n",(long)cn->numeric_value(),extra);
+		}
+	}
+	else
+	{
+		if (cn->value_string)
+		{
+			out_printf(out,"\042%s\042\n",cn->value_string);
+		}
+		else
+		{
+			out_printf(out,"NULL\n");
+		}
+	}
+
+	gen_shortname(out,cn,0,nest+1);
+
+	dump_nest(out,nest);
+	get_c_name(cn,n,sizeof(n));
+	out_printf(out,"#endif /* %s */\n",n);
+}
+
+void RHBsome_emitter::generate_class_guard(RHBoutput *out,int nest,RHBinterface *iface,boolean how)
+{
+	if (internal)
+	{
+		char n[256];
+
+		dump_nest(out,nest);
+
+		get_c_name(iface,n,sizeof(n));
+
+		if (how)
+		{
+			out_printf(out,"#ifdef %s_Class_Source\n",n);
+		}
+		else
+		{
+			out_printf(out,"#endif /* %s_Class_Source */\n",n);
+		}
+	}
+}
+
+void RHBsome_emitter::generate_passthru(RHBoutput *out,RHBinterface *iface,const char *which)
+{
+	int i=0;
+	RHBelement *el;
+	int j=0;
+
+	el=0;
+	while (iface->passthru_list.get(i))
+	{
+		el=iface->passthru_list.get(i);
+		if (0==strcmp(which,el->id))
+		{
+			break;
+		}
+
+		i++;
+		el=0;
+	}
+
+	if (!el) return;
+
+	while (j < el->modifier_data.length())
+	{
+		const char *p=el->modifier_data.get(j);
+
+		if (p)
+		{
+			if (*p==double_quote)
+			{
+				p++;
+			}
+
+			i=strlen(p);
+
+			if (i)
+			{
+				if (p[i-1]==double_quote)
+				{
+					i--;
+				}
+			}
+
+			out->write(p,i);
+			out_printf(out,"\n");
+		}
+
+		j++;
+	}
+
+}
+
+void RHBsome_emitter::generate_init_zero(
+		RHBoutput *out,const char *name,RHBtype *typ,int nest,
+		unsigned long /*initial_value*/)
+{
+/*	int i;
+	char buf[256];*/
+	char n[256];
+
+	if (!typ) return;
+
+	while (typ->is_typedef())
+	{
+		typ=typ->is_typedef()->alias_for;
+
+		get_ir_name(typ,n,sizeof(n));
+
+		if (!strcmp(n,"::SOMFOREIGN"))
+		{
+			return;
+		}
+	}
+
+	while (typ->is_qualified())
+	{
+		typ=typ->is_qualified()->base_type;
+	}
+
+	get_c_name(typ,n,sizeof(n));
+
+	if (!strcmp(n,"void")) return;
+
+	out_printf(out,"#ifdef _DEBUG\n");
+
+	dump_nest(out,nest+1);
+	out_printf(out,"memset(&%s,0xCC,sizeof(%s));\n",
+			name,name);
+
+	out_printf(out,"#endif /* _DEBUG */\n");
+
+#if 0
+	if (!strcmp(n,"any"))
+	{
+		dump_nest(out,nest+1);
+		i=sprintf(buf,"%s._type=(TypeCode)%ld;\n",name,initial_value);
+		out->write(buf,i);
+		dump_nest(out,nest+1);
+		i=sprintf(buf,"%s._value=(void *)%ld;\n",name,initial_value);
+		out->write(buf,i);
+		typ=0;
+	}
+
+	if (!strcmp(n,"float"))
+	{
+		dump_nest(out,nest+1);
+		i=sprintf(buf,"%s=(float)0.0;\n",name);
+		out->write(buf,i);
+		typ=0;
+	}
+
+	if (!strcmp(n,"double"))
+	{
+		dump_nest(out,nest+1);
+		i=sprintf(buf,"%s=(double)0.0;\n",name);
+		out->write(buf,i);
+		typ=0;
+	}
+
+/*	if (!strcmp(n,"TypeCode"))
+	{
+		dump_nest(out,1);
+		i=sprintf(buf,"%s=TC_void;\n",name);
+		out->write(buf,i);
+		typ=0;
+	}
+*/
+	if (typ)
+	{
+		if (typ->is_sequence())
+		{
+			dump_nest(out,nest+1);
+			i=sprintf(buf,"%s._length=%ld;\n",name,initial_value);
+			out->write(buf,i);
+			dump_nest(out,nest+1);
+			i=sprintf(buf,"%s._maximum=%ld;\n",name,initial_value);
+			out->write(buf,i);
+			dump_nest(out,nest+1);
+			i=sprintf(buf,"%s._buffer=%ld;\n",name,initial_value);
+			out->write(buf,i);
+			typ=0;
+		}
+	}
+
+	if (typ)
+	{
+		if (typ->is_union() || typ->is_struct() || typ->is_array())
+		{
+			dump_nest(out,nest+1);
+			i=sprintf(buf,"memset(&%s,%d,sizeof(%s));\n",name,(int)(unsigned char)initial_value,name);
+			out->write(buf,i);
+			typ=0;
+		}
+	}
+
+	if (typ)
+	{
+/*		if (typ->is_interface())
+		{
+			dump_nest(out,nest+1);
+			i=sprintf(buf,"%s=(%s SOMSTAR)%ld;\n",
+						name,n,initial_value);
+			out->write(buf,i);
+		}
+		else*/
+		{
+			if (!initial_value)
+			{
+				if (typ->is_base_type())
+				{
+					dump_nest(out,nest+1);
+					i=sprintf(buf,"%s=%ld;\n",name,initial_value);
+					out->write(buf,i);
+					typ=0;
+				}
+			}
+			
+		    if (typ)
+			{
+				dump_nest(out,nest+1);
+				i=sprintf(buf,"%s=(",name);
+				out->write(buf,i);
+				use_type(out,typ,0);
+				i=sprintf(buf,")%ld;\n",initial_value);
+				out->write(buf,i);
+			}
+		}
+	}
+
+	i=sprintf(buf,"\n");
+	out->write(buf,i);
+
+	i=sprintf(buf,"#endif /* _DEBUG */\n");
+	out->write(buf,i);
+#endif
+}
+
+
+boolean RHBsome_emitter::op_is_varg(RHBoperation *op)
+{
+	char buf[256];
+
+	if (!op) return 0;
+
+	RHBelement *el=op->children();
+	
+	RHBparameter *last_param=NULL;
+
+	if (!el) return 0;
+
+	while (el)
+	{
+		if (el->is_parameter())
+		{
+			last_param=el->is_parameter();
+		}
+
+		el=el->next();
+	}
+
+	if (!last_param) 
+	{
+		return 0;
+	}
+
+	if (strcmp(last_param->id,"ap"))
+	{
+		return 0;
+	}
+
+	get_c_name(last_param->parameter_type,buf,sizeof(buf));
+
+	if (strcmp(buf,"va_list"))
+	{
+		return 0;
+	}
+
+/*	get_c_name(op,buf);
+
+	printf("%s is varg op\n",buf);
+*/
+	return 1;
+}
+
+RHBelement *RHBsome_emitter::generate_va_proto(RHBoutput *out,RHBinterface *iface,RHBoperation *op,int nest,int flag,const char *prefix)
+{
+	char n[256];
+	RHBtype *t;
+	RHBelement *el;
+	RHBelement *penultimate=0;
+	const char *linkage=flag ? "SOMLINK" : "";
+
+	get_c_name(iface,n,sizeof(n));
+
+	t=op->return_type;
+
+	if (t)
+	{
+		use_type(out,t,0);
+	}
+	else
+	{
+		out_printf(out,"void ");
+	}
+
+	out_printf(out,"%s %s_%s_%s",linkage,prefix,n,op->id);
+
+	get_c_name(iface,n,sizeof(n));
+	out_printf(out,"(%s SOMSTAR somSelf,",n);
+
+	if (operation_needs_environment(iface,op))
+	{
+		out_printf(out,"Environment *ev,");
+	}
+
+	if (operation_needs_context(iface,op))
+	{
+		out_printf(out,"Context SOMSTAR ctx,");
+	}
+
+	out_printf(out,"\n");
+
+	el=op->children();
+
+	while (el->next())
+	{
+		RHBparameter *param=el->is_parameter();
+
+		if (param)
+		{
+			RHBelement *e2=NULL;
+			RHBparameter *another=NULL;
+
+			e2=param->next();
+
+			while (e2)
+			{
+				if (e2->is_parameter())
+				{
+					another=e2->is_parameter();
+				}
+
+				e2=e2->next();
+			}
+
+			if (!another) break;
+
+			penultimate=param;
+
+			dump_nest(out,nest+2);
+
+			use_type(out,param->parameter_type,0);
+
+			if (parameter_by_reference(param,NULL))
+			{
+				out_printf(out,"*");
+			}
+
+			out_printf(out,"%s,\n",param->id);
+		}
+
+		el=el->next();
+	}
+
+	dump_nest(out,nest+2);
+	out_printf(out,"...)");
+
+	return penultimate;
+}
+
+void RHBsome_emitter::generate_va_stub(RHBoutput *out,RHBinterface *iface,RHBoperation *op,int nest,int flags,const char *prefix)
+{
+	char n[256];
+	RHBelement *el;
+	RHBelement *penultimate;
+	int do_macros=(flags & 2) ? 0 : 1;
+
+	flags&=~2;
+
+	if (!prefix)
+	{
+		prefix=flags ? "somva" : "va";
+	}
+
+	get_c_name(iface,n,sizeof(n));
+
+	if (do_macros)
+	{
+		dump_nest(out,nest);
+		out_printf(out,"#ifdef %s_VA_EXTERN\n",n);
+
+		/* need to prototype the va function when it is not static... */
+
+		dump_nest(out,nest+1);
+		out_printf(out,"SOMEXTERN\n");
+
+		if (iface->has_modifier_value("dllname"))
+		{
+			get_c_name(iface,n,sizeof(n));
+dump_nest(out,nest+1);
+			out_printf(out,"#ifdef %s_VA_STUBS\n",n);
+dump_nest(out,nest+2);
+			out_printf(out,"#ifdef SOMDLLEXPORT\n");
+dump_nest(out,nest+3);
+			out_printf(out,"SOMDLLEXPORT\n");
+dump_nest(out,nest+2);
+			out_printf(out,"#endif /* SOMDLLEXPORT */\n");
+dump_nest(out,nest+1);
+			out_printf(out,"#else\n");
+			ifdef_import_export(out,iface,nest+2);
+dump_nest(out,nest+1);
+			out_printf(out,"#endif /* %s_VA_STUBS */\n",n);
+		}
+
+		dump_nest(out,nest+1);
+
+		generate_va_proto(out,iface,op,nest,flags,prefix);
+		
+		out_printf(out,";\n");
+
+		dump_nest(out,nest);
+		out_printf(out,"#endif\n");
+	}
+
+	int final_endif=0;
+
+	if (do_macros)
+	{
+		final_endif=1;
+		dump_nest(out,nest);
+		get_c_name(iface,n,sizeof(n));
+		out_printf(out,"#if (defined(%s_VA_STUBS)||!defined(%s_VA_EXTERN))\n",
+				n,n);
+	}
+
+	if (do_macros)
+	{
+		dump_nest(out,nest+1);
+
+		get_c_name(iface,n,sizeof(n));
+		out_printf(out,"#ifdef %s_VA_EXTERN\n",n);
+
+		dump_nest(out,nest+2);
+		out_printf(out,"SOMEXTERN\n");
+
+		dump_nest(out,nest+1);
+		out_printf(out,"#else\n");
+	}
+
+	dump_nest(out,nest+2);
+	out_printf(out,"static\n");
+
+	if (do_macros)
+	{
+		dump_nest(out,nest+1);
+		out_printf(out,"#endif\n");
+	}
+
+	dump_nest(out,nest+1);
+
+	penultimate=generate_va_proto(out,iface,op,nest+1,flags,prefix);
+
+	out_printf(out,"\n");
+
+	get_c_name(iface,n,sizeof(n));
+
+/*	if (do_macros)
+	{
+		get_c_name(iface,n,sizeof(n));
+		dump_nest(out,nest);
+		out_printf(out,"#if (defined(%s_VA_STUBS)||!defined(%s_VA_EXTERN))\n",
+				n,n);
+	}
+*/
+	dump_nest(out,nest+1);
+	out_printf(out,"{\n");
+
+	if (operation_has_return(op))
+	{
+		dump_nest(out,nest+2);
+		use_type(out,op->return_type,"__result");
+		out_printf(out,";\n");
+	}
+
+	dump_nest(out,nest+2);
+	out_printf(out,"va_list ap;\n");
+
+	dump_nest(out,nest+2);
+	out_printf(out,"va_start(ap,%s);\n",penultimate->id);
+
+	dump_nest(out,nest+2);
+	if (operation_has_return(op))
+	{
+		out_printf(out,"__result=");
+	}
+
+/*	i=sprintf(buf,"((somTD_%s_%s)somResolve\n",n,op->id);
+	out->write(buf,i);
+
+	get_c_name(op->parent(),n);
+	dump_nest(out,nest+2);
+	i=sprintf(buf,"(somSelf,%sClassData.%s))\n",n,op->id);
+	out->write(buf,i);
+*/
+	get_c_name(op->parent(),n,sizeof(n));
+	out_printf(out,"SOM_Resolve(somSelf,%s,%s)\n",n,op->id);
+
+	dump_nest(out,nest+4);
+	out_printf(out,"(somSelf,");
+
+	if (operation_needs_environment(iface,op))
+	{
+		out_printf(out,"ev,");
+	}
+
+	if (operation_needs_context(iface,op))
+	{
+		out_printf(out,"ctx,");
+	}
+
+	el=op->children();
+
+	while (el->next())
+	{
+		if (el->is_parameter())
+		{
+			out_printf(out,"%s,",el->id);
+		}
+
+		if (el==penultimate) break;
+
+		el=el->next();
+	}
+
+	out_printf(out,"ap);\n");
+
+	dump_nest(out,nest+2);
+	out_printf(out,"va_end(ap);\n");
+
+	if (operation_has_return(op))
+	{
+		dump_nest(out,nest+2);
+		out_printf(out,"return __result;\n");
+	}
+
+	dump_nest(out,nest+1);
+	out_printf(out,"}\n");
+
+/*	if (do_macros)
+	{
+		dump_nest(out,nest);
+		out_printf(out,"#else\n");
+
+		dump_nest(out,nest);
+		out_printf(out,";\n");
+
+		dump_nest(out,nest);
+		out_printf(out,"#endif\n");
+	}*/
+
+	if (final_endif)
+	{
+		dump_nest(out,nest);
+		out_printf(out,"#endif\n");
+	}
+}
+
+void RHBsome_emitter::generate_inline_varg_operation(RHBoutput *out,RHBinterface *iface,RHBoperation *op,int nest)
+{
+	char n[256];
+	RHBtype *t;
+	RHBelement *el;
+	RHBelement *ap=NULL;
+	RHBelement *penult=NULL;
+
+	const char *result_name="_somC_result";
+
+	el=op->children();
+
+	while (el)
+	{
+		if (el->is_parameter())
+		{
+			ap=el->is_parameter();
+		}
+
+		el=el->next();
+	}
+
+	el=op->children();
+
+	while (el)
+	{
+		if (el->is_parameter())
+		{
+			if (el==ap) break;
+
+			penult=el;
+		}
+
+		el=el->next();
+	}
+
+	get_c_name(op,n,sizeof(n));
+/*	i=sprintf(buf,"\n",n);
+	out->write(buf,i);*/
+
+	dump_nest(out,nest);
+	out_printf(out,"inline ");
+	t=op->return_type;
+	if (t)
+	{
+		use_type(out,t,0);
+	}
+	else
+	{
+		out_printf(out,"void ");
+	}
+
+	out_printf(out,"%s(",op->id);
+
+	if (operation_needs_environment(iface,op))
+	{
+		out_printf(out,"Environment *ev,");
+	}
+
+	if (operation_needs_context(iface,op))
+	{
+		out_printf(out,"Context * ctx,");
+	}
+
+	out_printf(out,"\n");
+
+	el=op->children();
+
+	while (el)
+	{
+		RHBparameter *param=el->is_parameter();
+
+		if (param)
+		{
+			dump_nest(out,nest+2);
+
+			use_type(out,param->parameter_type,0);
+
+			if (parameter_by_reference(param,NULL))
+			{
+				out_printf(out,"*");
+			}
+
+			out_printf(out,"%s,\n",param->id);
+
+			if (param==penult) break;
+		}
+
+		el=el->next();
+	}
+
+	dump_nest(out,nest+2);
+	out_printf(out,"...)\n");
+
+	dump_nest(out,nest);
+	out_printf(out,"{\n");
+
+	if (operation_has_return(op))
+	{
+		dump_nest(out,nest+1);
+		use_type(out,op->return_type,result_name);
+		out_printf(out,";\n");
+	}
+
+	dump_nest(out,nest+1);
+	out_printf(out,"va_list ap;\n");
+
+	dump_nest(out,nest+1);
+	out_printf(out,"va_start(ap,%s);\n",penult->id);
+
+	dump_nest(out,nest+1);
+	if (operation_has_return(op))
+	{
+		out_printf(out,"%s=",result_name);
+	}
+
+/*	get_c_name(iface,n);
+	i=sprintf(buf,"((somTD_%s_%s)somResolve\n",n,op->id);
+	out->write(buf,i);
+
+	get_c_name(op->parent(),n);
+	dump_nest(out,nest+2);
+	i=sprintf(buf,"((SOMObject *)(void *)this,%sClassData.%s))\n",n,op->id);
+	out->write(buf,i);
+*/
+	get_c_name(op->parent(),n,sizeof(n));
+	out_printf(out,"SOM_Resolve(this,%s,%s)\n",n,op->id);
+
+/*	get_c_name(iface,n);*/
+	get_c_name(op->parent(),n,sizeof(n));
+	dump_nest(out,nest+3);
+	out_printf(out,"((%s *)(void *)this,",n);
+
+	if (operation_needs_environment(iface,op))
+	{
+		out_printf(out,"ev,");
+	}
+
+	if (operation_needs_context(iface,op))
+	{
+		out_printf(out,"ctx,");
+	}
+
+	el=op->children();
+
+	while (el)
+	{
+		if (el->is_parameter())
+		{
+			out_printf(out,"%s,",el->id);
+			if (el==penult) break;
+		}
+
+		el=el->next();
+	}
+
+	out_printf(out,"ap);\n");
+
+	dump_nest(out,nest+1);
+	out_printf(out,"va_end(ap);\n");
+
+	if (operation_has_return(op))
+	{
+		dump_nest(out,nest+1);
+		out_printf(out,"return %s;\n",result_name);
+	}
+
+	dump_nest(out,nest);
+	out_printf(out,"};\n");
+}
+
+void RHBsome_emitter::generate_inline_somNew_operation(RHBoutput *out,RHBinterface *iface,RHBoperation * /*op */,int nest)
+{
+	char n[256];
+	RHBinterface *base=find_highest_common_parent(&iface->_metaclass_of);
+
+	nest++;
+
+	if (base)
+	{
+		get_c_name(base,n,sizeof(n));
+	}
+	else
+	{
+		strncpy(n,"SOMObject",sizeof(n));
+	}
+
+	dump_nest(out,nest);
+	out_printf(out,"inline %s * somNew()\n",n);
+
+	dump_nest(out,nest);
+	out_printf(out,"{\n");
+
+	dump_nest(out,nest+1);
+	out_printf(out,"return (%s *)(void *)SOM_Resolve(this,SOMClass,somNew)\n",n);
+
+	dump_nest(out,nest+2);
+	out_printf(out,"((SOMClass *)(void *)this);\n");
+
+	dump_nest(out,nest);
+	out_printf(out,"}\n");
+}
+
+RHBinterface *RHBsome_emitter::find_highest_common_parent(RHBelement_sequence *seq)
+{
+	RHBinterface *ret=seq->get(0)->is_interface();
+	size_t i=seq->length();
+
+	while (i--)
+	{
+		RHBinterface *iface=seq->get(i)->is_interface();
+
+		if (!iface->is_subclass_of(ret))
+		{
+			unsigned long j=0;
+
+			while (j < iface->_parents.length())
+			{
+				i=0;
+
+				ret=iface->_parents.get(j)->is_interface();
+
+				while (i < seq->length())
+				{
+					i++;
+
+					if (!seq->get(i)->is_interface()->is_subclass_of(ret))
+					{
+						ret=0;
+						i=seq->length();
+					}
+				}
+
+				j++;
+
+				if (ret) j=iface->_parents.length();
+			}
+
+			i=seq->length();
+		}
+	}
+
+	return ret;
+}
+
+boolean RHBsome_emitter::is_multiple_inherited(RHBinterface *iface)
+{
+	if (iface)
+	{
+		switch (iface->_parents.length())
+		{
+		case 0:
+			return 0;
+		case 1:
+			return is_multiple_inherited(iface->_parents.get(0)->is_interface());
+		default:
+			return 1;
+		}
+	}
+
+	return 0;
+}
+
+void RHBsome_emitter::generate_name_lookups(RHBoutput *out,RHBinterface *iface,int nest)
+{
+	RHBelement *e=iface->children();
+
+	while (e)
+	{
+		RHBoperation *op=e->is_operation();
+
+		if (op)
+		{
+			generate_name_lookup(out,iface,op,nest);
+		}
+
+		e=e->next();
+	}
+
+	if (cplusplus)
+	{
+		RHBelement_sequence seq;
+		unsigned long i=0;
+
+		determine_inherited(iface,iface,&seq);
+
+		while (i < seq.length())
+		{
+			RHBoperation *op=seq.get(i)->is_operation();
+			generate_name_lookup(out,iface,op,nest);
+			i++;
+		}
+	}
+}
+
+void RHBsome_emitter::generate_name_lookup(RHBoutput *out,RHBinterface *iface,RHBoperation *op,int nest)
+{
+	if (op->has_modifier_value("namelookup"))
+	{
+		char n[256];
+
+		dump_nest(out,nest);
+		get_c_name(iface,n,sizeof(n));
+		out_printf(out,"#ifndef %s_lookup_%s\n",
+				n,op->id);
+
+		dump_nest(out,nest+1);
+		out_printf(out,"#define %s_lookup_%s",n,op->id);
+
+		generate_name_only_parameter_list(out,iface,op,0);
+
+		get_c_name(iface,n,sizeof(n));
+		if (cplusplus)
+		{
+			out_printf(out,
+				" ((somTD_%s_%s)somResolveByName((SOMObject *)(void *)somSelf,%c%s%c))",
+				n,op->id,double_quote,op->id,double_quote);
+		}
+		else
+		{
+			out_printf(out,
+				" ((somTD_%s_%s)somResolveByName(somSelf,%c%s%c))",
+				n,op->id,double_quote,op->id,double_quote);
+		}
+
+		generate_name_only_parameter_list(out,iface,op,0);
+
+		out_printf(out,"\n");
+		
+		dump_nest(out,nest+1);
+		out_printf(out,"#ifndef lookup_%s\n",op->id);
+
+		get_c_name(iface,n,sizeof(n));
+		dump_nest(out,nest+2);
+		out_printf(out,"#define lookup_%s %s_lookup_%s\n",
+					op->id,n,op->id);
+
+		dump_nest(out,nest+1);
+		out_printf(out,"#endif /* lookup_%s */\n",op->id);
+
+		dump_nest(out,nest);
+		out_printf(out,"#endif /* %s_lookup_%s */\n",n,op->id);
+	}
+}
+
+void RHBsome_emitter::gen_shortname_sequence(RHBoutput *out,RHBtype *type,int nest)
+{
+	char n[256];
+
+	get_c_name(type,n,sizeof(n));
+
+	if (!type->id) return;
+	if (!n[0]) return;
+
+	if (!strcmp(n,type->id))
+	{
+		return;
+	}
+
+	dump_nest(out,nest);
+	out_printf(out,"#ifndef SOM_DONT_USE_SHORT_NAMES\n");
+
+	dump_nest(out,nest+1);
+	out_printf(out,"#ifndef _IDL_SEQUENCE_%s_defined\n",type->id);
+
+	dump_nest(out,nest+2);
+	out_printf(out,"#define _IDL_SEQUENCE_%s_defined\n",type->id);
+
+
+	dump_nest(out,nest+2);
+	out_printf(out,"#define _IDL_SEQUENCE_%s _IDL_SEQUENCE_%s\n",
+				type->id,n);
+
+	dump_nest(out,nest+1);
+	out_printf(out,"#endif /* _IDL_SEQUENCE_%s_defined */\n",type->id);
+
+	dump_nest(out,nest);
+	out_printf(out,"#endif /* SOM_DONT_USE_SHORT_NAMES */\n");
+}
+
+int RHBsome_emitter::get_cif(RHBinterface *iface,char *buf,size_t buflen)
+{
+	RHBelement *el;
+	char n[256];
+
+	strncpy(n,"classinit",sizeof(n));
+	buf[0]=0;
+
+	el=iface->find_named_element(0,n,sizeof(n));
+
+	if (el)
+	{
+		const char *p=el->modifier_data.get(0);
+		char cif[256]={0};
+		char *q=cif;
+
+		if (p)
+		{
+			while (*p)
+			{
+				if (*p!=double_quote)
+				{
+					*q++ = *p;
+				}
+				p++;
+			}
+
+			*q=0;
+		}
+
+		get_function_prefix(iface,buf,buflen);
+		strncat(buf,cif,buflen);
+
+		return 1;
+	}
+
+	*buf=0;
+
+	return 0;
+}
+
+boolean RHBsome_emitter::is_derived_from(RHBinterface *iface,RHBinterface *base)
+{
+	if (base)
+	{
+		unsigned long i=0;
+
+		if (base==iface) return 1;
+
+		while (i < iface->_parents.length())
+		{
+			if (is_derived_from(iface->_parents.get(i)->is_interface(),base))
+			{
+				return 1;
+			}
+
+			i++;
+		}
+	}
+
+	return 0;
+}
+
+int RHBsome_emitter::generate_parent_resolved(RHBoutput *out,
+												RHBinterface *iface,
+												RHBinterface *parent,
+												RHBoperation *op,
+												int mode)
+{
+	int retVal=0;
+
+	if (iface 
+		&& parent 
+		&& op 
+		&& 
+		strcmp(op->id,"somInit") && 
+		strcmp(op->id,"somUninit") &&
+		strcmp(op->id,"somDestruct"))
+	{
+		if (!op->has_modifier_value("init"))
+		{
+			if (does_override(iface,op->id))
+			{
+				if (is_derived_from(parent,op->parent()->is_interface()))
+				{
+					retVal=get_parent_index(iface,parent);
+
+					if (retVal)
+					{
+						char tokenName[1024];
+						char name[256],parent_name[256];
+
+						get_c_name(iface,name,sizeof(name));
+						get_c_name(parent,parent_name,sizeof(parent_name));
+
+						snprintf(tokenName,sizeof(tokenName),"_somC_%s_parent_%s_%s_resolved",
+									name,parent_name,op->id);
+
+						switch (mode)
+						{
+						case 1:
+							out_printf(out,"static somMethodPtr %s; /* %d */\n",tokenName,retVal);
+							break;
+						case 2:
+							get_c_name(op->parent(),parent_name,sizeof(parent_name));
+							out_printf(out,"\t%s=somParentNumResolve(%sCClassData.parentMtab,%d,%sClassData.%s);\n",
+									tokenName,
+									name,
+									retVal,
+									parent_name,
+									op->id);
+							break;
+						case 3:
+							out_printf(out,"%s",tokenName);
+							break;
+						default:
+							retVal=0;
+							break;
+						}
+					}
+				}
+			}
+		}
+	}
+
+	return retVal;
+}
+
+int RHBsome_emitter::is_kernel_class(RHBinterface *k)
+{
+	char buf[256];
+	get_c_name(k,buf,sizeof(buf));
+	if (strcmp(buf,"SOMObject")&&
+		strcmp(buf,"SOMClass")&&
+		strcmp(buf,"SOMClassMgr"))
+	{
+		return 0;
+	}
+	return 1;
+}
+
+int RHBsome_emitter::count_ClassData(RHBinterface *p)
+{
+	int count=0;
+
+	if (p)
+	{
+		if (p->classData)
+		{
+			RHBelement *el=p->classData->children();
+
+			while (el)
+			{
+				if (strcmp(el->id,"classObject"))
+				{
+					count++;
+				}
+
+				el=el->next();
+			}
+		}
+	}
+
+	return count;
+}
+
+int RHBsome_emitter::get_init_operations(RHBinterface *iface,RHBelement_sequence *seq)
+{
+	RHBelement *el=iface->classData->children();
+
+	while (el)
+	{
+		RHBelement *e2=iface->children();
+
+		while (e2)
+		{
+			if (!strcmp(e2->id,el->id))
+			{
+				RHBoperation *op=e2->is_operation();
+
+				if (op)
+				{
+					if (op->has_modifier_value("init"))
+					{
+						seq->add(op);
+					}
+				}
+			}
+
+			e2=e2->next();
+		}
+
+		el=el->next();
+	}
+
+	return seq->length();
+}
+
+int RHBsome_emitter::get_va_operations(RHBinterface *iface,RHBelement_sequence *seq)
+{
+	char buf[256];
+
+	strncpy(buf,"releaseorder",sizeof(buf));
+
+	RHBelement *e=iface->find_named_element(0,buf,sizeof(buf));
+
+	if (e)
+	{
+		int i=0;
+
+		while (e->modifier_data.get(i))
+		{
+			const char *p=e->modifier_data.get(i);
+			i++;
+
+			if (strcmp(p,","))
+			{
+				RHBelement *oe;
+
+				strncpy(buf,p,sizeof(buf));
+
+				oe=iface->find_named_element(0,buf,sizeof(buf));
+
+				if (oe) 
+				{
+					RHBoperation *op=oe->is_operation();
+
+					if (op && op_is_varg(op))
+					{
+						seq->add(op);
+					}
+				}
+			}
+		}
+	}
+
+	return seq->length();
+}
+
+typedef enum
+{
+	dts_destructor,dts_constructor,dts_assignment
+} dts_override_type;
+
+struct dts_override
+{
+	dts_override_type dts_type;
+	const char *name;
+	const char *initType;
+	const char *member;
+	const char *structInfo;
+	const char *macro;
+	const char *mtab;
+	const char *structCtrl;
+};
+
+static struct dts_override dts_overrides[]={
+	{dts_destructor,
+		"somDestruct","Destructor","defaultDestruct",
+		"somDestructInfo","DeInit","destructCtrl","somDestructCtrl"},
+	{dts_constructor,
+		"somDefaultInit","Initializer","defaultInit",
+		"somInitInfo","Init","initCtrl","somInitCtrl"},
+	{dts_assignment,
+		"somDefaultAssign","AssignmentOp","defaultNCArgAssign",
+		"somAssignInfo","Assign","assignCtrl","somAssignCtrl"},
+	{dts_assignment,
+		"somDefaultConstAssign","AssignmentOp","defaultConstAssign",
+		"somAssignInfo","Assign","assignCtrl","somAssignCtrl"}
+};
+
+struct dts_override * RHBsome_emitter::is_dts_override(RHBoperation *op)
+{
+	int i=sizeof(dts_overrides)/sizeof(dts_overrides[0]);
+	struct dts_override *s=dts_overrides;
+	while (i--)
+	{
+		if (!strcmp(s->name,op->id)) return s;
+		s++;
+	}
+	return 0;
+}
+
+void RHBsome_emitter::write_macro_args(RHBoutput *out,RHBoperation *op,int include_somSelf)
+{	
+	if (include_somSelf) 
+	{
+		out_printf(out,"(somSelf");
+	}
+
+	if (operation_needs_environment(op->parent()->is_interface(),op))
+	{
+		out_printf(out,",ev");
+	}
+
+	if (operation_needs_context(op->parent()->is_interface(),op))
+	{
+		out_printf(out,",ctx");
+	}
+
+	RHBelement *el=op->children();
+
+	while (el)
+	{
+		RHBparameter *param=el->is_parameter();
+
+		if (param)
+		{
+			out_printf(out,",%s",param->id);
+		}
+
+		el=el->next();
+	}
+
+	out_printf(out,")");
+}
+
+void RHBsome_emitter::dts_parent_macro(RHBoutput *out,RHBinterface *iface,int num,RHBinterface *parent,RHBoperation *op,int /* nest */)
+{
+	struct dts_override *dts=is_dts_override(op);
+	char n[256],m[256],o[256],objcls[256];
+	int parent_is_SOMObject;
+	const char *somstar=cplusplus ? "*" : "SOMSTAR";
+
+	get_c_name(iface,n,sizeof(n));
+	get_c_name(parent,m,sizeof(m));
+	get_c_name(op,o,sizeof(o));
+	get_c_name(op->parent(),objcls,sizeof(objcls));
+
+	parent_is_SOMObject=strcmp(m,"SOMObject") ? 0 : 1;
+
+#if 0
+	if (parent_is_SOMObject)
+	{
+		out_printf(out,"/* special case SOMObject */ \\\n");
+	}
+#endif
+
+	{
+		int parent_count=iface->_parents.length();
+		out_printf(out,"#define %s_%s_%s_%s",n,dts->macro,m,op->id);
+		write_macro_args(out,op,1);
+		out_printf(out,"\\\n");
+
+		if (dts->dts_type==dts_destructor)
+		{
+			/* destructor in reverse order */
+			out_printf(out,"if (myMask[%d]&1) {\\\n",(parent_count-num-1));
+		}
+		else
+		{
+			out_printf(out,"if (myMask[%d]&1) {\\\n",num);
+		}
+
+#ifdef _DEBUG
+		out_printf(out,
+			"SOM_Assert(ctrl->info->cls==%sClassData.classObject,SOM_Fatal); \\\n",
+			m);
+#endif
+
+		if (parent_is_SOMObject)
+		{
+			out_printf(out,"ctrl->info=(%s *)(ctrl->infoSize+(char *)ctrl->info); \\\n",dts->structInfo);
+		}
+		else
+		{
+			out_printf(out,"((somTD_%s)ctrl->info->%s) \\\n",
+						o,dts->member);
+
+			if (cplusplus)
+			{
+				out_printf(out,"(((%s %s)(void *)somSelf)",objcls,somstar);
+			}
+			else
+			{
+				out_printf(out,"(somSelf");
+			}
+
+			write_macro_args(out,op,0);
+			out_printf(out,"; \\\n");
+		}
+		out_printf(out,"}\n");
+	}
+}
+
+static void union_of_dts_ops(RHBsome_emitter *emitter,RHBinterface *iface,RHBelement_sequence *seq)
+{
+	int i=iface->_parents.length();
+	while (i--)
+	{
+		union_of_dts_ops(emitter,iface->_parents.get(i)->is_interface(),seq);
+	}
+	RHBelement *el=iface->children();
+	while (el)
+	{
+		RHBoperation *op=el->is_operation();
+
+		if (op)
+		{
+			if (emitter->is_dts_override(op))
+			{
+				i=seq->length();
+				while (i--)
+				{
+					if (seq->get(i)==op)
+					{
+						break;
+					}
+				}
+				if (i < 0)
+				{
+					seq->add(op);
+				}
+			}
+		}
+
+		el=el->next();
+	}
+}
+
+void RHBsome_emitter::generate_dts_macros(RHBoutput *out,RHBinterface *iface)
+{
+RHBelement_sequence seq;
+const int num_parents=iface->_parents.length();
+int done_destructor=0,done_assignment=0;
+
+	union_of_dts_ops(this,iface,&seq);
+
+	int it=seq.length();
+
+	while (it--)
+	{
+		RHBoperation *op=seq.get(it)->is_operation();
+
+		if (op)
+		{
+			if (does_override(iface,op->id))
+			{
+				struct dts_override *dts=is_dts_override(op);
+
+				if (dts)
+				{
+					switch (dts->dts_type)
+					{
+					case dts_destructor:
+						if (done_destructor)
+						{
+							dts=NULL;
+						}
+						else
+						{
+							done_destructor=1;
+						}
+						break;
+					case dts_assignment:
+						if (done_assignment)
+						{
+							dts=NULL;
+						}
+						else
+						{
+							done_assignment=1;
+						}
+						break;
+					default:
+						break;
+					}
+				}
+
+				if (dts)
+				{
+					out_printf(out,"/* special macros for %s */\n",op->id);
+					char n[256];
+					char macro_name[1024]={0};
+
+					get_c_name(iface,n,sizeof(n));
+
+					switch (dts->dts_type)
+					{
+					case dts_destructor:
+					case dts_assignment:
+						snprintf(macro_name,sizeof(macro_name),"%s_Begin%s",
+								n,
+								dts->initType);
+						break;
+					default:
+						snprintf(macro_name,sizeof(macro_name),"%s_Begin%s_%s",
+								n,
+								dts->initType,op->id);
+						break;
+					}
+
+					out_printf(out,"#ifndef %s\n",macro_name); 
+					out_printf(out,"#define %s \\\n",macro_name); 
+
+
+					{
+						out_printf(out,"if (!ctrl) { \\\n"); 
+						out_printf(out,"ctrl=&globalCtrl; \\\n"); 
+						out_printf(out,
+							"memcpy(ctrl,&(((somParentMtabStructPtr)(void *)%sCClassData.parentMtab)->%s),sizeof(%s)); \\\n",
+							n,dts->mtab,dts->structCtrl);
+						out_printf(out,"} \\\n"); 
+#ifdef _DEBUG
+						if (dts->dts_type==dts_destructor)
+						{
+/*							i=sprintf(buf,"somPrintf(\"%s_BeginDestructor\\n\"); \\\n",n);
+							out->write(buf,i);*/
+						}
+						out_printf(out,"SOM_Assert(ctrl->info->cls==%sClassData.classObject,SOM_Fatal); \\\n",n);
+#endif
+						if (iface->instanceData && iface->instanceData->children())
+						{
+							out_printf(out,"somThis=(%sData*)(((char *)somSelf)+ctrl->info->dataOffset); \\\n",n);
+#ifdef _DEBUG
+							out_printf(out,"SOM_Assert(somThis==%sGetData(somSelf),SOM_Fatal); \\\n",n);
+#endif
+						}
+
+						if (dts->dts_type==dts_destructor)
+						{
+							out_printf(out,"myMask=ctrl->mask; \n");
+						}
+						else
+						{
+							out_printf(out,"myMask=ctrl->mask; \\\n");
+
+							if (num_parents)
+							{
+								out_printf(out,"ctrl->mask+=%d; \\\n",num_parents);
+							}
+
+							out_printf(out,"ctrl->info=(%s *)(ctrl->infoSize+(char*)(ctrl->info));\n",
+									dts->structInfo);
+						}
+					}
+
+					if (dts->dts_type==dts_destructor)
+					{
+						out_printf(out,"#define %s_EndDestructor \\\n",n);
+#ifdef _DEBUG
+/*						i=sprintf(buf,"somPrintf(\"%s_EndDestructor\\n\"); \\\n",n);
+						out->write(buf,i);*/
+#endif
+						out_printf(out,"ctrl->info=(%s *)(ctrl->infoSize+(char *)ctrl->info); \\\n",
+								dts->structInfo);
+						if (num_parents)
+						{
+							out_printf(out,"ctrl->mask+=%d; \\\n",num_parents);
+						}
+
+						int k=num_parents;
+						while (k--)
+						{
+							RHBinterface *parent=iface->_parents.get(k)->is_interface();
+							char m[256];
+							get_c_name(parent,m,sizeof(m));
+							out_printf(out,"%s_%s_%s_%s(somSelf,0,ctrl); \\\n",n,dts->macro,m,op->id);
+						}
+
+						if (cplusplus)
+						{
+							out_printf(out,
+								"if (doFree) (*((somMethodTabPtr *)(void *)somSelf))->classObject->somDeallocate((somToken)(void *)somSelf);\n");
+						}
+						else
+						{
+							out_printf(out,
+								"if (doFree) SOMClass_somDeallocate(somSelf->mtab->classObject,somSelf);\n");
+						}
+					}
+
+					out_printf(out,"#endif /* %s */\n",macro_name); 
+
+				}
+			}
+		}
+	}
+}
+
+void RHBsome_emitter::undoublebar(RHBoutput *out,const char *n)
+{
+	if (cplusplus)
+	{
+		int x=strlen(n);
+		int do_dd=0;
+
+		if (x > 2)
+		{
+			const char *p=n;
+
+			x-=2;
+
+			while (x--)
+			{
+				if ((*p++)=='_')
+				{
+					if (*p=='_')
+					{
+						do_dd=1;
+
+						break;
+					}
+				}
+			}
+		}
+
+		if (do_dd)
+		{
+			char buf[1024];
+			char *p=buf;
+			const char *q=n;
+
+			while (*q)
+			{
+				if (*q=='_')
+				{
+					*p++=*q++;
+					if (*q=='_')
+					{
+						*p++='s';
+						*p++='o';
+						*p++='m';
+						*p++='C';
+					}
+				}
+				else
+				{
+					*p++=*q++;
+				}
+			}
+
+			*p=0;
+
+			if (strcmp(buf,n))
+			{
+				const char *gm="SOM_AVOID_DOUBLE_UNDERSCORES";
+				out_printf(out,"#ifdef %s\n",gm);
+				out_printf(out,"\t#ifdef %s\n",n);
+				out_printf(out,"\t\t#error %s already defined\n",n);
+				out_printf(out,"\t#else /* %s */\n",n);
+				out_printf(out,"\t\t#define %s %s\n",n,buf);
+				out_printf(out,"\t#endif /* %s */\n",n);
+				out_printf(out,"#endif /* %s */\n",gm);
+			}
+		}
+	}
+}
+
+boolean RHBsome_emitter::do_const_param(RHBparameter *param)
+{
+	if (cplusplus && param)
+	{
+#if 0
+		if (strcmp(param->mode,"in")) return 0;
+
+		RHBtype *typ=unwind_typedef(param->parameter_type);
+		if (!typ) return 0;
+
+		typ=unwind_typedef(typ);
+
+		if (typ->is_pointer()) return 0;
+		if (typ->is_array()) return 0;
+
+		if (parameter_by_reference(param,NULL)) return 1;
+		if (typ->is_struct()) return 1;
+		if (typ->is_union()) return 1;
+		if (some_ABI_kind_of_pointer(typ)) return 1;
+		if (type_is_any(typ)) return 1;
+#endif
+	}
+
+	return 0;
+}
+
+#endif
\ No newline at end of file
diff -urN somfree\somipc2\src\rhbsctxt.cpp newsomfree3\somipc2\src\rhbsctxt.cpp
--- somfree\somipc2\src\rhbsctxt.cpp	Thu Jan 01 07:00:00 1970
+++ newsomfree3\somipc2\src\rhbsctxt.cpp	Sat Mar 16 14:09:27 2024
@@ -0,0 +1,99 @@
+#include <rhbopt.h>
+
+/* IDL compiler */
+
+#include <stdio.h>
+#include <string.h>
+#include <stdlib.h>
+
+#include <rhbsc.h>
+
+RHBtextfile::RHBtextfile(const char *n)
+{
+	fp=0;
+	filename=0;
+
+	if (n)
+	{
+		size_t x=strlen(n)+1;
+		filename=new char[x];
+		strncpy(filename,n,x);
+	}
+	else
+	{
+		fp=stdout;
+	}
+
+/*	fp=fopen(n,"w");
+
+	if (!fp) 
+	{
+		fprintf(stderr,"failed to open %s for writing\n",n);
+		exit(1);
+	}*/
+}
+
+RHBtextfile::~RHBtextfile()
+{
+	if (fp)
+	{
+		fflush(fp);
+
+		if (fp!=stdout)
+		{
+			fclose(fp);
+		}
+		fp=0;
+	}
+	if (filename)
+	{
+		delete []filename;
+		filename=0;
+	}
+}
+
+static long cr_count;
+
+void RHBtextfile::write(const void *pn,size_t len)
+{
+	const char *n=(const char *)pn;
+
+	if (!fp)
+	{
+		fp=fopen(filename,"w");
+
+		if (!fp)
+		{
+			fprintf(stderr,"Failed to open '%s' for writing\n",filename);
+			exit(1);
+		}
+	}
+
+	if (len > 0)
+	{
+		if (fp)
+		{
+			fwrite(n,len,1,fp);
+
+			if (len--)
+			{
+				if (*n=='\n')
+				{
+					cr_count++;
+
+					if (cr_count > 4)
+					{
+						cr_count=0;
+						printf("Bad formatting\n");
+					}
+				}
+				else
+				{
+					cr_count=0;
+				}
+
+				n++;
+			}
+		}
+	}
+}
diff -urN somfree\somipc2\src\rhbsctyp.cpp newsomfree3\somipc2\src\rhbsctyp.cpp
--- somfree\somipc2\src\rhbsctyp.cpp	Thu Jan 01 07:00:00 1970
+++ newsomfree3\somipc2\src\rhbsctyp.cpp	Sat Mar 16 14:09:27 2024
@@ -0,0 +1,171 @@
+/**************************************************************************
+ *
+ *  Copyright 1998-2010, Roger Brown
+ *
+ *  This file is part of Roger Brown's Toolkit.
+ *
+ *  This program is free software: you can redistribute it and/or modify it
+ *  under the terms of the GNU Lesser General Public License as published by the
+ *  Free Software Foundation, either version 3 of the License, or (at your
+ *  option) any later version.
+ * 
+ *  This program is distributed in the hope that it will be useful, but WITHOUT
+ *  ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ *  FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for
+ *  more details.
+ *
+ *  You should have received a copy of the GNU Lesser General Public License
+ *  along with this program.  If not, see <http://www.gnu.org/licenses/>
+ *
+ */
+ 
+/* 
+ * $Id: rhbsctyp.cpp 2 2013-01-10 05:54:51Z somtoolkit $
+ */
+
+#include <rhbopt.h>
+#include <stdio.h>
+#include <string.h>
+#include <stdlib.h>
+
+#include <rhbsc.h>
+/* #include <rhbsctyp.h>*/
+
+void RHBbase_type::boot_root_types(RHBPreprocessor *pp,RHBrepository *rp)
+{
+	RHBtype *t;
+	RHBtype *int_type;
+	RHBtype *double_type;
+
+	int_type=new RHBbase_type(pp,"int",0,0,0);
+
+	double_type=new RHBbase_type(pp,"double",0,0,1);
+
+	t=new RHBbase_type(pp,"long",0,0,0);
+
+	rp->add(pp,t);
+
+	t=new RHBbase_type(pp,
+			"short",int_type,0,0);
+
+	rp->add(pp,t);
+
+	t=new RHBbase_type(pp,"char",int_type,0,0);
+	rp->add(pp,t);
+
+	t=new RHBbase_type(pp,"octet",int_type,0,0);
+	rp->add(pp,t);
+
+	t=new RHBbase_type(pp,"boolean",int_type,0,0);
+	rp->add(pp,t);
+
+	t=new RHBbase_type(pp,"float",double_type,0,1);
+	rp->add(pp,t);
+
+	t=new RHBbase_type(pp,"double",double_type,0,1);
+	rp->add(pp,t);
+
+	t=new RHBbase_type(pp,"void",0,1,0);
+	rp->add(pp,t);
+
+/*t=new RHBbase_type(pp,"string",0,0,0);*/
+	t=new RHBstring_type(pp,"string");
+	rp->add(pp,t);
+
+	t=new RHBany_type(pp,"any",0,1);
+	rp->add(pp,t);
+
+	t=new RHBTypeCode_type(pp,"TypeCode",0,0);
+	rp->add(pp,t);
+
+	t=new RHBinterface(pp,"SOMObject");
+
+	rp->add(pp,t);
+
+	/*RHBelement *el= */rp->children();
+}
+
+RHBattribute * RHBelement::is_attribute()
+{
+	return 0;
+}
+
+RHBattribute * RHBattribute::is_attribute()
+{
+	return this;
+}
+
+long RHBvalue::read_hex_value(const char *p)
+{
+	long x=0;
+
+	while (*p)
+	{
+		long d=0;
+
+		switch (*p)
+		{
+		case '0': d=0; break;
+		case '1': d=1; break;
+		case '2': d=2; break;
+		case '3': d=3; break;
+		case '4': d=4; break;
+		case '5': d=5; break;
+		case '6': d=6; break;
+		case '7': d=7; break;
+		case '8': d=8; break;
+		case '9': d=9; break;
+		case 'A': 
+		case 'a': d=10; break;
+		case 'B': 
+		case 'b': d=11; break;
+		case 'C': 
+		case 'c': d=12; break;
+		case 'D': 
+		case 'd': d=13; break;
+		case 'E': 
+		case 'e': d=14; break;
+		case 'F': 
+		case 'f': d=15; break;
+		default: bomb("invalid char");
+		}
+
+		x<<=4;
+		x+=d;
+
+		p++;
+	}
+
+	return x;
+}
+
+long RHBvalue::read_octal_value(const char *p)
+{
+	long x=0;
+
+	while (*p)
+	{
+		long d=0;
+
+		switch (*p)
+		{
+		case '0': d=0; break;
+		case '1': d=1; break;
+		case '2': d=2; break;
+		case '3': d=3; break;
+		case '4': d=4; break;
+		case '5': d=5; break;
+		case '6': d=6; break;
+		case '7': d=7; break;
+		default: bomb("invalid char");
+		}
+
+		x<<=3;
+		x+=d;
+
+		p++;
+	}
+
+	return x;
+}
+
diff -urN somfree\somipc2\win32\somipc2.mak newsomfree3\somipc2\win32\somipc2.mak
--- somfree\somipc2\win32\somipc2.mak	Thu Jan 01 07:00:00 1970
+++ newsomfree3\somipc2\win32\somipc2.mak	Sat Mar 16 14:09:28 2024
@@ -0,0 +1,102 @@
+#
+#  Copyright 2008, Roger Brown
+#
+#  This file is part of Roger Brown's Toolkit.
+#
+#  This program is free software: you can redistribute it and/or modify it
+#  under the terms of the GNU Lesser General Public License as published by the
+#  Free Software Foundation, either version 3 of the License, or (at your
+#  option) any later version.
+# 
+#  This program is distributed in the hope that it will be useful, but WITHOUT
+#  ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+#  FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for
+#  more details.
+#
+#  You should have received a copy of the GNU Lesser General Public License
+#  along with this program.  If not, see <http://www.gnu.org/licenses/>
+#
+#  $Id: somipc.mak 35 2020-06-07 02:05:42Z somtoolkit $
+
+!include $(MAKEDEFS)
+
+OUTDIR=$(OUTDIR_BIN)
+INTDIR=$(BUILDTYPE)
+
+APPNAME=somipc2
+
+OBJS=	$(INTDIR)\rhbidl.obj		\
+		$(INTDIR)\rhbsc.obj	\
+		$(INTDIR)\rhbscemt.obj	\
+		$(INTDIR)\rhbscsome.obj	\
+		$(INTDIR)\rhbscpp.obj	\
+		$(INTDIR)\rhbsctxt.obj	\
+		$(INTDIR)\rhbsctyp.obj
+
+TARGET_EXE=$(OUTDIR)\$(APPNAME).exe
+TARGET_PDB=$(OUTDIR)\$(APPNAME).pdb
+
+PARTOPTS=	$(STDOPTXX)					\
+			/DHAVE_CONFIG_HPP			\
+			/D_CONSOLE					\
+			/D_USE_SOME_					\
+			/DWIN32_LEAN_AND_MEAN		\
+			/I..\..\include\$(PLATFORM)	\
+			/I..\..\include\$(PLATFORM_DEF)	\
+			/I..\..\include				\
+			/I..\include				\
+			/I..\..\somc\include	\
+			/I..\..\somkpub\include	\
+			/I..\..\somidl\$(PLATFORM)				\
+			$(CC_OUT_PDB)$(TARGET_PDB)
+
+all: $(TARGET_EXE)
+
+clean:
+	$(CLEAN) $(TARGET_EXE)				\
+			 $(TARGET_PDB)				\
+			 $(OBJS)					\
+			 $(INTDIR)\$(APPNAME).res	\
+			 $(OUTDIR)\$(APPNAME).lib	\
+			 $(OUTDIR)\$(APPNAME).exp
+	
+$(TARGET_EXE): $(OBJS) $(OUTDIR) $(INTDIR)\$(APPNAME).res
+	$(CC) $(CC_OUT_EXE)$@ $(OBJS)		\
+		  $(CC_OUT_PDB)$(TARGET_PDB)	\
+		  $(CC_LINK)					\
+		  $(LD_SUBSYSTEM_CONSOLE)		\
+		  $(LD_ENTRY_MAIN) \
+		  $(LDFLAGS) $(INTDIR)\$(APPNAME).res
+	$(POSTLINK_EXE) $@
+
+$(INTDIR)\rhbidl.obj: ..\src\rhbidl.cpp $(INTDIR)
+	$(CXX) /c $(PARTOPTS) $(CC_OUT_OBJ)$@ ..\src\rhbidl.cpp
+
+$(INTDIR)\rhbsc.obj: ..\src\rhbsc.cpp $(INTDIR)
+	$(CXX) /c $(PARTOPTS) $(CC_OUT_OBJ)$@ ..\src\rhbsc.cpp
+
+$(INTDIR)\rhbscemt.obj: ..\src\rhbscemt.cpp $(INTDIR)
+	$(CXX) /c $(PARTOPTS) $(CC_OUT_OBJ)$@ ..\src\rhbscemt.cpp
+
+$(INTDIR)\rhbscsome.obj: ..\src\rhbscsome.cpp $(INTDIR)
+	$(CXX) /c $(PARTOPTS) $(CC_OUT_OBJ)$@ ..\src\rhbscsome.cpp
+
+$(INTDIR)\rhbscpp.obj: ..\src\rhbscpp.cpp $(INTDIR)
+	$(CXX) /c $(PARTOPTS) $(CC_OUT_OBJ)$@ ..\src\rhbscpp.cpp
+
+$(INTDIR)\rhbsctyp.obj: ..\src\rhbsctyp.cpp $(INTDIR)
+	$(CXX) /c $(PARTOPTS) $(CC_OUT_OBJ)$@ ..\src\rhbsctyp.cpp
+
+$(INTDIR)\rhbsctxt.obj: ..\src\rhbsctxt.cpp $(INTDIR)
+	$(CXX) /c $(PARTOPTS) $(CC_OUT_OBJ)$@ ..\src\rhbsctxt.cpp
+
+$(INTDIR):
+	mkdir $@
+
+$(INTDIR)\$(APPNAME).res: ..\win32\$(APPNAME).rc
+	rc /nologo /r /I.. /I..\..\include\$(PLATFORM) /fo$@ ..\win32\$(APPNAME).rc
+
+dist:
+
+
+test:
diff -urN somfree\somipc2\win32\somipc2.rc newsomfree3\somipc2\win32\somipc2.rc
--- somfree\somipc2\win32\somipc2.rc	Thu Jan 01 07:00:00 1970
+++ newsomfree3\somipc2\win32\somipc2.rc	Sat Mar 16 14:09:28 2024
@@ -0,0 +1,38 @@
+#include "windows.h"
+#include <depvers.h>
+
+1 VERSIONINFO
+ FILEVERSION DEPVERS_somipc_INT4
+ PRODUCTVERSION DEPVERS_somtkpkg_INT4
+ FILEFLAGSMASK 0x3fL
+#ifdef _DEBUG
+ FILEFLAGS VS_FF_DEBUG|VS_FF_PRERELEASE
+#else
+ FILEFLAGS VS_FF_PRERELEASE
+#endif
+ FILEOS VOS_NT_WINDOWS32
+ FILETYPE VFT_APP
+ FILESUBTYPE 0x0L
+BEGIN
+    BLOCK "StringFileInfo"
+    BEGIN
+        BLOCK "140904e4" // New Zealand
+        BEGIN
+            VALUE "Comments", "SOM IDL compiler\0"
+            VALUE "CompanyName", "Roger Brown\0"
+            VALUE "FileDescription", "SOM IDL compiler\0"
+            VALUE "FileVersion", DEPVERS_somipc_STR4
+            VALUE "InternalName", "somipc2\0"
+            VALUE "LegalCopyright", "й Roger Brown. 2007\0"
+    	    VALUE "LegalTrademarks", "SOMobjects is a trademark of IBM\0"
+            VALUE "OriginalFilename", "SOMIPC2.EXE\0"
+            VALUE "ProductName", DEPVERS_somtkpkg_PRODUCTNAME
+            VALUE "ProductVersion", DEPVERS_somtkpkg_STR4
+        END
+    END
+    BLOCK "VarFileInfo"
+    BEGIN
+        VALUE "Translation", 0x1409, 1252
+    END
+END
+
diff -urN somfree\somipc3\notes.txt newsomfree3\somipc3\notes.txt
--- somfree\somipc3\notes.txt	Thu Jan 01 07:00:00 1970
+++ newsomfree3\somipc3\notes.txt	Sat Mar 16 14:09:28 2024
@@ -0,0 +1,7 @@
+C Bindings
+
+In CORBA mapping environment is a last argument, not second as in SOM mapping
+
+CORBA 1.0 types mappings doesn't containg CORBA_ prefix for types
+CORBA 1.0 doesn't have enviroment, but exception used instead (seems later become environment).
+
diff -urN somfree\somipc3\somipc.c newsomfree3\somipc3\somipc.c
--- somfree\somipc3\somipc.c	Thu Jan 01 07:00:00 1970
+++ newsomfree3\somipc3\somipc.c	Sat Mar 16 14:09:28 2024
@@ -0,0 +1,686 @@
+/*
+  somFree IDL Gramma
+
+  Based on IDL 4.2 http://www.omg.org/spec/IDL/4.2/
+
+  Main difference: comment part of abstract syntax graph so not removed during parsing but stored.
+  Implementation setcion.
+
+*/
+
+// literals
+%token T_IDENTIFIER
+
+// syntax
+%token T_SEMICOLON T_COLON T_COMMA T_DOUBLECOLON T_ASSIGN
+
+// keywords
+%token T_ABSTRACT
+%token T_ANY
+%token T_ALIAS
+%token T_ATTRIBUTE
+%token T_BITFIELD
+%token T_BITMASK
+%token T_BITSET
+%token T_BOOLEAN
+%token T_CASE
+%token T_CHAR
+%token T_COMPONENT
+%token T_CONNECTOR
+%token T_CONST
+%token T_CONSUMES
+%token T_CONTEXT
+%token T_CUSTOM
+%token T_DEFAULT
+%token T_DOUBLE
+%token T_EXCEPTION
+%token T_EMITS
+%token T_ENUM
+%token T_EVENTTYPE
+%token T_FACTORY
+%token T_FALSE
+%token T_FINDER
+%token T_FIXED
+%token T_FLOAT
+%token T_GETRAISES
+%token T_HOME
+%token T_IMPORT
+%token T_IN
+%token T_INOUT
+%token T_INTERFACE
+%token T_LOCAL
+%token T_LONG
+%token T_MANAGES
+%token T_MAP
+%token T_MIRRORPORT
+%token T_MODULE
+%token T_MULTIPLE
+%token T_NATIVE
+%token T_OBJECT
+%token T_OCTET
+%token T_ONEWAY
+%token T_OUT
+%token T_PRIMARYKEY
+%token T_PRIVATE
+%token T_PORT
+%token T_PORTTYPE
+%token T_PROVIDES
+%token T_PUBLIC
+%token T_PUBLISHES
+%token T_RAISES
+%token T_READONLY
+%token T_SETRAISES
+%token T_SEQUENCE
+%token T_SHORT
+%token T_STRING
+%token T_STRUCT
+%token T_SUPPORTS
+%token T_SWITCH
+%token T_TRUE
+%token T_TRUNCATABLE
+%token T_TYPEDEF
+%token T_TYPEID
+%token T_TYPENAME
+%token T_TYPEPREFIX
+%token T_UNSIGNED
+%token T_UNION
+%token T_USES
+%token T_VALUEBASE
+%token T_VALUETYPE
+%token T_VOID
+%token T_WCHAR
+%token T_WSTRING
+%token T_INT8
+%token T_UINT8
+%token T_INT16
+%token T_INT32
+%token T_INT64
+%token T_UINT16
+%token T_UINT32
+%token T_UINT64
+
+%%
+
+/* 1 */ specification : [T_COMMENT] definitions
+		;
+
+definitions: definition
+		| definitions definition
+		;
+
+/* 2 */ definition : module_dcl T_SEMICOLON [T_COMMENT]	// was module
+		| const_dcl T_SEMICOLON [T_COMMENT]
+		| type_dcl T_SEMICOLON [T_COMMENT]
+/* 71 */	| except_dcl T_SEMICOLON [T_COMMENT]	// new
+		| interface_dcl T_SEMICOLON [T_COMMENT]	// was interface
+/* 98 */	| value_dcl T_SEMICOLON [T_COMMENT]		// new
+/* 111 */	| type_id_dcl T_SEMICOLON [T_COMMENT]	// new
+		| type_prefix_dcl T_SEMICOLON [T_COMMENT]	// new
+		| import_dcl T_SEMICOLON [T_COMMENT]	// new
+/* 133 */	| component_dcl T_SEMICOLON [T_COMMENT]	// new
+/* 144 */	| home_dcl T_SEMICOLON [T_COMMENT]		// new
+/* 153 */	| event_dcl T_SEMICOLON [T_COMMENT]		// new
+/* 171 */	| porttype_dcl T_SEMICOLON [T_COMMENT]	// new
+		| connector_dcl T_SEMICOLON [T_COMMENT]	// new
+/* 184 */	| template_module_dcl T_SEMICOLON [T_COMMENT] // new
+		| template_module_inst T_SEMICOLON [T_COMMENT] // new
+/* 218 */	| annotation_dcl T_SEMICOLON [T_COMMENT]	// new
+/* SOM */	| pragma_stm			// SOM extension
+		;
+
+/* 3 */ module_dcl : T_MODULE T_IDENTIFIER [T_COMMENT] { [T_COMMENT] definitions } // was module
+		;
+
+/* 72 */ except_dcl : T_EXCEPTION T_IDENTIFIER		// was in struct_type
+		| T_EXCEPTION [T_COMMENT] { [T_COMMENT] members }
+		
+members : /* empty */
+		| member
+		| members member
+		;
+
+/* 73 */ interface_dcl : interface_def
+		| interface_forward_dcl
+		;
+
+/* 74 */ interface_def : interface_header { [T_COMMENT] interface_body } [T_COMMENT]
+		;
+
+/* 75 */ interface_forward_dcl : interface_kind T_IDENTIFIER
+		| interface_dcl
+		;
+
+/* 76 */ interface_header : interface_kind T_IDENTIFIER [interface_inheritance_spec] [T_COMMENT]
+		;
+
+/* 77 */ interface_kind: T_INTERFACE
+/* 119 */	| T_LOCAL T_INTERFACE		// new
+/* 129 */	| T_ABSTRACT T_INTERFACE	// new
+		;
+
+/* 78 */ interface_inheritance_spec: T_COLON interface_names
+		;
+		
+interface_names: interface_name
+		| interface_names T_COMMA interface_name
+		;
+
+/* 79 */ interface_name : scoped_name
+		;
+
+/* 80 */ interface_body : exports
+		;
+
+exports : /* empty */
+		| export
+		| exports export
+		;
+		
+/* 81 */ export : op_dcl T_SEMICOLON [T_COMMENT]
+		| attr_dcl T_SEMICOLON [T_COMMENT]
+/* 97 */	| type_dcl T_SEMICOLON [T_COMMENT]
+		| const_dcl T_SEMICOLON [T_COMMENT]
+		| except_dcl T_SEMICOLON [T_COMMENT]		// was in const_decl
+/* 112 */	| type_id_dcl T_SEMICOLON [T_COMMENT]		// new
+		| type_prefix_dcl T_SEMICOLON [T_COMMENT]		// new
+		| import_dcl T_SEMICOLON [T_COMMENT]		// new
+		| op_oneway_dcl T_SEMICOLON [T_COMMENT]		// new
+		| op_with_context T_SEMICOLON [T_COMMENT]		// new
+/* SOM */	| implementation_body T_SEMICOLON [T_COMMENT]	// SOM extension
+		| pragma_stm				// SOM extension
+		;
+
+/* 4 */ scoped_name : T_IDENTIFIER
+		| T_DOUBLECOLON T_IDENTIFER
+		| scoped_name T_DOUBLECOLON T_IDENTIFER
+		;
+
+/* 5 */ const_dcl : T_CONST const_type T_IDENTIFIER T_ASSIGN const_expr
+		;
+
+/* 6 */ const_type : integer_type
+		| floating_pt_type
+		| fixed_pt_const_type			// new
+		| char_type
+		| wide_char_type			// new
+		| boolean_type
+		| octet_type				// new
+		| string_type
+		| wide_string_type			// new
+		| scoped_name
+		;
+
+/* 7 */ const_expr : or_expr
+		;
+
+/* 8 */ or_expr : xor_expr
+		| or_expr | xor_expr
+		;
+
+/* 9 */ xor_expr : and_expr
+		| xor_expr ^ and_expr
+		;
+
+/* 10 */ and_expr : shift_expr
+		| and_expr & shift_expr
+		;
+
+/* 11 */ shift_expr : add_expr
+		| shift_expr >> add_expr
+		| shift_expr << add_expr
+		;
+
+/* 12 */ add_expr : mult_expr
+		| add_expr + mult_expr
+		| add_expr - mult_expr
+		;
+
+/* 13 */ mult_expr : unary_expr
+		| mult_expr * unary_expr
+		| mult_expr / unary_expr
+		| mult_expr % unary_expr
+		;
+
+/* 14 */ unary_expr : unary_operator primary_expr
+		| primary_expr
+		;
+
+/* 15 */ unary_operator : -
+		| +
+		| ~
+		;
+
+/* 16 */ primary_expr : scoped_name
+		| literal
+		| ( const_expr )
+		;
+
+/* 17 */ literal : integer_literal
+		| floating_pt_literal
+		| fixed_pt_literal			// new
+		| character_literal
+		| wide_character_literal		// new
+		| boolean_literal
+		| string_literal
+		| wide_string_literal			// new
+		;
+
+/* 18, 19 */  // skiped fo while
+
+/* 20 */ type_dcl : constr_type_dcl			// was constr_type_spec
+		| native_dcl				// new
+		| typedef_dcl
+		;
+
+/* 21 */ type_spec : simple_type_spec
+/* 216 */		| template_type_spec		// new
+//		| constr_type_spec			// moved to type_declarator
+		;
+
+/* 22 */ simple_type_spec : base_type_spec
+//		| template_type_spec			// moved to type_declarator
+		| scoped_name
+		;
+
+/* 23 */ base_type_spec : integer_type
+		| floating_pt_type
+		| char_type
+		| wide_char_type			// new
+		| boolean_type
+		| octet_type
+/* 69 */	| any_type
+/* 117 */	| object_type				// new
+/* 131 */	| value_base_type			// new
+/* SOM */	| voidptr_type				// SOM extension
+		;
+
+/* 24 */ floating_pt_type : T_FLOAT
+		| T_DOUBLE
+		| T_LONG T_DOUBLE				// new
+		;
+
+/* 25 */ integer_type : signed_int
+		| unsigned_int
+		;
+
+/* 26 */ signed_int : signed_short_int
+		| signed_long_int
+		| signed_longlong_int			// new
+/* 206 */		| signed_tiny_int		// new
+		;
+
+/* 208 */ signed_tiny_int : T_INT8
+
+/* 27 */ signed_short_int: T_SHORT
+/* 210 */		| T_INT16				// new
+		;
+
+/* 28 */ signed_long_int: T_LONG
+/* 211 */		| T_INT32				// new
+		;
+
+/* 29 */ signed_longlong_int: T_LONG T_LONG
+/* 212 */		| T_INT64				// new
+		;
+
+/* 30 */ unsigned_int : unsigned_short_int
+		| unsigned_long_int
+		| unsigned_longlong_int			// new
+/* 207 */		| unsigned_tiny_int	// new
+		;
+
+/* 209 */ unsigned_tiny_int: T_UINT8
+
+/* 31 */ unsigned_short_int : T_UNSIGNED T_INT
+/* 213 */		| T_UINT16				// new
+		;
+
+/* 32 */ unsigned_long_int : T_UNSIGNED T_LONG
+/* 214 */		| T_UINT32				// new
+		;
+
+/* 33 */ unsigned_longlong_int : T_UNSIGNED T_LONG T_LONG
+/* 215 */		| T_UINT64				// new
+		;
+
+/* 34 */ char_type : T_CHAR
+		;
+
+/* 34 */ wide_char_type : T_WCHAR
+		;
+
+/* 36 */ boolean_type : T_BOOLEAN
+		;
+
+/* 37 */ octet_type : T_OCTET
+		;
+
+/* 38 */ template_type_spec : sequence_type
+		| string_type
+		| wide_string_type			// new
+		| fixed_pt_type				// new
+		;
+
+/* 39 */ sequence_type : TSEQUENCE < simple_type_spec T_COMMA const_expr >   // fix const_expr
+		| T_SEQUENCE < simple_type_spec >
+		;
+
+/* 40 */ string_type : T_STRING < const_expr >   // fix const_expr
+		| T_STRING
+		;
+
+/* 41 */ wide_string_type : T_WSTRING < const_expr >   // fix const_expr
+		| T_WSTRING
+		;
+
+/* 42 */ fixed_pt_type : T_FIXED < const_expr T_COMMA const_expr >   // fix const_expr
+		;
+
+/* 42 */ fixed_pt_const_type: T_FIXED
+		;
+
+/* 44 */ constr_type_dcl : struct_dcl				// was struct_type
+		| union_dcl					// was union_type
+		| enum_dcl					// was enum_type
+		;
+
+/* 45 */ struct_dcl : struct_def				// exception moved to except_dcl
+		| struct_forward_def
+		;
+
+/* 46 */ struct_def : T_STRUCT [T_COMMENT] { [T_COMMENT] members }
+/* 195 */	| T_STRUCT T_IDENTIFIER T_COLON <scoped_name> "{" members "}"	// new
+		 T_STRUCT T_IDENTIFIER "{" "}" // new
+		;
+
+/* 47 */ member : type_declarator T_SEMICOLON [T_COMMENT]		// fix
+
+/* 48 */ struct_forward_def : T_STRUCT T_IDENTIFIER
+		;
+
+/* 49 */ union_dcl : union_def
+		| union_forward_dcl
+		;
+
+/* 50 */ union_def : T_UNION T_IDENTIFIER T_SWITCH ( switch_type_spec ) [T_COMMENT] { [T_COMMENT] switch_body }
+		;
+
+/* 51 */ switch_type_spec : integer_type
+		| char_type
+		| boolean_type
+		| scoped_name
+		| enum_type					// SOM extension
+		;
+
+/* 52 */ switch_body : case+
+		;
+
+/* 53 */ case : case_label+ element_spec T_SEMICOLON [T_COMMENT]
+		;
+
+/* 54 */ case_label : T_CASE const_expr : [T_COMMENT]
+		| T_DEFAULT : [T_COMMENT]
+		;
+
+/* 55 */ element_spec : type_spec declarator
+		;
+
+/* 56 */ union_forward_dcl: T_UNION T_IDENTIFIER
+		;
+
+/* 57 */ enum_dcl : T_ENUM T_IDENTIFIER { enumerator {, enumerator}* [T_COMMENT] }
+
+/* 58 */ enumerator: T_IDENTIFIER
+		;
+
+/* 59 */ array_declarator : T_IDENTIFIER fixed_array_size+
+
+/* 60 */ fixed_array_size : [ const_expr ]			// fix const_expr
+
+/* 62 */ simple_declarator : T_IDENTIFIER
+
+/* 63 */ typedef_dcl : T_TYPEDEF type_declarator
+		;
+
+/* 64 */ type_declarator : { simple_type_spec
+		| template_type_spec
+		| constr_type_dcl
+		} any_declarators
+		;
+
+/* 65 */ any_declarators : any_declarator { T_COMMA any_declarator }*
+		;
+
+/* 66 */ any_declarator : simple_declarator
+		| array_declarator
+		;
+
+/* SOM */ declarator : [stars] std_declarator   // SOM Extension
+		;
+
+/* 68 */ std_declarator : simple_declarator
+/* 217 */		| array_declarator			// new
+		;
+
+/* 67 */ declarators : declarator
+		| declarators T_COMMA declarator
+		;
+
+/* 70 */ any_type : T_ANY
+		;
+
+/* SOM */ voidptr_type : T_VOID stars		// SOM Extension
+		;
+
+/* 82 */ op_dcl : op_type_spec [stars] T_IDENTIFIER ( [parameter_dcls] ) [raises_expr] // oneway moved to op_oneway_dcl, context_expr moved to op_with_context,  stars is SOM extensions
+		;
+
+/* 83 */ op_type_spec  : type_spec		// was simple_type_spec
+		| T_VOID
+		;
+
+/* 84 */ parameter_dcls :  param_dcl {, param_dcl}* [T_COMMENT]
+		;
+
+/* 85 */ param_dcl : param_attribute type_spec simple_declarator	// was simple-type_spec\
+		| declarator
+		;
+
+/* 86 */ param_attribute : T_IN
+		| T_OUT
+		| T_INOUT
+		;
+
+/* 87 */ raises_expr : T_RAISES ( scoped_name+ )
+		;
+
+/* 88 */ attr_dcl : readonly_attr_spec
+		| attr_spec
+		;
+
+/* 89 */ readonly_attr_spec : T_READONLY T_ATTRIBUTE type_spec readony_attr_declarator
+		;
+
+/* 90 */ readonly_attr_declarator: simple_declarator raises_expr	// new
+		| simple_declarator {, simple_declarator}*
+		;
+
+/* 91 */ attr_spec : T_ATTRIBUTE type_spec attr_declarator
+		;
+
+/* 92 */ attr_declarator: simple_declarator attr_raises_expr	// new
+		| simple_declarator {, simple_declarator}*
+		;
+
+/* 93 */ attr_raises_expr : get_excep_expr [ set_excep_expr ]
+		| set_excep_expr
+		;
+
+/* 94 */ <get_excep_expr> ::= T_GETRAISES <exception_list>
+
+/* 95 */ <set_excep_expr> ::= T_SETRAISES <exception_list>
+
+/* 96 */ <exception_list> ::= "(" <scoped_name> { T_COMMA <scoped_name> } * ")"
+
+/* 99 */ value_dcl : value_def
+		| value_forward_dcl
+/* 125 */ | value_box_def
+		| value_abs_def
+		;
+
+/* 100 */ value_def : value_header> "{" <value_element>* "}"
+
+/* 101 */ value_header : value_kind T_IDENTIFIER [ value_inheritance_spec ]
+		;
+/* 102 */ value_kind : T_VALUETYPE
+/* 128 */ 		| T_CUSTOM T_VALUETYPE
+				;
+				
+/* 103 */ <value_inheritance_spec> ::= [ T_COLON <value_name> ] [ "supports" <interface_name> ]
+/* 130 */ <value_inheritance_spec> ::+ ":" ["truncatable"] <value_name> { "," <value_name> }* [ "supports" <interface_name> { "," <interface_name> }* ]
+/* 104 */ <value_name> ::= <scoped_name>
+/* 105 */ <value_element> ::= <export> | <state_member> | <init_dcl>
+/* 106 */ <state_member> ::= ( "public" | "private" ) <type_spec> <declarators> ";"
+/* 107 */ <init_dcl> ::= "factory" <identifier> "(" [ <init_param_dcls> ] ")" [ <raises_expr> ] ";"
+/* 108 */ <init_param_dcls> ::= <init_param_dcl> { "," <init_param_dcl>}*
+/* 109 */ <init_param_dcl> ::= "in" <type_spec> <simple_declarator> (110) <value_forward_dcl> ::= <value_kind> <identifier>
+
+/* 113 */ <type_id_dcl> ::= "typeid" <scoped_name> <string_literal>
+/* 114 */ <type_prefix_dcl> ::= "typeprefix" <scoped_name> <string_literal>
+/* 115 */ <import_dcl> ::= "import" <imported_scope>
+/* 116 */ <imported_scope> ::= <scoped_name> | <string_literal>
+/* 118 */ <object_type> ::= "Object"
+/* 120 */ <op_oneway_dcl> ::= "oneway" "void" <identifier> "(" [ <in_parameter_dcls> ] ")"
+/* 121 */ <in_parameter_dcls> ::= <in_param_dcl> { "," <in_param_dcl> } *
+/* 122 */ <in_param_dcl> ::= "in" <type_spec> <simple_declarator>
+/* 123 */ <op_with_context> ::= {<op_dcl> | <op_oneway_dcl>} <context_expr>
+/* 124 */ <context_expr> ::= "context" "(" <string_literal> { "," <string_literal>* } ")"
+
+/* 126 */ <value_box_def> ::= "valuetype" <identifier> <type_spec>
+/* 127 */ <value_abs_def> ::= "abstract" "valuetype" <identifier> [ <value_inheritance_spec> ] "{" <export>* "}"
+/* 132 */ <value_base_type> ::= "ValueBase"
+
+/* 134 */ <component_dcl> ::= <component_def> | <component_forward_dcl>
+/* 135 */ <component_forward_dcl> ::= "component" <identifier>
+/* 136 */ <component_def> ::= <component_header> "{" <component_body> "}"
+/* 137 */ <component_header> ::= "component" <identifier> [ <component_inheritance_spec> ]
+/* 154 */ <component_header> ::+ "component" <identifier> [ <component_inheritance_spec> ] <supported_interface_spec>
+/* 138 */ <component_inheritance_spec> ::= ":" <scoped_name>
+/* 139 */ <component_body> ::= <component_export>*
+/* 140 */ <component_export> ::= <provides_dcl> T_SEMICOLON | <uses_dcl> T_SEMICOLON | <attr_dcl> T_SEMICOLON
+/* 156 */ <component_export> ::+ <emits_dcl> T_SEMICOLON | <publishes_dcl> T_SEMICOLON | <consumes_dcl> T_SEMICOLON
+/* 179 */ <component_export> ::+ <port_dcl> T_SEMICOLON
+/* 141 */ <provides_dcl> ::= "provides" <interface_type> <identifier>
+/* 142 */ <interface_type> ::= <scoped_name>
+/* 157 */ <interface_type> ::+ "Object"
+/* 143 */ <uses_dcl> ::= "uses" <interface_type> <identifier>
+/* 158 */ <uses_dcl> ::+ "uses" "multiple" <interface_type> <identifier>
+
+/* 145 */ <home_dcl> ::= <home_header> "{" <home_body> "}"
+/* 146 */ <home_header> ::= "home" <identifier> [ <home_inheritance_spec> ] "manages" <scoped_name>
+/* 162 */ <home_header> ::+ "home" <identifier> [ <home_inheritance_spec> ] [ <supported_interface_spec> ] "manages" <scoped_name> [ <primary_key_spec> ]
+/* 147 */ <home_inheritance_spec> ::= ":" <scoped_name>
+/* 148 */ <home_body> ::= <home_export>*
+/* 149 */ <home_export> ::= <export> | <factory_dcl> T_SEMICOLON
+/* 164 */ <home_export> ::+ <finder_dcl> ";"
+/* 150 */ <factory_dcl> ::= "factory" <identifier> "(" [ <factory_param_dcls> ] ")" [ <raises_expr> ]
+/* 151 */ <factory_param_dcls> ::= <factory_param_dcl> {"," <factory_param_dcl>}*
+/* 152 */ <factory_param_dcl> ::= "in" <type_spec> <simple_declarator>
+
+/* 155 */ <supported_interface_spec> ::= "supports" <scoped_name> { "," <scoped_name> }*
+/* 159 */ <emits_dcl> ::= "emits" <scoped_name> <identifier>
+/* 160 */ <publishes_dcl> ::= "publishes" <scoped_name> <identifier>
+/* 161 */ <consumes_dcl> ::= "consumes" <scoped_name> <identifier>
+/* 163 */ <primary_key_spec> ::= "primarykey" <scoped_name>
+/* 165 */ <finder_dcl> ::= "finder" <identifier> "(" [ <init_param_dcls> ] ")" [ <raises_expr> ]
+/* 166 */ <event_dcl> ::= ( <event_def> | <event_abs_def> | <event_forward_dcl> )
+/* 167 */ <event_forward_dcl> ::= [ "abstract" ] "eventtype" <identifier>
+/* 168 */ <event_abs_def> ::= "abstract" "eventtype" <identifier> [ <value_inheritance_spec> ] "{" <export>* "}"
+/* 169 */ <event_def> ::= <event_header> "{" <value_element> * "}"
+/* 170 */ <event_header> ::= [ "custom" ] "eventtype" <identifier> [ <value_inheritance_spec> ]
+
+/* 172 */ <porttype_dcl> ::= <porttype_def> | <porttype_forward_dcl>
+/* 173 */ <porttype_forward_dcl> ::= "porttype" <identifier>
+/* 174 */ <porttype_def> ::= "porttype" <identifier> "{" <port_body> "}"
+/* 175 */ <port_body> ::= <port_ref> <port_export>*
+/* 176 */ <port_ref> ::= <provides_dcl> T_SEMICOLON | <uses_dcl> T_SEMICOLON | <port_dcl> T_SEMICOLON
+/* 177 */ <port_export> ::= <port_ref> | <attr_dcl> T_SEMICOLON
+/* 178 */ <port_dcl> ::= {"port" | "mirrorport"} <scoped_name> <identifier>
+/* 180 */ <connector_dcl> ::= <connector_header> "{" <connector_export>+ "}"
+/* 181 */ <connector_header> ::= "connector" <identifier> [ <connector_inherit_spec> ]
+/* 182 */ <connector_inherit_spec> ::= ":" <scoped_name>
+/* 183 */ <connector_export> ::= <port_ref> | <attr_dcl> T_SEMICOLON
+
+/* 185 */ <template_module_dcl> ::= "module" <identifier> "<" <formal_parameters> ">" "{" <tpl_definition> +"}"
+/* 186 */ <formal_parameters> ::= <formal_parameter> {"," <formal_parameter>}*
+/* 187 */ <formal_parameter> ::= <formal_parameter_type> <identifier>
+/* 188 */ <formal_parameter_type> ::= "typename" | "interface" | "valuetype" | "eventtype" | "struct" | "union" | "exception" | "enum" | "sequence" | "const" <const_type> | <sequence_type>
+/* 189 */ <tpl_definition> ::= <definition> | <template_module_ref> T_SEMICOLON
+/* 190 */ <template_module_inst> ::= "module" <scoped_name> "<" <actual_parameters> ">" <identifier>
+/* 191 */ <actual_parameters> ::= <actual_parameter> { "," <actual_parameter>}*
+/* 192 */ <actual_parameter> ::= <type_spec> | <const_expr>
+/* 193 */ <template_module_ref> ::= "alias" <scoped_name> "<" <formal_parameter_names> ">" <identifier>
+/* 194 */ <formal_parameter_names> ::= <identifier> { "," <identifier>}*
+
+/* 196 */ <switch_type_spec> ::+ <wide_char_type> | <octet_type>
+/* 197 */ <template_type_spec> ::+ <map_type>
+/* 198 */ <constr_type_dcl> ::+ <bitset_dcl> | <bitmask_dcl>
+/* 199 */ <map_type> ::= "map" "<" <type_spec> "," <type_spec> "," <positive_int_const> ">" | "map" "<" <type_spec> "," <type_spec> ">"
+/* 200 */ <bitset_dcl> ::= "bitset" <identifier> [":" <scoped_name>] "{" <bitfield>* "}"
+/* 201 */ <bitfield> ::= <bitfield_spec> <identifier>* T_SEMICOLON
+/* 202 */ <bitfield_spec> ::= "bitfield" "<" <positive_int_const> ">" | "bitfield" "<" <positive_int_const> "," <destination_type> ">"
+/* 203 */ <destination_type> ::= <boolean_type> | <octet_type> | <integer_type>
+/* 204 */ <bitmask_dcl> ::= "bitmask" <identifier> "{" <bit_value> { "," <bit_value> }* "}"
+/* 205 */ <bit_value> ::= <identifier>
+
+
+/* 219 */ <annotation_dcl> ::= <annotation_header> "{" <annotation_body> "}"
+/* 220 */ <annotation_header> ::= "@annotation" <identifier>
+/* 221 */ <annotation_body> ::= { <annotation_member> | <enum_dcl> T_SEMICOLON | <const_dcl> T_SEMICOLON | <typedef_dcl> T_SEMICOLON }*
+/* 222 */ <annotation_member> ::= <annotation_member_type> <simple_declarator> [ "default" <const_expr> ] T_SEMICOLON
+/* 223 */ <annotation_member_type> ::= <const_type> | <any_const_type> | <scoped_name>
+/* 224 */ <any_const_type> ::= "any"
+/* 225 */ <annotation_appl> ::= "@" <scoped_name> [ "(" <annotation_appl_params> ")" ]
+/* 226 */ <annotation_appl_params>::= <const_expr> | <annotation_appl_param> { "," <annotation_appl_param> }*
+/* 227 */ <annotation_appl_param> ::= <identifier> "=" <const_expr>
+
+/* SOM */ implementation_body : implementation [T_COMMENT] { [T_COMMENT] implementation+ }
+		;
+
+/* SOM */ implementation : modifier_stm
+		| pragma_stm
+		| passthru
+		| member
+		;
+
+/* SOM */ pragma_stm : #pragma modifier modifier_stm
+		| #pragma somtemittypes on
+		| #pragma somtemittypes off
+		;
+
+/* SOM */ modifier_stm : smidentifier : [modifier {, modifier}*]
+		| T_SEMICOLON [T_COMMENT] modifier T_SEMICOLON [T_COMMENT]
+		;
+
+/* SOM */ modifier : smidentifier
+		| smidentifier = modifier_value
+		;
+
+/* SOM */ modifier_value : smidentifier
+		| string_literal
+		| integer_literal
+		| keyword
+		;
+
+/* SOM */ passthru : passthru identifier = string_literal+ T_SEMICOLON
+		| [T_COMMENT]
+		;
+
+/* SOM */ smidentifier : identifer
+		| _identifier
+		;
+
+/* SOM */ stars : *+
+		;
+
+%%
diff -urN somfree\somopc\makedefs.cf newsomfree3\somopc\makedefs.cf
--- somfree\somopc\makedefs.cf	Thu Jan 01 07:00:00 1970
+++ newsomfree3\somopc\makedefs.cf	Sat Mar 16 14:09:28 2024
@@ -0,0 +1,4 @@
+NAME somopc
+DEPENDS spp somc
+PROVIDES somopc
+VERSION 1.0
diff -urN somfree\somopc\src\_gramma.yy.output newsomfree3\somopc\src\_gramma.yy.output
--- somfree\somopc\src\_gramma.yy.output	Thu Jan 01 07:00:00 1970
+++ newsomfree3\somopc\src\_gramma.yy.output	Sat Mar 16 14:09:28 2024
@@ -0,0 +1,840 @@
+
+
+Terminals which are not used:
+
+   T_RELEASE
+   T_ORDER
+   T_METACLASS
+   T_PASSTHRU
+   T_BEFORE
+   T_AFTER
+   T_ENDPASSTHRU
+   T_DATA
+   T_PRIVATE
+   T_PUBLIC
+   T_INTERNAL
+   T_METHODS
+   T_GROUP
+   T_METHOD
+   T_PROCEDURE
+   T_OFFSET
+   T_NAME
+   T_LOOKUP
+   T_USE
+   T_OVERRIDE
+
+
+
+Grammar
+rule 1    oidl -> parent
+rule 2    oidl -> class
+rule 3    class -> classdef
+rule 4    class -> classdef description
+rule 5    classdef -> T_CLASS T_COLON T_IDENTIFIER T_SEMICOLON
+rule 6    classdef -> T_CLASS T_COLON T_IDENTIFIER attributes T_SEMICOLON
+rule 7    attributes -> T_COMMA attribute
+rule 8    attributes -> attributes T_COMMA attribute
+rule 9    attribute -> T_FILE T_STEM T_EQUAL T_IDENTIFIER
+rule 10   attribute -> T_EXTERNAL T_STEM T_EQUAL T_IDENTIFIER
+rule 11   attribute -> T_FUNCTION T_PREFIX T_EQUAL T_IDENTIFIER
+rule 12   attribute -> T_EXTERNAL T_PREFIX T_EQUAL T_IDENTIFIER
+rule 13   attribute -> T_CLASSPREFIX T_EQUAL T_IDENTIFIER
+rule 14   attribute -> T_MAJOR T_VERSION T_EQUAL T_NUMBER
+rule 15   attribute -> T_MINOR T_VERSION T_EQUAL T_NUMBER
+rule 16   attribute -> T_GLOBAL
+rule 17   attribute -> T_LOCAL
+rule 18   attribute -> T_CLASSINIT T_EQUAL T_IDENTIFIER
+rule 19   parent -> parentdef
+rule 20   parent -> parentdef description
+rule 21   parentsection -> T_PARENT T_CLASS T_COLON
+rule 22   parentsection -> T_PARENT T_COLON
+rule 23   parentdef -> parentsection T_IDENTIFIER T_SEMICOLON
+rule 24   parentdef -> parentsection T_IDENTIFIER T_COMMA parentattributes T_SEMICOLON
+rule 25   parentattributes -> T_COMMA parentattribute
+rule 26   parentattributes -> parentattributes T_COMMA parentattribute
+rule 27   parentattribute -> T_FILE T_STEM T_EQUAL T_IDENTIFIER
+rule 28   parentattribute -> T_MAJOR T_VERSION T_EQUAL T_NUMBER
+rule 29   parentattribute -> T_MINOR T_VERSION T_EQUAL T_NUMBER
+rule 30   parentattribute -> T_GLOBAL
+rule 31   parentattribute -> T_LOCAL
+rule 32   description -> T_DASHES T_COMMENT
+
+Terminals, with rules where they appear
+
+$ (-1)
+error (256)
+T_COLON (257) 5 6 21 22
+T_SEMICOLON (258) 5 6 23 24
+T_COMMA (259) 7 8 24 25 26
+T_NUMBER (260) 14 15 28 29
+T_IDENTIFIER (261) 5 6 9 10 11 12 13 18 23 24 27
+T_EQUAL (262) 9 10 11 12 13 14 15 18 27 28 29
+T_DASHES (263) 32
+T_COMMENT (264) 32
+T_CLASS (265) 5 6 21
+T_FILE (266) 9 27
+T_STEM (267) 9 10 27
+T_FUNCTION (268) 11
+T_PREFIX (269) 11 12
+T_CLASSPREFIX (270) 13
+T_MAJOR (271) 14 28
+T_MINOR (272) 15 29
+T_VERSION (273) 14 15 28 29
+T_GLOBAL (274) 16 30
+T_LOCAL (275) 17 31
+T_CLASSINIT (276) 18
+T_RELEASE (277)
+T_ORDER (278)
+T_METACLASS (279)
+T_PARENT (280) 21 22
+T_PASSTHRU (281)
+T_BEFORE (282)
+T_AFTER (283)
+T_ENDPASSTHRU (284)
+T_DATA (285)
+T_PRIVATE (286)
+T_PUBLIC (287)
+T_INTERNAL (288)
+T_METHODS (289)
+T_GROUP (290)
+T_METHOD (291)
+T_PROCEDURE (292)
+T_OFFSET (293)
+T_NAME (294)
+T_LOOKUP (295)
+T_EXTERNAL (296) 10 12
+T_USE (297)
+T_OVERRIDE (298)
+
+Nonterminals, with rules where they appear
+
+oidl (45)
+    on left: 1 2
+class (46)
+    on left: 3 4, on right: 2
+classdef (47)
+    on left: 5 6, on right: 3 4
+attributes (48)
+    on left: 7 8, on right: 6 8
+attribute (49)
+    on left: 9 10 11 12 13 14 15 16 17 18, on right: 7 8
+parent (50)
+    on left: 19 20, on right: 1
+parentsection (51)
+    on left: 21 22, on right: 23 24
+parentdef (52)
+    on left: 23 24, on right: 19 20
+parentattributes (53)
+    on left: 25 26, on right: 24 26
+parentattribute (54)
+    on left: 27 28 29 30 31, on right: 25 26
+description (55)
+    on left: 32, on right: 4 20
+
+
+state 0
+
+    T_CLASS	shift, and go to state 1
+    T_PARENT	shift, and go to state 2
+
+    oidl	go to state 78
+    class	go to state 3
+    classdef	go to state 4
+    parent	go to state 5
+    parentsection	go to state 6
+    parentdef	go to state 7
+
+
+
+state 1
+
+    classdef  ->  T_CLASS . T_COLON T_IDENTIFIER T_SEMICOLON   (rule 5)
+    classdef  ->  T_CLASS . T_COLON T_IDENTIFIER attributes T_SEMICOLON   (rule 6)
+
+    T_COLON	shift, and go to state 8
+
+
+
+state 2
+
+    parentsection  ->  T_PARENT . T_CLASS T_COLON   (rule 21)
+    parentsection  ->  T_PARENT . T_COLON   (rule 22)
+
+    T_COLON	shift, and go to state 9
+    T_CLASS	shift, and go to state 10
+
+
+
+state 3
+
+    oidl  ->  class .   (rule 2)
+
+    $default	reduce using rule 2 (oidl)
+
+
+
+state 4
+
+    class  ->  classdef .   (rule 3)
+    class  ->  classdef . description   (rule 4)
+
+    T_DASHES	shift, and go to state 11
+
+    $default	reduce using rule 3 (class)
+
+    description	go to state 12
+
+
+
+state 5
+
+    oidl  ->  parent .   (rule 1)
+
+    $default	reduce using rule 1 (oidl)
+
+
+
+state 6
+
+    parentdef  ->  parentsection . T_IDENTIFIER T_SEMICOLON   (rule 23)
+    parentdef  ->  parentsection . T_IDENTIFIER T_COMMA parentattributes T_SEMICOLON   (rule 24)
+
+    T_IDENTIFIER	shift, and go to state 13
+
+
+
+state 7
+
+    parent  ->  parentdef .   (rule 19)
+    parent  ->  parentdef . description   (rule 20)
+
+    T_DASHES	shift, and go to state 11
+
+    $default	reduce using rule 19 (parent)
+
+    description	go to state 14
+
+
+
+state 8
+
+    classdef  ->  T_CLASS T_COLON . T_IDENTIFIER T_SEMICOLON   (rule 5)
+    classdef  ->  T_CLASS T_COLON . T_IDENTIFIER attributes T_SEMICOLON   (rule 6)
+
+    T_IDENTIFIER	shift, and go to state 15
+
+
+
+state 9
+
+    parentsection  ->  T_PARENT T_COLON .   (rule 22)
+
+    $default	reduce using rule 22 (parentsection)
+
+
+
+state 10
+
+    parentsection  ->  T_PARENT T_CLASS . T_COLON   (rule 21)
+
+    T_COLON	shift, and go to state 16
+
+
+
+state 11
+
+    description  ->  T_DASHES . T_COMMENT   (rule 32)
+
+    T_COMMENT	shift, and go to state 17
+
+
+
+state 12
+
+    class  ->  classdef description .   (rule 4)
+
+    $default	reduce using rule 4 (class)
+
+
+
+state 13
+
+    parentdef  ->  parentsection T_IDENTIFIER . T_SEMICOLON   (rule 23)
+    parentdef  ->  parentsection T_IDENTIFIER . T_COMMA parentattributes T_SEMICOLON   (rule 24)
+
+    T_SEMICOLON	shift, and go to state 18
+    T_COMMA	shift, and go to state 19
+
+
+
+state 14
+
+    parent  ->  parentdef description .   (rule 20)
+
+    $default	reduce using rule 20 (parent)
+
+
+
+state 15
+
+    classdef  ->  T_CLASS T_COLON T_IDENTIFIER . T_SEMICOLON   (rule 5)
+    classdef  ->  T_CLASS T_COLON T_IDENTIFIER . attributes T_SEMICOLON   (rule 6)
+
+    T_SEMICOLON	shift, and go to state 20
+    T_COMMA	shift, and go to state 21
+
+    attributes	go to state 22
+
+
+
+state 16
+
+    parentsection  ->  T_PARENT T_CLASS T_COLON .   (rule 21)
+
+    $default	reduce using rule 21 (parentsection)
+
+
+
+state 17
+
+    description  ->  T_DASHES T_COMMENT .   (rule 32)
+
+    $default	reduce using rule 32 (description)
+
+
+
+state 18
+
+    parentdef  ->  parentsection T_IDENTIFIER T_SEMICOLON .   (rule 23)
+
+    $default	reduce using rule 23 (parentdef)
+
+
+
+state 19
+
+    parentdef  ->  parentsection T_IDENTIFIER T_COMMA . parentattributes T_SEMICOLON   (rule 24)
+
+    T_COMMA	shift, and go to state 23
+
+    parentattributes	go to state 24
+
+
+
+state 20
+
+    classdef  ->  T_CLASS T_COLON T_IDENTIFIER T_SEMICOLON .   (rule 5)
+
+    $default	reduce using rule 5 (classdef)
+
+
+
+state 21
+
+    attributes  ->  T_COMMA . attribute   (rule 7)
+
+    T_FILE	shift, and go to state 25
+    T_FUNCTION	shift, and go to state 26
+    T_CLASSPREFIX	shift, and go to state 27
+    T_MAJOR	shift, and go to state 28
+    T_MINOR	shift, and go to state 29
+    T_GLOBAL	shift, and go to state 30
+    T_LOCAL	shift, and go to state 31
+    T_CLASSINIT	shift, and go to state 32
+    T_EXTERNAL	shift, and go to state 33
+
+    attribute	go to state 34
+
+
+
+state 22
+
+    classdef  ->  T_CLASS T_COLON T_IDENTIFIER attributes . T_SEMICOLON   (rule 6)
+    attributes  ->  attributes . T_COMMA attribute   (rule 8)
+
+    T_SEMICOLON	shift, and go to state 35
+    T_COMMA	shift, and go to state 36
+
+
+
+state 23
+
+    parentattributes  ->  T_COMMA . parentattribute   (rule 25)
+
+    T_FILE	shift, and go to state 37
+    T_MAJOR	shift, and go to state 38
+    T_MINOR	shift, and go to state 39
+    T_GLOBAL	shift, and go to state 40
+    T_LOCAL	shift, and go to state 41
+
+    parentattribute	go to state 42
+
+
+
+state 24
+
+    parentdef  ->  parentsection T_IDENTIFIER T_COMMA parentattributes . T_SEMICOLON   (rule 24)
+    parentattributes  ->  parentattributes . T_COMMA parentattribute   (rule 26)
+
+    T_SEMICOLON	shift, and go to state 43
+    T_COMMA	shift, and go to state 44
+
+
+
+state 25
+
+    attribute  ->  T_FILE . T_STEM T_EQUAL T_IDENTIFIER   (rule 9)
+
+    T_STEM	shift, and go to state 45
+
+
+
+state 26
+
+    attribute  ->  T_FUNCTION . T_PREFIX T_EQUAL T_IDENTIFIER   (rule 11)
+
+    T_PREFIX	shift, and go to state 46
+
+
+
+state 27
+
+    attribute  ->  T_CLASSPREFIX . T_EQUAL T_IDENTIFIER   (rule 13)
+
+    T_EQUAL	shift, and go to state 47
+
+
+
+state 28
+
+    attribute  ->  T_MAJOR . T_VERSION T_EQUAL T_NUMBER   (rule 14)
+
+    T_VERSION	shift, and go to state 48
+
+
+
+state 29
+
+    attribute  ->  T_MINOR . T_VERSION T_EQUAL T_NUMBER   (rule 15)
+
+    T_VERSION	shift, and go to state 49
+
+
+
+state 30
+
+    attribute  ->  T_GLOBAL .   (rule 16)
+
+    $default	reduce using rule 16 (attribute)
+
+
+
+state 31
+
+    attribute  ->  T_LOCAL .   (rule 17)
+
+    $default	reduce using rule 17 (attribute)
+
+
+
+state 32
+
+    attribute  ->  T_CLASSINIT . T_EQUAL T_IDENTIFIER   (rule 18)
+
+    T_EQUAL	shift, and go to state 50
+
+
+
+state 33
+
+    attribute  ->  T_EXTERNAL . T_STEM T_EQUAL T_IDENTIFIER   (rule 10)
+    attribute  ->  T_EXTERNAL . T_PREFIX T_EQUAL T_IDENTIFIER   (rule 12)
+
+    T_STEM	shift, and go to state 51
+    T_PREFIX	shift, and go to state 52
+
+
+
+state 34
+
+    attributes  ->  T_COMMA attribute .   (rule 7)
+
+    $default	reduce using rule 7 (attributes)
+
+
+
+state 35
+
+    classdef  ->  T_CLASS T_COLON T_IDENTIFIER attributes T_SEMICOLON .   (rule 6)
+
+    $default	reduce using rule 6 (classdef)
+
+
+
+state 36
+
+    attributes  ->  attributes T_COMMA . attribute   (rule 8)
+
+    T_FILE	shift, and go to state 25
+    T_FUNCTION	shift, and go to state 26
+    T_CLASSPREFIX	shift, and go to state 27
+    T_MAJOR	shift, and go to state 28
+    T_MINOR	shift, and go to state 29
+    T_GLOBAL	shift, and go to state 30
+    T_LOCAL	shift, and go to state 31
+    T_CLASSINIT	shift, and go to state 32
+    T_EXTERNAL	shift, and go to state 33
+
+    attribute	go to state 53
+
+
+
+state 37
+
+    parentattribute  ->  T_FILE . T_STEM T_EQUAL T_IDENTIFIER   (rule 27)
+
+    T_STEM	shift, and go to state 54
+
+
+
+state 38
+
+    parentattribute  ->  T_MAJOR . T_VERSION T_EQUAL T_NUMBER   (rule 28)
+
+    T_VERSION	shift, and go to state 55
+
+
+
+state 39
+
+    parentattribute  ->  T_MINOR . T_VERSION T_EQUAL T_NUMBER   (rule 29)
+
+    T_VERSION	shift, and go to state 56
+
+
+
+state 40
+
+    parentattribute  ->  T_GLOBAL .   (rule 30)
+
+    $default	reduce using rule 30 (parentattribute)
+
+
+
+state 41
+
+    parentattribute  ->  T_LOCAL .   (rule 31)
+
+    $default	reduce using rule 31 (parentattribute)
+
+
+
+state 42
+
+    parentattributes  ->  T_COMMA parentattribute .   (rule 25)
+
+    $default	reduce using rule 25 (parentattributes)
+
+
+
+state 43
+
+    parentdef  ->  parentsection T_IDENTIFIER T_COMMA parentattributes T_SEMICOLON .   (rule 24)
+
+    $default	reduce using rule 24 (parentdef)
+
+
+
+state 44
+
+    parentattributes  ->  parentattributes T_COMMA . parentattribute   (rule 26)
+
+    T_FILE	shift, and go to state 37
+    T_MAJOR	shift, and go to state 38
+    T_MINOR	shift, and go to state 39
+    T_GLOBAL	shift, and go to state 40
+    T_LOCAL	shift, and go to state 41
+
+    parentattribute	go to state 57
+
+
+
+state 45
+
+    attribute  ->  T_FILE T_STEM . T_EQUAL T_IDENTIFIER   (rule 9)
+
+    T_EQUAL	shift, and go to state 58
+
+
+
+state 46
+
+    attribute  ->  T_FUNCTION T_PREFIX . T_EQUAL T_IDENTIFIER   (rule 11)
+
+    T_EQUAL	shift, and go to state 59
+
+
+
+state 47
+
+    attribute  ->  T_CLASSPREFIX T_EQUAL . T_IDENTIFIER   (rule 13)
+
+    T_IDENTIFIER	shift, and go to state 60
+
+
+
+state 48
+
+    attribute  ->  T_MAJOR T_VERSION . T_EQUAL T_NUMBER   (rule 14)
+
+    T_EQUAL	shift, and go to state 61
+
+
+
+state 49
+
+    attribute  ->  T_MINOR T_VERSION . T_EQUAL T_NUMBER   (rule 15)
+
+    T_EQUAL	shift, and go to state 62
+
+
+
+state 50
+
+    attribute  ->  T_CLASSINIT T_EQUAL . T_IDENTIFIER   (rule 18)
+
+    T_IDENTIFIER	shift, and go to state 63
+
+
+
+state 51
+
+    attribute  ->  T_EXTERNAL T_STEM . T_EQUAL T_IDENTIFIER   (rule 10)
+
+    T_EQUAL	shift, and go to state 64
+
+
+
+state 52
+
+    attribute  ->  T_EXTERNAL T_PREFIX . T_EQUAL T_IDENTIFIER   (rule 12)
+
+    T_EQUAL	shift, and go to state 65
+
+
+
+state 53
+
+    attributes  ->  attributes T_COMMA attribute .   (rule 8)
+
+    $default	reduce using rule 8 (attributes)
+
+
+
+state 54
+
+    parentattribute  ->  T_FILE T_STEM . T_EQUAL T_IDENTIFIER   (rule 27)
+
+    T_EQUAL	shift, and go to state 66
+
+
+
+state 55
+
+    parentattribute  ->  T_MAJOR T_VERSION . T_EQUAL T_NUMBER   (rule 28)
+
+    T_EQUAL	shift, and go to state 67
+
+
+
+state 56
+
+    parentattribute  ->  T_MINOR T_VERSION . T_EQUAL T_NUMBER   (rule 29)
+
+    T_EQUAL	shift, and go to state 68
+
+
+
+state 57
+
+    parentattributes  ->  parentattributes T_COMMA parentattribute .   (rule 26)
+
+    $default	reduce using rule 26 (parentattributes)
+
+
+
+state 58
+
+    attribute  ->  T_FILE T_STEM T_EQUAL . T_IDENTIFIER   (rule 9)
+
+    T_IDENTIFIER	shift, and go to state 69
+
+
+
+state 59
+
+    attribute  ->  T_FUNCTION T_PREFIX T_EQUAL . T_IDENTIFIER   (rule 11)
+
+    T_IDENTIFIER	shift, and go to state 70
+
+
+
+state 60
+
+    attribute  ->  T_CLASSPREFIX T_EQUAL T_IDENTIFIER .   (rule 13)
+
+    $default	reduce using rule 13 (attribute)
+
+
+
+state 61
+
+    attribute  ->  T_MAJOR T_VERSION T_EQUAL . T_NUMBER   (rule 14)
+
+    T_NUMBER	shift, and go to state 71
+
+
+
+state 62
+
+    attribute  ->  T_MINOR T_VERSION T_EQUAL . T_NUMBER   (rule 15)
+
+    T_NUMBER	shift, and go to state 72
+
+
+
+state 63
+
+    attribute  ->  T_CLASSINIT T_EQUAL T_IDENTIFIER .   (rule 18)
+
+    $default	reduce using rule 18 (attribute)
+
+
+
+state 64
+
+    attribute  ->  T_EXTERNAL T_STEM T_EQUAL . T_IDENTIFIER   (rule 10)
+
+    T_IDENTIFIER	shift, and go to state 73
+
+
+
+state 65
+
+    attribute  ->  T_EXTERNAL T_PREFIX T_EQUAL . T_IDENTIFIER   (rule 12)
+
+    T_IDENTIFIER	shift, and go to state 74
+
+
+
+state 66
+
+    parentattribute  ->  T_FILE T_STEM T_EQUAL . T_IDENTIFIER   (rule 27)
+
+    T_IDENTIFIER	shift, and go to state 75
+
+
+
+state 67
+
+    parentattribute  ->  T_MAJOR T_VERSION T_EQUAL . T_NUMBER   (rule 28)
+
+    T_NUMBER	shift, and go to state 76
+
+
+
+state 68
+
+    parentattribute  ->  T_MINOR T_VERSION T_EQUAL . T_NUMBER   (rule 29)
+
+    T_NUMBER	shift, and go to state 77
+
+
+
+state 69
+
+    attribute  ->  T_FILE T_STEM T_EQUAL T_IDENTIFIER .   (rule 9)
+
+    $default	reduce using rule 9 (attribute)
+
+
+
+state 70
+
+    attribute  ->  T_FUNCTION T_PREFIX T_EQUAL T_IDENTIFIER .   (rule 11)
+
+    $default	reduce using rule 11 (attribute)
+
+
+
+state 71
+
+    attribute  ->  T_MAJOR T_VERSION T_EQUAL T_NUMBER .   (rule 14)
+
+    $default	reduce using rule 14 (attribute)
+
+
+
+state 72
+
+    attribute  ->  T_MINOR T_VERSION T_EQUAL T_NUMBER .   (rule 15)
+
+    $default	reduce using rule 15 (attribute)
+
+
+
+state 73
+
+    attribute  ->  T_EXTERNAL T_STEM T_EQUAL T_IDENTIFIER .   (rule 10)
+
+    $default	reduce using rule 10 (attribute)
+
+
+
+state 74
+
+    attribute  ->  T_EXTERNAL T_PREFIX T_EQUAL T_IDENTIFIER .   (rule 12)
+
+    $default	reduce using rule 12 (attribute)
+
+
+
+state 75
+
+    parentattribute  ->  T_FILE T_STEM T_EQUAL T_IDENTIFIER .   (rule 27)
+
+    $default	reduce using rule 27 (parentattribute)
+
+
+
+state 76
+
+    parentattribute  ->  T_MAJOR T_VERSION T_EQUAL T_NUMBER .   (rule 28)
+
+    $default	reduce using rule 28 (parentattribute)
+
+
+
+state 77
+
+    parentattribute  ->  T_MINOR T_VERSION T_EQUAL T_NUMBER .   (rule 29)
+
+    $default	reduce using rule 29 (parentattribute)
+
+
+
+state 78
+
+    $   	go to state 79
+
+
+
+state 79
+
+    $   	go to state 80
+
+
+
+state 80
+
+    $default	accept
diff -urN somfree\somopc\src\bison.hairy newsomfree3\somopc\src\bison.hairy
--- somfree\somopc\src\bison.hairy	Thu Jan 01 07:00:00 1970
+++ newsomfree3\somopc\src\bison.hairy	Sat Mar 16 14:09:28 2024
@@ -0,0 +1,334 @@
+
+extern int timeclock;
+
+
+int yyerror;		/*  Yyerror and yycost are set by guards.	*/
+int yycost;		/*  If yyerror is set to a nonzero value by a	*/
+			/*  guard, the reduction with which the guard	*/
+			/*  is associated is not performed, and the	*/
+			/*  error recovery mechanism is invoked.	*/
+			/*  Yycost indicates the cost of performing	*/
+			/*  the reduction given the attributes of the	*/
+			/*  symbols.					*/
+
+
+/*  YYMAXDEPTH indicates the size of the parser's state and value	*/
+/*  stacks.								*/
+
+#ifndef	YYMAXDEPTH
+#define	YYMAXDEPTH	500
+#endif
+
+/*  YYMAXRULES must be at least as large as the number of rules that	*/
+/*  could be placed in the rule queue.  That number could be determined	*/
+/*  from the grammar and the size of the stack, but, as yet, it is not.	*/
+
+#ifndef	YYMAXRULES
+#define	YYMAXRULES	100
+#endif
+
+#ifndef	YYMAXBACKUP
+#define YYMAXBACKUP	100
+#endif
+
+
+short	yyss[YYMAXDEPTH];	/*  the state stack			*/
+YYSTYPE	yyvs[YYMAXDEPTH];	/*  the semantic value stack		*/
+YYLTYPE yyls[YYMAXDEPTH];	/*  the location stack			*/
+short	yyrq[YYMAXRULES];	/*  the rule queue			*/
+int	yychar;			/*  the lookahead symbol		*/
+
+YYSTYPE	yylval;			/*  the semantic value of the		*/
+				/*  lookahead symbol			*/
+
+YYSTYPE yytval;			/*  the semantic value for the state	*/
+				/*  at the top of the state stack.	*/
+
+YYSTYPE yyval;			/*  the variable used to return		*/
+				/*  semantic values from the action	*/
+				/*  routines				*/
+
+YYLTYPE yylloc;		/*  location data for the lookahead	*/
+				/*  symbol				*/
+
+YYLTYPE yytloc;		/*  location data for the state at the	*/
+				/*  top of the state stack		*/
+
+
+int	yynunlexed;
+short	yyunchar[YYMAXBACKUP];
+YYSTYPE	yyunval[YYMAXBACKUP];
+YYLTYPE yyunloc[YYMAXBACKUP];
+
+short *yygssp;			/*  a pointer to the top of the state	*/
+				/*  stack; only set during error	*/
+				/*  recovery.				*/
+
+YYSTYPE *yygvsp;		/*  a pointer to the top of the value	*/
+				/*  stack; only set during error	*/
+				/*  recovery.				*/
+
+YYLTYPE *yyglsp;		/*  a pointer to the top of the		*/
+				/*  location stack; only set during	*/
+				/*  error recovery.			*/
+
+
+/*  Yyget is an interface between the parser and the lexical analyzer.	*/
+/*  It is costly to provide such an interface, but it avoids requiring	*/
+/*  the lexical analyzer to be able to back up the scan.		*/
+
+yyget()
+{
+  if (yynunlexed > 0)
+    {
+      yynunlexed--;
+      yychar = yyunchar[yynunlexed];
+      yylval = yyunval[yynunlexed];
+      yylloc = yyunloc[yynunlexed];
+    }
+  else if (yychar <= 0)
+    yychar = 0;
+  else
+    {
+      yychar = yylex();
+      if (yychar < 0)
+	yychar = 0;
+      else yychar = YYTRANSLATE(yychar);
+    }
+}
+
+
+
+yyunlex(chr, val, loc)
+int chr;
+YYSTYPE val;
+YYLTYPE loc;
+{
+  yyunchar[yynunlexed] = chr;
+  yyunval[yynunlexed] = val;
+  yyunloc[yynunlexed] = loc;
+  yynunlexed++;
+}
+
+
+
+yyrestore(first, last)
+register short *first;
+register short *last;
+{
+  register short *ssp;
+  register short *rp;
+  register int symbol;
+  register int state;
+  register int tvalsaved;
+
+  ssp = yygssp;
+  yyunlex(yychar, yylval, yylloc);
+
+  tvalsaved = 0;
+  while (first != last)
+    {
+      symbol = yystos[*ssp];
+      if (symbol < YYNTBASE)
+	{
+	  yyunlex(symbol, yytval, yytloc);
+	  tvalsaved = 1;
+	  ssp--;
+	}
+
+      ssp--;
+
+      if (first == yyrq)
+	first = yyrq + YYMAXRULES;
+
+      first--;
+
+      for (rp = yyrhs + yyprhs[*first]; symbol = *rp; rp++)
+	{
+	  if (symbol < YYNTBASE)
+	    state = yytable[yypact[*ssp] + symbol];
+	  else
+	    {
+	      state = yypgoto[symbol - YYNTBASE] + *ssp;
+
+	      if (state >= 0 && state <= YYLAST && yycheck[state] == *ssp)
+		state = yytable[state];
+	      else
+		state = yydefgoto[symbol - YYNTBASE];
+	    }
+
+	  *++ssp = state;
+	}
+    }
+
+  if ( ! tvalsaved && ssp > yyss)
+    {
+      yyunlex(yystos[*ssp], yytval, yytloc);
+      ssp--;
+    }
+
+  yygssp = ssp;
+}
+
+
+
+int
+yyparse()
+{
+  register int yystate;
+  register int yyn;
+  register short *yyssp;
+  register short *yyrq0;
+  register short *yyptr;
+  register YYSTYPE *yyvsp;
+
+  int yylen;
+  YYLTYPE *yylsp;
+  short *yyrq1;
+  short *yyrq2;
+
+  yystate = 0;
+  yyssp = yyss - 1;
+  yyvsp = yyvs - 1;
+  yylsp = yyls - 1;
+  yyrq0 = yyrq;
+  yyrq1 = yyrq0;
+  yyrq2 = yyrq0;
+
+  yychar = yylex();
+  if (yychar < 0)
+    yychar = 0;
+  else yychar = YYTRANSLATE(yychar);
+
+yynewstate:
+
+  if (yyssp >= yyss + YYMAXDEPTH - 1)
+    {
+      yyabort("Parser Stack Overflow");
+      YYABORT;
+    }
+
+  *++yyssp = yystate;
+
+yyresume:
+
+  yyn = yypact[yystate];
+  if (yyn == YYFLAG)
+    goto yydefault;
+
+  yyn += yychar;
+  if (yyn < 0 || yyn > YYLAST || yycheck[yyn] != yychar)
+    goto yydefault;
+
+  yyn = yytable[yyn];
+  if (yyn < 0)
+    {
+      yyn = -yyn;
+      goto yyreduce;
+    }
+  else if (yyn == 0)
+    goto yyerrlab;
+
+  yystate = yyn;
+
+  yyptr = yyrq2;
+  while (yyptr != yyrq1)
+    {
+      yyn = *yyptr++;
+      yylen = yyr2[yyn];
+      yyvsp -= yylen;
+      yylsp -= yylen;
+
+      yyguard(yyn, yyvsp, yylsp);
+      if (yyerror)
+	goto yysemerr;
+
+      yyaction(yyn, yyvsp, yylsp);
+      *++yyvsp = yyval;
+
+      yylsp++;
+      if (yylen == 0)
+	{
+	  yylsp->timestamp = timeclock;
+	  yylsp->first_line = yytloc.first_line;
+	  yylsp->first_column = yytloc.first_column;
+	  yylsp->last_line = (yylsp-1)->last_line;
+	  yylsp->last_column = (yylsp-1)->last_column;
+	  yylsp->text = 0;
+	}
+      else
+	{
+	  yylsp->last_line = (yylsp+yylen-1)->last_line;
+	  yylsp->last_column = (yylsp+yylen-1)->last_column;
+	}
+	  
+      if (yyptr == yyrq + YYMAXRULES)
+        yyptr = yyrq;
+    }
+
+  if (yystate == YYFINAL)
+    YYACCEPT;
+
+  yyrq2 = yyptr;
+  yyrq1 = yyrq0;
+
+  *++yyvsp = yytval;
+  *++yylsp = yytloc;
+  yytval = yylval;
+  yytloc = yylloc;
+  yyget();
+
+  goto yynewstate;
+
+yydefault:
+
+  yyn = yydefact[yystate];
+  if (yyn == 0)
+    goto yyerrlab;
+
+yyreduce:
+
+  *yyrq0++ = yyn;
+
+  if (yyrq0 == yyrq + YYMAXRULES)
+    yyrq0 = yyrq;
+
+  if (yyrq0 == yyrq2)
+    {
+      yyabort("Parser Rule Queue Overflow");
+      YYABORT;
+    }
+
+  yyssp -= yyr2[yyn];
+  yyn = yyr1[yyn];
+
+  yystate = yypgoto[yyn - YYNTBASE] + *yyssp;
+  if (yystate >= 0 && yystate <= YYLAST && yycheck[yystate] == *yyssp)
+    yystate = yytable[yystate];
+  else
+    yystate = yydefgoto[yyn - YYNTBASE];
+
+  goto yynewstate;
+
+yysemerr:
+  *--yyptr = yyn;
+  yyrq2 = yyptr;
+  yyvsp += yyr2[yyn];
+
+yyerrlab:
+
+  yygssp = yyssp;
+  yygvsp = yyvsp;
+  yyglsp = yylsp;
+  yyrestore(yyrq0, yyrq2);
+  yyrecover();
+  yystate = *yygssp;
+  yyssp = yygssp;
+  yyvsp = yygvsp;
+  yyrq0 = yyrq;
+  yyrq1 = yyrq0;
+  yyrq2 = yyrq0;
+  goto yyresume;
+}
+
+$
diff -urN somfree\somopc\src\bison.simple newsomfree3\somopc\src\bison.simple
--- somfree\somopc\src\bison.simple	Thu Jan 01 07:00:00 1970
+++ newsomfree3\somopc\src\bison.simple	Sat Mar 16 14:09:28 2024
@@ -0,0 +1,762 @@
+/* -*-C-*-  Note some compilers choke on comments on `#line' lines.  */
+#line 3 "/emx/share/bison.simple"
+/* This file comes from bison-1.28.  */
+
+/* Skeleton output parser for bison,
+   Copyright (C) 1984, 1989, 1990 Free Software Foundation, Inc.
+
+   This program is free software; you can redistribute it and/or modify
+   it under the terms of the GNU General Public License as published by
+   the Free Software Foundation; either version 2, or (at your option)
+   any later version.
+
+   This program is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+   GNU General Public License for more details.
+
+   You should have received a copy of the GNU General Public License
+   along with this program; if not, write to the Free Software
+   Foundation, Inc., 59 Temple Place - Suite 330,
+   Boston, MA 02111-1307, USA.  */
+
+/* As a special exception, when this file is copied by Bison into a
+   Bison output file, you may use that output file without restriction.
+   This special exception was added by the Free Software Foundation
+   in version 1.24 of Bison.  */
+
+/* This is the parser code that is written into each bison parser
+  when the %semantic_parser declaration is not specified in the grammar.
+  It was written by Richard Stallman by simplifying the hairy parser
+  used when %semantic_parser is specified.  */
+
+#ifndef YYSTACK_USE_ALLOCA
+#ifdef alloca
+#define YYSTACK_USE_ALLOCA
+#else /* alloca not defined */
+#ifdef __GNUC__
+#define YYSTACK_USE_ALLOCA
+#define alloca __builtin_alloca
+#else /* not GNU C.  */
+#if (!defined (__STDC__) && defined (sparc)) || defined (__sparc__) || defined (__sparc) || defined (__sgi) || (defined (__sun) && defined (__i386))
+#define YYSTACK_USE_ALLOCA
+#include <alloca.h>
+#else /* not sparc */
+/* We think this test detects Watcom and Microsoft C.  */
+/* This used to test MSDOS, but that is a bad idea
+   since that symbol is in the user namespace.  */
+#if (defined (_MSDOS) || defined (_MSDOS_)) && !defined (__TURBOC__)
+#if 0 /* No need for malloc.h, which pollutes the namespace;
+	 instead, just don't use alloca.  */
+#include <malloc.h>
+#endif
+#else /* not MSDOS, or __TURBOC__ */
+#if defined(_AIX)
+/* I don't know what this was needed for, but it pollutes the namespace.
+   So I turned it off.   rms, 2 May 1997.  */
+/* #include <malloc.h>  */
+ #pragma alloca
+#define YYSTACK_USE_ALLOCA
+#else /* not MSDOS, or __TURBOC__, or _AIX */
+#include <malloc.h>
+#if 0
+#ifdef __hpux /* haible@ilog.fr says this works for HPUX 9.05 and up,
+		 and on HPUX 10.  Eventually we can turn this on.  */
+#define YYSTACK_USE_ALLOCA
+#define alloca __builtin_alloca
+#endif /* __hpux */
+#endif
+#endif /* not _AIX */
+#endif /* not MSDOS, or __TURBOC__ */
+#endif /* not sparc */
+#endif /* not GNU C */
+#endif /* alloca not defined */
+#endif /* YYSTACK_USE_ALLOCA not defined */
+
+#ifdef YYSTACK_USE_ALLOCA
+#define YYSTACK_ALLOC alloca
+#else
+#define YYSTACK_ALLOC malloc
+#endif
+
+/* Note: there must be only one dollar sign in this file.
+   It is replaced by the list of actions, each action
+   as one case of the switch.  */
+
+#define yyerrok		(yyerrstatus = 0)
+#define yyclearin	(yychar = YYEMPTY)
+#define YYEMPTY		-2
+#define YYEOF		0
+#define YYACCEPT	goto yyacceptlab
+#define YYABORT 	goto yyabortlab
+#define YYERROR		goto yyerrlab1
+/* Like YYERROR except do call yyerror.
+   This remains here temporarily to ease the
+   transition to the new meaning of YYERROR, for GCC.
+   Once GCC version 2 has supplanted version 1, this can go.  */
+#define YYFAIL		goto yyerrlab
+#define YYRECOVERING()  (!!yyerrstatus)
+#define YYBACKUP(token, value) \
+do								\
+  if (yychar == YYEMPTY && yylen == 1)				\
+    { yychar = (token), yylval = (value);			\
+      yychar1 = YYTRANSLATE (yychar);				\
+      YYPOPSTACK;						\
+      goto yybackup;						\
+    }								\
+  else								\
+    { yyerror ("syntax error: cannot back up"); YYERROR; }	\
+while (0)
+
+#define YYTERROR	1
+#define YYERRCODE	256
+
+#ifndef YYPURE
+#define YYLEX		yylex()
+#endif
+
+#ifdef YYPURE
+#ifdef YYLSP_NEEDED
+#ifdef YYLEX_PARAM
+#define YYLEX		yylex(&yylval, &yylloc, YYLEX_PARAM)
+#else
+#define YYLEX		yylex(&yylval, &yylloc)
+#endif
+#else /* not YYLSP_NEEDED */
+#ifdef YYLEX_PARAM
+#define YYLEX		yylex(&yylval, YYLEX_PARAM)
+#else
+#define YYLEX		yylex(&yylval)
+#endif
+#endif /* not YYLSP_NEEDED */
+#endif
+
+/* If nonreentrant, generate the variables here */
+
+#ifndef YYPURE
+
+int	yychar;			/*  the lookahead symbol		*/
+YYSTYPE	yylval;			/*  the semantic value of the		*/
+				/*  lookahead symbol			*/
+
+#ifdef YYLSP_NEEDED
+YYLTYPE yylloc;			/*  location data for the lookahead	*/
+				/*  symbol				*/
+#endif
+
+int yynerrs;			/*  number of parse errors so far       */
+#endif  /* not YYPURE */
+
+#if YYDEBUG != 0
+int yydebug;			/*  nonzero means print parse trace	*/
+/* Since this is uninitialized, it does not stop multiple parsers
+   from coexisting.  */
+#endif
+
+/*  YYINITDEPTH indicates the initial size of the parser's stacks	*/
+
+#ifndef	YYINITDEPTH
+#define YYINITDEPTH 200
+#endif
+
+/*  YYMAXDEPTH is the maximum size the stacks can grow to
+    (effective only if the built-in stack extension method is used).  */
+
+#if YYMAXDEPTH == 0
+#undef YYMAXDEPTH
+#endif
+
+#ifndef YYMAXDEPTH
+#define YYMAXDEPTH 10000
+#endif
+
+/* Define __yy_memcpy.  Note that the size argument
+   should be passed with type unsigned int, because that is what the non-GCC
+   definitions require.  With GCC, __builtin_memcpy takes an arg
+   of type size_t, but it can handle unsigned int.  */
+
+#if __GNUC__ > 1		/* GNU C and GNU C++ define this.  */
+#define __yy_memcpy(TO,FROM,COUNT)	__builtin_memcpy(TO,FROM,COUNT)
+#else				/* not GNU C or C++ */
+#ifndef __cplusplus
+
+/* This is the most reliable way to avoid incompatibilities
+   in available built-in functions on various systems.  */
+static void
+__yy_memcpy (to, from, count)
+     char *to;
+     char *from;
+     unsigned int count;
+{
+  register char *f = from;
+  register char *t = to;
+  register int i = count;
+
+  while (i-- > 0)
+    *t++ = *f++;
+}
+
+#else /* __cplusplus */
+
+/* This is the most reliable way to avoid incompatibilities
+   in available built-in functions on various systems.  */
+static void
+__yy_memcpy (char *to, char *from, unsigned int count)
+{
+  register char *t = to;
+  register char *f = from;
+  register int i = count;
+
+  while (i-- > 0)
+    *t++ = *f++;
+}
+
+#endif
+#endif
+
+#line 217 "/emx/share/bison.simple"
+
+/* The user can define YYPARSE_PARAM as the name of an argument to be passed
+   into yyparse.  The argument should have type void *.
+   It should actually point to an object.
+   Grammar actions can access the variable by casting it
+   to the proper pointer type.  */
+
+#ifdef YYPARSE_PARAM
+#ifdef __cplusplus
+#define YYPARSE_PARAM_ARG void *YYPARSE_PARAM
+#define YYPARSE_PARAM_DECL
+#else /* not __cplusplus */
+#define YYPARSE_PARAM_ARG YYPARSE_PARAM
+#define YYPARSE_PARAM_DECL void *YYPARSE_PARAM;
+#endif /* not __cplusplus */
+#else /* not YYPARSE_PARAM */
+#define YYPARSE_PARAM_ARG
+#define YYPARSE_PARAM_DECL
+#endif /* not YYPARSE_PARAM */
+
+/* Prevent warning if -Wstrict-prototypes.  */
+#ifdef __GNUC__
+#ifdef YYPARSE_PARAM
+int yyparse (void *);
+#else
+int yyparse (void);
+#endif
+#endif
+
+int
+yyparse(YYPARSE_PARAM_ARG)
+     YYPARSE_PARAM_DECL
+{
+  register int yystate;
+  register int yyn;
+  register short *yyssp;
+  register YYSTYPE *yyvsp;
+  int yyerrstatus;	/*  number of tokens to shift before error messages enabled */
+  int yychar1 = 0;		/*  lookahead token as an internal (translated) token number */
+
+  short	yyssa[YYINITDEPTH];	/*  the state stack			*/
+  YYSTYPE yyvsa[YYINITDEPTH];	/*  the semantic value stack		*/
+
+  short *yyss = yyssa;		/*  refer to the stacks thru separate pointers */
+  YYSTYPE *yyvs = yyvsa;	/*  to allow yyoverflow to reallocate them elsewhere */
+
+#ifdef YYLSP_NEEDED
+  YYLTYPE yylsa[YYINITDEPTH];	/*  the location stack			*/
+  YYLTYPE *yyls = yylsa;
+  YYLTYPE *yylsp;
+
+#define YYPOPSTACK   (yyvsp--, yyssp--, yylsp--)
+#else
+#define YYPOPSTACK   (yyvsp--, yyssp--)
+#endif
+
+  int yystacksize = YYINITDEPTH;
+  int yyfree_stacks = 0;
+
+#ifdef YYPURE
+  int yychar;
+  YYSTYPE yylval;
+  int yynerrs;
+#ifdef YYLSP_NEEDED
+  YYLTYPE yylloc;
+#endif
+#endif
+
+  YYSTYPE yyval;		/*  the variable used to return		*/
+				/*  semantic values from the action	*/
+				/*  routines				*/
+
+  int yylen;
+
+#if YYDEBUG != 0
+  if (yydebug)
+    fprintf(stderr, "Starting parse\n");
+#endif
+
+  yystate = 0;
+  yyerrstatus = 0;
+  yynerrs = 0;
+  yychar = YYEMPTY;		/* Cause a token to be read.  */
+
+  /* Initialize stack pointers.
+     Waste one element of value and location stack
+     so that they stay on the same level as the state stack.
+     The wasted elements are never initialized.  */
+
+  yyssp = yyss - 1;
+  yyvsp = yyvs;
+#ifdef YYLSP_NEEDED
+  yylsp = yyls;
+#endif
+
+/* Push a new state, which is found in  yystate  .  */
+/* In all cases, when you get here, the value and location stacks
+   have just been pushed. so pushing a state here evens the stacks.  */
+yynewstate:
+
+  *++yyssp = yystate;
+
+  if (yyssp >= yyss + yystacksize - 1)
+    {
+      /* Give user a chance to reallocate the stack */
+      /* Use copies of these so that the &'s don't force the real ones into memory. */
+      YYSTYPE *yyvs1 = yyvs;
+      short *yyss1 = yyss;
+#ifdef YYLSP_NEEDED
+      YYLTYPE *yyls1 = yyls;
+#endif
+
+      /* Get the current used size of the three stacks, in elements.  */
+      int size = yyssp - yyss + 1;
+
+#ifdef yyoverflow
+      /* Each stack pointer address is followed by the size of
+	 the data in use in that stack, in bytes.  */
+#ifdef YYLSP_NEEDED
+      /* This used to be a conditional around just the two extra args,
+	 but that might be undefined if yyoverflow is a macro.  */
+      yyoverflow("parser stack overflow",
+		 &yyss1, size * sizeof (*yyssp),
+		 &yyvs1, size * sizeof (*yyvsp),
+		 &yyls1, size * sizeof (*yylsp),
+		 &yystacksize);
+#else
+      yyoverflow("parser stack overflow",
+		 &yyss1, size * sizeof (*yyssp),
+		 &yyvs1, size * sizeof (*yyvsp),
+		 &yystacksize);
+#endif
+
+      yyss = yyss1; yyvs = yyvs1;
+#ifdef YYLSP_NEEDED
+      yyls = yyls1;
+#endif
+#else /* no yyoverflow */
+      /* Extend the stack our own way.  */
+      if (yystacksize >= YYMAXDEPTH)
+	{
+	  yyerror("parser stack overflow");
+	  if (yyfree_stacks)
+	    {
+	      free (yyss);
+	      free (yyvs);
+#ifdef YYLSP_NEEDED
+	      free (yyls);
+#endif
+	    }
+	  return 2;
+	}
+      yystacksize *= 2;
+      if (yystacksize > YYMAXDEPTH)
+	yystacksize = YYMAXDEPTH;
+#ifndef YYSTACK_USE_ALLOCA
+      yyfree_stacks = 1;
+#endif
+      yyss = (short *) YYSTACK_ALLOC (yystacksize * sizeof (*yyssp));
+      __yy_memcpy ((char *)yyss, (char *)yyss1,
+		   size * (unsigned int) sizeof (*yyssp));
+      yyvs = (YYSTYPE *) YYSTACK_ALLOC (yystacksize * sizeof (*yyvsp));
+      __yy_memcpy ((char *)yyvs, (char *)yyvs1,
+		   size * (unsigned int) sizeof (*yyvsp));
+#ifdef YYLSP_NEEDED
+      yyls = (YYLTYPE *) YYSTACK_ALLOC (yystacksize * sizeof (*yylsp));
+      __yy_memcpy ((char *)yyls, (char *)yyls1,
+		   size * (unsigned int) sizeof (*yylsp));
+#endif
+#endif /* no yyoverflow */
+
+      yyssp = yyss + size - 1;
+      yyvsp = yyvs + size - 1;
+#ifdef YYLSP_NEEDED
+      yylsp = yyls + size - 1;
+#endif
+
+#if YYDEBUG != 0
+      if (yydebug)
+	fprintf(stderr, "Stack size increased to %d\n", yystacksize);
+#endif
+
+      if (yyssp >= yyss + yystacksize - 1)
+	YYABORT;
+    }
+
+#if YYDEBUG != 0
+  if (yydebug)
+    fprintf(stderr, "Entering state %d\n", yystate);
+#endif
+
+  goto yybackup;
+ yybackup:
+
+/* Do appropriate processing given the current state.  */
+/* Read a lookahead token if we need one and don't already have one.  */
+/* yyresume: */
+
+  /* First try to decide what to do without reference to lookahead token.  */
+
+  yyn = yypact[yystate];
+  if (yyn == YYFLAG)
+    goto yydefault;
+
+  /* Not known => get a lookahead token if don't already have one.  */
+
+  /* yychar is either YYEMPTY or YYEOF
+     or a valid token in external form.  */
+
+  if (yychar == YYEMPTY)
+    {
+#if YYDEBUG != 0
+      if (yydebug)
+	fprintf(stderr, "Reading a token: ");
+#endif
+      yychar = YYLEX;
+    }
+
+  /* Convert token to internal form (in yychar1) for indexing tables with */
+
+  if (yychar <= 0)		/* This means end of input. */
+    {
+      yychar1 = 0;
+      yychar = YYEOF;		/* Don't call YYLEX any more */
+
+#if YYDEBUG != 0
+      if (yydebug)
+	fprintf(stderr, "Now at end of input.\n");
+#endif
+    }
+  else
+    {
+      yychar1 = YYTRANSLATE(yychar);
+
+#if YYDEBUG != 0
+      if (yydebug)
+	{
+	  fprintf (stderr, " Next token is %d (%s", yychar, yytname[yychar1]);
+	  /* Give the individual parser a way to print the precise meaning
+	     of a token, for further debugging info.  */
+#ifdef YYPRINT
+	  YYPRINT (stderr, yychar, yylval);
+#endif
+	  fprintf (stderr, ")\n");
+	}
+#endif
+    }
+
+  yyn += yychar1;
+  if (yyn < 0 || yyn > YYLAST || yycheck[yyn] != yychar1)
+    goto yydefault;
+
+  yyn = yytable[yyn];
+
+  /* yyn is what to do for this token type in this state.
+     Negative => reduce, -yyn is rule number.
+     Positive => shift, yyn is new state.
+       New state is final state => don't bother to shift,
+       just return success.
+     0, or most negative number => error.  */
+
+  if (yyn < 0)
+    {
+      if (yyn == YYFLAG)
+	goto yyerrlab;
+      yyn = -yyn;
+      goto yyreduce;
+    }
+  else if (yyn == 0)
+    goto yyerrlab;
+
+  if (yyn == YYFINAL)
+    YYACCEPT;
+
+  /* Shift the lookahead token.  */
+
+#if YYDEBUG != 0
+  if (yydebug)
+    fprintf(stderr, "Shifting token %d (%s), ", yychar, yytname[yychar1]);
+#endif
+
+  /* Discard the token being shifted unless it is eof.  */
+  if (yychar != YYEOF)
+    yychar = YYEMPTY;
+
+  *++yyvsp = yylval;
+#ifdef YYLSP_NEEDED
+  *++yylsp = yylloc;
+#endif
+
+  /* count tokens shifted since error; after three, turn off error status.  */
+  if (yyerrstatus) yyerrstatus--;
+
+  yystate = yyn;
+  goto yynewstate;
+
+/* Do the default action for the current state.  */
+yydefault:
+
+  yyn = yydefact[yystate];
+  if (yyn == 0)
+    goto yyerrlab;
+
+/* Do a reduction.  yyn is the number of a rule to reduce with.  */
+yyreduce:
+  yylen = yyr2[yyn];
+  if (yylen > 0)
+    yyval = yyvsp[1-yylen]; /* implement default value of the action */
+
+#if YYDEBUG != 0
+  if (yydebug)
+    {
+      int i;
+
+      fprintf (stderr, "Reducing via rule %d (line %d), ",
+	       yyn, yyrline[yyn]);
+
+      /* Print the symbols being reduced, and their result.  */
+      for (i = yyprhs[yyn]; yyrhs[i] > 0; i++)
+	fprintf (stderr, "%s ", yytname[yyrhs[i]]);
+      fprintf (stderr, " -> %s\n", yytname[yyr1[yyn]]);
+    }
+#endif
+
+$   /* the action file gets copied in in place of this dollarsign */
+#line 543 "/emx/share/bison.simple"
+
+  yyvsp -= yylen;
+  yyssp -= yylen;
+#ifdef YYLSP_NEEDED
+  yylsp -= yylen;
+#endif
+
+#if YYDEBUG != 0
+  if (yydebug)
+    {
+      short *ssp1 = yyss - 1;
+      fprintf (stderr, "state stack now");
+      while (ssp1 != yyssp)
+	fprintf (stderr, " %d", *++ssp1);
+      fprintf (stderr, "\n");
+    }
+#endif
+
+  *++yyvsp = yyval;
+
+#ifdef YYLSP_NEEDED
+  yylsp++;
+  if (yylen == 0)
+    {
+      yylsp->first_line = yylloc.first_line;
+      yylsp->first_column = yylloc.first_column;
+      yylsp->last_line = (yylsp-1)->last_line;
+      yylsp->last_column = (yylsp-1)->last_column;
+      yylsp->text = 0;
+    }
+  else
+    {
+      yylsp->last_line = (yylsp+yylen-1)->last_line;
+      yylsp->last_column = (yylsp+yylen-1)->last_column;
+    }
+#endif
+
+  /* Now "shift" the result of the reduction.
+     Determine what state that goes to,
+     based on the state we popped back to
+     and the rule number reduced by.  */
+
+  yyn = yyr1[yyn];
+
+  yystate = yypgoto[yyn - YYNTBASE] + *yyssp;
+  if (yystate >= 0 && yystate <= YYLAST && yycheck[yystate] == *yyssp)
+    yystate = yytable[yystate];
+  else
+    yystate = yydefgoto[yyn - YYNTBASE];
+
+  goto yynewstate;
+
+yyerrlab:   /* here on detecting error */
+
+  if (! yyerrstatus)
+    /* If not already recovering from an error, report this error.  */
+    {
+      ++yynerrs;
+
+#ifdef YYERROR_VERBOSE
+      yyn = yypact[yystate];
+
+      if (yyn > YYFLAG && yyn < YYLAST)
+	{
+	  int size = 0;
+	  char *msg;
+	  int x, count;
+
+	  count = 0;
+	  /* Start X at -yyn if nec to avoid negative indexes in yycheck.  */
+	  for (x = (yyn < 0 ? -yyn : 0);
+	       x < (sizeof(yytname) / sizeof(char *)); x++)
+	    if (yycheck[x + yyn] == x)
+	      size += strlen(yytname[x]) + 15, count++;
+	  msg = (char *) malloc(size + 15);
+	  if (msg != 0)
+	    {
+	      strcpy(msg, "parse error");
+
+	      if (count < 5)
+		{
+		  count = 0;
+		  for (x = (yyn < 0 ? -yyn : 0);
+		       x < (sizeof(yytname) / sizeof(char *)); x++)
+		    if (yycheck[x + yyn] == x)
+		      {
+			strcat(msg, count == 0 ? ", expecting `" : " or `");
+			strcat(msg, yytname[x]);
+			strcat(msg, "'");
+			count++;
+		      }
+		}
+	      yyerror(msg);
+	      free(msg);
+	    }
+	  else
+	    yyerror ("parse error; also virtual memory exceeded");
+	}
+      else
+#endif /* YYERROR_VERBOSE */
+	yyerror("parse error");
+    }
+
+  goto yyerrlab1;
+yyerrlab1:   /* here on error raised explicitly by an action */
+
+  if (yyerrstatus == 3)
+    {
+      /* if just tried and failed to reuse lookahead token after an error, discard it.  */
+
+      /* return failure if at end of input */
+      if (yychar == YYEOF)
+	YYABORT;
+
+#if YYDEBUG != 0
+      if (yydebug)
+	fprintf(stderr, "Discarding token %d (%s).\n", yychar, yytname[yychar1]);
+#endif
+
+      yychar = YYEMPTY;
+    }
+
+  /* Else will try to reuse lookahead token
+     after shifting the error token.  */
+
+  yyerrstatus = 3;		/* Each real token shifted decrements this */
+
+  goto yyerrhandle;
+
+yyerrdefault:  /* current state does not do anything special for the error token. */
+
+#if 0
+  /* This is wrong; only states that explicitly want error tokens
+     should shift them.  */
+  yyn = yydefact[yystate];  /* If its default is to accept any token, ok.  Otherwise pop it.*/
+  if (yyn) goto yydefault;
+#endif
+
+yyerrpop:   /* pop the current state because it cannot handle the error token */
+
+  if (yyssp == yyss) YYABORT;
+  yyvsp--;
+  yystate = *--yyssp;
+#ifdef YYLSP_NEEDED
+  yylsp--;
+#endif
+
+#if YYDEBUG != 0
+  if (yydebug)
+    {
+      short *ssp1 = yyss - 1;
+      fprintf (stderr, "Error: state stack now");
+      while (ssp1 != yyssp)
+	fprintf (stderr, " %d", *++ssp1);
+      fprintf (stderr, "\n");
+    }
+#endif
+
+yyerrhandle:
+
+  yyn = yypact[yystate];
+  if (yyn == YYFLAG)
+    goto yyerrdefault;
+
+  yyn += YYTERROR;
+  if (yyn < 0 || yyn > YYLAST || yycheck[yyn] != YYTERROR)
+    goto yyerrdefault;
+
+  yyn = yytable[yyn];
+  if (yyn < 0)
+    {
+      if (yyn == YYFLAG)
+	goto yyerrpop;
+      yyn = -yyn;
+      goto yyreduce;
+    }
+  else if (yyn == 0)
+    goto yyerrpop;
+
+  if (yyn == YYFINAL)
+    YYACCEPT;
+
+#if YYDEBUG != 0
+  if (yydebug)
+    fprintf(stderr, "Shifting error token, ");
+#endif
+
+  *++yyvsp = yylval;
+#ifdef YYLSP_NEEDED
+  *++yylsp = yylloc;
+#endif
+
+  yystate = yyn;
+  goto yynewstate;
+
+ yyacceptlab:
+  /* YYACCEPT comes here.  */
+  if (yyfree_stacks)
+    {
+      free (yyss);
+      free (yyvs);
+#ifdef YYLSP_NEEDED
+      free (yyls);
+#endif
+    }
+  return 0;
+
+ yyabortlab:
+  /* YYABORT comes here.  */
+  if (yyfree_stacks)
+    {
+      free (yyss);
+      free (yyvs);
+#ifdef YYLSP_NEEDED
+      free (yyls);
+#endif
+    }
+  return 1;
+}
diff -urN somfree\somopc\src\gramma.yy newsomfree3\somopc\src\gramma.yy
--- somfree\somopc\src\gramma.yy	Thu Jan 01 07:00:00 1970
+++ newsomfree3\somopc\src\gramma.yy	Sat Mar 16 14:09:28 2024
@@ -0,0 +1,1125 @@
+%{
+#include <stdio.h> // fopen, fprintf
+#include <string.h>
+
+#include <emitlib.h>
+
+#define YYERROR_VERBOSE
+
+extern int lineno, column;
+
+Entry e;
+
+Entry *cls;	// Current Class Entry
+Entry *pcls;	// Parent Class Entry
+Entry *mcls;	// Meta Class Entry
+
+void yyerror(const char *str)
+{
+        fprintf(stderr,"\nerror: %s\n", str);
+}
+ 
+int yywrap()
+{
+        return 1;
+} 
+  
+%}
+
+
+
+%start oidl
+
+%union{
+ char *stval;
+ int ival;
+}
+
+
+%type <stval> overridemethod_name
+
+%type <ival> T_CONSTANT
+
+%token T_COLON T_SEMICOLON T_COMMA T_STAR T_COMMENT T_IDENTIFIER
+%token T_EQUAL T_DASHES T_CONSTANT T_PERIOD  T_STRING
+%token T_ELLIPSIS T_LEFTPARENTHESIS T_RIGHTPARENTHESIS
+%token T_LEFTSQUAREBRACKET T_RIGHTSQUAREBRACKET
+
+%token T_VERSION T_GLOBAL T_LOCAL T_CLASSINIT T_RELEASE T_ORDER T_METACLASS T_PARENT
+%token T_CLASS T_LINE
+%token T_FILE T_STEM T_FUNCTION T_PREFIX T_CLASSPREFIX T_MAJOR T_MINOR
+%token T_PASSTHRU T_BEFORE T_AFTER T_ENDPASSTHRU T_DATA T_PRIVATE T_PUBLIC T_INTERNAL
+%token T_METHODS T_GROUP T_METHOD T_PROCEDURE T_OFFSET T_NAME T_LOOKUP T_EXTERNAL
+%token T_USE T_OVERRIDE
+
+%%
+
+oidl
+	:
+		{
+			if (somtg_f.verbose) printf("Parsing of \"%s\" started.\n", somtfilePath);
+			somtg_f._ERROR=0;   /* @todo subject to move to parse() */
+			somtg_f.WARN=0;   /* @todo subject to move to parse() */
+			somtg_f.FATAL=0;   /* @todo subject to move to parse() */
+			somtg_f.INTERNAL=0;   /* @todo subject to move to parse() */
+			somtg_buf=somtsmallocSL(somtg_f.commentsize, TRUE);   /* @todo subject to move to parse() */
+		}
+	  class_list
+		{
+			somtfree(somtg_buf);   /* @todo subject to move to parse() */
+			if (somtg_f.verbose) printf("Parsing of \"%s\" finished.\n", somtfilePath);
+		}
+	| line
+        ;
+
+line	: T_LINE T_CONSTANT T_STRING
+	;
+
+class_list
+	: class_definition
+	| class_list class_definition
+	;
+
+class_definition
+	:
+		{
+			cls=(Entry *)somtsmallocSL(sizeof(Entry), TRUE);
+			cls->atts=somtaddModifierSL(cls->atts, "callstyle", "oidl");
+			cls->type=SOMTClassE;
+			somtclassIdlCall=FALSE;
+			cls->u.c.file=strdup(somtfilePath);
+		}
+	  class_section section_list
+		{
+			somtaddEntrySL(somtstab, cls->name, cls);
+			somtfree(cls);
+		}
+	;
+
+section_list
+	: section
+        | section_list section
+        ;
+
+section
+	: releaseorder_section
+        | metaclass_section
+        |
+		{
+			pcls=(Entry *)somtsmallocSL(sizeof(Entry), TRUE);
+			pcls->atts=somtaddModifierSL(pcls->atts, "callstyle", "oidl");
+			pcls->type=SOMTBaseE;
+			somtclassIdlCall=FALSE;
+//			pcls->u.c.file=strdup(somtfilePath);
+		}
+	  parent_section
+		{
+			cls->u.c.parent=somtaddEntrySL(somtstab, pcls->name, pcls);
+			somtfree(pcls);
+		}
+        | passthru_section
+        | data_section
+	| methods_section
+	;
+
+class_section
+	: classdef 
+        | classdef description
+		{
+			cls->comment=$<stval>2;
+		}
+	;
+
+classdef
+	: class_header class_name T_SEMICOLON 
+	| class_header class_name class_attributes T_SEMICOLON
+        ;
+
+class_header
+	: T_CLASS T_COLON 
+	;
+
+class_name
+	: T_IDENTIFIER 
+		{
+			somtclassName=$<stval>1;
+			cls->lineno=lineno;                 
+			cls->name=$<stval>1;
+		}
+        ;
+
+class_attributes
+	: T_COMMA class_attribute
+	| class_attributes T_COMMA class_attribute
+        ;
+
+class_attribute
+	: T_FILE T_STEM T_EQUAL T_IDENTIFIER
+		{
+			cls->atts=somtaddModifierSL(cls->atts, "filestem", $<stval>4);
+		}
+        | T_EXTERNAL T_STEM T_EQUAL T_IDENTIFIER
+		{
+			cls->atts=somtaddModifierSL(cls->atts, "externalstem", $<stval>4);
+		}
+        | T_FUNCTION T_PREFIX T_EQUAL T_IDENTIFIER
+		{
+			cls->atts=somtaddModifierSL(cls->atts, "functionprefix", $<stval>4);
+		}
+        | T_EXTERNAL T_PREFIX T_EQUAL T_IDENTIFIER
+		{
+			cls->atts=somtaddModifierSL(cls->atts, "externalprefix", $<stval>4);
+		}
+        | T_CLASSPREFIX T_EQUAL T_IDENTIFIER
+		{
+			cls->atts=somtaddModifierSL(cls->atts, "classprefix", $<stval>3);
+		}
+        | T_MAJOR T_VERSION T_EQUAL T_CONSTANT
+		{
+			char *st=itoa($4, somtsmallocSL(_MAX_ITOSTR_BASE10_COUNT, TRUE), 10);
+			cls->atts=somtaddModifierSL(cls->atts, "majorversion", st);
+			somtmajorVersion=strdup(st);
+			somtfree(st);
+		}
+        | T_MINOR T_VERSION T_EQUAL T_CONSTANT
+		{
+			char *st=itoa($4, somtsmallocSL(_MAX_ITOSTR_BASE10_COUNT, TRUE), 10);
+			cls->atts=somtaddModifierSL(cls->atts, "minorversion", st);
+			somtminorVersion=strdup(st);
+			somtfree(st);
+		}
+        | T_CLASSINIT T_EQUAL T_IDENTIFIER
+		{
+			cls->atts=somtaddModifierSL(cls->atts, "classInit", $<stval>3);
+		}
+	| visibility
+        ;
+
+visibility
+	: T_GLOBAL
+        | T_LOCAL
+	;
+
+releaseorder_section
+	: releaseorder_header release_list T_SEMICOLON
+		{
+			cls->atts=somtaddModifierSL(cls->atts, "releaseorder", $<stval>2);
+		}
+	;
+
+releaseorder_header
+	: T_RELEASE T_ORDER T_COLON
+	;
+
+release_list
+	: release
+		{ 
+			$<stval>$=strdup($<stval>1);
+		}
+	| release_list T_COMMA release
+		{
+			char *r=somtsmallocSL(strlen($<stval>1)+strlen($<stval>3)+2, TRUE);
+			strcat(strcat(strcat(r, $<stval>1), ","), $<stval>3);
+			$<stval>$=strdup(r);
+			somtfree(r);
+		}
+	;
+
+release
+	: T_IDENTIFIER
+		{
+			cls->u.c.release=somtaddModifierSL(cls->u.c.release, $<stval>1, NULL);
+			$<stval>$=$<stval>1;
+		}
+	;
+
+metaclass_section
+	: metaclassdef
+        | metaclassdef description
+		{
+			mcls->comment=$<stval>2;
+		}
+	;
+
+metaclassdef
+	: metaclass_header metaclass_name T_SEMICOLON
+        | metaclass_header metaclass_name metaclass_attributes T_SEMICOLON
+        ;
+
+metaclass_header
+	: T_METACLASS T_COLON
+        ;
+
+metaclass_name
+	: T_IDENTIFIER
+	;
+
+metaclass_attributes
+	: T_COMMA metaclass_attribute
+	| metaclass_attributes T_COMMA metaclass_attribute 
+	;
+
+metaclass_attribute
+	: T_FILE T_STEM T_EQUAL T_IDENTIFIER
+        | T_MAJOR T_VERSION T_EQUAL T_CONSTANT
+        | T_MINOR T_VERSION T_EQUAL T_CONSTANT
+        | visibility
+        ;
+
+parent_section
+	: parentdef
+        | parentdef description
+		{
+			pcls->comment=$<stval>2;
+		}
+	;
+
+
+parentdef
+	: parent_header parent_name T_SEMICOLON
+        | parent_header parent_name parent_attributes T_SEMICOLON
+        ;
+
+parent_header
+	: T_PARENT T_CLASS T_COLON
+        | T_PARENT T_COLON 
+        ;
+
+parent_name
+	: T_IDENTIFIER
+		{
+			pcls->lineno=lineno;  // @todo line of class definition?
+			pcls->name=$<stval>1;
+		}
+	;
+
+parent_attributes
+	: T_COMMA parent_attribute
+	| parent_attributes T_COMMA parent_attribute
+	;
+
+parent_attribute
+	: T_FILE T_STEM T_EQUAL T_IDENTIFIER
+        | T_MAJOR T_VERSION T_EQUAL T_CONSTANT
+        | T_MINOR T_VERSION T_EQUAL T_CONSTANT
+        | visibility
+        ;
+
+passthru_section
+	: T_PASSTHRU
+        ;
+
+data_section
+	: data_header variables
+	;
+
+data_header
+	: T_DATA T_COLON
+	;
+
+variables
+	: declaration
+        | declaration variables
+        ;
+
+declaration
+	: declarationdef T_SEMICOLON
+	| declarationdef T_SEMICOLON description
+		{
+//			cls->comment=$<stval>2;
+		}
+	;
+
+declarationdef
+	: declaration_specifiers
+	| declaration_specifiers data_attributes
+	;
+
+data_attributes
+	: T_COMMA data_attribute
+	| data_attributes T_COMMA data_attribute
+	;
+
+data_attribute
+	: T_PRIVATE
+	| T_PUBLIC
+	| T_INTERNAL
+	| T_CLASS
+	;
+
+declaration_specifiers
+	: type_specifier declarator
+	| type_specifier declarator declaration_specifiers
+	;
+
+type_specifier
+	: T_IDENTIFIER 
+		{
+			$<stval>$=$<stval>1;
+		}
+	;
+
+declarator
+	: pointer direct_declarator
+	| direct_declarator
+	;
+
+direct_declarator
+	: T_IDENTIFIER {printf("$<stval>1");}
+	| T_LEFTPARENTHESIS declarator T_RIGHTPARENTHESIS
+	| direct_declarator T_LEFTSQUAREBRACKET T_CONSTANT T_RIGHTSQUAREBRACKET
+	| direct_declarator T_LEFTSQUAREBRACKET T_RIGHTSQUAREBRACKET
+	| direct_declarator T_LEFTPARENTHESIS declaration_specifiers T_RIGHTPARENTHESIS
+	| direct_declarator T_LEFTPARENTHESIS T_RIGHTPARENTHESIS
+	;
+
+pointer
+	: T_STAR
+		{
+			$<stval>$=$<stval>1;
+		}
+	| pointer T_STAR
+		{
+			char *r=somtsmallocSL(strlen($<stval>1)+strlen($<stval>2)+1, TRUE);
+			strcat(r, $<stval>1);
+			strcat(r, $<stval>2);
+			free($<stval>1);
+			$<stval>$=strdup(r);
+			somtfree(r);
+		}
+	;
+
+
+methods_section
+	: method_header method_list
+	| method_header description method_list
+		{
+			e.comment=$<stval>2;
+		}
+	;
+
+method_header
+	: T_METHODS T_COLON
+	;
+
+method_list
+	: method 
+		{
+			cls->u.c.methodcnt++;
+			somtaddEntrySL(somtstab, e.name, &e);
+			memset(&e, 0, sizeof(Entry));
+		}
+	| method_list method 
+		{
+			cls->u.c.methodcnt++;
+			somtaddEntrySL(somtstab, e.name, &e);
+			memset(&e, 0, sizeof(Entry));
+		}
+        ;
+
+method
+	: methoddef T_SEMICOLON 
+	| methoddef T_SEMICOLON description 
+	;
+
+methoddef
+	: method_specifier
+	| method_specifier method_attributes
+	| overridemethod_specifier
+	;
+
+method_specifier
+	: method_type method_name T_LEFTPARENTHESIS parameter_list T_RIGHTPARENTHESIS 
+		{
+			e.u.m.type=strdup($<stval>1);
+		}
+	;                                             
+
+method_name
+	: T_IDENTIFIER 
+		{
+			e.type=SOMTNewMethodE;
+			e.lineno=lineno;
+			e.name=$<stval>1;
+			e.sname=&somtclassName;
+			char * desc=somtsmallocSL(MAX_DESCRIPTOR_LENGTH, TRUE);
+			strcat(desc, "::");
+			strcat(desc, $<stval>1);
+			strcat(desc, "::");
+			strcat(desc, somtclassName);
+			e.atts=somtaddModifierSL(e.atts, "descriptor", desc);
+			somtfree(desc);
+		}
+	;
+
+method_type
+	: type_specifier
+		{
+			$<stval>$=$<stval>1;
+		}
+	| type_specifier pointer
+		{
+			char *r=somtsmallocSL(strlen($<stval>1)+strlen($<stval>2)+1, TRUE);
+			strcat(r, $<stval>1);
+			strcat(r, $<stval>2);
+			free($<stval>1);
+			$<stval>$=strdup(r);
+			somtfree(r);
+		}
+	;
+
+overridemethod_specifier
+	: overridemethod_header overridemethod_name
+	| overridemethod_header overridemethod_name overridemethod_attributes
+	;                                             
+
+overridemethod_header
+	: T_OVERRIDE
+	| T_OVERRIDE T_COLON
+	;
+
+overridemethod_name
+	: T_IDENTIFIER 
+		{
+			e.type=SOMTOverrideMethodE;
+			e.lineno=lineno;
+			e.name=$<stval>1;
+			e.sname=&somtclassName;
+			char * desc=somtsmallocSL(MAX_DESCRIPTOR_LENGTH, TRUE);
+			strcat(strcat(strcat(strcat(desc ,"::"), $<stval>1), "::"), somtclassName);
+			e.atts=somtaddModifierSL(e.atts, "descriptor", desc);
+			somtfree(desc);
+		}
+	;
+
+parameter_list
+	: parameter
+	| parameter_list T_COMMA parameter
+	;
+
+parameter
+	: T_ELLIPSIS
+	| type_specifier declarator
+	;
+
+method_attributes
+	: T_COMMA method_attribute
+	| method_attributes T_COMMA method_attribute
+	;
+
+method_attribute
+	: T_PRIVATE
+	| T_PUBLIC
+	| T_METHOD
+	| T_PROCEDURE
+	| T_CLASS
+	| T_OFFSET
+	| T_NAME T_LOOKUP
+	| T_LOCAL
+	| T_EXTERNAL
+	| T_USE T_EQUAL T_IDENTIFIER
+	;
+
+/* descriptor */
+/* noset */
+/* original */
+
+overridemethod_attributes
+	: T_COMMA overridemethod_attribute
+	| overridemethod_attributes T_COMMA overridemethod_attribute
+	;
+
+overridemethod_attribute
+	: T_PRIVATE
+	| T_PUBLIC
+	| T_CLASS
+	| T_LOCAL
+	| T_EXTERNAL
+	| T_USE T_EQUAL T_IDENTIFIER
+	;
+
+description
+	: T_COMMENT 
+		{
+			$<stval>$=$<stval>1;
+		}
+        ;
+
+%%
+
+FILE *yyin;
+
+// Experimental replacement of somttype
+char * mysomttype(SOMTTypes ttype)
+{
+  char * result=NULL;
+  switch ( ttype )
+  {
+    case SOMTAnyBE:
+      result="SOMTAnyBE";
+      break;
+    case     SOMTArgumentE:
+      result="SOMTArgumentE";
+      break;
+    case     SOMTAttE:
+      result="SOMTAttE";
+      break;
+    case     SOMTBadEntryE:
+      result="SOMTBadEntryE";
+      break;
+    case     SOMTBaseE:
+      result="SOMTBaseE";
+      break;
+    case     SOMTBooleanBE:
+      result="SOMTBooleanBE";
+      break;
+    case     SOMTCaseEntryE:
+      result="SOMTCaseEntryE";
+      break;
+    case     SOMTCaseListE:
+      result="SOMTCaseListE";
+      break;
+    case     SOMTCaseSTME:
+      result="SOMTCaseSTME";
+      break;
+    case     SOMTCharBE:
+      result="SOMTCharBE";
+      break;
+    case     SOMTClassE:
+      result="SOMTClassE";
+      break;
+    case     SOMTConstE:
+      result="SOMTConstE";
+      break;
+    case     SOMTCopyrightE:
+      result="SOMTCopyrightE";
+      break;
+    case     SOMTDataE:
+      result="SOMTDataE";
+      break;
+    case     SOMTDclListE:
+      result="SOMTDclListE";
+      break;
+    case     SOMTDefaultE:
+      result="SOMTDefaultE";
+      break;
+    case     SOMTDoubleBE:
+      result="SOMTDoubleBE";
+      break;
+    case     SOMTEBaseE:
+      result="SOMTEBaseE";
+      break;
+    case     SOMTEEnumE:
+      result="SOMTEEnumE";
+      break;
+    case     SOMTEnumBE:
+      result="SOMTEnumBE";
+      break;
+    case     SOMTEnumE:
+      result="SOMTEnumE";
+      break;
+    case     SOMTEnumPE:
+      result="SOMTEnumPE";
+      break;
+    case     SOMTFloatBE:
+      result="SOMTFloatBE";
+      break;
+    case     SOMTGroupE:
+      result="SOMTGroupE";
+      break;
+    case     SOMTLongBE:
+      result="SOMTLongBE";
+      break;
+    case     SOMTMetaE:
+      result="SOMTMetaE";
+      break;
+    case     SOMTModuleE:
+      result="SOMTModuleE";
+      break;
+    case     SOMTNegativeBE:
+      result="SOMTNegativeBE";
+      break;
+    case     SOMTNewMethodE:
+      result="SOMTNewMethodE";
+      break;
+    case     SOMTOctetBE:
+      result="SOMTOctetBE";
+      break;
+    case     SOMTOverriddenMethodE:
+      result="SOMTOverriddenMethodE";
+      break;
+    case     SOMTOverrideMethodE:
+      result="SOMTOverrideMethodE";
+      break;
+    case     SOMTPassthruE:
+      result="SOMTPassthruE";
+      break;
+    case     SOMTSequenceE:
+      result="SOMTSequenceE";
+      break;
+    case     SOMTSequenceTDE:
+      result="SOMTSequenceTDE";
+      break;
+    case     SOMTShortBE:
+      result="SOMTShortBE";
+      break;
+    case     SOMTStringBE:
+      result="SOMTStringBE";
+      break;
+    case     SOMTStringE:
+      result="SOMTStringE";
+      break;
+    case     SOMTStructE:
+      result="SOMTStructE";
+      break;
+    case     SOMTStructPE:
+      result="SOMTStructPE";
+      break;
+    case     SOMTStructSE:
+      result="SOMTStructSE";
+      break;
+    case     SOMTTyDclE:
+      result="SOMTTyDclE";
+      break;
+    case     SOMTTypeCodeBE:
+      result="SOMTTypeCodeBE";
+      break;
+    case     SOMTTypedefBE:
+      result="SOMTTypedefBE";
+      break;
+    case     SOMTTypedefE:
+      result="SOMTTypedefE";
+      break;
+    case     SOMTUnionE:
+      result="SOMTUnionE";
+      break;
+    case     SOMTUnionPE:
+      result="SOMTUnionPE";
+      break;
+    case     SOMTUnionSE:
+      result="SOMTUnionSE";
+      break;
+    case     SOMTUnsignedLongBE:
+      result="SOMTUnsignedLongBE";
+      break;
+    case     SOMTUnsignedShortBE:
+      result="SOMTUnsignedShortBE";
+      break;
+    case     SOMTVoidBE:
+      result="SOMTVoidBE";
+      break;
+    case     SOMTVoidPtrBE:
+      result="SOMTVoidPtrBE";
+      break;
+// This is special case SOMTTypes used on call of emitter start and emitter end
+/*    case     SOMTEmitterBeginE:
+      result="SOMTEmitterBeginE";
+      break;
+    case     SOMTEmitterEndE:
+      result="SOMTEmitterEndE";
+      break; */
+    default:
+      printf("Unknown entry type: %d.\n", ttype);
+  }
+  return result;
+}
+
+void dumpReleaseOrder(char * name, AttList *ap)
+{
+  AttList *cur=ap;
+
+  for(; cur; cur = cur->next) 
+  {
+    printf("\t%s %s\n", name, cur->name);
+//    dumpAttrs("static", cur->staticlist);
+//    dumpAttrs("protectted", cur->protectedlist);
+//    dumpAttrs("public", cur->publiclist);
+//    dumpAttrs("private", cur->privatelist);
+  }
+}
+
+void dumpMethodOrData(Entry * ep)
+{
+  printf("\teptype = %08p\n", ep->u.m.eptype);
+  printf("\tptrs = %08p\n", ep->u.m.ptrs);
+  printf("\tarray = %08p\n", ep->u.m.array);
+  printf("\tarrays = %s\n", ep->u.m.arrays);
+  printf("\tdefn = %s\n", ep->u.m.defn);
+  printf("\ttype = %s\n", ep->u.m.type);
+  printf("\tvarargs = %s\n", ep->u.m.varargs ? "true" : "false");
+  printf("\tprivate = %s\n", ep->u.m.isprivate ? "true" : "false");
+  printf("\tinout = %d\n", ep->u.m.inoutmode);
+  printf("\tselfref = %s\n", ep->u.m.isselfref ? "true" : "false");
+  printf("\toneway = %s\n", ep->u.m.isoneway ? "true" : "false");
+  printf("\targcnt = %d\n", ep->u.m.argcnt);
+  printf("\targs = %08p\n", ep->u.m.args);
+  printf("\tomethod = %08p\n", ep->u.m.omethod);
+  printf("\toparent = %08p\n", ep->u.m.oparent);
+  printf("\tgroup = %08p\n", ep->u.m.group);
+  printf("\tnext = %08p\n", ep->u.m.next);
+  printf("\tctxsa = %08p\n", ep->u.m.ctxsa);
+  printf("\traiseslist = %08p\n", ep->u.m.raiseslist);
+}
+
+void mysomtShowEntry(Entry * ep)
+{
+  if (ep)
+  {
+    printf("      somtShowEntry: Entry at %08p, name = %s, type = %d\n", ep, ep->name, ep->type);
+    printf("\tlineno = %d\n", ep->lineno);
+    switch ( ep->type )
+    {
+      case SOMTAnyBE:
+        printf("\t SOMTAnyBE\n");
+        break;
+      case     SOMTArgumentE:
+        printf("\t SOMTArgumentE\n");
+        dumpMethodOrData(ep);
+        break;
+      case     SOMTAttE:
+        printf("\t SOMTAttE\n");
+        break;
+      case     SOMTBadEntryE:
+        printf("\t SOMTBadEntryE\n");
+        break;
+      case     SOMTBaseE:
+        printf("\t SOMTBaseE\n");
+        printf("\tparentdef = %08p\n", ep->u.p.parentdef);
+        break;
+      case     SOMTBooleanBE:
+        printf("\t SOMTBooleanBE\n");
+        break;
+      case     SOMTCaseEntryE:
+        printf("\t SOMTCaseEntryE\n");
+        break;
+      case     SOMTCaseListE:
+        printf("\t SOMTCaseListE\n");
+        break;
+      case     SOMTCaseSTME:
+        printf("\t SOMTCaseSTME\n");
+        break;
+      case     SOMTCharBE:
+        printf("\t SOMTCharBE\n");
+        break;
+      case     SOMTClassE:
+        printf("\tClass Definition Entry:\n");
+        printf("\tfile = %s\n", ep->u.c.file);
+        printf("\tmeta = %08p\n", ep->u.c.meta);
+        printf("\tparent = %08p\n", ep->u.c.parent);
+        printf("\tparents = %08p\n", ep->u.c.parents);
+        printf("\trelease = %08p\n", ep->u.c.release);
+	dumpReleaseOrder("\t", ep->u.c.release);
+        printf("\tpassthru = %08p\n", ep->u.c.passthrus);
+        printf("\tdata = %08p\n", ep->u.c.data);
+        printf("\ttc = %08p\n", ep->tc);
+        printf("\tmethodcnt = %08d\n", ep->u.c.methodcnt);
+        printf("\tmethods = %08p\n", ep->u.c.methods);
+        printf("\tinherited = %08p\n", ep->u.c.inherited);
+        printf("\tpubdefs = %08p\n", ep->u.c.pubdefs);
+        printf("\tmod = %08p\n", ep->u.c.mod);
+        printf("\tcls = %08p\n", ep->u.c.cls);
+        printf("\tforward = %s\n", ep->u.c.isforward ? "true" : "false");
+        break;
+      case     SOMTConstE:
+        printf("\t SOMTConstE\n");
+        break;
+      case     SOMTCopyrightE:
+        printf("\t SOMTCopyrightE\n");
+        break;
+      case     SOMTDataE:
+        printf("\t SOMTDataE\n");
+        dumpMethodOrData(ep);
+        break;
+      case     SOMTDclListE:
+        printf("\t SOMTDclListE\n");
+        break;
+      case     SOMTDefaultE:
+        printf("\t SOMTDefaultE\n");
+        break;
+      case     SOMTDoubleBE:
+        printf("\t SOMTDoubleBE\n");
+        break;
+      case     SOMTEBaseE:
+        printf("\t SOMTEBaseE\n");
+        break;
+      case     SOMTEEnumE:
+        printf("\t SOMTEEnumE\n");
+        break;
+      case     SOMTEnumBE:
+        printf("\t SOMTEnumBE\n");
+        break;
+      case     SOMTEnumE:
+        printf("\t SOMTEnumE\n");
+        break;
+      case     SOMTEnumPE:
+        printf("\t SOMTEnumPE\n");
+        break;
+      case     SOMTFloatBE:
+        printf("\t SOMTFloatBE\n");
+        break;
+      case     SOMTGroupE:
+        printf("\t SOMTGroupE\n");
+        break;
+      case     SOMTLongBE:
+        printf("\t SOMTLongBE\n");
+        break;
+      case     SOMTMetaE:
+        printf("\t SOMTMetaE\n");
+        break;
+      case     SOMTModuleE:
+        printf("\t SOMTModuleE\n");
+        break;
+      case     SOMTNegativeBE:
+        printf("\t SOMTNegativeBE\n");
+        break;
+      case     SOMTNewMethodE:
+        printf("\t SOMTNewMethodE\n");
+        dumpMethodOrData(ep);
+        break;
+      case     SOMTOctetBE:
+        printf("\t SOMTOctetBE\n");
+        break;
+      case     SOMTOverriddenMethodE:
+        printf("\t SOMTOverriddenMethodE\n");
+        dumpMethodOrData(ep);
+        break;
+      case     SOMTOverrideMethodE:
+        printf("\t SOMTOverrideMethodE\n");
+        dumpMethodOrData(ep);
+        break;
+      case     SOMTPassthruE:
+        printf("\t SOMTPassthruE\n");
+        break;
+      case     SOMTSequenceE:
+        printf("\t SOMTSequenceE\n");
+        break;
+      case     SOMTSequenceTDE:
+        printf("\t SOMTSequenceTDE\n");
+        break;
+      case     SOMTShortBE:
+        printf("\t SOMTShortBE\n");
+        break;
+      case     SOMTStringBE:
+        printf("\t SOMTStringBE\n");
+        break;
+      case     SOMTStringE:
+        printf("\t SOMTStringE\n");
+        break;
+      case     SOMTStructE:
+        printf("\t SOMTStructE\n");
+        break;
+      case     SOMTStructPE:
+        printf("\t SOMTStructPE\n");
+        break;
+      case     SOMTStructSE:
+        printf("\t SOMTStructSE\n");
+        printf("\tdcllist = %08p\n", ep->u.struc.dcllist);
+        printf("\tcls = %08p\n", ep->u.struc.cls);
+        printf("\texception = %s\n", ep->u.struc.isexcept ? "true" : "false");
+        printf("\tmutref = %s\n", ep->u.struc.ismutref ? "true" : "false");
+        break;
+      case     SOMTTyDclE:
+        printf("\t SOMTTyDclE\n");
+        break;
+      case     SOMTTypeCodeBE:
+        printf("\t SOMTTypeCodeBE\n");
+        break;
+      case     SOMTTypedefBE:
+        printf("\t SOMTTypedefBE\n");
+        dumpMethodOrData(ep);
+        break;
+      case     SOMTTypedefE:
+        printf("\t SOMTTypedefE\n");
+        break;
+      case     SOMTUnionE:
+        printf("\t SOMTUnionE\n");
+        break;
+      case     SOMTUnionPE:
+        printf("\t SOMTUnionPE\n");
+        break;
+      case     SOMTUnionSE:
+        printf("\t SOMTUnionSE\n");
+        break;
+      case     SOMTUnsignedLongBE:
+        printf("\t SOMTUnsignedLongBE\n");
+        break;
+      case     SOMTUnsignedShortBE:
+        printf("\t SOMTUnsignedShortBE\n");
+        break;
+      case     SOMTVoidBE:
+        printf("\t SOMTVoidBE\n");
+        break;
+      case     SOMTVoidPtrBE:
+        printf("\t SOMTVoidPtrBE\n");
+        dumpMethodOrData(ep);
+        break;
+  // This is special case SOMTTypes used on call of emitter start and emitter end
+  /*    case     SOMTEmitterBeginE:
+        result="SOMTEmitterBeginE";
+        break;
+      case     SOMTEmitterEndE:
+        result="SOMTEmitterEndE";
+        break; */
+      default:
+        printf("Error: somtShowEntry, bad entry type of %d", ep->type);
+//        SOM_Error(SOM_Fatal, __FILE__, __LINE__);
+//        SOMError(9, __FILE__, __LINE__);
+    }
+  }
+  else 
+  {
+    printf("somtShowEntry: NULL entry\n");
+  }
+}
+
+dumpAttrs(AttList *ap)
+{
+  struct AttList *cur = ap;
+
+  for(cur = ap; cur; cur = cur->next) 
+  {
+    printf("\tModifier %s=%s\n", cur->name, cur->value);
+  }
+}
+
+
+void mydumpEntry(Entry * ep)
+{
+  printf("Entry at address %p\n", ep);
+  printf("--------------------------\n");
+  printf("Entry type: %s (%d)\n", mysomttype(ep->type), ep->type);
+//  printf("Entry type: %s (%d)\n", somtEntryTypeName(ep->type), ep->type);
+  if (ep->sname) printf("Scoped name: %s\n", *ep->sname);
+  if (ep->comment) printf("Comment associated with entry: %s\n", ep->comment);
+  printf("Modifiers: %p\n", ep->atts);
+  if (ep->atts) dumpAttrs(ep->atts);
+  printf("TypeCode: %p\n", ep->tc);
+  printf("Points to the object: %p\n", ep->objref);
+  printf("Reference to real type: %s\n", ep->isref ? "true" : "false");
+  printf("Entry union: %p\n", &ep->u);
+#ifdef __PRIVATE__
+//    RHBelement *data;
+//    char *filestem;
+#endif    
+  mysomtShowEntry(ep);
+//  somtShowEntry(ep);
+};
+
+void dumpSep(Sep * sep)
+{
+    printf("Linked list item at address %p\n", sep);
+    printf("---------------------------------------\n");
+    printf("Position number: %d\n", sep->posn);
+    printf("Address of Entry: %p\n", sep->ep);
+    printf("Next linked list item address: %p\n", sep->next);
+    if (sep->ep) 
+    {
+      mydumpEntry((Entry *)sep->ep);
+      dumpSep(sep->next);
+    }
+}
+
+void dumpStab(Stab * stab)
+{
+  printf("Basic Symbol Table/Hash table (STab) structure\n");
+  printf("----------------------------------------------\n");
+  printf("Size of buscet: %d\n", stab->size);
+  printf("Size of entry structure: %d\n", stab->entrysize);
+  printf("Number of elements: %d\n", stab->nelms);
+  printf("Address of base slot: %p\n", stab->base);
+  printf("Max address of slot: %p\n", stab->limit);
+  printf("Start address of slot buffer: %p\n", stab->buf);
+  printf("Address of MemBuf: %p\n", stab->membuf);
+  printf("Ignore case flag: %s\n", stab->ignorecase ? "true" : "false");
+  for(unsigned int i=0; i<stab->size;i++)
+  {
+    printf("Linked list at slot %d at offset %08x at address %p\n", i, sizeof(Sep)*i, stab->buf+i);
+    printf("----------------------\n");
+    dumpSep(stab->buf+i);
+  }
+};
+
+
+void usage(void)
+{
+  printf("\nSC [-options] file[.CSC]\n");
+  printf("\n-C n\n\tset the size of the comment buffer (default: 16384)\n");
+  printf("\n-s n\n\tset the total amount of string space for names and passthru lines (default: 32768)\n");
+  printf("\n-V\n\tdisplay version information\n");
+  printf("\n-a name[=value]\n\tadd a global attribute. The currently supported attributes are defined below (at the end of this section)\n");
+  printf("\n-d directory\n\tspecify a directory where all files emitted during the execution of this command should be placed. If the -d option is not used, all emitted output files are placed in the same directory as the input .csc file\n");
+  printf("\n-h or ?\n\tprovide usage information for reference\n");
+  printf("\n-i filename\n\tspecify the name of the OIDL class definition file. Use this option to override the built-in assumption that the input file will have a .csc extension. Any filename you supply with the -i option is used exactly as you provide it\n");
+  printf("\n-r\n\tcheck that all release-order entries actually exist (default: FALSE)\n");
+  printf("\n-s string\n\tsubstitute string in place of the contents of the SMEMIT environment variable for the duration of the current SC command. If you supply a list of values, you\n");
+  printf("must enclose the list with double quotation marks (\" \"). You can use the -s option as a convenient way to override the SMEMIT environment variable. For example:\n\n");
+  printf("SC -s \"h;sc\" EXAMPLE\n\n");
+  printf("is equivalent to the following sequence of commands:\n\n");
+  printf("SET OLDSMEMIT = %%SMEMIT%%\n");
+  printf("SET SMEMIT = h;sc\n");
+  printf("SC EXAMPLE\n");
+  printf("SET SMEMIT = %%OLDSMEMIT%%\n");
+  printf("\n-w\n\tsuppress warning messages (default: FALSE)\n\n");
+  printf("The only global attributes currently supported by SC.EXE are:\n");
+  printf("\ncomment = comment string\n\twhere comment string can be one of the following: \"/*\", \"--\", or \"//\". This\n");
+  printf("indicates that comments marked in the indicated way are to be completely\n");
+  printf("ignored by SC.EXE and not retained for subsequent processing by one of the\n");
+  printf("emitters.\n");
+  printf("Note: Comments indicated by lines whose first non-white-space character is\n");
+  printf("a # are always ignored by SC.EXE. Also note that comments of any\n");
+  printf("form in passthru lines are passed through.\n");
+  printf("\ncstyle = comment style\n\tcontrols the form of emitted comments. Comment style must be one of s, c, or\n");
+  printf("+ to cause emitted comments to be in \"--\", \"/* */\", or \"//\" form , respectively\n");
+  printf("The default form is s\n");
+  printf("\nibmc\n\tcauses EMITC, EMITH, EMITIH, EMITPH, and EMITDEF to generate code with\n");
+  printf("pragmas specifically intended for the IBM C Set/2 Compiler. This attribute is\n");
+  printf("specified by default\n");
+  printf("\ncl386\n\tcauses EMITC, EMITH, EMITIH, EMITPH, and EMITDEF not to generate code\n");
+  printf("with pragmas specifically intended for the IBM C Set/2 Compiler\n");
+}
+
+void parse_file(char * file)
+{
+  // parser input stream
+  yyin=fopen(file,"r");
+
+  strcpy(somtfilePath, file);
+
+  // Initialize symbol table
+  somtstab=(Stab *)somtsmallocSL(sizeof(Stab), 0);
+  somtcreateStabSL(somtstab, HASH_SIZE, sizeof(Entry));
+
+  yyparse();
+
+  dumpStab(somtstab);
+}
+
+void emit_file(char * file)
+{
+   EmitFn proc;
+   FILE * fp;
+   HMODULE hmod;
+   Entry * root;
+   Stab * stab;
+
+   proc=somtloadSL("emitpsc.dll", "emitSL", &hmod);
+
+   fp=proc(file, root, stab);
+
+   if (fp) somtfcloseSL(fp);
+}
+
+void main(int argc, char *argv[])
+{
+   yydebug =1 ;
+
+//   parse_args(argc, argv);
+
+   usage();
+
+   parse_file(argv[1]);
+
+//   dump();
+
+//   emit_file(argv[1]);
+}
diff -urN somfree\somopc\src\gramma.yy.output newsomfree3\somopc\src\gramma.yy.output
--- somfree\somopc\src\gramma.yy.output	Thu Jan 01 07:00:00 1970
+++ newsomfree3\somopc\src\gramma.yy.output	Sat Mar 16 14:09:28 2024
@@ -0,0 +1,2606 @@
+
+
+Terminals which are not used:
+
+   T_DASHES
+   T_PERIOD
+   T_BEFORE
+   T_AFTER
+   T_ENDPASSTHRU
+   T_GROUP
+
+
+
+Grammar
+rule 1    @1 ->		/* empty */
+rule 2    oidl -> @1 class_list
+rule 3    class_list -> class_definition
+rule 4    class_list -> class_list class_definition
+rule 5    @2 ->		/* empty */
+rule 6    class_definition -> @2 class_section section_list
+rule 7    section_list -> section
+rule 8    section_list -> section_list section
+rule 9    section -> releaseorder_section
+rule 10   section -> metaclass_section
+rule 11   @3 ->		/* empty */
+rule 12   section -> @3 parent_section
+rule 13   section -> passthru_section
+rule 14   section -> data_section
+rule 15   section -> methods_section
+rule 16   class_section -> classdef
+rule 17   class_section -> classdef description
+rule 18   classdef -> class_header class_name T_SEMICOLON
+rule 19   classdef -> class_header class_name class_attributes T_SEMICOLON
+rule 20   class_header -> T_CLASS T_COLON
+rule 21   class_name -> T_IDENTIFIER
+rule 22   class_attributes -> T_COMMA class_attribute
+rule 23   class_attributes -> class_attributes T_COMMA class_attribute
+rule 24   class_attribute -> T_FILE T_STEM T_EQUAL T_IDENTIFIER
+rule 25   class_attribute -> T_EXTERNAL T_STEM T_EQUAL T_IDENTIFIER
+rule 26   class_attribute -> T_FUNCTION T_PREFIX T_EQUAL T_IDENTIFIER
+rule 27   class_attribute -> T_EXTERNAL T_PREFIX T_EQUAL T_IDENTIFIER
+rule 28   class_attribute -> T_CLASSPREFIX T_EQUAL T_IDENTIFIER
+rule 29   class_attribute -> T_MAJOR T_VERSION T_EQUAL T_CONSTANT
+rule 30   class_attribute -> T_MINOR T_VERSION T_EQUAL T_CONSTANT
+rule 31   class_attribute -> T_CLASSINIT T_EQUAL T_IDENTIFIER
+rule 32   class_attribute -> visibility
+rule 33   visibility -> T_GLOBAL
+rule 34   visibility -> T_LOCAL
+rule 35   releaseorder_section -> releaseorder_header release_list T_SEMICOLON
+rule 36   releaseorder_header -> T_RELEASE T_ORDER T_COLON
+rule 37   release_list -> release
+rule 38   release_list -> release_list T_COMMA release
+rule 39   release -> T_IDENTIFIER
+rule 40   metaclass_section -> metaclassdef
+rule 41   metaclass_section -> metaclassdef description
+rule 42   metaclassdef -> metaclass_header metaclass_name T_SEMICOLON
+rule 43   metaclassdef -> metaclass_header metaclass_name metaclass_attributes T_SEMICOLON
+rule 44   metaclass_header -> T_METACLASS T_COLON
+rule 45   metaclass_name -> T_IDENTIFIER
+rule 46   metaclass_attributes -> T_COMMA metaclass_attribute
+rule 47   metaclass_attributes -> metaclass_attributes T_COMMA metaclass_attribute
+rule 48   metaclass_attribute -> T_FILE T_STEM T_EQUAL T_IDENTIFIER
+rule 49   metaclass_attribute -> T_MAJOR T_VERSION T_EQUAL T_CONSTANT
+rule 50   metaclass_attribute -> T_MINOR T_VERSION T_EQUAL T_CONSTANT
+rule 51   metaclass_attribute -> visibility
+rule 52   parent_section -> parentdef
+rule 53   parent_section -> parentdef description
+rule 54   parentdef -> parent_header parent_name T_SEMICOLON
+rule 55   parentdef -> parent_header parent_name parent_attributes T_SEMICOLON
+rule 56   parent_header -> T_PARENT T_CLASS T_COLON
+rule 57   parent_header -> T_PARENT T_COLON
+rule 58   parent_name -> T_IDENTIFIER
+rule 59   parent_attributes -> T_COMMA parent_attribute
+rule 60   parent_attributes -> parent_attributes T_COMMA parent_attribute
+rule 61   parent_attribute -> T_FILE T_STEM T_EQUAL T_IDENTIFIER
+rule 62   parent_attribute -> T_MAJOR T_VERSION T_EQUAL T_CONSTANT
+rule 63   parent_attribute -> T_MINOR T_VERSION T_EQUAL T_CONSTANT
+rule 64   parent_attribute -> visibility
+rule 65   passthru_section -> T_PASSTHRU
+rule 66   data_section -> data_header variables
+rule 67   data_header -> T_DATA T_COLON
+rule 68   variables -> declaration
+rule 69   variables -> declaration variables
+rule 70   declaration -> declarationdef T_SEMICOLON
+rule 71   declaration -> declarationdef T_SEMICOLON description
+rule 72   declarationdef -> declaration_specifiers
+rule 73   declarationdef -> declaration_specifiers data_attributes
+rule 74   data_attributes -> T_COMMA data_attribute
+rule 75   data_attributes -> data_attributes T_COMMA data_attribute
+rule 76   data_attribute -> T_PRIVATE
+rule 77   data_attribute -> T_PUBLIC
+rule 78   data_attribute -> T_INTERNAL
+rule 79   data_attribute -> T_CLASS
+rule 80   declaration_specifiers -> type_specifier declarator
+rule 81   declaration_specifiers -> type_specifier declarator declaration_specifiers
+rule 82   type_specifier -> T_IDENTIFIER
+rule 83   declarator -> pointer direct_declarator
+rule 84   declarator -> direct_declarator
+rule 85   direct_declarator -> T_IDENTIFIER
+rule 86   direct_declarator -> T_LEFTPARENTHESIS declarator T_RIGHTPARENTHESIS
+rule 87   direct_declarator -> direct_declarator T_LEFTSQUAREBRACKET T_CONSTANT T_RIGHTSQUAREBRACKET
+rule 88   direct_declarator -> direct_declarator T_LEFTSQUAREBRACKET T_RIGHTSQUAREBRACKET
+rule 89   direct_declarator -> direct_declarator T_LEFTPARENTHESIS declaration_specifiers T_RIGHTPARENTHESIS
+rule 90   direct_declarator -> direct_declarator T_LEFTPARENTHESIS T_RIGHTPARENTHESIS
+rule 91   pointer -> T_STAR
+rule 92   pointer -> pointer T_STAR
+rule 93   methods_section -> method_header method_list
+rule 94   methods_section -> method_header description method_list
+rule 95   method_header -> T_METHODS T_COLON
+rule 96   method_list -> method
+rule 97   method_list -> method_list method
+rule 98   method -> methoddef T_SEMICOLON
+rule 99   method -> methoddef T_SEMICOLON description
+rule 100  methoddef -> method_specifier
+rule 101  methoddef -> method_specifier method_attributes
+rule 102  methoddef -> overridemethod_specifier
+rule 103  method_specifier -> method_type method_name T_LEFTPARENTHESIS parameter_list T_RIGHTPARENTHESIS
+rule 104  method_name -> T_IDENTIFIER
+rule 105  method_type -> type_specifier
+rule 106  method_type -> type_specifier pointer
+rule 107  overridemethod_specifier -> overridemethod_header overridemethod_name
+rule 108  overridemethod_specifier -> overridemethod_header overridemethod_name overridemethod_attributes
+rule 109  overridemethod_header -> T_OVERRIDE
+rule 110  overridemethod_header -> T_OVERRIDE T_COLON
+rule 111  overridemethod_name -> T_IDENTIFIER
+rule 112  parameter_list -> parameter
+rule 113  parameter_list -> parameter_list T_COMMA parameter
+rule 114  parameter -> T_ELLIPSIS
+rule 115  parameter -> type_specifier declarator
+rule 116  method_attributes -> T_COMMA method_attribute
+rule 117  method_attributes -> method_attributes T_COMMA method_attribute
+rule 118  method_attribute -> T_PRIVATE
+rule 119  method_attribute -> T_PUBLIC
+rule 120  method_attribute -> T_METHOD
+rule 121  method_attribute -> T_PROCEDURE
+rule 122  method_attribute -> T_CLASS
+rule 123  method_attribute -> T_OFFSET
+rule 124  method_attribute -> T_NAME T_LOOKUP
+rule 125  method_attribute -> T_LOCAL
+rule 126  method_attribute -> T_EXTERNAL
+rule 127  method_attribute -> T_USE T_EQUAL T_IDENTIFIER
+rule 128  overridemethod_attributes -> T_COMMA overridemethod_attribute
+rule 129  overridemethod_attributes -> overridemethod_attributes T_COMMA overridemethod_attribute
+rule 130  overridemethod_attribute -> T_PRIVATE
+rule 131  overridemethod_attribute -> T_PUBLIC
+rule 132  overridemethod_attribute -> T_CLASS
+rule 133  overridemethod_attribute -> T_LOCAL
+rule 134  overridemethod_attribute -> T_EXTERNAL
+rule 135  overridemethod_attribute -> T_USE T_EQUAL T_IDENTIFIER
+rule 136  description -> T_COMMENT
+
+Terminals, with rules where they appear
+
+$ (-1)
+error (256)
+T_CONSTANT (257) 29 30 49 50 62 63 87
+T_COLON (258) 20 36 44 56 57 67 95 110
+T_SEMICOLON (259) 18 19 35 42 43 54 55 70 71 98 99
+T_COMMA (260) 22 23 38 46 47 59 60 74 75 113 116 117 128 129
+T_STAR (261) 91 92
+T_COMMENT (262) 136
+T_IDENTIFIER (263) 21 24 25 26 27 28 31 39 45 48 58 61 82 85 104 111
+    127 135
+T_EQUAL (264) 24 25 26 27 28 29 30 31 48 49 50 61 62 63 127 135
+T_DASHES (265)
+T_PERIOD (266)
+T_ELLIPSIS (267) 114
+T_LEFTPARENTHESIS (268) 86 89 90 103
+T_RIGHTPARENTHESIS (269) 86 89 90 103
+T_LEFTSQUAREBRACKET (270) 87 88
+T_RIGHTSQUAREBRACKET (271) 87 88
+T_VERSION (272) 29 30 49 50 62 63
+T_GLOBAL (273) 33
+T_LOCAL (274) 34 125 133
+T_CLASSINIT (275) 31
+T_RELEASE (276) 36
+T_ORDER (277) 36
+T_METACLASS (278) 44
+T_PARENT (279) 56 57
+T_CLASS (280) 20 56 79 122 132
+T_FILE (281) 24 48 61
+T_STEM (282) 24 25 48 61
+T_FUNCTION (283) 26
+T_PREFIX (284) 26 27
+T_CLASSPREFIX (285) 28
+T_MAJOR (286) 29 49 62
+T_MINOR (287) 30 50 63
+T_PASSTHRU (288) 65
+T_BEFORE (289)
+T_AFTER (290)
+T_ENDPASSTHRU (291)
+T_DATA (292) 67
+T_PRIVATE (293) 76 118 130
+T_PUBLIC (294) 77 119 131
+T_INTERNAL (295) 78
+T_METHODS (296) 95
+T_GROUP (297)
+T_METHOD (298) 120
+T_PROCEDURE (299) 121
+T_OFFSET (300) 123
+T_NAME (301) 124
+T_LOOKUP (302) 124
+T_EXTERNAL (303) 25 27 126 134
+T_USE (304) 127 135
+T_OVERRIDE (305) 109 110
+
+Nonterminals, with rules where they appear
+
+oidl (52)
+    on left: 2
+@1 (53)
+    on left: 1, on right: 2
+class_list (54)
+    on left: 3 4, on right: 2 4
+class_definition (55)
+    on left: 6, on right: 3 4
+@2 (56)
+    on left: 5, on right: 6
+section_list (57)
+    on left: 7 8, on right: 6 8
+section (58)
+    on left: 9 10 12 13 14 15, on right: 7 8
+@3 (59)
+    on left: 11, on right: 12
+class_section (60)
+    on left: 16 17, on right: 6
+classdef (61)
+    on left: 18 19, on right: 16 17
+class_header (62)
+    on left: 20, on right: 18 19
+class_name (63)
+    on left: 21, on right: 18 19
+class_attributes (64)
+    on left: 22 23, on right: 19 23
+class_attribute (65)
+    on left: 24 25 26 27 28 29 30 31 32, on right: 22 23
+visibility (66)
+    on left: 33 34, on right: 32 51 64
+releaseorder_section (67)
+    on left: 35, on right: 9
+releaseorder_header (68)
+    on left: 36, on right: 35
+release_list (69)
+    on left: 37 38, on right: 35 38
+release (70)
+    on left: 39, on right: 37 38
+metaclass_section (71)
+    on left: 40 41, on right: 10
+metaclassdef (72)
+    on left: 42 43, on right: 40 41
+metaclass_header (73)
+    on left: 44, on right: 42 43
+metaclass_name (74)
+    on left: 45, on right: 42 43
+metaclass_attributes (75)
+    on left: 46 47, on right: 43 47
+metaclass_attribute (76)
+    on left: 48 49 50 51, on right: 46 47
+parent_section (77)
+    on left: 52 53, on right: 12
+parentdef (78)
+    on left: 54 55, on right: 52 53
+parent_header (79)
+    on left: 56 57, on right: 54 55
+parent_name (80)
+    on left: 58, on right: 54 55
+parent_attributes (81)
+    on left: 59 60, on right: 55 60
+parent_attribute (82)
+    on left: 61 62 63 64, on right: 59 60
+passthru_section (83)
+    on left: 65, on right: 13
+data_section (84)
+    on left: 66, on right: 14
+data_header (85)
+    on left: 67, on right: 66
+variables (86)
+    on left: 68 69, on right: 66 69
+declaration (87)
+    on left: 70 71, on right: 68 69
+declarationdef (88)
+    on left: 72 73, on right: 70 71
+data_attributes (89)
+    on left: 74 75, on right: 73 75
+data_attribute (90)
+    on left: 76 77 78 79, on right: 74 75
+declaration_specifiers (91)
+    on left: 80 81, on right: 72 73 81 89
+type_specifier (92)
+    on left: 82, on right: 80 81 105 106 115
+declarator (93)
+    on left: 83 84, on right: 80 81 86 115
+direct_declarator (94)
+    on left: 85 86 87 88 89 90, on right: 83 84 87 88 89 90
+pointer (95)
+    on left: 91 92, on right: 83 92 106
+methods_section (96)
+    on left: 93 94, on right: 15
+method_header (97)
+    on left: 95, on right: 93 94
+method_list (98)
+    on left: 96 97, on right: 93 94 97
+method (99)
+    on left: 98 99, on right: 96 97
+methoddef (100)
+    on left: 100 101 102, on right: 98 99
+method_specifier (101)
+    on left: 103, on right: 100 101
+method_name (102)
+    on left: 104, on right: 103
+method_type (103)
+    on left: 105 106, on right: 103
+overridemethod_specifier (104)
+    on left: 107 108, on right: 102
+overridemethod_header (105)
+    on left: 109 110, on right: 107 108
+overridemethod_name (106)
+    on left: 111, on right: 107 108
+parameter_list (107)
+    on left: 112 113, on right: 103 113
+parameter (108)
+    on left: 114 115, on right: 112 113
+method_attributes (109)
+    on left: 116 117, on right: 101 117
+method_attribute (110)
+    on left: 118 119 120 121 122 123 124 125 126 127,
+    on right: 116 117
+overridemethod_attributes (111)
+    on left: 128 129, on right: 108 129
+overridemethod_attribute (112)
+    on left: 130 131 132 133 134 135, on right: 128 129
+description (113)
+    on left: 136, on right: 17 41 53 71 94 99
+
+
+state 0
+
+    $default	reduce using rule 1 (@1)
+
+    oidl	go to state 234
+    @1  	go to state 1
+
+
+
+state 1
+
+    oidl  ->  @1 . class_list   (rule 2)
+
+    $default	reduce using rule 5 (@2)
+
+    class_list	go to state 2
+    class_definition	go to state 3
+    @2  	go to state 4
+
+
+
+state 2
+
+    oidl  ->  @1 class_list .   (rule 2)
+    class_list  ->  class_list . class_definition   (rule 4)
+
+    T_CLASS	reduce using rule 5 (@2)
+    $default	reduce using rule 2 (oidl)
+
+    class_definition	go to state 5
+    @2  	go to state 4
+
+
+
+state 3
+
+    class_list  ->  class_definition .   (rule 3)
+
+    $default	reduce using rule 3 (class_list)
+
+
+
+state 4
+
+    class_definition  ->  @2 . class_section section_list   (rule 6)
+
+    T_CLASS	shift, and go to state 6
+
+    class_section	go to state 7
+    classdef	go to state 8
+    class_header	go to state 9
+
+
+
+state 5
+
+    class_list  ->  class_list class_definition .   (rule 4)
+
+    $default	reduce using rule 4 (class_list)
+
+
+
+state 6
+
+    class_header  ->  T_CLASS . T_COLON   (rule 20)
+
+    T_COLON	shift, and go to state 10
+
+
+
+state 7
+
+    class_definition  ->  @2 class_section . section_list   (rule 6)
+
+    T_RELEASE	shift, and go to state 11
+    T_METACLASS	shift, and go to state 12
+    T_PASSTHRU	shift, and go to state 13
+    T_DATA	shift, and go to state 14
+    T_METHODS	shift, and go to state 15
+
+    $default	reduce using rule 11 (@3)
+
+    section_list	go to state 16
+    section	go to state 17
+    @3  	go to state 18
+    releaseorder_section	go to state 19
+    releaseorder_header	go to state 20
+    metaclass_section	go to state 21
+    metaclassdef	go to state 22
+    metaclass_header	go to state 23
+    passthru_section	go to state 24
+    data_section	go to state 25
+    data_header	go to state 26
+    methods_section	go to state 27
+    method_header	go to state 28
+
+
+
+state 8
+
+    class_section  ->  classdef .   (rule 16)
+    class_section  ->  classdef . description   (rule 17)
+
+    T_COMMENT	shift, and go to state 29
+
+    $default	reduce using rule 16 (class_section)
+
+    description	go to state 30
+
+
+
+state 9
+
+    classdef  ->  class_header . class_name T_SEMICOLON   (rule 18)
+    classdef  ->  class_header . class_name class_attributes T_SEMICOLON   (rule 19)
+
+    T_IDENTIFIER	shift, and go to state 31
+
+    class_name	go to state 32
+
+
+
+state 10
+
+    class_header  ->  T_CLASS T_COLON .   (rule 20)
+
+    $default	reduce using rule 20 (class_header)
+
+
+
+state 11
+
+    releaseorder_header  ->  T_RELEASE . T_ORDER T_COLON   (rule 36)
+
+    T_ORDER	shift, and go to state 33
+
+
+
+state 12
+
+    metaclass_header  ->  T_METACLASS . T_COLON   (rule 44)
+
+    T_COLON	shift, and go to state 34
+
+
+
+state 13
+
+    passthru_section  ->  T_PASSTHRU .   (rule 65)
+
+    $default	reduce using rule 65 (passthru_section)
+
+
+
+state 14
+
+    data_header  ->  T_DATA . T_COLON   (rule 67)
+
+    T_COLON	shift, and go to state 35
+
+
+
+state 15
+
+    method_header  ->  T_METHODS . T_COLON   (rule 95)
+
+    T_COLON	shift, and go to state 36
+
+
+
+state 16
+
+    class_definition  ->  @2 class_section section_list .   (rule 6)
+    section_list  ->  section_list . section   (rule 8)
+
+    T_RELEASE	shift, and go to state 11
+    T_METACLASS	shift, and go to state 12
+    T_PASSTHRU	shift, and go to state 13
+    T_DATA	shift, and go to state 14
+    T_METHODS	shift, and go to state 15
+
+    T_PARENT	reduce using rule 11 (@3)
+    $default	reduce using rule 6 (class_definition)
+
+    section	go to state 37
+    @3  	go to state 18
+    releaseorder_section	go to state 19
+    releaseorder_header	go to state 20
+    metaclass_section	go to state 21
+    metaclassdef	go to state 22
+    metaclass_header	go to state 23
+    passthru_section	go to state 24
+    data_section	go to state 25
+    data_header	go to state 26
+    methods_section	go to state 27
+    method_header	go to state 28
+
+
+
+state 17
+
+    section_list  ->  section .   (rule 7)
+
+    $default	reduce using rule 7 (section_list)
+
+
+
+state 18
+
+    section  ->  @3 . parent_section   (rule 12)
+
+    T_PARENT	shift, and go to state 38
+
+    parent_section	go to state 39
+    parentdef	go to state 40
+    parent_header	go to state 41
+
+
+
+state 19
+
+    section  ->  releaseorder_section .   (rule 9)
+
+    $default	reduce using rule 9 (section)
+
+
+
+state 20
+
+    releaseorder_section  ->  releaseorder_header . release_list T_SEMICOLON   (rule 35)
+
+    T_IDENTIFIER	shift, and go to state 42
+
+    release_list	go to state 43
+    release	go to state 44
+
+
+
+state 21
+
+    section  ->  metaclass_section .   (rule 10)
+
+    $default	reduce using rule 10 (section)
+
+
+
+state 22
+
+    metaclass_section  ->  metaclassdef .   (rule 40)
+    metaclass_section  ->  metaclassdef . description   (rule 41)
+
+    T_COMMENT	shift, and go to state 29
+
+    $default	reduce using rule 40 (metaclass_section)
+
+    description	go to state 45
+
+
+
+state 23
+
+    metaclassdef  ->  metaclass_header . metaclass_name T_SEMICOLON   (rule 42)
+    metaclassdef  ->  metaclass_header . metaclass_name metaclass_attributes T_SEMICOLON   (rule 43)
+
+    T_IDENTIFIER	shift, and go to state 46
+
+    metaclass_name	go to state 47
+
+
+
+state 24
+
+    section  ->  passthru_section .   (rule 13)
+
+    $default	reduce using rule 13 (section)
+
+
+
+state 25
+
+    section  ->  data_section .   (rule 14)
+
+    $default	reduce using rule 14 (section)
+
+
+
+state 26
+
+    data_section  ->  data_header . variables   (rule 66)
+
+    T_IDENTIFIER	shift, and go to state 48
+
+    variables	go to state 49
+    declaration	go to state 50
+    declarationdef	go to state 51
+    declaration_specifiers	go to state 52
+    type_specifier	go to state 53
+
+
+
+state 27
+
+    section  ->  methods_section .   (rule 15)
+
+    $default	reduce using rule 15 (section)
+
+
+
+state 28
+
+    methods_section  ->  method_header . method_list   (rule 93)
+    methods_section  ->  method_header . description method_list   (rule 94)
+
+    T_COMMENT	shift, and go to state 29
+    T_IDENTIFIER	shift, and go to state 48
+    T_OVERRIDE	shift, and go to state 54
+
+    type_specifier	go to state 55
+    method_list	go to state 56
+    method	go to state 57
+    methoddef	go to state 58
+    method_specifier	go to state 59
+    method_type	go to state 60
+    overridemethod_specifier	go to state 61
+    overridemethod_header	go to state 62
+    description	go to state 63
+
+
+
+state 29
+
+    description  ->  T_COMMENT .   (rule 136)
+
+    $default	reduce using rule 136 (description)
+
+
+
+state 30
+
+    class_section  ->  classdef description .   (rule 17)
+
+    $default	reduce using rule 17 (class_section)
+
+
+
+state 31
+
+    class_name  ->  T_IDENTIFIER .   (rule 21)
+
+    $default	reduce using rule 21 (class_name)
+
+
+
+state 32
+
+    classdef  ->  class_header class_name . T_SEMICOLON   (rule 18)
+    classdef  ->  class_header class_name . class_attributes T_SEMICOLON   (rule 19)
+
+    T_SEMICOLON	shift, and go to state 64
+    T_COMMA	shift, and go to state 65
+
+    class_attributes	go to state 66
+
+
+
+state 33
+
+    releaseorder_header  ->  T_RELEASE T_ORDER . T_COLON   (rule 36)
+
+    T_COLON	shift, and go to state 67
+
+
+
+state 34
+
+    metaclass_header  ->  T_METACLASS T_COLON .   (rule 44)
+
+    $default	reduce using rule 44 (metaclass_header)
+
+
+
+state 35
+
+    data_header  ->  T_DATA T_COLON .   (rule 67)
+
+    $default	reduce using rule 67 (data_header)
+
+
+
+state 36
+
+    method_header  ->  T_METHODS T_COLON .   (rule 95)
+
+    $default	reduce using rule 95 (method_header)
+
+
+
+state 37
+
+    section_list  ->  section_list section .   (rule 8)
+
+    $default	reduce using rule 8 (section_list)
+
+
+
+state 38
+
+    parent_header  ->  T_PARENT . T_CLASS T_COLON   (rule 56)
+    parent_header  ->  T_PARENT . T_COLON   (rule 57)
+
+    T_COLON	shift, and go to state 68
+    T_CLASS	shift, and go to state 69
+
+
+
+state 39
+
+    section  ->  @3 parent_section .   (rule 12)
+
+    $default	reduce using rule 12 (section)
+
+
+
+state 40
+
+    parent_section  ->  parentdef .   (rule 52)
+    parent_section  ->  parentdef . description   (rule 53)
+
+    T_COMMENT	shift, and go to state 29
+
+    $default	reduce using rule 52 (parent_section)
+
+    description	go to state 70
+
+
+
+state 41
+
+    parentdef  ->  parent_header . parent_name T_SEMICOLON   (rule 54)
+    parentdef  ->  parent_header . parent_name parent_attributes T_SEMICOLON   (rule 55)
+
+    T_IDENTIFIER	shift, and go to state 71
+
+    parent_name	go to state 72
+
+
+
+state 42
+
+    release  ->  T_IDENTIFIER .   (rule 39)
+
+    $default	reduce using rule 39 (release)
+
+
+
+state 43
+
+    releaseorder_section  ->  releaseorder_header release_list . T_SEMICOLON   (rule 35)
+    release_list  ->  release_list . T_COMMA release   (rule 38)
+
+    T_SEMICOLON	shift, and go to state 73
+    T_COMMA	shift, and go to state 74
+
+
+
+state 44
+
+    release_list  ->  release .   (rule 37)
+
+    $default	reduce using rule 37 (release_list)
+
+
+
+state 45
+
+    metaclass_section  ->  metaclassdef description .   (rule 41)
+
+    $default	reduce using rule 41 (metaclass_section)
+
+
+
+state 46
+
+    metaclass_name  ->  T_IDENTIFIER .   (rule 45)
+
+    $default	reduce using rule 45 (metaclass_name)
+
+
+
+state 47
+
+    metaclassdef  ->  metaclass_header metaclass_name . T_SEMICOLON   (rule 42)
+    metaclassdef  ->  metaclass_header metaclass_name . metaclass_attributes T_SEMICOLON   (rule 43)
+
+    T_SEMICOLON	shift, and go to state 75
+    T_COMMA	shift, and go to state 76
+
+    metaclass_attributes	go to state 77
+
+
+
+state 48
+
+    type_specifier  ->  T_IDENTIFIER .   (rule 82)
+
+    $default	reduce using rule 82 (type_specifier)
+
+
+
+state 49
+
+    data_section  ->  data_header variables .   (rule 66)
+
+    $default	reduce using rule 66 (data_section)
+
+
+
+state 50
+
+    variables  ->  declaration .   (rule 68)
+    variables  ->  declaration . variables   (rule 69)
+
+    T_IDENTIFIER	shift, and go to state 48
+
+    $default	reduce using rule 68 (variables)
+
+    variables	go to state 78
+    declaration	go to state 50
+    declarationdef	go to state 51
+    declaration_specifiers	go to state 52
+    type_specifier	go to state 53
+
+
+
+state 51
+
+    declaration  ->  declarationdef . T_SEMICOLON   (rule 70)
+    declaration  ->  declarationdef . T_SEMICOLON description   (rule 71)
+
+    T_SEMICOLON	shift, and go to state 79
+
+
+
+state 52
+
+    declarationdef  ->  declaration_specifiers .   (rule 72)
+    declarationdef  ->  declaration_specifiers . data_attributes   (rule 73)
+
+    T_COMMA	shift, and go to state 80
+
+    $default	reduce using rule 72 (declarationdef)
+
+    data_attributes	go to state 81
+
+
+
+state 53
+
+    declaration_specifiers  ->  type_specifier . declarator   (rule 80)
+    declaration_specifiers  ->  type_specifier . declarator declaration_specifiers   (rule 81)
+
+    T_STAR	shift, and go to state 82
+    T_IDENTIFIER	shift, and go to state 83
+    T_LEFTPARENTHESIS	shift, and go to state 84
+
+    declarator	go to state 85
+    direct_declarator	go to state 86
+    pointer	go to state 87
+
+
+
+state 54
+
+    overridemethod_header  ->  T_OVERRIDE .   (rule 109)
+    overridemethod_header  ->  T_OVERRIDE . T_COLON   (rule 110)
+
+    T_COLON	shift, and go to state 88
+
+    $default	reduce using rule 109 (overridemethod_header)
+
+
+
+state 55
+
+    method_type  ->  type_specifier .   (rule 105)
+    method_type  ->  type_specifier . pointer   (rule 106)
+
+    T_STAR	shift, and go to state 82
+
+    $default	reduce using rule 105 (method_type)
+
+    pointer	go to state 89
+
+
+
+state 56
+
+    methods_section  ->  method_header method_list .   (rule 93)
+    method_list  ->  method_list . method   (rule 97)
+
+    T_IDENTIFIER	shift, and go to state 48
+    T_OVERRIDE	shift, and go to state 54
+
+    $default	reduce using rule 93 (methods_section)
+
+    type_specifier	go to state 55
+    method	go to state 90
+    methoddef	go to state 58
+    method_specifier	go to state 59
+    method_type	go to state 60
+    overridemethod_specifier	go to state 61
+    overridemethod_header	go to state 62
+
+
+
+state 57
+
+    method_list  ->  method .   (rule 96)
+
+    $default	reduce using rule 96 (method_list)
+
+
+
+state 58
+
+    method  ->  methoddef . T_SEMICOLON   (rule 98)
+    method  ->  methoddef . T_SEMICOLON description   (rule 99)
+
+    T_SEMICOLON	shift, and go to state 91
+
+
+
+state 59
+
+    methoddef  ->  method_specifier .   (rule 100)
+    methoddef  ->  method_specifier . method_attributes   (rule 101)
+
+    T_COMMA	shift, and go to state 92
+
+    $default	reduce using rule 100 (methoddef)
+
+    method_attributes	go to state 93
+
+
+
+state 60
+
+    method_specifier  ->  method_type . method_name T_LEFTPARENTHESIS parameter_list T_RIGHTPARENTHESIS   (rule 103)
+
+    T_IDENTIFIER	shift, and go to state 94
+
+    method_name	go to state 95
+
+
+
+state 61
+
+    methoddef  ->  overridemethod_specifier .   (rule 102)
+
+    $default	reduce using rule 102 (methoddef)
+
+
+
+state 62
+
+    overridemethod_specifier  ->  overridemethod_header . overridemethod_name   (rule 107)
+    overridemethod_specifier  ->  overridemethod_header . overridemethod_name overridemethod_attributes   (rule 108)
+
+    T_IDENTIFIER	shift, and go to state 96
+
+    overridemethod_name	go to state 97
+
+
+
+state 63
+
+    methods_section  ->  method_header description . method_list   (rule 94)
+
+    T_IDENTIFIER	shift, and go to state 48
+    T_OVERRIDE	shift, and go to state 54
+
+    type_specifier	go to state 55
+    method_list	go to state 98
+    method	go to state 57
+    methoddef	go to state 58
+    method_specifier	go to state 59
+    method_type	go to state 60
+    overridemethod_specifier	go to state 61
+    overridemethod_header	go to state 62
+
+
+
+state 64
+
+    classdef  ->  class_header class_name T_SEMICOLON .   (rule 18)
+
+    $default	reduce using rule 18 (classdef)
+
+
+
+state 65
+
+    class_attributes  ->  T_COMMA . class_attribute   (rule 22)
+
+    T_GLOBAL	shift, and go to state 99
+    T_LOCAL	shift, and go to state 100
+    T_CLASSINIT	shift, and go to state 101
+    T_FILE	shift, and go to state 102
+    T_FUNCTION	shift, and go to state 103
+    T_CLASSPREFIX	shift, and go to state 104
+    T_MAJOR	shift, and go to state 105
+    T_MINOR	shift, and go to state 106
+    T_EXTERNAL	shift, and go to state 107
+
+    class_attribute	go to state 108
+    visibility	go to state 109
+
+
+
+state 66
+
+    classdef  ->  class_header class_name class_attributes . T_SEMICOLON   (rule 19)
+    class_attributes  ->  class_attributes . T_COMMA class_attribute   (rule 23)
+
+    T_SEMICOLON	shift, and go to state 110
+    T_COMMA	shift, and go to state 111
+
+
+
+state 67
+
+    releaseorder_header  ->  T_RELEASE T_ORDER T_COLON .   (rule 36)
+
+    $default	reduce using rule 36 (releaseorder_header)
+
+
+
+state 68
+
+    parent_header  ->  T_PARENT T_COLON .   (rule 57)
+
+    $default	reduce using rule 57 (parent_header)
+
+
+
+state 69
+
+    parent_header  ->  T_PARENT T_CLASS . T_COLON   (rule 56)
+
+    T_COLON	shift, and go to state 112
+
+
+
+state 70
+
+    parent_section  ->  parentdef description .   (rule 53)
+
+    $default	reduce using rule 53 (parent_section)
+
+
+
+state 71
+
+    parent_name  ->  T_IDENTIFIER .   (rule 58)
+
+    $default	reduce using rule 58 (parent_name)
+
+
+
+state 72
+
+    parentdef  ->  parent_header parent_name . T_SEMICOLON   (rule 54)
+    parentdef  ->  parent_header parent_name . parent_attributes T_SEMICOLON   (rule 55)
+
+    T_SEMICOLON	shift, and go to state 113
+    T_COMMA	shift, and go to state 114
+
+    parent_attributes	go to state 115
+
+
+
+state 73
+
+    releaseorder_section  ->  releaseorder_header release_list T_SEMICOLON .   (rule 35)
+
+    $default	reduce using rule 35 (releaseorder_section)
+
+
+
+state 74
+
+    release_list  ->  release_list T_COMMA . release   (rule 38)
+
+    T_IDENTIFIER	shift, and go to state 42
+
+    release	go to state 116
+
+
+
+state 75
+
+    metaclassdef  ->  metaclass_header metaclass_name T_SEMICOLON .   (rule 42)
+
+    $default	reduce using rule 42 (metaclassdef)
+
+
+
+state 76
+
+    metaclass_attributes  ->  T_COMMA . metaclass_attribute   (rule 46)
+
+    T_GLOBAL	shift, and go to state 99
+    T_LOCAL	shift, and go to state 100
+    T_FILE	shift, and go to state 117
+    T_MAJOR	shift, and go to state 118
+    T_MINOR	shift, and go to state 119
+
+    visibility	go to state 120
+    metaclass_attribute	go to state 121
+
+
+
+state 77
+
+    metaclassdef  ->  metaclass_header metaclass_name metaclass_attributes . T_SEMICOLON   (rule 43)
+    metaclass_attributes  ->  metaclass_attributes . T_COMMA metaclass_attribute   (rule 47)
+
+    T_SEMICOLON	shift, and go to state 122
+    T_COMMA	shift, and go to state 123
+
+
+
+state 78
+
+    variables  ->  declaration variables .   (rule 69)
+
+    $default	reduce using rule 69 (variables)
+
+
+
+state 79
+
+    declaration  ->  declarationdef T_SEMICOLON .   (rule 70)
+    declaration  ->  declarationdef T_SEMICOLON . description   (rule 71)
+
+    T_COMMENT	shift, and go to state 29
+
+    $default	reduce using rule 70 (declaration)
+
+    description	go to state 124
+
+
+
+state 80
+
+    data_attributes  ->  T_COMMA . data_attribute   (rule 74)
+
+    T_CLASS	shift, and go to state 125
+    T_PRIVATE	shift, and go to state 126
+    T_PUBLIC	shift, and go to state 127
+    T_INTERNAL	shift, and go to state 128
+
+    data_attribute	go to state 129
+
+
+
+state 81
+
+    declarationdef  ->  declaration_specifiers data_attributes .   (rule 73)
+    data_attributes  ->  data_attributes . T_COMMA data_attribute   (rule 75)
+
+    T_COMMA	shift, and go to state 130
+
+    $default	reduce using rule 73 (declarationdef)
+
+
+
+state 82
+
+    pointer  ->  T_STAR .   (rule 91)
+
+    $default	reduce using rule 91 (pointer)
+
+
+
+state 83
+
+    direct_declarator  ->  T_IDENTIFIER .   (rule 85)
+
+    $default	reduce using rule 85 (direct_declarator)
+
+
+
+state 84
+
+    direct_declarator  ->  T_LEFTPARENTHESIS . declarator T_RIGHTPARENTHESIS   (rule 86)
+
+    T_STAR	shift, and go to state 82
+    T_IDENTIFIER	shift, and go to state 83
+    T_LEFTPARENTHESIS	shift, and go to state 84
+
+    declarator	go to state 131
+    direct_declarator	go to state 86
+    pointer	go to state 87
+
+
+
+state 85
+
+    declaration_specifiers  ->  type_specifier declarator .   (rule 80)
+    declaration_specifiers  ->  type_specifier declarator . declaration_specifiers   (rule 81)
+
+    T_IDENTIFIER	shift, and go to state 48
+
+    $default	reduce using rule 80 (declaration_specifiers)
+
+    declaration_specifiers	go to state 132
+    type_specifier	go to state 53
+
+
+
+state 86
+
+    declarator  ->  direct_declarator .   (rule 84)
+    direct_declarator  ->  direct_declarator . T_LEFTSQUAREBRACKET T_CONSTANT T_RIGHTSQUAREBRACKET   (rule 87)
+    direct_declarator  ->  direct_declarator . T_LEFTSQUAREBRACKET T_RIGHTSQUAREBRACKET   (rule 88)
+    direct_declarator  ->  direct_declarator . T_LEFTPARENTHESIS declaration_specifiers T_RIGHTPARENTHESIS   (rule 89)
+    direct_declarator  ->  direct_declarator . T_LEFTPARENTHESIS T_RIGHTPARENTHESIS   (rule 90)
+
+    T_LEFTPARENTHESIS	shift, and go to state 133
+    T_LEFTSQUAREBRACKET	shift, and go to state 134
+
+    $default	reduce using rule 84 (declarator)
+
+
+
+state 87
+
+    declarator  ->  pointer . direct_declarator   (rule 83)
+    pointer  ->  pointer . T_STAR   (rule 92)
+
+    T_STAR	shift, and go to state 135
+    T_IDENTIFIER	shift, and go to state 83
+    T_LEFTPARENTHESIS	shift, and go to state 84
+
+    direct_declarator	go to state 136
+
+
+
+state 88
+
+    overridemethod_header  ->  T_OVERRIDE T_COLON .   (rule 110)
+
+    $default	reduce using rule 110 (overridemethod_header)
+
+
+
+state 89
+
+    pointer  ->  pointer . T_STAR   (rule 92)
+    method_type  ->  type_specifier pointer .   (rule 106)
+
+    T_STAR	shift, and go to state 135
+
+    $default	reduce using rule 106 (method_type)
+
+
+
+state 90
+
+    method_list  ->  method_list method .   (rule 97)
+
+    $default	reduce using rule 97 (method_list)
+
+
+
+state 91
+
+    method  ->  methoddef T_SEMICOLON .   (rule 98)
+    method  ->  methoddef T_SEMICOLON . description   (rule 99)
+
+    T_COMMENT	shift, and go to state 29
+
+    $default	reduce using rule 98 (method)
+
+    description	go to state 137
+
+
+
+state 92
+
+    method_attributes  ->  T_COMMA . method_attribute   (rule 116)
+
+    T_LOCAL	shift, and go to state 138
+    T_CLASS	shift, and go to state 139
+    T_PRIVATE	shift, and go to state 140
+    T_PUBLIC	shift, and go to state 141
+    T_METHOD	shift, and go to state 142
+    T_PROCEDURE	shift, and go to state 143
+    T_OFFSET	shift, and go to state 144
+    T_NAME	shift, and go to state 145
+    T_EXTERNAL	shift, and go to state 146
+    T_USE	shift, and go to state 147
+
+    method_attribute	go to state 148
+
+
+
+state 93
+
+    methoddef  ->  method_specifier method_attributes .   (rule 101)
+    method_attributes  ->  method_attributes . T_COMMA method_attribute   (rule 117)
+
+    T_COMMA	shift, and go to state 149
+
+    $default	reduce using rule 101 (methoddef)
+
+
+
+state 94
+
+    method_name  ->  T_IDENTIFIER .   (rule 104)
+
+    $default	reduce using rule 104 (method_name)
+
+
+
+state 95
+
+    method_specifier  ->  method_type method_name . T_LEFTPARENTHESIS parameter_list T_RIGHTPARENTHESIS   (rule 103)
+
+    T_LEFTPARENTHESIS	shift, and go to state 150
+
+
+
+state 96
+
+    overridemethod_name  ->  T_IDENTIFIER .   (rule 111)
+
+    $default	reduce using rule 111 (overridemethod_name)
+
+
+
+state 97
+
+    overridemethod_specifier  ->  overridemethod_header overridemethod_name .   (rule 107)
+    overridemethod_specifier  ->  overridemethod_header overridemethod_name . overridemethod_attributes   (rule 108)
+
+    T_COMMA	shift, and go to state 151
+
+    $default	reduce using rule 107 (overridemethod_specifier)
+
+    overridemethod_attributes	go to state 152
+
+
+
+state 98
+
+    methods_section  ->  method_header description method_list .   (rule 94)
+    method_list  ->  method_list . method   (rule 97)
+
+    T_IDENTIFIER	shift, and go to state 48
+    T_OVERRIDE	shift, and go to state 54
+
+    $default	reduce using rule 94 (methods_section)
+
+    type_specifier	go to state 55
+    method	go to state 90
+    methoddef	go to state 58
+    method_specifier	go to state 59
+    method_type	go to state 60
+    overridemethod_specifier	go to state 61
+    overridemethod_header	go to state 62
+
+
+
+state 99
+
+    visibility  ->  T_GLOBAL .   (rule 33)
+
+    $default	reduce using rule 33 (visibility)
+
+
+
+state 100
+
+    visibility  ->  T_LOCAL .   (rule 34)
+
+    $default	reduce using rule 34 (visibility)
+
+
+
+state 101
+
+    class_attribute  ->  T_CLASSINIT . T_EQUAL T_IDENTIFIER   (rule 31)
+
+    T_EQUAL	shift, and go to state 153
+
+
+
+state 102
+
+    class_attribute  ->  T_FILE . T_STEM T_EQUAL T_IDENTIFIER   (rule 24)
+
+    T_STEM	shift, and go to state 154
+
+
+
+state 103
+
+    class_attribute  ->  T_FUNCTION . T_PREFIX T_EQUAL T_IDENTIFIER   (rule 26)
+
+    T_PREFIX	shift, and go to state 155
+
+
+
+state 104
+
+    class_attribute  ->  T_CLASSPREFIX . T_EQUAL T_IDENTIFIER   (rule 28)
+
+    T_EQUAL	shift, and go to state 156
+
+
+
+state 105
+
+    class_attribute  ->  T_MAJOR . T_VERSION T_EQUAL T_CONSTANT   (rule 29)
+
+    T_VERSION	shift, and go to state 157
+
+
+
+state 106
+
+    class_attribute  ->  T_MINOR . T_VERSION T_EQUAL T_CONSTANT   (rule 30)
+
+    T_VERSION	shift, and go to state 158
+
+
+
+state 107
+
+    class_attribute  ->  T_EXTERNAL . T_STEM T_EQUAL T_IDENTIFIER   (rule 25)
+    class_attribute  ->  T_EXTERNAL . T_PREFIX T_EQUAL T_IDENTIFIER   (rule 27)
+
+    T_STEM	shift, and go to state 159
+    T_PREFIX	shift, and go to state 160
+
+
+
+state 108
+
+    class_attributes  ->  T_COMMA class_attribute .   (rule 22)
+
+    $default	reduce using rule 22 (class_attributes)
+
+
+
+state 109
+
+    class_attribute  ->  visibility .   (rule 32)
+
+    $default	reduce using rule 32 (class_attribute)
+
+
+
+state 110
+
+    classdef  ->  class_header class_name class_attributes T_SEMICOLON .   (rule 19)
+
+    $default	reduce using rule 19 (classdef)
+
+
+
+state 111
+
+    class_attributes  ->  class_attributes T_COMMA . class_attribute   (rule 23)
+
+    T_GLOBAL	shift, and go to state 99
+    T_LOCAL	shift, and go to state 100
+    T_CLASSINIT	shift, and go to state 101
+    T_FILE	shift, and go to state 102
+    T_FUNCTION	shift, and go to state 103
+    T_CLASSPREFIX	shift, and go to state 104
+    T_MAJOR	shift, and go to state 105
+    T_MINOR	shift, and go to state 106
+    T_EXTERNAL	shift, and go to state 107
+
+    class_attribute	go to state 161
+    visibility	go to state 109
+
+
+
+state 112
+
+    parent_header  ->  T_PARENT T_CLASS T_COLON .   (rule 56)
+
+    $default	reduce using rule 56 (parent_header)
+
+
+
+state 113
+
+    parentdef  ->  parent_header parent_name T_SEMICOLON .   (rule 54)
+
+    $default	reduce using rule 54 (parentdef)
+
+
+
+state 114
+
+    parent_attributes  ->  T_COMMA . parent_attribute   (rule 59)
+
+    T_GLOBAL	shift, and go to state 99
+    T_LOCAL	shift, and go to state 100
+    T_FILE	shift, and go to state 162
+    T_MAJOR	shift, and go to state 163
+    T_MINOR	shift, and go to state 164
+
+    visibility	go to state 165
+    parent_attribute	go to state 166
+
+
+
+state 115
+
+    parentdef  ->  parent_header parent_name parent_attributes . T_SEMICOLON   (rule 55)
+    parent_attributes  ->  parent_attributes . T_COMMA parent_attribute   (rule 60)
+
+    T_SEMICOLON	shift, and go to state 167
+    T_COMMA	shift, and go to state 168
+
+
+
+state 116
+
+    release_list  ->  release_list T_COMMA release .   (rule 38)
+
+    $default	reduce using rule 38 (release_list)
+
+
+
+state 117
+
+    metaclass_attribute  ->  T_FILE . T_STEM T_EQUAL T_IDENTIFIER   (rule 48)
+
+    T_STEM	shift, and go to state 169
+
+
+
+state 118
+
+    metaclass_attribute  ->  T_MAJOR . T_VERSION T_EQUAL T_CONSTANT   (rule 49)
+
+    T_VERSION	shift, and go to state 170
+
+
+
+state 119
+
+    metaclass_attribute  ->  T_MINOR . T_VERSION T_EQUAL T_CONSTANT   (rule 50)
+
+    T_VERSION	shift, and go to state 171
+
+
+
+state 120
+
+    metaclass_attribute  ->  visibility .   (rule 51)
+
+    $default	reduce using rule 51 (metaclass_attribute)
+
+
+
+state 121
+
+    metaclass_attributes  ->  T_COMMA metaclass_attribute .   (rule 46)
+
+    $default	reduce using rule 46 (metaclass_attributes)
+
+
+
+state 122
+
+    metaclassdef  ->  metaclass_header metaclass_name metaclass_attributes T_SEMICOLON .   (rule 43)
+
+    $default	reduce using rule 43 (metaclassdef)
+
+
+
+state 123
+
+    metaclass_attributes  ->  metaclass_attributes T_COMMA . metaclass_attribute   (rule 47)
+
+    T_GLOBAL	shift, and go to state 99
+    T_LOCAL	shift, and go to state 100
+    T_FILE	shift, and go to state 117
+    T_MAJOR	shift, and go to state 118
+    T_MINOR	shift, and go to state 119
+
+    visibility	go to state 120
+    metaclass_attribute	go to state 172
+
+
+
+state 124
+
+    declaration  ->  declarationdef T_SEMICOLON description .   (rule 71)
+
+    $default	reduce using rule 71 (declaration)
+
+
+
+state 125
+
+    data_attribute  ->  T_CLASS .   (rule 79)
+
+    $default	reduce using rule 79 (data_attribute)
+
+
+
+state 126
+
+    data_attribute  ->  T_PRIVATE .   (rule 76)
+
+    $default	reduce using rule 76 (data_attribute)
+
+
+
+state 127
+
+    data_attribute  ->  T_PUBLIC .   (rule 77)
+
+    $default	reduce using rule 77 (data_attribute)
+
+
+
+state 128
+
+    data_attribute  ->  T_INTERNAL .   (rule 78)
+
+    $default	reduce using rule 78 (data_attribute)
+
+
+
+state 129
+
+    data_attributes  ->  T_COMMA data_attribute .   (rule 74)
+
+    $default	reduce using rule 74 (data_attributes)
+
+
+
+state 130
+
+    data_attributes  ->  data_attributes T_COMMA . data_attribute   (rule 75)
+
+    T_CLASS	shift, and go to state 125
+    T_PRIVATE	shift, and go to state 126
+    T_PUBLIC	shift, and go to state 127
+    T_INTERNAL	shift, and go to state 128
+
+    data_attribute	go to state 173
+
+
+
+state 131
+
+    direct_declarator  ->  T_LEFTPARENTHESIS declarator . T_RIGHTPARENTHESIS   (rule 86)
+
+    T_RIGHTPARENTHESIS	shift, and go to state 174
+
+
+
+state 132
+
+    declaration_specifiers  ->  type_specifier declarator declaration_specifiers .   (rule 81)
+
+    $default	reduce using rule 81 (declaration_specifiers)
+
+
+
+state 133
+
+    direct_declarator  ->  direct_declarator T_LEFTPARENTHESIS . declaration_specifiers T_RIGHTPARENTHESIS   (rule 89)
+    direct_declarator  ->  direct_declarator T_LEFTPARENTHESIS . T_RIGHTPARENTHESIS   (rule 90)
+
+    T_IDENTIFIER	shift, and go to state 48
+    T_RIGHTPARENTHESIS	shift, and go to state 175
+
+    declaration_specifiers	go to state 176
+    type_specifier	go to state 53
+
+
+
+state 134
+
+    direct_declarator  ->  direct_declarator T_LEFTSQUAREBRACKET . T_CONSTANT T_RIGHTSQUAREBRACKET   (rule 87)
+    direct_declarator  ->  direct_declarator T_LEFTSQUAREBRACKET . T_RIGHTSQUAREBRACKET   (rule 88)
+
+    T_CONSTANT	shift, and go to state 177
+    T_RIGHTSQUAREBRACKET	shift, and go to state 178
+
+
+
+state 135
+
+    pointer  ->  pointer T_STAR .   (rule 92)
+
+    $default	reduce using rule 92 (pointer)
+
+
+
+state 136
+
+    declarator  ->  pointer direct_declarator .   (rule 83)
+    direct_declarator  ->  direct_declarator . T_LEFTSQUAREBRACKET T_CONSTANT T_RIGHTSQUAREBRACKET   (rule 87)
+    direct_declarator  ->  direct_declarator . T_LEFTSQUAREBRACKET T_RIGHTSQUAREBRACKET   (rule 88)
+    direct_declarator  ->  direct_declarator . T_LEFTPARENTHESIS declaration_specifiers T_RIGHTPARENTHESIS   (rule 89)
+    direct_declarator  ->  direct_declarator . T_LEFTPARENTHESIS T_RIGHTPARENTHESIS   (rule 90)
+
+    T_LEFTPARENTHESIS	shift, and go to state 133
+    T_LEFTSQUAREBRACKET	shift, and go to state 134
+
+    $default	reduce using rule 83 (declarator)
+
+
+
+state 137
+
+    method  ->  methoddef T_SEMICOLON description .   (rule 99)
+
+    $default	reduce using rule 99 (method)
+
+
+
+state 138
+
+    method_attribute  ->  T_LOCAL .   (rule 125)
+
+    $default	reduce using rule 125 (method_attribute)
+
+
+
+state 139
+
+    method_attribute  ->  T_CLASS .   (rule 122)
+
+    $default	reduce using rule 122 (method_attribute)
+
+
+
+state 140
+
+    method_attribute  ->  T_PRIVATE .   (rule 118)
+
+    $default	reduce using rule 118 (method_attribute)
+
+
+
+state 141
+
+    method_attribute  ->  T_PUBLIC .   (rule 119)
+
+    $default	reduce using rule 119 (method_attribute)
+
+
+
+state 142
+
+    method_attribute  ->  T_METHOD .   (rule 120)
+
+    $default	reduce using rule 120 (method_attribute)
+
+
+
+state 143
+
+    method_attribute  ->  T_PROCEDURE .   (rule 121)
+
+    $default	reduce using rule 121 (method_attribute)
+
+
+
+state 144
+
+    method_attribute  ->  T_OFFSET .   (rule 123)
+
+    $default	reduce using rule 123 (method_attribute)
+
+
+
+state 145
+
+    method_attribute  ->  T_NAME . T_LOOKUP   (rule 124)
+
+    T_LOOKUP	shift, and go to state 179
+
+
+
+state 146
+
+    method_attribute  ->  T_EXTERNAL .   (rule 126)
+
+    $default	reduce using rule 126 (method_attribute)
+
+
+
+state 147
+
+    method_attribute  ->  T_USE . T_EQUAL T_IDENTIFIER   (rule 127)
+
+    T_EQUAL	shift, and go to state 180
+
+
+
+state 148
+
+    method_attributes  ->  T_COMMA method_attribute .   (rule 116)
+
+    $default	reduce using rule 116 (method_attributes)
+
+
+
+state 149
+
+    method_attributes  ->  method_attributes T_COMMA . method_attribute   (rule 117)
+
+    T_LOCAL	shift, and go to state 138
+    T_CLASS	shift, and go to state 139
+    T_PRIVATE	shift, and go to state 140
+    T_PUBLIC	shift, and go to state 141
+    T_METHOD	shift, and go to state 142
+    T_PROCEDURE	shift, and go to state 143
+    T_OFFSET	shift, and go to state 144
+    T_NAME	shift, and go to state 145
+    T_EXTERNAL	shift, and go to state 146
+    T_USE	shift, and go to state 147
+
+    method_attribute	go to state 181
+
+
+
+state 150
+
+    method_specifier  ->  method_type method_name T_LEFTPARENTHESIS . parameter_list T_RIGHTPARENTHESIS   (rule 103)
+
+    T_IDENTIFIER	shift, and go to state 48
+    T_ELLIPSIS	shift, and go to state 182
+
+    type_specifier	go to state 183
+    parameter_list	go to state 184
+    parameter	go to state 185
+
+
+
+state 151
+
+    overridemethod_attributes  ->  T_COMMA . overridemethod_attribute   (rule 128)
+
+    T_LOCAL	shift, and go to state 186
+    T_CLASS	shift, and go to state 187
+    T_PRIVATE	shift, and go to state 188
+    T_PUBLIC	shift, and go to state 189
+    T_EXTERNAL	shift, and go to state 190
+    T_USE	shift, and go to state 191
+
+    overridemethod_attribute	go to state 192
+
+
+
+state 152
+
+    overridemethod_specifier  ->  overridemethod_header overridemethod_name overridemethod_attributes .   (rule 108)
+    overridemethod_attributes  ->  overridemethod_attributes . T_COMMA overridemethod_attribute   (rule 129)
+
+    T_COMMA	shift, and go to state 193
+
+    $default	reduce using rule 108 (overridemethod_specifier)
+
+
+
+state 153
+
+    class_attribute  ->  T_CLASSINIT T_EQUAL . T_IDENTIFIER   (rule 31)
+
+    T_IDENTIFIER	shift, and go to state 194
+
+
+
+state 154
+
+    class_attribute  ->  T_FILE T_STEM . T_EQUAL T_IDENTIFIER   (rule 24)
+
+    T_EQUAL	shift, and go to state 195
+
+
+
+state 155
+
+    class_attribute  ->  T_FUNCTION T_PREFIX . T_EQUAL T_IDENTIFIER   (rule 26)
+
+    T_EQUAL	shift, and go to state 196
+
+
+
+state 156
+
+    class_attribute  ->  T_CLASSPREFIX T_EQUAL . T_IDENTIFIER   (rule 28)
+
+    T_IDENTIFIER	shift, and go to state 197
+
+
+
+state 157
+
+    class_attribute  ->  T_MAJOR T_VERSION . T_EQUAL T_CONSTANT   (rule 29)
+
+    T_EQUAL	shift, and go to state 198
+
+
+
+state 158
+
+    class_attribute  ->  T_MINOR T_VERSION . T_EQUAL T_CONSTANT   (rule 30)
+
+    T_EQUAL	shift, and go to state 199
+
+
+
+state 159
+
+    class_attribute  ->  T_EXTERNAL T_STEM . T_EQUAL T_IDENTIFIER   (rule 25)
+
+    T_EQUAL	shift, and go to state 200
+
+
+
+state 160
+
+    class_attribute  ->  T_EXTERNAL T_PREFIX . T_EQUAL T_IDENTIFIER   (rule 27)
+
+    T_EQUAL	shift, and go to state 201
+
+
+
+state 161
+
+    class_attributes  ->  class_attributes T_COMMA class_attribute .   (rule 23)
+
+    $default	reduce using rule 23 (class_attributes)
+
+
+
+state 162
+
+    parent_attribute  ->  T_FILE . T_STEM T_EQUAL T_IDENTIFIER   (rule 61)
+
+    T_STEM	shift, and go to state 202
+
+
+
+state 163
+
+    parent_attribute  ->  T_MAJOR . T_VERSION T_EQUAL T_CONSTANT   (rule 62)
+
+    T_VERSION	shift, and go to state 203
+
+
+
+state 164
+
+    parent_attribute  ->  T_MINOR . T_VERSION T_EQUAL T_CONSTANT   (rule 63)
+
+    T_VERSION	shift, and go to state 204
+
+
+
+state 165
+
+    parent_attribute  ->  visibility .   (rule 64)
+
+    $default	reduce using rule 64 (parent_attribute)
+
+
+
+state 166
+
+    parent_attributes  ->  T_COMMA parent_attribute .   (rule 59)
+
+    $default	reduce using rule 59 (parent_attributes)
+
+
+
+state 167
+
+    parentdef  ->  parent_header parent_name parent_attributes T_SEMICOLON .   (rule 55)
+
+    $default	reduce using rule 55 (parentdef)
+
+
+
+state 168
+
+    parent_attributes  ->  parent_attributes T_COMMA . parent_attribute   (rule 60)
+
+    T_GLOBAL	shift, and go to state 99
+    T_LOCAL	shift, and go to state 100
+    T_FILE	shift, and go to state 162
+    T_MAJOR	shift, and go to state 163
+    T_MINOR	shift, and go to state 164
+
+    visibility	go to state 165
+    parent_attribute	go to state 205
+
+
+
+state 169
+
+    metaclass_attribute  ->  T_FILE T_STEM . T_EQUAL T_IDENTIFIER   (rule 48)
+
+    T_EQUAL	shift, and go to state 206
+
+
+
+state 170
+
+    metaclass_attribute  ->  T_MAJOR T_VERSION . T_EQUAL T_CONSTANT   (rule 49)
+
+    T_EQUAL	shift, and go to state 207
+
+
+
+state 171
+
+    metaclass_attribute  ->  T_MINOR T_VERSION . T_EQUAL T_CONSTANT   (rule 50)
+
+    T_EQUAL	shift, and go to state 208
+
+
+
+state 172
+
+    metaclass_attributes  ->  metaclass_attributes T_COMMA metaclass_attribute .   (rule 47)
+
+    $default	reduce using rule 47 (metaclass_attributes)
+
+
+
+state 173
+
+    data_attributes  ->  data_attributes T_COMMA data_attribute .   (rule 75)
+
+    $default	reduce using rule 75 (data_attributes)
+
+
+
+state 174
+
+    direct_declarator  ->  T_LEFTPARENTHESIS declarator T_RIGHTPARENTHESIS .   (rule 86)
+
+    $default	reduce using rule 86 (direct_declarator)
+
+
+
+state 175
+
+    direct_declarator  ->  direct_declarator T_LEFTPARENTHESIS T_RIGHTPARENTHESIS .   (rule 90)
+
+    $default	reduce using rule 90 (direct_declarator)
+
+
+
+state 176
+
+    direct_declarator  ->  direct_declarator T_LEFTPARENTHESIS declaration_specifiers . T_RIGHTPARENTHESIS   (rule 89)
+
+    T_RIGHTPARENTHESIS	shift, and go to state 209
+
+
+
+state 177
+
+    direct_declarator  ->  direct_declarator T_LEFTSQUAREBRACKET T_CONSTANT . T_RIGHTSQUAREBRACKET   (rule 87)
+
+    T_RIGHTSQUAREBRACKET	shift, and go to state 210
+
+
+
+state 178
+
+    direct_declarator  ->  direct_declarator T_LEFTSQUAREBRACKET T_RIGHTSQUAREBRACKET .   (rule 88)
+
+    $default	reduce using rule 88 (direct_declarator)
+
+
+
+state 179
+
+    method_attribute  ->  T_NAME T_LOOKUP .   (rule 124)
+
+    $default	reduce using rule 124 (method_attribute)
+
+
+
+state 180
+
+    method_attribute  ->  T_USE T_EQUAL . T_IDENTIFIER   (rule 127)
+
+    T_IDENTIFIER	shift, and go to state 211
+
+
+
+state 181
+
+    method_attributes  ->  method_attributes T_COMMA method_attribute .   (rule 117)
+
+    $default	reduce using rule 117 (method_attributes)
+
+
+
+state 182
+
+    parameter  ->  T_ELLIPSIS .   (rule 114)
+
+    $default	reduce using rule 114 (parameter)
+
+
+
+state 183
+
+    parameter  ->  type_specifier . declarator   (rule 115)
+
+    T_STAR	shift, and go to state 82
+    T_IDENTIFIER	shift, and go to state 83
+    T_LEFTPARENTHESIS	shift, and go to state 84
+
+    declarator	go to state 212
+    direct_declarator	go to state 86
+    pointer	go to state 87
+
+
+
+state 184
+
+    method_specifier  ->  method_type method_name T_LEFTPARENTHESIS parameter_list . T_RIGHTPARENTHESIS   (rule 103)
+    parameter_list  ->  parameter_list . T_COMMA parameter   (rule 113)
+
+    T_COMMA	shift, and go to state 213
+    T_RIGHTPARENTHESIS	shift, and go to state 214
+
+
+
+state 185
+
+    parameter_list  ->  parameter .   (rule 112)
+
+    $default	reduce using rule 112 (parameter_list)
+
+
+
+state 186
+
+    overridemethod_attribute  ->  T_LOCAL .   (rule 133)
+
+    $default	reduce using rule 133 (overridemethod_attribute)
+
+
+
+state 187
+
+    overridemethod_attribute  ->  T_CLASS .   (rule 132)
+
+    $default	reduce using rule 132 (overridemethod_attribute)
+
+
+
+state 188
+
+    overridemethod_attribute  ->  T_PRIVATE .   (rule 130)
+
+    $default	reduce using rule 130 (overridemethod_attribute)
+
+
+
+state 189
+
+    overridemethod_attribute  ->  T_PUBLIC .   (rule 131)
+
+    $default	reduce using rule 131 (overridemethod_attribute)
+
+
+
+state 190
+
+    overridemethod_attribute  ->  T_EXTERNAL .   (rule 134)
+
+    $default	reduce using rule 134 (overridemethod_attribute)
+
+
+
+state 191
+
+    overridemethod_attribute  ->  T_USE . T_EQUAL T_IDENTIFIER   (rule 135)
+
+    T_EQUAL	shift, and go to state 215
+
+
+
+state 192
+
+    overridemethod_attributes  ->  T_COMMA overridemethod_attribute .   (rule 128)
+
+    $default	reduce using rule 128 (overridemethod_attributes)
+
+
+
+state 193
+
+    overridemethod_attributes  ->  overridemethod_attributes T_COMMA . overridemethod_attribute   (rule 129)
+
+    T_LOCAL	shift, and go to state 186
+    T_CLASS	shift, and go to state 187
+    T_PRIVATE	shift, and go to state 188
+    T_PUBLIC	shift, and go to state 189
+    T_EXTERNAL	shift, and go to state 190
+    T_USE	shift, and go to state 191
+
+    overridemethod_attribute	go to state 216
+
+
+
+state 194
+
+    class_attribute  ->  T_CLASSINIT T_EQUAL T_IDENTIFIER .   (rule 31)
+
+    $default	reduce using rule 31 (class_attribute)
+
+
+
+state 195
+
+    class_attribute  ->  T_FILE T_STEM T_EQUAL . T_IDENTIFIER   (rule 24)
+
+    T_IDENTIFIER	shift, and go to state 217
+
+
+
+state 196
+
+    class_attribute  ->  T_FUNCTION T_PREFIX T_EQUAL . T_IDENTIFIER   (rule 26)
+
+    T_IDENTIFIER	shift, and go to state 218
+
+
+
+state 197
+
+    class_attribute  ->  T_CLASSPREFIX T_EQUAL T_IDENTIFIER .   (rule 28)
+
+    $default	reduce using rule 28 (class_attribute)
+
+
+
+state 198
+
+    class_attribute  ->  T_MAJOR T_VERSION T_EQUAL . T_CONSTANT   (rule 29)
+
+    T_CONSTANT	shift, and go to state 219
+
+
+
+state 199
+
+    class_attribute  ->  T_MINOR T_VERSION T_EQUAL . T_CONSTANT   (rule 30)
+
+    T_CONSTANT	shift, and go to state 220
+
+
+
+state 200
+
+    class_attribute  ->  T_EXTERNAL T_STEM T_EQUAL . T_IDENTIFIER   (rule 25)
+
+    T_IDENTIFIER	shift, and go to state 221
+
+
+
+state 201
+
+    class_attribute  ->  T_EXTERNAL T_PREFIX T_EQUAL . T_IDENTIFIER   (rule 27)
+
+    T_IDENTIFIER	shift, and go to state 222
+
+
+
+state 202
+
+    parent_attribute  ->  T_FILE T_STEM . T_EQUAL T_IDENTIFIER   (rule 61)
+
+    T_EQUAL	shift, and go to state 223
+
+
+
+state 203
+
+    parent_attribute  ->  T_MAJOR T_VERSION . T_EQUAL T_CONSTANT   (rule 62)
+
+    T_EQUAL	shift, and go to state 224
+
+
+
+state 204
+
+    parent_attribute  ->  T_MINOR T_VERSION . T_EQUAL T_CONSTANT   (rule 63)
+
+    T_EQUAL	shift, and go to state 225
+
+
+
+state 205
+
+    parent_attributes  ->  parent_attributes T_COMMA parent_attribute .   (rule 60)
+
+    $default	reduce using rule 60 (parent_attributes)
+
+
+
+state 206
+
+    metaclass_attribute  ->  T_FILE T_STEM T_EQUAL . T_IDENTIFIER   (rule 48)
+
+    T_IDENTIFIER	shift, and go to state 226
+
+
+
+state 207
+
+    metaclass_attribute  ->  T_MAJOR T_VERSION T_EQUAL . T_CONSTANT   (rule 49)
+
+    T_CONSTANT	shift, and go to state 227
+
+
+
+state 208
+
+    metaclass_attribute  ->  T_MINOR T_VERSION T_EQUAL . T_CONSTANT   (rule 50)
+
+    T_CONSTANT	shift, and go to state 228
+
+
+
+state 209
+
+    direct_declarator  ->  direct_declarator T_LEFTPARENTHESIS declaration_specifiers T_RIGHTPARENTHESIS .   (rule 89)
+
+    $default	reduce using rule 89 (direct_declarator)
+
+
+
+state 210
+
+    direct_declarator  ->  direct_declarator T_LEFTSQUAREBRACKET T_CONSTANT T_RIGHTSQUAREBRACKET .   (rule 87)
+
+    $default	reduce using rule 87 (direct_declarator)
+
+
+
+state 211
+
+    method_attribute  ->  T_USE T_EQUAL T_IDENTIFIER .   (rule 127)
+
+    $default	reduce using rule 127 (method_attribute)
+
+
+
+state 212
+
+    parameter  ->  type_specifier declarator .   (rule 115)
+
+    $default	reduce using rule 115 (parameter)
+
+
+
+state 213
+
+    parameter_list  ->  parameter_list T_COMMA . parameter   (rule 113)
+
+    T_IDENTIFIER	shift, and go to state 48
+    T_ELLIPSIS	shift, and go to state 182
+
+    type_specifier	go to state 183
+    parameter	go to state 229
+
+
+
+state 214
+
+    method_specifier  ->  method_type method_name T_LEFTPARENTHESIS parameter_list T_RIGHTPARENTHESIS .   (rule 103)
+
+    $default	reduce using rule 103 (method_specifier)
+
+
+
+state 215
+
+    overridemethod_attribute  ->  T_USE T_EQUAL . T_IDENTIFIER   (rule 135)
+
+    T_IDENTIFIER	shift, and go to state 230
+
+
+
+state 216
+
+    overridemethod_attributes  ->  overridemethod_attributes T_COMMA overridemethod_attribute .   (rule 129)
+
+    $default	reduce using rule 129 (overridemethod_attributes)
+
+
+
+state 217
+
+    class_attribute  ->  T_FILE T_STEM T_EQUAL T_IDENTIFIER .   (rule 24)
+
+    $default	reduce using rule 24 (class_attribute)
+
+
+
+state 218
+
+    class_attribute  ->  T_FUNCTION T_PREFIX T_EQUAL T_IDENTIFIER .   (rule 26)
+
+    $default	reduce using rule 26 (class_attribute)
+
+
+
+state 219
+
+    class_attribute  ->  T_MAJOR T_VERSION T_EQUAL T_CONSTANT .   (rule 29)
+
+    $default	reduce using rule 29 (class_attribute)
+
+
+
+state 220
+
+    class_attribute  ->  T_MINOR T_VERSION T_EQUAL T_CONSTANT .   (rule 30)
+
+    $default	reduce using rule 30 (class_attribute)
+
+
+
+state 221
+
+    class_attribute  ->  T_EXTERNAL T_STEM T_EQUAL T_IDENTIFIER .   (rule 25)
+
+    $default	reduce using rule 25 (class_attribute)
+
+
+
+state 222
+
+    class_attribute  ->  T_EXTERNAL T_PREFIX T_EQUAL T_IDENTIFIER .   (rule 27)
+
+    $default	reduce using rule 27 (class_attribute)
+
+
+
+state 223
+
+    parent_attribute  ->  T_FILE T_STEM T_EQUAL . T_IDENTIFIER   (rule 61)
+
+    T_IDENTIFIER	shift, and go to state 231
+
+
+
+state 224
+
+    parent_attribute  ->  T_MAJOR T_VERSION T_EQUAL . T_CONSTANT   (rule 62)
+
+    T_CONSTANT	shift, and go to state 232
+
+
+
+state 225
+
+    parent_attribute  ->  T_MINOR T_VERSION T_EQUAL . T_CONSTANT   (rule 63)
+
+    T_CONSTANT	shift, and go to state 233
+
+
+
+state 226
+
+    metaclass_attribute  ->  T_FILE T_STEM T_EQUAL T_IDENTIFIER .   (rule 48)
+
+    $default	reduce using rule 48 (metaclass_attribute)
+
+
+
+state 227
+
+    metaclass_attribute  ->  T_MAJOR T_VERSION T_EQUAL T_CONSTANT .   (rule 49)
+
+    $default	reduce using rule 49 (metaclass_attribute)
+
+
+
+state 228
+
+    metaclass_attribute  ->  T_MINOR T_VERSION T_EQUAL T_CONSTANT .   (rule 50)
+
+    $default	reduce using rule 50 (metaclass_attribute)
+
+
+
+state 229
+
+    parameter_list  ->  parameter_list T_COMMA parameter .   (rule 113)
+
+    $default	reduce using rule 113 (parameter_list)
+
+
+
+state 230
+
+    overridemethod_attribute  ->  T_USE T_EQUAL T_IDENTIFIER .   (rule 135)
+
+    $default	reduce using rule 135 (overridemethod_attribute)
+
+
+
+state 231
+
+    parent_attribute  ->  T_FILE T_STEM T_EQUAL T_IDENTIFIER .   (rule 61)
+
+    $default	reduce using rule 61 (parent_attribute)
+
+
+
+state 232
+
+    parent_attribute  ->  T_MAJOR T_VERSION T_EQUAL T_CONSTANT .   (rule 62)
+
+    $default	reduce using rule 62 (parent_attribute)
+
+
+
+state 233
+
+    parent_attribute  ->  T_MINOR T_VERSION T_EQUAL T_CONSTANT .   (rule 63)
+
+    $default	reduce using rule 63 (parent_attribute)
+
+
+
+state 234
+
+    $   	go to state 235
+
+
+
+state 235
+
+    $   	go to state 236
+
+
+
+state 236
+
+    $default	accept
diff -urN somfree\somopc\src\gramma.yy.tab.c newsomfree3\somopc\src\gramma.yy.tab.c
--- somfree\somopc\src\gramma.yy.tab.c	Thu Jan 01 07:00:00 1970
+++ newsomfree3\somopc\src\gramma.yy.tab.c	Sat Mar 16 14:09:28 2024
@@ -0,0 +1,2042 @@
+
+/*  A Bison parser, made from gramma.yy
+    by GNU Bison version 1.28  */
+
+#define YYBISON 1  /* Identify Bison output.  */
+
+#define	T_CONSTANT	257
+#define	T_COLON	258
+#define	T_SEMICOLON	259
+#define	T_COMMA	260
+#define	T_STAR	261
+#define	T_COMMENT	262
+#define	T_IDENTIFIER	263
+#define	T_EQUAL	264
+#define	T_DASHES	265
+#define	T_PERIOD	266
+#define	T_ELLIPSIS	267
+#define	T_LEFTPARENTHESIS	268
+#define	T_RIGHTPARENTHESIS	269
+#define	T_LEFTSQUAREBRACKET	270
+#define	T_RIGHTSQUAREBRACKET	271
+#define	T_VERSION	272
+#define	T_GLOBAL	273
+#define	T_LOCAL	274
+#define	T_CLASSINIT	275
+#define	T_RELEASE	276
+#define	T_ORDER	277
+#define	T_METACLASS	278
+#define	T_PARENT	279
+#define	T_CLASS	280
+#define	T_FILE	281
+#define	T_STEM	282
+#define	T_FUNCTION	283
+#define	T_PREFIX	284
+#define	T_CLASSPREFIX	285
+#define	T_MAJOR	286
+#define	T_MINOR	287
+#define	T_PASSTHRU	288
+#define	T_BEFORE	289
+#define	T_AFTER	290
+#define	T_ENDPASSTHRU	291
+#define	T_DATA	292
+#define	T_PRIVATE	293
+#define	T_PUBLIC	294
+#define	T_INTERNAL	295
+#define	T_METHODS	296
+#define	T_GROUP	297
+#define	T_METHOD	298
+#define	T_PROCEDURE	299
+#define	T_OFFSET	300
+#define	T_NAME	301
+#define	T_LOOKUP	302
+#define	T_EXTERNAL	303
+#define	T_USE	304
+#define	T_OVERRIDE	305
+
+#line 1 "gramma.yy"
+
+#include <stdio.h> // fopen, fprintf
+#include <string.h>
+
+#include <emitlib.h>
+
+#define YYERROR_VERBOSE
+
+extern int lineno, column;
+
+Entry e;
+
+Entry *cls;	// Current Class Entry
+Entry *pcls;	// Parent Class Entry
+Entry *mcls;	// Meta Class Entry
+
+void yyerror(const char *str)
+{
+        fprintf(stderr,"\nerror: %s\n", str);
+}
+ 
+int yywrap()
+{
+        return 1;
+} 
+  
+
+#line 33 "gramma.yy"
+typedef union{
+ char *stval;
+ int ival;
+} YYSTYPE;
+#ifndef YYDEBUG
+#define YYDEBUG 1
+#endif
+
+#include <stdio.h>
+
+#ifndef __cplusplus
+#ifndef __STDC__
+#define const
+#endif
+#endif
+
+
+
+#define	YYFINAL		236
+#define	YYFLAG		-32768
+#define	YYNTBASE	52
+
+#define YYTRANSLATE(x) ((unsigned)(x) <= 305 ? yytranslate[x] : 114)
+
+static const char yytranslate[] = {     0,
+     2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
+     2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
+     2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
+     2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
+     2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
+     2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
+     2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
+     2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
+     2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
+     2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
+     2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
+     2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
+     2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
+     2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
+     2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
+     2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
+     2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
+     2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
+     2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
+     2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
+     2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
+     2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
+     2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
+     2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
+     2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
+     2,     2,     2,     2,     2,     1,     3,     4,     5,     6,
+     7,     8,     9,    10,    11,    12,    13,    14,    15,    16,
+    17,    18,    19,    20,    21,    22,    23,    24,    25,    26,
+    27,    28,    29,    30,    31,    32,    33,    34,    35,    36,
+    37,    38,    39,    40,    41,    42,    43,    44,    45,    46,
+    47,    48,    49,    50,    51
+};
+
+#if YYDEBUG != 0
+static const short yyprhs[] = {     0,
+     0,     1,     4,     6,     9,    10,    14,    16,    19,    21,
+    23,    24,    27,    29,    31,    33,    35,    38,    42,    47,
+    50,    52,    55,    59,    64,    69,    74,    79,    83,    88,
+    93,    97,    99,   101,   103,   107,   111,   113,   117,   119,
+   121,   124,   128,   133,   136,   138,   141,   145,   150,   155,
+   160,   162,   164,   167,   171,   176,   180,   183,   185,   188,
+   192,   197,   202,   207,   209,   211,   214,   217,   219,   222,
+   225,   229,   231,   234,   237,   241,   243,   245,   247,   249,
+   252,   256,   258,   261,   263,   265,   269,   274,   278,   283,
+   287,   289,   292,   295,   299,   302,   304,   307,   310,   314,
+   316,   319,   321,   327,   329,   331,   334,   337,   341,   343,
+   346,   348,   350,   354,   356,   359,   362,   366,   368,   370,
+   372,   374,   376,   378,   381,   383,   385,   389,   392,   396,
+   398,   400,   402,   404,   406,   410
+};
+
+static const short yyrhs[] = {    -1,
+    53,    54,     0,    55,     0,    54,    55,     0,     0,    56,
+    60,    57,     0,    58,     0,    57,    58,     0,    67,     0,
+    71,     0,     0,    59,    77,     0,    83,     0,    84,     0,
+    96,     0,    61,     0,    61,   113,     0,    62,    63,     5,
+     0,    62,    63,    64,     5,     0,    26,     4,     0,     9,
+     0,     6,    65,     0,    64,     6,    65,     0,    27,    28,
+    10,     9,     0,    49,    28,    10,     9,     0,    29,    30,
+    10,     9,     0,    49,    30,    10,     9,     0,    31,    10,
+     9,     0,    32,    18,    10,     3,     0,    33,    18,    10,
+     3,     0,    21,    10,     9,     0,    66,     0,    19,     0,
+    20,     0,    68,    69,     5,     0,    22,    23,     4,     0,
+    70,     0,    69,     6,    70,     0,     9,     0,    72,     0,
+    72,   113,     0,    73,    74,     5,     0,    73,    74,    75,
+     5,     0,    24,     4,     0,     9,     0,     6,    76,     0,
+    75,     6,    76,     0,    27,    28,    10,     9,     0,    32,
+    18,    10,     3,     0,    33,    18,    10,     3,     0,    66,
+     0,    78,     0,    78,   113,     0,    79,    80,     5,     0,
+    79,    80,    81,     5,     0,    25,    26,     4,     0,    25,
+     4,     0,     9,     0,     6,    82,     0,    81,     6,    82,
+     0,    27,    28,    10,     9,     0,    32,    18,    10,     3,
+     0,    33,    18,    10,     3,     0,    66,     0,    34,     0,
+    85,    86,     0,    38,     4,     0,    87,     0,    87,    86,
+     0,    88,     5,     0,    88,     5,   113,     0,    91,     0,
+    91,    89,     0,     6,    90,     0,    89,     6,    90,     0,
+    39,     0,    40,     0,    41,     0,    26,     0,    92,    93,
+     0,    92,    93,    91,     0,     9,     0,    95,    94,     0,
+    94,     0,     9,     0,    14,    93,    15,     0,    94,    16,
+     3,    17,     0,    94,    16,    17,     0,    94,    14,    91,
+    15,     0,    94,    14,    15,     0,     7,     0,    95,     7,
+     0,    97,    98,     0,    97,   113,    98,     0,    42,     4,
+     0,    99,     0,    98,    99,     0,   100,     5,     0,   100,
+     5,   113,     0,   101,     0,   101,   109,     0,   104,     0,
+   103,   102,    14,   107,    15,     0,     9,     0,    92,     0,
+    92,    95,     0,   105,   106,     0,   105,   106,   111,     0,
+    51,     0,    51,     4,     0,     9,     0,   108,     0,   107,
+     6,   108,     0,    13,     0,    92,    93,     0,     6,   110,
+     0,   109,     6,   110,     0,    39,     0,    40,     0,    44,
+     0,    45,     0,    26,     0,    46,     0,    47,    48,     0,
+    20,     0,    49,     0,    50,    10,     9,     0,     6,   112,
+     0,   111,     6,   112,     0,    39,     0,    40,     0,    26,
+     0,    20,     0,    49,     0,    50,    10,     9,     0,     8,
+     0
+};
+
+#endif
+
+#if YYDEBUG != 0
+static const short yyrline[] = { 0,
+    58,    68,    75,    76,    80,    88,    96,    97,   101,   102,
+   103,   112,   116,   117,   118,   122,   123,   130,   131,   135,
+   139,   148,   149,   153,   157,   161,   165,   169,   173,   180,
+   187,   191,   195,   196,   200,   207,   211,   215,   225,   233,
+   234,   241,   242,   246,   250,   254,   255,   259,   260,   261,
+   262,   266,   267,   275,   276,   280,   281,   285,   293,   294,
+   298,   299,   300,   301,   305,   309,   313,   317,   318,   322,
+   323,   330,   331,   335,   336,   340,   341,   342,   343,   347,
+   348,   352,   359,   360,   364,   365,   366,   367,   368,   369,
+   373,   377,   390,   391,   398,   402,   408,   417,   418,   422,
+   423,   424,   428,   435,   452,   456,   468,   469,   473,   474,
+   478,   492,   493,   497,   498,   502,   503,   507,   508,   509,
+   510,   511,   512,   513,   514,   515,   516,   524,   525,   529,
+   530,   531,   532,   533,   534,   538
+};
+#endif
+
+
+#if YYDEBUG != 0 || defined (YYERROR_VERBOSE)
+
+static const char * const yytname[] = {   "$","error","$undefined.","T_CONSTANT",
+"T_COLON","T_SEMICOLON","T_COMMA","T_STAR","T_COMMENT","T_IDENTIFIER","T_EQUAL",
+"T_DASHES","T_PERIOD","T_ELLIPSIS","T_LEFTPARENTHESIS","T_RIGHTPARENTHESIS",
+"T_LEFTSQUAREBRACKET","T_RIGHTSQUAREBRACKET","T_VERSION","T_GLOBAL","T_LOCAL",
+"T_CLASSINIT","T_RELEASE","T_ORDER","T_METACLASS","T_PARENT","T_CLASS","T_FILE",
+"T_STEM","T_FUNCTION","T_PREFIX","T_CLASSPREFIX","T_MAJOR","T_MINOR","T_PASSTHRU",
+"T_BEFORE","T_AFTER","T_ENDPASSTHRU","T_DATA","T_PRIVATE","T_PUBLIC","T_INTERNAL",
+"T_METHODS","T_GROUP","T_METHOD","T_PROCEDURE","T_OFFSET","T_NAME","T_LOOKUP",
+"T_EXTERNAL","T_USE","T_OVERRIDE","oidl","@1","class_list","class_definition",
+"@2","section_list","section","@3","class_section","classdef","class_header",
+"class_name","class_attributes","class_attribute","visibility","releaseorder_section",
+"releaseorder_header","release_list","release","metaclass_section","metaclassdef",
+"metaclass_header","metaclass_name","metaclass_attributes","metaclass_attribute",
+"parent_section","parentdef","parent_header","parent_name","parent_attributes",
+"parent_attribute","passthru_section","data_section","data_header","variables",
+"declaration","declarationdef","data_attributes","data_attribute","declaration_specifiers",
+"type_specifier","declarator","direct_declarator","pointer","methods_section",
+"method_header","method_list","method","methoddef","method_specifier","method_name",
+"method_type","overridemethod_specifier","overridemethod_header","overridemethod_name",
+"parameter_list","parameter","method_attributes","method_attribute","overridemethod_attributes",
+"overridemethod_attribute","description", NULL
+};
+#endif
+
+static const short yyr1[] = {     0,
+    53,    52,    54,    54,    56,    55,    57,    57,    58,    58,
+    59,    58,    58,    58,    58,    60,    60,    61,    61,    62,
+    63,    64,    64,    65,    65,    65,    65,    65,    65,    65,
+    65,    65,    66,    66,    67,    68,    69,    69,    70,    71,
+    71,    72,    72,    73,    74,    75,    75,    76,    76,    76,
+    76,    77,    77,    78,    78,    79,    79,    80,    81,    81,
+    82,    82,    82,    82,    83,    84,    85,    86,    86,    87,
+    87,    88,    88,    89,    89,    90,    90,    90,    90,    91,
+    91,    92,    93,    93,    94,    94,    94,    94,    94,    94,
+    95,    95,    96,    96,    97,    98,    98,    99,    99,   100,
+   100,   100,   101,   102,   103,   103,   104,   104,   105,   105,
+   106,   107,   107,   108,   108,   109,   109,   110,   110,   110,
+   110,   110,   110,   110,   110,   110,   110,   111,   111,   112,
+   112,   112,   112,   112,   112,   113
+};
+
+static const short yyr2[] = {     0,
+     0,     2,     1,     2,     0,     3,     1,     2,     1,     1,
+     0,     2,     1,     1,     1,     1,     2,     3,     4,     2,
+     1,     2,     3,     4,     4,     4,     4,     3,     4,     4,
+     3,     1,     1,     1,     3,     3,     1,     3,     1,     1,
+     2,     3,     4,     2,     1,     2,     3,     4,     4,     4,
+     1,     1,     2,     3,     4,     3,     2,     1,     2,     3,
+     4,     4,     4,     1,     1,     2,     2,     1,     2,     2,
+     3,     1,     2,     2,     3,     1,     1,     1,     1,     2,
+     3,     1,     2,     1,     1,     3,     4,     3,     4,     3,
+     1,     2,     2,     3,     2,     1,     2,     2,     3,     1,
+     2,     1,     5,     1,     1,     2,     2,     3,     1,     2,
+     1,     1,     3,     1,     2,     2,     3,     1,     1,     1,
+     1,     1,     1,     2,     1,     1,     3,     2,     3,     1,
+     1,     1,     1,     1,     3,     1
+};
+
+static const short yydefact[] = {     1,
+     5,     2,     3,     0,     4,     0,    11,    16,     0,    20,
+     0,     0,    65,     0,     0,     6,     7,     0,     9,     0,
+    10,    40,     0,    13,    14,     0,    15,     0,   136,    17,
+    21,     0,     0,    44,    67,    95,     8,     0,    12,    52,
+     0,    39,     0,    37,    41,    45,     0,    82,    66,    68,
+     0,    72,     0,   109,   105,    93,    96,     0,   100,     0,
+   102,     0,     0,    18,     0,     0,    36,    57,     0,    53,
+    58,     0,    35,     0,    42,     0,     0,    69,    70,     0,
+    73,    91,    85,     0,    80,    84,     0,   110,   106,    97,
+    98,     0,   101,   104,     0,   111,   107,    94,    33,    34,
+     0,     0,     0,     0,     0,     0,     0,    22,    32,    19,
+     0,    56,    54,     0,     0,    38,     0,     0,     0,    51,
+    46,    43,     0,    71,    79,    76,    77,    78,    74,     0,
+     0,    81,     0,     0,    92,    83,    99,   125,   122,   118,
+   119,   120,   121,   123,     0,   126,     0,   116,     0,     0,
+     0,   108,     0,     0,     0,     0,     0,     0,     0,     0,
+    23,     0,     0,     0,    64,    59,    55,     0,     0,     0,
+     0,    47,    75,    86,    90,     0,     0,    88,   124,     0,
+   117,   114,     0,     0,   112,   133,   132,   130,   131,   134,
+     0,   128,     0,    31,     0,     0,    28,     0,     0,     0,
+     0,     0,     0,     0,    60,     0,     0,     0,    89,    87,
+   127,   115,     0,   103,     0,   129,    24,    26,    29,    30,
+    25,    27,     0,     0,     0,    48,    49,    50,   113,   135,
+    61,    62,    63,     0,     0,     0
+};
+
+static const short yydefgoto[] = {   234,
+     1,     2,     3,     4,    16,    17,    18,     7,     8,     9,
+    32,    66,   108,   109,    19,    20,    43,    44,    21,    22,
+    23,    47,    77,   121,    39,    40,    41,    72,   115,   166,
+    24,    25,    26,    49,    50,    51,    81,   129,    52,    53,
+    85,    86,    87,    27,    28,    56,    57,    58,    59,    95,
+    60,    61,    62,    97,   184,   185,    93,   148,   152,   192,
+    30
+};
+
+static const short yypact[] = {-32768,
+-32768,    25,-32768,    43,-32768,    54,    51,    63,    56,-32768,
+    55,    70,-32768,    76,    79,    57,-32768,    65,-32768,    83,
+-32768,    63,    89,-32768,-32768,    94,-32768,    -3,-32768,-32768,
+-32768,    39,    84,-32768,-32768,-32768,-32768,    12,-32768,    63,
+   114,-32768,    96,-32768,-32768,-32768,   102,-32768,-32768,    94,
+   119,   120,     5,   121,   122,    -1,-32768,   123,   124,   118,
+-32768,   125,    -1,-32768,    35,   106,-32768,-32768,   127,-32768,
+-32768,   109,-32768,    83,-32768,    77,   111,-32768,    63,   -16,
+   126,-32768,-32768,     5,    94,     4,     8,-32768,   128,-32768,
+    63,   -13,   130,-32768,   129,-32768,   131,    -1,-32768,-32768,
+   132,   105,   108,   134,   133,   135,    31,-32768,-32768,-32768,
+    35,-32768,-32768,    86,   115,-32768,   112,   136,   137,-32768,
+-32768,-32768,    77,-32768,-32768,-32768,-32768,-32768,-32768,   -16,
+   141,-32768,    32,    26,-32768,     4,-32768,-32768,-32768,-32768,
+-32768,-32768,-32768,-32768,    91,-32768,   138,-32768,   -13,    33,
+    37,   139,   140,   142,   147,   149,   150,   151,   152,   153,
+-32768,   113,   146,   148,-32768,-32768,-32768,    86,   155,   157,
+   158,-32768,-32768,-32768,-32768,   144,   154,-32768,-32768,   160,
+-32768,-32768,     5,    24,-32768,-32768,-32768,-32768,-32768,-32768,
+   162,-32768,    37,-32768,   161,   164,-32768,   143,   171,   166,
+   167,   168,   169,   170,-32768,   172,   174,   179,-32768,-32768,
+-32768,-32768,    33,-32768,   175,-32768,-32768,-32768,-32768,-32768,
+-32768,-32768,   177,   180,   184,-32768,-32768,-32768,-32768,-32768,
+-32768,-32768,-32768,   188,   189,-32768
+};
+
+static const short yypgoto[] = {-32768,
+-32768,-32768,   145,-32768,-32768,   176,-32768,-32768,-32768,-32768,
+-32768,-32768,    80,   -74,-32768,-32768,-32768,   116,-32768,-32768,
+-32768,-32768,-32768,    27,-32768,-32768,-32768,-32768,-32768,    28,
+-32768,-32768,-32768,   156,-32768,-32768,-32768,    64,   -81,   -28,
+   -83,   110,   159,-32768,-32768,   163,   -45,-32768,-32768,-32768,
+-32768,-32768,-32768,-32768,-32768,   -20,-32768,    46,-32768,     6,
+   -19
+};
+
+
+#define	YYLAST		226
+
+
+static const short yytable[] = {    55,
+   131,   120,    45,   132,    29,    48,   138,    48,    63,   125,
+    90,    82,   139,    83,   135,    68,    83,   133,    84,   134,
+    70,    84,   126,   127,   128,   140,   141,    55,   177,   213,
+   142,   143,   144,   145,    55,   146,   147,    69,   214,   165,
+    48,    48,   178,    64,    65,   182,   175,    54,   120,    54,
+    -5,   176,    90,    99,   100,   101,   186,    10,   159,   124,
+   160,   102,   187,   103,    31,   104,   105,   106,     6,    55,
+    29,   137,    11,    34,    12,   188,   189,    33,    11,    35,
+    12,   -11,    36,   107,    13,   190,   191,    67,    14,    38,
+    13,    42,    15,   165,    14,    99,   100,    46,    15,   212,
+    73,    74,    48,   117,    99,   100,    75,    76,   118,   119,
+   110,   111,   162,   113,   114,   122,   123,   163,   164,   167,
+   168,   183,    71,    79,    88,    80,    94,    91,    82,    92,
+   112,   130,   154,    96,   135,   149,   151,   155,   179,   169,
+   202,   153,   150,   156,   193,   219,     5,   180,   194,   172,
+   157,   195,   158,   170,   171,   174,   196,   197,   209,   198,
+   199,   200,   201,   203,   206,   204,   207,   208,   211,   217,
+   210,   215,   218,   220,   221,   222,   227,   223,   224,   225,
+   226,   228,   232,   230,   183,   231,   233,   235,   236,   116,
+   161,    37,   229,   173,   181,   205,   136,     0,   216,     0,
+     0,     0,     0,     0,     0,    78,     0,     0,     0,     0,
+     0,     0,     0,    89,     0,     0,     0,     0,     0,     0,
+     0,     0,     0,     0,     0,    98
+};
+
+static const short yycheck[] = {    28,
+    84,    76,    22,    85,     8,     9,    20,     9,    28,    26,
+    56,     7,    26,     9,     7,     4,     9,    14,    14,    16,
+    40,    14,    39,    40,    41,    39,    40,    56,     3,     6,
+    44,    45,    46,    47,    63,    49,    50,    26,    15,   114,
+     9,     9,    17,     5,     6,    13,    15,    51,   123,    51,
+    26,   133,    98,    19,    20,    21,    20,     4,    28,    79,
+    30,    27,    26,    29,     9,    31,    32,    33,    26,    98,
+     8,    91,    22,     4,    24,    39,    40,    23,    22,     4,
+    24,    25,     4,    49,    34,    49,    50,     4,    38,    25,
+    34,     9,    42,   168,    38,    19,    20,     9,    42,   183,
+     5,     6,     9,    27,    19,    20,     5,     6,    32,    33,
+     5,     6,    27,     5,     6,     5,     6,    32,    33,     5,
+     6,   150,     9,     5,     4,     6,     9,     5,     7,     6,
+     4,     6,    28,     9,     7,     6,     6,    30,    48,    28,
+    28,    10,    14,    10,     6,     3,     2,    10,     9,   123,
+    18,    10,    18,    18,    18,    15,    10,     9,    15,    10,
+    10,    10,    10,    18,    10,    18,    10,    10,     9,     9,
+    17,    10,     9,     3,     9,     9,     3,    10,    10,    10,
+     9,     3,     3,     9,   213,     9,     3,     0,     0,    74,
+   111,    16,   213,   130,   149,   168,    87,    -1,   193,    -1,
+    -1,    -1,    -1,    -1,    -1,    50,    -1,    -1,    -1,    -1,
+    -1,    -1,    -1,    55,    -1,    -1,    -1,    -1,    -1,    -1,
+    -1,    -1,    -1,    -1,    -1,    63
+};
+/* -*-C-*-  Note some compilers choke on comments on `#line' lines.  */
+#line 3 "/emx/share/bison.simple"
+/* This file comes from bison-1.28.  */
+
+/* Skeleton output parser for bison,
+   Copyright (C) 1984, 1989, 1990 Free Software Foundation, Inc.
+
+   This program is free software; you can redistribute it and/or modify
+   it under the terms of the GNU General Public License as published by
+   the Free Software Foundation; either version 2, or (at your option)
+   any later version.
+
+   This program is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+   GNU General Public License for more details.
+
+   You should have received a copy of the GNU General Public License
+   along with this program; if not, write to the Free Software
+   Foundation, Inc., 59 Temple Place - Suite 330,
+   Boston, MA 02111-1307, USA.  */
+
+/* As a special exception, when this file is copied by Bison into a
+   Bison output file, you may use that output file without restriction.
+   This special exception was added by the Free Software Foundation
+   in version 1.24 of Bison.  */
+
+/* This is the parser code that is written into each bison parser
+  when the %semantic_parser declaration is not specified in the grammar.
+  It was written by Richard Stallman by simplifying the hairy parser
+  used when %semantic_parser is specified.  */
+
+#ifndef YYSTACK_USE_ALLOCA
+#ifdef alloca
+#define YYSTACK_USE_ALLOCA
+#else /* alloca not defined */
+#ifdef __GNUC__
+#define YYSTACK_USE_ALLOCA
+#define alloca __builtin_alloca
+#else /* not GNU C.  */
+#if (!defined (__STDC__) && defined (sparc)) || defined (__sparc__) || defined (__sparc) || defined (__sgi) || (defined (__sun) && defined (__i386))
+#define YYSTACK_USE_ALLOCA
+#include <alloca.h>
+#else /* not sparc */
+/* We think this test detects Watcom and Microsoft C.  */
+/* This used to test MSDOS, but that is a bad idea
+   since that symbol is in the user namespace.  */
+#if (defined (_MSDOS) || defined (_MSDOS_)) && !defined (__TURBOC__)
+#if 0 /* No need for malloc.h, which pollutes the namespace;
+	 instead, just don't use alloca.  */
+#include <malloc.h>
+#endif
+#else /* not MSDOS, or __TURBOC__ */
+#if defined(_AIX)
+/* I don't know what this was needed for, but it pollutes the namespace.
+   So I turned it off.   rms, 2 May 1997.  */
+/* #include <malloc.h>  */
+ #pragma alloca
+#define YYSTACK_USE_ALLOCA
+#else /* not MSDOS, or __TURBOC__, or _AIX */
+#include <malloc.h>
+#if 0
+#ifdef __hpux /* haible@ilog.fr says this works for HPUX 9.05 and up,
+		 and on HPUX 10.  Eventually we can turn this on.  */
+#define YYSTACK_USE_ALLOCA
+#define alloca __builtin_alloca
+#endif /* __hpux */
+#endif
+#endif /* not _AIX */
+#endif /* not MSDOS, or __TURBOC__ */
+#endif /* not sparc */
+#endif /* not GNU C */
+#endif /* alloca not defined */
+#endif /* YYSTACK_USE_ALLOCA not defined */
+
+#ifdef YYSTACK_USE_ALLOCA
+#define YYSTACK_ALLOC alloca
+#else
+#define YYSTACK_ALLOC malloc
+#endif
+
+/* Note: there must be only one dollar sign in this file.
+   It is replaced by the list of actions, each action
+   as one case of the switch.  */
+
+#define yyerrok		(yyerrstatus = 0)
+#define yyclearin	(yychar = YYEMPTY)
+#define YYEMPTY		-2
+#define YYEOF		0
+#define YYACCEPT	goto yyacceptlab
+#define YYABORT 	goto yyabortlab
+#define YYERROR		goto yyerrlab1
+/* Like YYERROR except do call yyerror.
+   This remains here temporarily to ease the
+   transition to the new meaning of YYERROR, for GCC.
+   Once GCC version 2 has supplanted version 1, this can go.  */
+#define YYFAIL		goto yyerrlab
+#define YYRECOVERING()  (!!yyerrstatus)
+#define YYBACKUP(token, value) \
+do								\
+  if (yychar == YYEMPTY && yylen == 1)				\
+    { yychar = (token), yylval = (value);			\
+      yychar1 = YYTRANSLATE (yychar);				\
+      YYPOPSTACK;						\
+      goto yybackup;						\
+    }								\
+  else								\
+    { yyerror ("syntax error: cannot back up"); YYERROR; }	\
+while (0)
+
+#define YYTERROR	1
+#define YYERRCODE	256
+
+#ifndef YYPURE
+#define YYLEX		yylex()
+#endif
+
+#ifdef YYPURE
+#ifdef YYLSP_NEEDED
+#ifdef YYLEX_PARAM
+#define YYLEX		yylex(&yylval, &yylloc, YYLEX_PARAM)
+#else
+#define YYLEX		yylex(&yylval, &yylloc)
+#endif
+#else /* not YYLSP_NEEDED */
+#ifdef YYLEX_PARAM
+#define YYLEX		yylex(&yylval, YYLEX_PARAM)
+#else
+#define YYLEX		yylex(&yylval)
+#endif
+#endif /* not YYLSP_NEEDED */
+#endif
+
+/* If nonreentrant, generate the variables here */
+
+#ifndef YYPURE
+
+int	yychar;			/*  the lookahead symbol		*/
+YYSTYPE	yylval;			/*  the semantic value of the		*/
+				/*  lookahead symbol			*/
+
+#ifdef YYLSP_NEEDED
+YYLTYPE yylloc;			/*  location data for the lookahead	*/
+				/*  symbol				*/
+#endif
+
+int yynerrs;			/*  number of parse errors so far       */
+#endif  /* not YYPURE */
+
+#if YYDEBUG != 0
+int yydebug;			/*  nonzero means print parse trace	*/
+/* Since this is uninitialized, it does not stop multiple parsers
+   from coexisting.  */
+#endif
+
+/*  YYINITDEPTH indicates the initial size of the parser's stacks	*/
+
+#ifndef	YYINITDEPTH
+#define YYINITDEPTH 200
+#endif
+
+/*  YYMAXDEPTH is the maximum size the stacks can grow to
+    (effective only if the built-in stack extension method is used).  */
+
+#if YYMAXDEPTH == 0
+#undef YYMAXDEPTH
+#endif
+
+#ifndef YYMAXDEPTH
+#define YYMAXDEPTH 10000
+#endif
+
+/* Define __yy_memcpy.  Note that the size argument
+   should be passed with type unsigned int, because that is what the non-GCC
+   definitions require.  With GCC, __builtin_memcpy takes an arg
+   of type size_t, but it can handle unsigned int.  */
+
+#if __GNUC__ > 1		/* GNU C and GNU C++ define this.  */
+#define __yy_memcpy(TO,FROM,COUNT)	__builtin_memcpy(TO,FROM,COUNT)
+#else				/* not GNU C or C++ */
+#ifndef __cplusplus
+
+/* This is the most reliable way to avoid incompatibilities
+   in available built-in functions on various systems.  */
+static void
+__yy_memcpy (to, from, count)
+     char *to;
+     char *from;
+     unsigned int count;
+{
+  register char *f = from;
+  register char *t = to;
+  register int i = count;
+
+  while (i-- > 0)
+    *t++ = *f++;
+}
+
+#else /* __cplusplus */
+
+/* This is the most reliable way to avoid incompatibilities
+   in available built-in functions on various systems.  */
+static void
+__yy_memcpy (char *to, char *from, unsigned int count)
+{
+  register char *t = to;
+  register char *f = from;
+  register int i = count;
+
+  while (i-- > 0)
+    *t++ = *f++;
+}
+
+#endif
+#endif
+
+#line 217 "/emx/share/bison.simple"
+
+/* The user can define YYPARSE_PARAM as the name of an argument to be passed
+   into yyparse.  The argument should have type void *.
+   It should actually point to an object.
+   Grammar actions can access the variable by casting it
+   to the proper pointer type.  */
+
+#ifdef YYPARSE_PARAM
+#ifdef __cplusplus
+#define YYPARSE_PARAM_ARG void *YYPARSE_PARAM
+#define YYPARSE_PARAM_DECL
+#else /* not __cplusplus */
+#define YYPARSE_PARAM_ARG YYPARSE_PARAM
+#define YYPARSE_PARAM_DECL void *YYPARSE_PARAM;
+#endif /* not __cplusplus */
+#else /* not YYPARSE_PARAM */
+#define YYPARSE_PARAM_ARG
+#define YYPARSE_PARAM_DECL
+#endif /* not YYPARSE_PARAM */
+
+/* Prevent warning if -Wstrict-prototypes.  */
+#ifdef __GNUC__
+#ifdef YYPARSE_PARAM
+int yyparse (void *);
+#else
+int yyparse (void);
+#endif
+#endif
+
+int
+yyparse(YYPARSE_PARAM_ARG)
+     YYPARSE_PARAM_DECL
+{
+  register int yystate;
+  register int yyn;
+  register short *yyssp;
+  register YYSTYPE *yyvsp;
+  int yyerrstatus;	/*  number of tokens to shift before error messages enabled */
+  int yychar1 = 0;		/*  lookahead token as an internal (translated) token number */
+
+  short	yyssa[YYINITDEPTH];	/*  the state stack			*/
+  YYSTYPE yyvsa[YYINITDEPTH];	/*  the semantic value stack		*/
+
+  short *yyss = yyssa;		/*  refer to the stacks thru separate pointers */
+  YYSTYPE *yyvs = yyvsa;	/*  to allow yyoverflow to reallocate them elsewhere */
+
+#ifdef YYLSP_NEEDED
+  YYLTYPE yylsa[YYINITDEPTH];	/*  the location stack			*/
+  YYLTYPE *yyls = yylsa;
+  YYLTYPE *yylsp;
+
+#define YYPOPSTACK   (yyvsp--, yyssp--, yylsp--)
+#else
+#define YYPOPSTACK   (yyvsp--, yyssp--)
+#endif
+
+  int yystacksize = YYINITDEPTH;
+  int yyfree_stacks = 0;
+
+#ifdef YYPURE
+  int yychar;
+  YYSTYPE yylval;
+  int yynerrs;
+#ifdef YYLSP_NEEDED
+  YYLTYPE yylloc;
+#endif
+#endif
+
+  YYSTYPE yyval;		/*  the variable used to return		*/
+				/*  semantic values from the action	*/
+				/*  routines				*/
+
+  int yylen;
+
+#if YYDEBUG != 0
+  if (yydebug)
+    fprintf(stderr, "Starting parse\n");
+#endif
+
+  yystate = 0;
+  yyerrstatus = 0;
+  yynerrs = 0;
+  yychar = YYEMPTY;		/* Cause a token to be read.  */
+
+  /* Initialize stack pointers.
+     Waste one element of value and location stack
+     so that they stay on the same level as the state stack.
+     The wasted elements are never initialized.  */
+
+  yyssp = yyss - 1;
+  yyvsp = yyvs;
+#ifdef YYLSP_NEEDED
+  yylsp = yyls;
+#endif
+
+/* Push a new state, which is found in  yystate  .  */
+/* In all cases, when you get here, the value and location stacks
+   have just been pushed. so pushing a state here evens the stacks.  */
+yynewstate:
+
+  *++yyssp = yystate;
+
+  if (yyssp >= yyss + yystacksize - 1)
+    {
+      /* Give user a chance to reallocate the stack */
+      /* Use copies of these so that the &'s don't force the real ones into memory. */
+      YYSTYPE *yyvs1 = yyvs;
+      short *yyss1 = yyss;
+#ifdef YYLSP_NEEDED
+      YYLTYPE *yyls1 = yyls;
+#endif
+
+      /* Get the current used size of the three stacks, in elements.  */
+      int size = yyssp - yyss + 1;
+
+#ifdef yyoverflow
+      /* Each stack pointer address is followed by the size of
+	 the data in use in that stack, in bytes.  */
+#ifdef YYLSP_NEEDED
+      /* This used to be a conditional around just the two extra args,
+	 but that might be undefined if yyoverflow is a macro.  */
+      yyoverflow("parser stack overflow",
+		 &yyss1, size * sizeof (*yyssp),
+		 &yyvs1, size * sizeof (*yyvsp),
+		 &yyls1, size * sizeof (*yylsp),
+		 &yystacksize);
+#else
+      yyoverflow("parser stack overflow",
+		 &yyss1, size * sizeof (*yyssp),
+		 &yyvs1, size * sizeof (*yyvsp),
+		 &yystacksize);
+#endif
+
+      yyss = yyss1; yyvs = yyvs1;
+#ifdef YYLSP_NEEDED
+      yyls = yyls1;
+#endif
+#else /* no yyoverflow */
+      /* Extend the stack our own way.  */
+      if (yystacksize >= YYMAXDEPTH)
+	{
+	  yyerror("parser stack overflow");
+	  if (yyfree_stacks)
+	    {
+	      free (yyss);
+	      free (yyvs);
+#ifdef YYLSP_NEEDED
+	      free (yyls);
+#endif
+	    }
+	  return 2;
+	}
+      yystacksize *= 2;
+      if (yystacksize > YYMAXDEPTH)
+	yystacksize = YYMAXDEPTH;
+#ifndef YYSTACK_USE_ALLOCA
+      yyfree_stacks = 1;
+#endif
+      yyss = (short *) YYSTACK_ALLOC (yystacksize * sizeof (*yyssp));
+      __yy_memcpy ((char *)yyss, (char *)yyss1,
+		   size * (unsigned int) sizeof (*yyssp));
+      yyvs = (YYSTYPE *) YYSTACK_ALLOC (yystacksize * sizeof (*yyvsp));
+      __yy_memcpy ((char *)yyvs, (char *)yyvs1,
+		   size * (unsigned int) sizeof (*yyvsp));
+#ifdef YYLSP_NEEDED
+      yyls = (YYLTYPE *) YYSTACK_ALLOC (yystacksize * sizeof (*yylsp));
+      __yy_memcpy ((char *)yyls, (char *)yyls1,
+		   size * (unsigned int) sizeof (*yylsp));
+#endif
+#endif /* no yyoverflow */
+
+      yyssp = yyss + size - 1;
+      yyvsp = yyvs + size - 1;
+#ifdef YYLSP_NEEDED
+      yylsp = yyls + size - 1;
+#endif
+
+#if YYDEBUG != 0
+      if (yydebug)
+	fprintf(stderr, "Stack size increased to %d\n", yystacksize);
+#endif
+
+      if (yyssp >= yyss + yystacksize - 1)
+	YYABORT;
+    }
+
+#if YYDEBUG != 0
+  if (yydebug)
+    fprintf(stderr, "Entering state %d\n", yystate);
+#endif
+
+  goto yybackup;
+ yybackup:
+
+/* Do appropriate processing given the current state.  */
+/* Read a lookahead token if we need one and don't already have one.  */
+/* yyresume: */
+
+  /* First try to decide what to do without reference to lookahead token.  */
+
+  yyn = yypact[yystate];
+  if (yyn == YYFLAG)
+    goto yydefault;
+
+  /* Not known => get a lookahead token if don't already have one.  */
+
+  /* yychar is either YYEMPTY or YYEOF
+     or a valid token in external form.  */
+
+  if (yychar == YYEMPTY)
+    {
+#if YYDEBUG != 0
+      if (yydebug)
+	fprintf(stderr, "Reading a token: ");
+#endif
+      yychar = YYLEX;
+    }
+
+  /* Convert token to internal form (in yychar1) for indexing tables with */
+
+  if (yychar <= 0)		/* This means end of input. */
+    {
+      yychar1 = 0;
+      yychar = YYEOF;		/* Don't call YYLEX any more */
+
+#if YYDEBUG != 0
+      if (yydebug)
+	fprintf(stderr, "Now at end of input.\n");
+#endif
+    }
+  else
+    {
+      yychar1 = YYTRANSLATE(yychar);
+
+#if YYDEBUG != 0
+      if (yydebug)
+	{
+	  fprintf (stderr, " Next token is %d (%s", yychar, yytname[yychar1]);
+	  /* Give the individual parser a way to print the precise meaning
+	     of a token, for further debugging info.  */
+#ifdef YYPRINT
+	  YYPRINT (stderr, yychar, yylval);
+#endif
+	  fprintf (stderr, ")\n");
+	}
+#endif
+    }
+
+  yyn += yychar1;
+  if (yyn < 0 || yyn > YYLAST || yycheck[yyn] != yychar1)
+    goto yydefault;
+
+  yyn = yytable[yyn];
+
+  /* yyn is what to do for this token type in this state.
+     Negative => reduce, -yyn is rule number.
+     Positive => shift, yyn is new state.
+       New state is final state => don't bother to shift,
+       just return success.
+     0, or most negative number => error.  */
+
+  if (yyn < 0)
+    {
+      if (yyn == YYFLAG)
+	goto yyerrlab;
+      yyn = -yyn;
+      goto yyreduce;
+    }
+  else if (yyn == 0)
+    goto yyerrlab;
+
+  if (yyn == YYFINAL)
+    YYACCEPT;
+
+  /* Shift the lookahead token.  */
+
+#if YYDEBUG != 0
+  if (yydebug)
+    fprintf(stderr, "Shifting token %d (%s), ", yychar, yytname[yychar1]);
+#endif
+
+  /* Discard the token being shifted unless it is eof.  */
+  if (yychar != YYEOF)
+    yychar = YYEMPTY;
+
+  *++yyvsp = yylval;
+#ifdef YYLSP_NEEDED
+  *++yylsp = yylloc;
+#endif
+
+  /* count tokens shifted since error; after three, turn off error status.  */
+  if (yyerrstatus) yyerrstatus--;
+
+  yystate = yyn;
+  goto yynewstate;
+
+/* Do the default action for the current state.  */
+yydefault:
+
+  yyn = yydefact[yystate];
+  if (yyn == 0)
+    goto yyerrlab;
+
+/* Do a reduction.  yyn is the number of a rule to reduce with.  */
+yyreduce:
+  yylen = yyr2[yyn];
+  if (yylen > 0)
+    yyval = yyvsp[1-yylen]; /* implement default value of the action */
+
+#if YYDEBUG != 0
+  if (yydebug)
+    {
+      int i;
+
+      fprintf (stderr, "Reducing via rule %d (line %d), ",
+	       yyn, yyrline[yyn]);
+
+      /* Print the symbols being reduced, and their result.  */
+      for (i = yyprhs[yyn]; yyrhs[i] > 0; i++)
+	fprintf (stderr, "%s ", yytname[yyrhs[i]]);
+      fprintf (stderr, " -> %s\n", yytname[yyr1[yyn]]);
+    }
+#endif
+
+
+  switch (yyn) {
+
+case 1:
+#line 59 "gramma.yy"
+{
+			if (somtg_f.verbose) printf("Parsing of \"%s\" started.\n", somtfilePath);
+			somtg_f._ERROR=0;   /* @todo subject to move to parse() */
+			somtg_f.WARN=0;   /* @todo subject to move to parse() */
+			somtg_f.FATAL=0;   /* @todo subject to move to parse() */
+			somtg_f.INTERNAL=0;   /* @todo subject to move to parse() */
+			somtg_buf=somtsmallocSL(somtg_f.commentsize, TRUE);   /* @todo subject to move to parse() */
+		;
+    break;}
+case 2:
+#line 68 "gramma.yy"
+{
+			somtfree(somtg_buf);   /* @todo subject to move to parse() */
+			if (somtg_f.verbose) printf("Parsing of \"%s\" finished.\n", somtfilePath);
+		;
+    break;}
+case 5:
+#line 81 "gramma.yy"
+{
+			cls=(Entry *)somtsmallocSL(sizeof(Entry), TRUE);
+			cls->atts=somtaddModifierSL(cls->atts, "callstyle", "oidl");
+			cls->type=SOMTClassE;
+			somtclassIdlCall=FALSE;
+			cls->u.c.file=strdup(somtfilePath);
+		;
+    break;}
+case 6:
+#line 89 "gramma.yy"
+{
+			somtaddEntrySL(somtstab, cls->name, cls);
+			somtfree(cls);
+		;
+    break;}
+case 11:
+#line 104 "gramma.yy"
+{
+			pcls=(Entry *)somtsmallocSL(sizeof(Entry), TRUE);
+			pcls->atts=somtaddModifierSL(pcls->atts, "callstyle", "oidl");
+			pcls->type=SOMTBaseE;
+			somtclassIdlCall=FALSE;
+//			pcls->u.c.file=strdup(somtfilePath);
+		;
+    break;}
+case 12:
+#line 112 "gramma.yy"
+{
+			cls->u.c.parent=somtaddEntrySL(somtstab, pcls->name, pcls);
+			somtfree(pcls);
+		;
+    break;}
+case 17:
+#line 124 "gramma.yy"
+{
+			cls->comment=yyvsp[0].stval;
+		;
+    break;}
+case 21:
+#line 140 "gramma.yy"
+{
+			somtclassName=yyvsp[0].stval;
+			cls->lineno=lineno;                 
+			cls->name=yyvsp[0].stval;
+		;
+    break;}
+case 24:
+#line 154 "gramma.yy"
+{
+			cls->atts=somtaddModifierSL(cls->atts, "filestem", yyvsp[0].stval);
+		;
+    break;}
+case 25:
+#line 158 "gramma.yy"
+{
+			cls->atts=somtaddModifierSL(cls->atts, "externalstem", yyvsp[0].stval);
+		;
+    break;}
+case 26:
+#line 162 "gramma.yy"
+{
+			cls->atts=somtaddModifierSL(cls->atts, "functionprefix", yyvsp[0].stval);
+		;
+    break;}
+case 27:
+#line 166 "gramma.yy"
+{
+			cls->atts=somtaddModifierSL(cls->atts, "externalprefix", yyvsp[0].stval);
+		;
+    break;}
+case 28:
+#line 170 "gramma.yy"
+{
+			cls->atts=somtaddModifierSL(cls->atts, "classprefix", yyvsp[0].stval);
+		;
+    break;}
+case 29:
+#line 174 "gramma.yy"
+{
+			char *st=itoa(yyvsp[0].ival, somtsmallocSL(_MAX_ITOSTR_BASE10_COUNT, TRUE), 10);
+			cls->atts=somtaddModifierSL(cls->atts, "majorversion", st);
+			somtmajorVersion=strdup(st);
+			somtfree(st);
+		;
+    break;}
+case 30:
+#line 181 "gramma.yy"
+{
+			char *st=itoa(yyvsp[0].ival, somtsmallocSL(_MAX_ITOSTR_BASE10_COUNT, TRUE), 10);
+			cls->atts=somtaddModifierSL(cls->atts, "minorversion", st);
+			somtminorVersion=strdup(st);
+			somtfree(st);
+		;
+    break;}
+case 31:
+#line 188 "gramma.yy"
+{
+			cls->atts=somtaddModifierSL(cls->atts, "classInit", yyvsp[0].stval);
+		;
+    break;}
+case 35:
+#line 201 "gramma.yy"
+{
+			cls->atts=somtaddModifierSL(cls->atts, "releaseorder", yyvsp[-1].stval);
+		;
+    break;}
+case 37:
+#line 212 "gramma.yy"
+{ 
+			yyval.stval=strdup(yyvsp[0].stval);
+		;
+    break;}
+case 38:
+#line 216 "gramma.yy"
+{
+			char *r=somtsmallocSL(strlen(yyvsp[-2].stval)+strlen(yyvsp[0].stval)+2, TRUE);
+			strcat(strcat(strcat(r, yyvsp[-2].stval), ","), yyvsp[0].stval);
+			yyval.stval=strdup(r);
+			somtfree(r);
+		;
+    break;}
+case 39:
+#line 226 "gramma.yy"
+{
+			cls->u.c.release=somtaddModifierSL(cls->u.c.release, yyvsp[0].stval, NULL);
+			yyval.stval=yyvsp[0].stval;
+		;
+    break;}
+case 41:
+#line 235 "gramma.yy"
+{
+			mcls->comment=yyvsp[0].stval;
+		;
+    break;}
+case 53:
+#line 268 "gramma.yy"
+{
+			pcls->comment=yyvsp[0].stval;
+		;
+    break;}
+case 58:
+#line 286 "gramma.yy"
+{
+			pcls->lineno=lineno;  // @todo line of class definition?
+			pcls->name=yyvsp[0].stval;
+		;
+    break;}
+case 71:
+#line 324 "gramma.yy"
+{
+//			cls->comment=$<stval>2;
+		;
+    break;}
+case 82:
+#line 353 "gramma.yy"
+{
+			yyval.stval=yyvsp[0].stval;
+		;
+    break;}
+case 85:
+#line 364 "gramma.yy"
+{printf("$<stval>1");;
+    break;}
+case 91:
+#line 374 "gramma.yy"
+{
+			yyval.stval=yyvsp[0].stval;
+		;
+    break;}
+case 92:
+#line 378 "gramma.yy"
+{
+			char *r=somtsmallocSL(strlen(yyvsp[-1].stval)+strlen(yyvsp[0].stval)+1, TRUE);
+			strcat(r, yyvsp[-1].stval);
+			strcat(r, yyvsp[0].stval);
+			free(yyvsp[-1].stval);
+			yyval.stval=strdup(r);
+			somtfree(r);
+		;
+    break;}
+case 94:
+#line 392 "gramma.yy"
+{
+			e.comment=yyvsp[-1].stval;
+		;
+    break;}
+case 96:
+#line 403 "gramma.yy"
+{
+			cls->u.c.methodcnt++;
+			somtaddEntrySL(somtstab, e.name, &e);
+			memset(&e, 0, sizeof(Entry));
+		;
+    break;}
+case 97:
+#line 409 "gramma.yy"
+{
+			cls->u.c.methodcnt++;
+			somtaddEntrySL(somtstab, e.name, &e);
+			memset(&e, 0, sizeof(Entry));
+		;
+    break;}
+case 103:
+#line 429 "gramma.yy"
+{
+			e.u.m.type=strdup(yyvsp[-4].stval);
+		;
+    break;}
+case 104:
+#line 436 "gramma.yy"
+{
+			e.type=SOMTNewMethodE;
+			e.lineno=lineno;
+			e.name=yyvsp[0].stval;
+			e.sname=&somtclassName;
+			char * desc=somtsmallocSL(MAX_DESCRIPTOR_LENGTH, TRUE);
+			strcat(desc, "::");
+			strcat(desc, yyvsp[0].stval);
+			strcat(desc, "::");
+			strcat(desc, somtclassName);
+			e.atts=somtaddModifierSL(e.atts, "descriptor", desc);
+			somtfree(desc);
+		;
+    break;}
+case 105:
+#line 453 "gramma.yy"
+{
+			yyval.stval=yyvsp[0].stval;
+		;
+    break;}
+case 106:
+#line 457 "gramma.yy"
+{
+			char *r=somtsmallocSL(strlen(yyvsp[-1].stval)+strlen(yyvsp[0].stval)+1, TRUE);
+			strcat(r, yyvsp[-1].stval);
+			strcat(r, yyvsp[0].stval);
+			free(yyvsp[-1].stval);
+			yyval.stval=strdup(r);
+			somtfree(r);
+		;
+    break;}
+case 111:
+#line 479 "gramma.yy"
+{
+			e.type=SOMTOverrideMethodE;
+			e.lineno=lineno;
+			e.name=yyvsp[0].stval;
+			e.sname=&somtclassName;
+			char * desc=somtsmallocSL(MAX_DESCRIPTOR_LENGTH, TRUE);
+			strcat(strcat(strcat(strcat(desc ,"::"), yyvsp[0].stval), "::"), somtclassName);
+			e.atts=somtaddModifierSL(e.atts, "descriptor", desc);
+			somtfree(desc);
+		;
+    break;}
+case 136:
+#line 539 "gramma.yy"
+{
+			yyval.stval=yyvsp[0].stval;
+		;
+    break;}
+}
+   /* the action file gets copied in in place of this dollarsign */
+#line 543 "/emx/share/bison.simple"
+
+  yyvsp -= yylen;
+  yyssp -= yylen;
+#ifdef YYLSP_NEEDED
+  yylsp -= yylen;
+#endif
+
+#if YYDEBUG != 0
+  if (yydebug)
+    {
+      short *ssp1 = yyss - 1;
+      fprintf (stderr, "state stack now");
+      while (ssp1 != yyssp)
+	fprintf (stderr, " %d", *++ssp1);
+      fprintf (stderr, "\n");
+    }
+#endif
+
+  *++yyvsp = yyval;
+
+#ifdef YYLSP_NEEDED
+  yylsp++;
+  if (yylen == 0)
+    {
+      yylsp->first_line = yylloc.first_line;
+      yylsp->first_column = yylloc.first_column;
+      yylsp->last_line = (yylsp-1)->last_line;
+      yylsp->last_column = (yylsp-1)->last_column;
+      yylsp->text = 0;
+    }
+  else
+    {
+      yylsp->last_line = (yylsp+yylen-1)->last_line;
+      yylsp->last_column = (yylsp+yylen-1)->last_column;
+    }
+#endif
+
+  /* Now "shift" the result of the reduction.
+     Determine what state that goes to,
+     based on the state we popped back to
+     and the rule number reduced by.  */
+
+  yyn = yyr1[yyn];
+
+  yystate = yypgoto[yyn - YYNTBASE] + *yyssp;
+  if (yystate >= 0 && yystate <= YYLAST && yycheck[yystate] == *yyssp)
+    yystate = yytable[yystate];
+  else
+    yystate = yydefgoto[yyn - YYNTBASE];
+
+  goto yynewstate;
+
+yyerrlab:   /* here on detecting error */
+
+  if (! yyerrstatus)
+    /* If not already recovering from an error, report this error.  */
+    {
+      ++yynerrs;
+
+#ifdef YYERROR_VERBOSE
+      yyn = yypact[yystate];
+
+      if (yyn > YYFLAG && yyn < YYLAST)
+	{
+	  int size = 0;
+	  char *msg;
+	  int x, count;
+
+	  count = 0;
+	  /* Start X at -yyn if nec to avoid negative indexes in yycheck.  */
+	  for (x = (yyn < 0 ? -yyn : 0);
+	       x < (sizeof(yytname) / sizeof(char *)); x++)
+	    if (yycheck[x + yyn] == x)
+	      size += strlen(yytname[x]) + 15, count++;
+	  msg = (char *) malloc(size + 15);
+	  if (msg != 0)
+	    {
+	      strcpy(msg, "parse error");
+
+	      if (count < 5)
+		{
+		  count = 0;
+		  for (x = (yyn < 0 ? -yyn : 0);
+		       x < (sizeof(yytname) / sizeof(char *)); x++)
+		    if (yycheck[x + yyn] == x)
+		      {
+			strcat(msg, count == 0 ? ", expecting `" : " or `");
+			strcat(msg, yytname[x]);
+			strcat(msg, "'");
+			count++;
+		      }
+		}
+	      yyerror(msg);
+	      free(msg);
+	    }
+	  else
+	    yyerror ("parse error; also virtual memory exceeded");
+	}
+      else
+#endif /* YYERROR_VERBOSE */
+	yyerror("parse error");
+    }
+
+  goto yyerrlab1;
+yyerrlab1:   /* here on error raised explicitly by an action */
+
+  if (yyerrstatus == 3)
+    {
+      /* if just tried and failed to reuse lookahead token after an error, discard it.  */
+
+      /* return failure if at end of input */
+      if (yychar == YYEOF)
+	YYABORT;
+
+#if YYDEBUG != 0
+      if (yydebug)
+	fprintf(stderr, "Discarding token %d (%s).\n", yychar, yytname[yychar1]);
+#endif
+
+      yychar = YYEMPTY;
+    }
+
+  /* Else will try to reuse lookahead token
+     after shifting the error token.  */
+
+  yyerrstatus = 3;		/* Each real token shifted decrements this */
+
+  goto yyerrhandle;
+
+yyerrdefault:  /* current state does not do anything special for the error token. */
+
+#if 0
+  /* This is wrong; only states that explicitly want error tokens
+     should shift them.  */
+  yyn = yydefact[yystate];  /* If its default is to accept any token, ok.  Otherwise pop it.*/
+  if (yyn) goto yydefault;
+#endif
+
+yyerrpop:   /* pop the current state because it cannot handle the error token */
+
+  if (yyssp == yyss) YYABORT;
+  yyvsp--;
+  yystate = *--yyssp;
+#ifdef YYLSP_NEEDED
+  yylsp--;
+#endif
+
+#if YYDEBUG != 0
+  if (yydebug)
+    {
+      short *ssp1 = yyss - 1;
+      fprintf (stderr, "Error: state stack now");
+      while (ssp1 != yyssp)
+	fprintf (stderr, " %d", *++ssp1);
+      fprintf (stderr, "\n");
+    }
+#endif
+
+yyerrhandle:
+
+  yyn = yypact[yystate];
+  if (yyn == YYFLAG)
+    goto yyerrdefault;
+
+  yyn += YYTERROR;
+  if (yyn < 0 || yyn > YYLAST || yycheck[yyn] != YYTERROR)
+    goto yyerrdefault;
+
+  yyn = yytable[yyn];
+  if (yyn < 0)
+    {
+      if (yyn == YYFLAG)
+	goto yyerrpop;
+      yyn = -yyn;
+      goto yyreduce;
+    }
+  else if (yyn == 0)
+    goto yyerrpop;
+
+  if (yyn == YYFINAL)
+    YYACCEPT;
+
+#if YYDEBUG != 0
+  if (yydebug)
+    fprintf(stderr, "Shifting error token, ");
+#endif
+
+  *++yyvsp = yylval;
+#ifdef YYLSP_NEEDED
+  *++yylsp = yylloc;
+#endif
+
+  yystate = yyn;
+  goto yynewstate;
+
+ yyacceptlab:
+  /* YYACCEPT comes here.  */
+  if (yyfree_stacks)
+    {
+      free (yyss);
+      free (yyvs);
+#ifdef YYLSP_NEEDED
+      free (yyls);
+#endif
+    }
+  return 0;
+
+ yyabortlab:
+  /* YYABORT comes here.  */
+  if (yyfree_stacks)
+    {
+      free (yyss);
+      free (yyvs);
+#ifdef YYLSP_NEEDED
+      free (yyls);
+#endif
+    }
+  return 1;
+}
+#line 544 "gramma.yy"
+
+
+FILE *yyin;
+
+// Experimental replacement of somttype
+char * mysomttype(SOMTTypes ttype)
+{
+  char * result=NULL;
+  switch ( ttype )
+  {
+    case SOMTAnyBE:
+      result="SOMTAnyBE";
+      break;
+    case     SOMTArgumentE:
+      result="SOMTArgumentE";
+      break;
+    case     SOMTAttE:
+      result="SOMTAttE";
+      break;
+    case     SOMTBadEntryE:
+      result="SOMTBadEntryE";
+      break;
+    case     SOMTBaseE:
+      result="SOMTBaseE";
+      break;
+    case     SOMTBooleanBE:
+      result="SOMTBooleanBE";
+      break;
+    case     SOMTCaseEntryE:
+      result="SOMTCaseEntryE";
+      break;
+    case     SOMTCaseListE:
+      result="SOMTCaseListE";
+      break;
+    case     SOMTCaseSTME:
+      result="SOMTCaseSTME";
+      break;
+    case     SOMTCharBE:
+      result="SOMTCharBE";
+      break;
+    case     SOMTClassE:
+      result="SOMTClassE";
+      break;
+    case     SOMTConstE:
+      result="SOMTConstE";
+      break;
+    case     SOMTCopyrightE:
+      result="SOMTCopyrightE";
+      break;
+    case     SOMTDataE:
+      result="SOMTDataE";
+      break;
+    case     SOMTDclListE:
+      result="SOMTDclListE";
+      break;
+    case     SOMTDefaultE:
+      result="SOMTDefaultE";
+      break;
+    case     SOMTDoubleBE:
+      result="SOMTDoubleBE";
+      break;
+    case     SOMTEBaseE:
+      result="SOMTEBaseE";
+      break;
+    case     SOMTEEnumE:
+      result="SOMTEEnumE";
+      break;
+    case     SOMTEnumBE:
+      result="SOMTEnumBE";
+      break;
+    case     SOMTEnumE:
+      result="SOMTEnumE";
+      break;
+    case     SOMTEnumPE:
+      result="SOMTEnumPE";
+      break;
+    case     SOMTFloatBE:
+      result="SOMTFloatBE";
+      break;
+    case     SOMTGroupE:
+      result="SOMTGroupE";
+      break;
+    case     SOMTLongBE:
+      result="SOMTLongBE";
+      break;
+    case     SOMTMetaE:
+      result="SOMTMetaE";
+      break;
+    case     SOMTModuleE:
+      result="SOMTModuleE";
+      break;
+    case     SOMTNegativeBE:
+      result="SOMTNegativeBE";
+      break;
+    case     SOMTNewMethodE:
+      result="SOMTNewMethodE";
+      break;
+    case     SOMTOctetBE:
+      result="SOMTOctetBE";
+      break;
+    case     SOMTOverriddenMethodE:
+      result="SOMTOverriddenMethodE";
+      break;
+    case     SOMTOverrideMethodE:
+      result="SOMTOverrideMethodE";
+      break;
+    case     SOMTPassthruE:
+      result="SOMTPassthruE";
+      break;
+    case     SOMTSequenceE:
+      result="SOMTSequenceE";
+      break;
+    case     SOMTSequenceTDE:
+      result="SOMTSequenceTDE";
+      break;
+    case     SOMTShortBE:
+      result="SOMTShortBE";
+      break;
+    case     SOMTStringBE:
+      result="SOMTStringBE";
+      break;
+    case     SOMTStringE:
+      result="SOMTStringE";
+      break;
+    case     SOMTStructE:
+      result="SOMTStructE";
+      break;
+    case     SOMTStructPE:
+      result="SOMTStructPE";
+      break;
+    case     SOMTStructSE:
+      result="SOMTStructSE";
+      break;
+    case     SOMTTyDclE:
+      result="SOMTTyDclE";
+      break;
+    case     SOMTTypeCodeBE:
+      result="SOMTTypeCodeBE";
+      break;
+    case     SOMTTypedefBE:
+      result="SOMTTypedefBE";
+      break;
+    case     SOMTTypedefE:
+      result="SOMTTypedefE";
+      break;
+    case     SOMTUnionE:
+      result="SOMTUnionE";
+      break;
+    case     SOMTUnionPE:
+      result="SOMTUnionPE";
+      break;
+    case     SOMTUnionSE:
+      result="SOMTUnionSE";
+      break;
+    case     SOMTUnsignedLongBE:
+      result="SOMTUnsignedLongBE";
+      break;
+    case     SOMTUnsignedShortBE:
+      result="SOMTUnsignedShortBE";
+      break;
+    case     SOMTVoidBE:
+      result="SOMTVoidBE";
+      break;
+    case     SOMTVoidPtrBE:
+      result="SOMTVoidPtrBE";
+      break;
+// This is special case SOMTTypes used on call of emitter start and emitter end
+/*    case     SOMTEmitterBeginE:
+      result="SOMTEmitterBeginE";
+      break;
+    case     SOMTEmitterEndE:
+      result="SOMTEmitterEndE";
+      break; */
+    default:
+      printf("Unknown entry type: %d.\n", ttype);
+  }
+  return result;
+}
+
+void dumpReleaseOrder(char * name, AttList *ap)
+{
+  AttList *cur=ap;
+
+  for(; cur; cur = cur->next) 
+  {
+    printf("\t%s %s\n", name, cur->name);
+//    dumpAttrs("static", cur->staticlist);
+//    dumpAttrs("protectted", cur->protectedlist);
+//    dumpAttrs("public", cur->publiclist);
+//    dumpAttrs("private", cur->privatelist);
+  }
+}
+
+void dumpMethodOrData(Entry * ep)
+{
+  printf("\teptype = %08p\n", ep->u.m.eptype);
+  printf("\tptrs = %08p\n", ep->u.m.ptrs);
+  printf("\tarray = %08p\n", ep->u.m.array);
+  printf("\tarrays = %s\n", ep->u.m.arrays);
+  printf("\tdefn = %s\n", ep->u.m.defn);
+  printf("\ttype = %s\n", ep->u.m.type);
+  printf("\tvarargs = %s\n", ep->u.m.varargs ? "true" : "false");
+  printf("\tprivate = %s\n", ep->u.m.isprivate ? "true" : "false");
+  printf("\tinout = %d\n", ep->u.m.inoutmode);
+  printf("\tselfref = %s\n", ep->u.m.isselfref ? "true" : "false");
+  printf("\toneway = %s\n", ep->u.m.isoneway ? "true" : "false");
+  printf("\targcnt = %d\n", ep->u.m.argcnt);
+  printf("\targs = %08p\n", ep->u.m.args);
+  printf("\tomethod = %08p\n", ep->u.m.omethod);
+  printf("\toparent = %08p\n", ep->u.m.oparent);
+  printf("\tgroup = %08p\n", ep->u.m.group);
+  printf("\tnext = %08p\n", ep->u.m.next);
+  printf("\tctxsa = %08p\n", ep->u.m.ctxsa);
+  printf("\traiseslist = %08p\n", ep->u.m.raiseslist);
+}
+
+void mysomtShowEntry(Entry * ep)
+{
+  if (ep)
+  {
+    printf("      somtShowEntry: Entry at %08p, name = %s, type = %d\n", ep, ep->name, ep->type);
+    printf("\tlineno = %d\n", ep->lineno);
+    switch ( ep->type )
+    {
+      case SOMTAnyBE:
+        printf("\t SOMTAnyBE\n");
+        break;
+      case     SOMTArgumentE:
+        printf("\t SOMTArgumentE\n");
+        dumpMethodOrData(ep);
+        break;
+      case     SOMTAttE:
+        printf("\t SOMTAttE\n");
+        break;
+      case     SOMTBadEntryE:
+        printf("\t SOMTBadEntryE\n");
+        break;
+      case     SOMTBaseE:
+        printf("\t SOMTBaseE\n");
+        printf("\tparentdef = %08p\n", ep->u.p.parentdef);
+        break;
+      case     SOMTBooleanBE:
+        printf("\t SOMTBooleanBE\n");
+        break;
+      case     SOMTCaseEntryE:
+        printf("\t SOMTCaseEntryE\n");
+        break;
+      case     SOMTCaseListE:
+        printf("\t SOMTCaseListE\n");
+        break;
+      case     SOMTCaseSTME:
+        printf("\t SOMTCaseSTME\n");
+        break;
+      case     SOMTCharBE:
+        printf("\t SOMTCharBE\n");
+        break;
+      case     SOMTClassE:
+        printf("\tClass Definition Entry:\n");
+        printf("\tfile = %s\n", ep->u.c.file);
+        printf("\tmeta = %08p\n", ep->u.c.meta);
+        printf("\tparent = %08p\n", ep->u.c.parent);
+        printf("\tparents = %08p\n", ep->u.c.parents);
+        printf("\trelease = %08p\n", ep->u.c.release);
+	dumpReleaseOrder("\t", ep->u.c.release);
+        printf("\tpassthru = %08p\n", ep->u.c.passthrus);
+        printf("\tdata = %08p\n", ep->u.c.data);
+        printf("\ttc = %08p\n", ep->tc);
+        printf("\tmethodcnt = %08d\n", ep->u.c.methodcnt);
+        printf("\tmethods = %08p\n", ep->u.c.methods);
+        printf("\tinherited = %08p\n", ep->u.c.inherited);
+        printf("\tpubdefs = %08p\n", ep->u.c.pubdefs);
+        printf("\tmod = %08p\n", ep->u.c.mod);
+        printf("\tcls = %08p\n", ep->u.c.cls);
+        printf("\tforward = %s\n", ep->u.c.isforward ? "true" : "false");
+        break;
+      case     SOMTConstE:
+        printf("\t SOMTConstE\n");
+        break;
+      case     SOMTCopyrightE:
+        printf("\t SOMTCopyrightE\n");
+        break;
+      case     SOMTDataE:
+        printf("\t SOMTDataE\n");
+        dumpMethodOrData(ep);
+        break;
+      case     SOMTDclListE:
+        printf("\t SOMTDclListE\n");
+        break;
+      case     SOMTDefaultE:
+        printf("\t SOMTDefaultE\n");
+        break;
+      case     SOMTDoubleBE:
+        printf("\t SOMTDoubleBE\n");
+        break;
+      case     SOMTEBaseE:
+        printf("\t SOMTEBaseE\n");
+        break;
+      case     SOMTEEnumE:
+        printf("\t SOMTEEnumE\n");
+        break;
+      case     SOMTEnumBE:
+        printf("\t SOMTEnumBE\n");
+        break;
+      case     SOMTEnumE:
+        printf("\t SOMTEnumE\n");
+        break;
+      case     SOMTEnumPE:
+        printf("\t SOMTEnumPE\n");
+        break;
+      case     SOMTFloatBE:
+        printf("\t SOMTFloatBE\n");
+        break;
+      case     SOMTGroupE:
+        printf("\t SOMTGroupE\n");
+        break;
+      case     SOMTLongBE:
+        printf("\t SOMTLongBE\n");
+        break;
+      case     SOMTMetaE:
+        printf("\t SOMTMetaE\n");
+        break;
+      case     SOMTModuleE:
+        printf("\t SOMTModuleE\n");
+        break;
+      case     SOMTNegativeBE:
+        printf("\t SOMTNegativeBE\n");
+        break;
+      case     SOMTNewMethodE:
+        printf("\t SOMTNewMethodE\n");
+        dumpMethodOrData(ep);
+        break;
+      case     SOMTOctetBE:
+        printf("\t SOMTOctetBE\n");
+        break;
+      case     SOMTOverriddenMethodE:
+        printf("\t SOMTOverriddenMethodE\n");
+        dumpMethodOrData(ep);
+        break;
+      case     SOMTOverrideMethodE:
+        printf("\t SOMTOverrideMethodE\n");
+        dumpMethodOrData(ep);
+        break;
+      case     SOMTPassthruE:
+        printf("\t SOMTPassthruE\n");
+        break;
+      case     SOMTSequenceE:
+        printf("\t SOMTSequenceE\n");
+        break;
+      case     SOMTSequenceTDE:
+        printf("\t SOMTSequenceTDE\n");
+        break;
+      case     SOMTShortBE:
+        printf("\t SOMTShortBE\n");
+        break;
+      case     SOMTStringBE:
+        printf("\t SOMTStringBE\n");
+        break;
+      case     SOMTStringE:
+        printf("\t SOMTStringE\n");
+        break;
+      case     SOMTStructE:
+        printf("\t SOMTStructE\n");
+        break;
+      case     SOMTStructPE:
+        printf("\t SOMTStructPE\n");
+        break;
+      case     SOMTStructSE:
+        printf("\t SOMTStructSE\n");
+        printf("\tdcllist = %08p\n", ep->u.struc.dcllist);
+        printf("\tcls = %08p\n", ep->u.struc.cls);
+        printf("\texception = %s\n", ep->u.struc.isexcept ? "true" : "false");
+        printf("\tmutref = %s\n", ep->u.struc.ismutref ? "true" : "false");
+        break;
+      case     SOMTTyDclE:
+        printf("\t SOMTTyDclE\n");
+        break;
+      case     SOMTTypeCodeBE:
+        printf("\t SOMTTypeCodeBE\n");
+        break;
+      case     SOMTTypedefBE:
+        printf("\t SOMTTypedefBE\n");
+        dumpMethodOrData(ep);
+        break;
+      case     SOMTTypedefE:
+        printf("\t SOMTTypedefE\n");
+        break;
+      case     SOMTUnionE:
+        printf("\t SOMTUnionE\n");
+        break;
+      case     SOMTUnionPE:
+        printf("\t SOMTUnionPE\n");
+        break;
+      case     SOMTUnionSE:
+        printf("\t SOMTUnionSE\n");
+        break;
+      case     SOMTUnsignedLongBE:
+        printf("\t SOMTUnsignedLongBE\n");
+        break;
+      case     SOMTUnsignedShortBE:
+        printf("\t SOMTUnsignedShortBE\n");
+        break;
+      case     SOMTVoidBE:
+        printf("\t SOMTVoidBE\n");
+        break;
+      case     SOMTVoidPtrBE:
+        printf("\t SOMTVoidPtrBE\n");
+        dumpMethodOrData(ep);
+        break;
+  // This is special case SOMTTypes used on call of emitter start and emitter end
+  /*    case     SOMTEmitterBeginE:
+        result="SOMTEmitterBeginE";
+        break;
+      case     SOMTEmitterEndE:
+        result="SOMTEmitterEndE";
+        break; */
+      default:
+        printf("Error: somtShowEntry, bad entry type of %d", ep->type);
+//        SOM_Error(SOM_Fatal, __FILE__, __LINE__);
+//        SOMError(9, __FILE__, __LINE__);
+    }
+  }
+  else 
+  {
+    printf("somtShowEntry: NULL entry\n");
+  }
+}
+
+dumpAttrs(AttList *ap)
+{
+  struct AttList *cur = ap;
+
+  for(cur = ap; cur; cur = cur->next) 
+  {
+    printf("\tModifier %s=%s\n", cur->name, cur->value);
+  }
+}
+
+
+void mydumpEntry(Entry * ep)
+{
+  printf("Entry at address %p\n", ep);
+  printf("--------------------------\n");
+  printf("Entry type: %s (%d)\n", mysomttype(ep->type), ep->type);
+//  printf("Entry type: %s (%d)\n", somtEntryTypeName(ep->type), ep->type);
+  if (ep->sname) printf("Scoped name: %s\n", *ep->sname);
+  if (ep->comment) printf("Comment associated with entry: %s\n", ep->comment);
+  printf("Modifiers: %p\n", ep->atts);
+  if (ep->atts) dumpAttrs(ep->atts);
+  printf("TypeCode: %p\n", ep->tc);
+  printf("Points to the object: %p\n", ep->objref);
+  printf("Reference to real type: %s\n", ep->isref ? "true" : "false");
+  printf("Entry union: %p\n", &ep->u);
+#ifdef __PRIVATE__
+//    RHBelement *data;
+//    char *filestem;
+#endif    
+  mysomtShowEntry(ep);
+//  somtShowEntry(ep);
+};
+
+void dumpSep(Sep * sep)
+{
+    printf("Linked list item at address %p\n", sep);
+    printf("---------------------------------------\n");
+    printf("Position number: %d\n", sep->posn);
+    printf("Address of Entry: %p\n", sep->ep);
+    printf("Next linked list item address: %p\n", sep->next);
+    if (sep->ep) 
+    {
+      mydumpEntry((Entry *)sep->ep);
+      dumpSep(sep->next);
+    }
+}
+
+void dumpStab(Stab * stab)
+{
+  printf("Basic Symbol Table/Hash table (STab) structure\n");
+  printf("----------------------------------------------\n");
+  printf("Size of buscet: %d\n", stab->size);
+  printf("Size of entry structure: %d\n", stab->entrysize);
+  printf("Number of elements: %d\n", stab->nelms);
+  printf("Address of base slot: %p\n", stab->base);
+  printf("Max address of slot: %p\n", stab->limit);
+  printf("Start address of slot buffer: %p\n", stab->buf);
+  printf("Address of MemBuf: %p\n", stab->membuf);
+  printf("Ignore case flag: %s\n", stab->ignorecase ? "true" : "false");
+  for(unsigned int i=0; i<stab->size;i++)
+  {
+    printf("Linked list at slot %d at offset %08x at address %p\n", i, sizeof(Sep)*i, stab->buf+i);
+    printf("----------------------\n");
+    dumpSep(stab->buf+i);
+  }
+};
+
+
+void usage(void)
+{
+  printf("\nSC [-options] file[.CSC]\n");
+  printf("\n-C n\n\tset the size of the comment buffer (default: 16384)\n");
+  printf("\n-s n\n\tset the total amount of string space for names and passthru lines (default: 32768)\n");
+  printf("\n-V\n\tdisplay version information\n");
+  printf("\n-a name[=value]\n\tadd a global attribute. The currently supported attributes are defined below (at the end of this section)\n");
+  printf("\n-d directory\n\tspecify a directory where all files emitted during the execution of this command should be placed. If the -d option is not used, all emitted output files are placed in the same directory as the input .csc file\n");
+  printf("\n-h or ?\n\tprovide usage information for reference\n");
+  printf("\n-i filename\n\tspecify the name of the OIDL class definition file. Use this option to override the built-in assumption that the input file will have a .csc extension. Any filename you supply with the -i option is used exactly as you provide it\n");
+  printf("\n-r\n\tcheck that all release-order entries actually exist (default: FALSE)\n");
+  printf("\n-s string\n\tsubstitute string in place of the contents of the SMEMIT environment variable for the duration of the current SC command. If you supply a list of values, you\n");
+  printf("must enclose the list with double quotation marks (\" \"). You can use the -s option as a convenient way to override the SMEMIT environment variable. For example:\n\n");
+  printf("SC -s \"h;sc\" EXAMPLE\n\n");
+  printf("is equivalent to the following sequence of commands:\n\n");
+  printf("SET OLDSMEMIT = %%SMEMIT%%\n");
+  printf("SET SMEMIT = h;sc\n");
+  printf("SC EXAMPLE\n");
+  printf("SET SMEMIT = %%OLDSMEMIT%%\n");
+  printf("\n-w\n\tsuppress warning messages (default: FALSE)\n\n");
+  printf("The only global attributes currently supported by SC.EXE are:\n");
+  printf("\ncomment = comment string\n\twhere comment string can be one of the following: \"/*\", \"--\", or \"//\". This\n");
+  printf("indicates that comments marked in the indicated way are to be completely\n");
+  printf("ignored by SC.EXE and not retained for subsequent processing by one of the\n");
+  printf("emitters.\n");
+  printf("Note: Comments indicated by lines whose first non-white-space character is\n");
+  printf("a # are always ignored by SC.EXE. Also note that comments of any\n");
+  printf("form in passthru lines are passed through.\n");
+  printf("\ncstyle = comment style\n\tcontrols the form of emitted comments. Comment style must be one of s, c, or\n");
+  printf("+ to cause emitted comments to be in \"--\", \"/* */\", or \"//\" form , respectively\n");
+  printf("The default form is s\n");
+  printf("\nibmc\n\tcauses EMITC, EMITH, EMITIH, EMITPH, and EMITDEF to generate code with\n");
+  printf("pragmas specifically intended for the IBM C Set/2 Compiler. This attribute is\n");
+  printf("specified by default\n");
+  printf("\ncl386\n\tcauses EMITC, EMITH, EMITIH, EMITPH, and EMITDEF not to generate code\n");
+  printf("with pragmas specifically intended for the IBM C Set/2 Compiler\n");
+}
+
+void parse_file(char * file)
+{
+  // parser input stream
+  yyin=fopen(file,"r");
+
+  strcpy(somtfilePath, file);
+
+  // Initialize symbol table
+  somtstab=(Stab *)somtsmallocSL(sizeof(Stab), 0);
+  somtcreateStabSL(somtstab, HASH_SIZE, sizeof(Entry));
+
+  yyparse();
+
+  dumpStab(somtstab);
+}
+
+void emit_file(char * file)
+{
+   EmitFn proc;
+   FILE * fp;
+   HMODULE hmod;
+   Entry * root;
+   Stab * stab;
+
+   proc=somtloadSL("emitpsc.dll", "emitSL", &hmod);
+
+   fp=proc(file, root, stab);
+
+   if (fp) somtfcloseSL(fp);
+}
+
+void main(int argc, char *argv[])
+{
+   yydebug =1 ;
+
+//   parse_args(argc, argv);
+
+   usage();
+
+   parse_file(argv[1]);
+
+//   dump();
+
+//   emit_file(argv[1]);
+}
diff -urN somfree\somopc\src\gramma.yy.tab.h newsomfree3\somopc\src\gramma.yy.tab.h
--- somfree\somopc\src\gramma.yy.tab.h	Thu Jan 01 07:00:00 1970
+++ newsomfree3\somopc\src\gramma.yy.tab.h	Sat Mar 16 14:09:28 2024
@@ -0,0 +1,56 @@
+typedef union{
+ char *stval;
+ int ival;
+} YYSTYPE;
+#define	T_CONSTANT	257
+#define	T_COLON	258
+#define	T_SEMICOLON	259
+#define	T_COMMA	260
+#define	T_STAR	261
+#define	T_COMMENT	262
+#define	T_IDENTIFIER	263
+#define	T_EQUAL	264
+#define	T_DASHES	265
+#define	T_PERIOD	266
+#define	T_ELLIPSIS	267
+#define	T_LEFTPARENTHESIS	268
+#define	T_RIGHTPARENTHESIS	269
+#define	T_LEFTSQUAREBRACKET	270
+#define	T_RIGHTSQUAREBRACKET	271
+#define	T_VERSION	272
+#define	T_GLOBAL	273
+#define	T_LOCAL	274
+#define	T_CLASSINIT	275
+#define	T_RELEASE	276
+#define	T_ORDER	277
+#define	T_METACLASS	278
+#define	T_PARENT	279
+#define	T_CLASS	280
+#define	T_FILE	281
+#define	T_STEM	282
+#define	T_FUNCTION	283
+#define	T_PREFIX	284
+#define	T_CLASSPREFIX	285
+#define	T_MAJOR	286
+#define	T_MINOR	287
+#define	T_PASSTHRU	288
+#define	T_BEFORE	289
+#define	T_AFTER	290
+#define	T_ENDPASSTHRU	291
+#define	T_DATA	292
+#define	T_PRIVATE	293
+#define	T_PUBLIC	294
+#define	T_INTERNAL	295
+#define	T_METHODS	296
+#define	T_GROUP	297
+#define	T_METHOD	298
+#define	T_PROCEDURE	299
+#define	T_OFFSET	300
+#define	T_NAME	301
+#define	T_LOOKUP	302
+#define	T_EXTERNAL	303
+#define	T_USE	304
+#define	T_OVERRIDE	305
+
+
+extern YYSTYPE yylval;
diff -urN somfree\somopc\src\lex.yy.c newsomfree3\somopc\src\lex.yy.c
--- somfree\somopc\src\lex.yy.c	Thu Jan 01 07:00:00 1970
+++ newsomfree3\somopc\src\lex.yy.c	Sat Mar 16 14:09:28 2024
@@ -0,0 +1,1923 @@
+/* A lexical scanner generated by flex */
+
+/* Scanner skeleton version:
+ * $Header: /home/daffy/u0/vern/flex/RCS/flex.skl,v 2.91 96/09/10 16:58:48 vern Exp $
+ */
+
+#define FLEX_SCANNER
+#define YY_FLEX_MAJOR_VERSION 2
+#define YY_FLEX_MINOR_VERSION 5
+
+#ifdef __CRTRSXNT__
+#include <crtrsxnt.h>
+#endif
+#include <stdio.h>
+
+
+/* cfront 1.2 defines "c_plusplus" instead of "__cplusplus" */
+#ifdef c_plusplus
+#ifndef __cplusplus
+#define __cplusplus
+#endif
+#endif
+
+
+#ifdef __cplusplus
+
+#include <stdlib.h>
+#include <unistd.h>
+
+/* Use prototypes in function declarations. */
+#define YY_USE_PROTOS
+
+/* The "const" storage-class-modifier is valid. */
+#define YY_USE_CONST
+
+#else	/* ! __cplusplus */
+
+#if __STDC__
+
+#define YY_USE_PROTOS
+#define YY_USE_CONST
+
+#endif	/* __STDC__ */
+#endif	/* ! __cplusplus */
+
+#ifdef __TURBOC__
+ #pragma warn -rch
+ #pragma warn -use
+#include <io.h>
+#include <stdlib.h>
+#define YY_USE_CONST
+#define YY_USE_PROTOS
+#endif
+
+#ifdef YY_USE_CONST
+#define yyconst const
+#else
+#define yyconst
+#endif
+
+
+#ifdef YY_USE_PROTOS
+#define YY_PROTO(proto) proto
+#else
+#define YY_PROTO(proto) ()
+#endif
+
+/* Returned upon end-of-file. */
+#define YY_NULL 0
+
+/* Promotes a possibly negative, possibly signed char to an unsigned
+ * integer for use as an array index.  If the signed char is negative,
+ * we want to instead treat it as an 8-bit unsigned char, hence the
+ * double cast.
+ */
+#define YY_SC_TO_UI(c) ((unsigned int) (unsigned char) c)
+
+/* Enter a start condition.  This macro really ought to take a parameter,
+ * but we do it the disgusting crufty way forced on us by the ()-less
+ * definition of BEGIN.
+ */
+#define BEGIN yy_start = 1 + 2 *
+
+/* Translate the current start state into a value that can be later handed
+ * to BEGIN to return to the state.  The YYSTATE alias is for lex
+ * compatibility.
+ */
+#define YY_START ((yy_start - 1) / 2)
+#define YYSTATE YY_START
+
+/* Action number for EOF rule of a given start state. */
+#define YY_STATE_EOF(state) (YY_END_OF_BUFFER + state + 1)
+
+/* Special action meaning "start processing a new file". */
+#define YY_NEW_FILE yyrestart( yyin )
+
+#define YY_END_OF_BUFFER_CHAR 0
+
+/* Size of default input buffer. */
+#define YY_BUF_SIZE 16384
+
+typedef struct yy_buffer_state *YY_BUFFER_STATE;
+
+extern int yyleng;
+extern FILE *yyin, *yyout;
+
+#define EOB_ACT_CONTINUE_SCAN 0
+#define EOB_ACT_END_OF_FILE 1
+#define EOB_ACT_LAST_MATCH 2
+
+/* The funky do-while in the following #define is used to turn the definition
+ * int a single C statement (which needs a semi-colon terminator).  This
+ * avoids problems with code like:
+ *
+ * 	if ( condition_holds )
+ *		yyless( 5 );
+ *	else
+ *		do_something_else();
+ *
+ * Prior to using the do-while the compiler would get upset at the
+ * "else" because it interpreted the "if" statement as being all
+ * done when it reached the ';' after the yyless() call.
+ */
+
+/* Return all but the first 'n' matched characters back to the input stream. */
+
+#define yyless(n) \
+	do \
+		{ \
+		/* Undo effects of setting up yytext. */ \
+		*yy_cp = yy_hold_char; \
+		YY_RESTORE_YY_MORE_OFFSET \
+		yy_c_buf_p = yy_cp = yy_bp + n - YY_MORE_ADJ; \
+		YY_DO_BEFORE_ACTION; /* set up yytext again */ \
+		} \
+	while ( 0 )
+
+#define unput(c) yyunput( c, yytext_ptr )
+
+/* The following is because we cannot portably get our hands on size_t
+ * (without autoconf's help, which isn't available because we want
+ * flex-generated scanners to compile on their own).
+ */
+typedef unsigned int yy_size_t;
+
+
+struct yy_buffer_state
+	{
+	FILE *yy_input_file;
+
+	char *yy_ch_buf;		/* input buffer */
+	char *yy_buf_pos;		/* current position in input buffer */
+
+	/* Size of input buffer in bytes, not including room for EOB
+	 * characters.
+	 */
+	yy_size_t yy_buf_size;
+
+	/* Number of characters read into yy_ch_buf, not including EOB
+	 * characters.
+	 */
+	int yy_n_chars;
+
+	/* Whether we "own" the buffer - i.e., we know we created it,
+	 * and can realloc() it to grow it, and should free() it to
+	 * delete it.
+	 */
+	int yy_is_our_buffer;
+
+	/* Whether this is an "interactive" input source; if so, and
+	 * if we're using stdio for input, then we want to use getc()
+	 * instead of fread(), to make sure we stop fetching input after
+	 * each newline.
+	 */
+	int yy_is_interactive;
+
+	/* Whether we're considered to be at the beginning of a line.
+	 * If so, '^' rules will be active on the next match, otherwise
+	 * not.
+	 */
+	int yy_at_bol;
+
+	/* Whether to try to fill the input buffer when we reach the
+	 * end of it.
+	 */
+	int yy_fill_buffer;
+
+	int yy_buffer_status;
+#define YY_BUFFER_NEW 0
+#define YY_BUFFER_NORMAL 1
+	/* When an EOF's been seen but there's still some text to process
+	 * then we mark the buffer as YY_EOF_PENDING, to indicate that we
+	 * shouldn't try reading from the input source any more.  We might
+	 * still have a bunch of tokens to match, though, because of
+	 * possible backing-up.
+	 *
+	 * When we actually see the EOF, we change the status to "new"
+	 * (via yyrestart()), so that the user can continue scanning by
+	 * just pointing yyin at a new input file.
+	 */
+#define YY_BUFFER_EOF_PENDING 2
+	};
+
+static YY_BUFFER_STATE yy_current_buffer = 0;
+
+/* We provide macros for accessing buffer states in case in the
+ * future we want to put the buffer states in a more general
+ * "scanner state".
+ */
+#define YY_CURRENT_BUFFER yy_current_buffer
+
+
+/* yy_hold_char holds the character lost when yytext is formed. */
+static char yy_hold_char;
+
+static int yy_n_chars;		/* number of characters read into yy_ch_buf */
+
+
+int yyleng;
+
+/* Points to current character in buffer. */
+static char *yy_c_buf_p = (char *) 0;
+static int yy_init = 1;		/* whether we need to initialize */
+static int yy_start = 0;	/* start state number */
+
+/* Flag which is used to allow yywrap()'s to do buffer switches
+ * instead of setting up a fresh yyin.  A bit of a hack ...
+ */
+static int yy_did_buffer_switch_on_eof;
+
+void yyrestart YY_PROTO(( FILE *input_file ));
+
+void yy_switch_to_buffer YY_PROTO(( YY_BUFFER_STATE new_buffer ));
+void yy_load_buffer_state YY_PROTO(( void ));
+YY_BUFFER_STATE yy_create_buffer YY_PROTO(( FILE *file, int size ));
+void yy_delete_buffer YY_PROTO(( YY_BUFFER_STATE b ));
+void yy_init_buffer YY_PROTO(( YY_BUFFER_STATE b, FILE *file ));
+void yy_flush_buffer YY_PROTO(( YY_BUFFER_STATE b ));
+#define YY_FLUSH_BUFFER yy_flush_buffer( yy_current_buffer )
+
+YY_BUFFER_STATE yy_scan_buffer YY_PROTO(( char *base, yy_size_t size ));
+YY_BUFFER_STATE yy_scan_string YY_PROTO(( yyconst char *yy_str ));
+YY_BUFFER_STATE yy_scan_bytes YY_PROTO(( yyconst char *bytes, int len ));
+
+static void *yy_flex_alloc YY_PROTO(( yy_size_t ));
+static void *yy_flex_realloc YY_PROTO(( void *, yy_size_t ));
+static void yy_flex_free YY_PROTO(( void * ));
+
+#define yy_new_buffer yy_create_buffer
+
+#define yy_set_interactive(is_interactive) \
+	{ \
+	if ( ! yy_current_buffer ) \
+		yy_current_buffer = yy_create_buffer( yyin, YY_BUF_SIZE ); \
+	yy_current_buffer->yy_is_interactive = is_interactive; \
+	}
+
+#define yy_set_bol(at_bol) \
+	{ \
+	if ( ! yy_current_buffer ) \
+		yy_current_buffer = yy_create_buffer( yyin, YY_BUF_SIZE ); \
+	yy_current_buffer->yy_at_bol = at_bol; \
+	}
+
+#define YY_AT_BOL() (yy_current_buffer->yy_at_bol)
+
+typedef unsigned char YY_CHAR;
+FILE *yyin = (FILE *) 0, *yyout = (FILE *) 0;
+typedef int yy_state_type;
+extern char *yytext;
+#define yytext_ptr yytext
+
+static yy_state_type yy_get_previous_state YY_PROTO(( void ));
+static yy_state_type yy_try_NUL_trans YY_PROTO(( yy_state_type current_state ));
+static int yy_get_next_buffer YY_PROTO(( void ));
+static void yy_fatal_error YY_PROTO(( yyconst char msg[] ));
+
+/* Done after the current pattern has been matched and before the
+ * corresponding action - sets up yytext.
+ */
+#define YY_DO_BEFORE_ACTION \
+	yytext_ptr = yy_bp; \
+	yyleng = (int) (yy_cp - yy_bp); \
+	yy_hold_char = *yy_cp; \
+	*yy_cp = '\0'; \
+	yy_c_buf_p = yy_cp;
+
+#define YY_NUM_RULES 55
+#define YY_END_OF_BUFFER 56
+static yyconst short int yy_accept[213] =
+    {   0,
+        0,    0,    0,    0,    0,    0,   56,   54,   52,   53,
+       18,   19,   17,   13,   54,   54,   54,   10,   11,   12,
+       14,   51,   20,   21,   51,   51,   51,   51,   51,   51,
+       51,   51,   51,   51,   51,   51,   51,   51,    4,    6,
+        5,    8,    9,    8,   52,   15,    0,    1,   10,   51,
+       51,   51,   51,   51,   51,   51,   51,   51,   51,   51,
+       51,   51,   51,   51,   51,   51,   51,   51,   51,   51,
+       51,   51,    4,    3,    8,    8,   16,   51,   51,   51,
+       51,   51,   51,   51,   51,   51,   51,   51,   51,   51,
+       51,   51,   51,   51,   51,   51,   51,   51,   51,   51,
+
+       51,   51,   51,    8,   51,   38,   51,   23,   51,   51,
+       51,   51,   51,   51,   51,   51,   51,   51,   47,   51,
+       51,   51,   51,   51,   51,   51,   51,   51,   51,   24,
+       51,    8,   22,   51,   51,   51,   43,   51,   32,   51,
+       28,   51,   51,   29,   51,   35,   51,   51,   51,   51,
+       51,   51,   51,   51,   51,    8,   51,   51,   51,   51,
+       31,   51,   48,   51,   44,   46,   51,   37,   51,   26,
+       51,   51,   40,   51,   51,    8,   51,   51,   51,   51,
+       51,   51,   42,   51,   51,   39,   51,   34,   30,    8,
+       51,   51,   49,   25,   41,   51,   50,   51,   51,    8,
+
+       33,   51,   36,    2,   45,    8,   51,    8,   27,    8,
+        7,    0
+    } ;
+
+static yyconst int yy_ec[256] =
+    {   0,
+        1,    1,    1,    1,    1,    1,    1,    1,    2,    3,
+        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
+        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
+        1,    2,    1,    1,    1,    1,    1,    1,    1,    4,
+        5,    6,    1,    7,    8,    9,   10,   11,   11,   11,
+       11,   11,   11,   11,   11,   11,   11,   12,   13,    1,
+       14,    1,    1,    1,   15,   15,   15,   15,   15,   15,
+       15,   15,   16,   15,   15,   15,   15,   15,   15,   15,
+       15,   15,   15,   15,   15,   15,   15,   15,   15,   15,
+       17,    1,   18,    1,   19,    1,   20,   21,   22,   23,
+
+       24,   25,   26,   27,   28,   29,   30,   31,   32,   33,
+       34,   35,   15,   36,   37,   38,   39,   40,   15,   41,
+       15,   15,    1,    1,    1,    1,    1,    1,    1,    1,
+        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
+        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
+        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
+        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
+        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
+        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
+        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
+
+        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
+        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
+        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
+        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
+        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
+        1,    1,    1,    1,    1
+    } ;
+
+static yyconst int yy_meta[42] =
+    {   0,
+        1,    1,    2,    1,    1,    3,    1,    1,    1,    1,
+        4,    1,    1,    1,    4,    4,    1,    1,    4,    4,
+        4,    4,    4,    4,    4,    4,    4,    4,    4,    4,
+        4,    4,    4,    4,    4,    4,    4,    4,    4,    4,
+        4
+    } ;
+
+static yyconst short int yy_base[218] =
+    {   0,
+        0,    0,   39,   40,   41,   44,  230,  231,  227,  231,
+      231,  231,  231,  231,  220,  218,  220,  214,  231,  231,
+      231,    0,  231,  231,  193,  203,  181,   20,   18,  188,
+      186,   32,  199,   26,   33,  194,  179,  192,    0,  231,
+      205,    0,  231,  181,  211,  231,  203,  231,  200,    0,
+      190,  171,  170,  176,  173,  171,  170,  165,   33,  173,
+      163,  167,  167,  173,  174,  172,   21,   46,  174,  163,
+      169,  156,    0,  231,    0,  168,  231,  153,  169,  164,
+      163,  164,  164,  145,  159,  162,  151,  146,   44,  145,
+      154,  140,  152,  139,  150,  136,  147,  131,  148,  138,
+
+      144,  135,  129,  130,  127,    0,  127,    0,  124,  141,
+      125,  123,  127,  118,  120,  133,  120,  117,    0,  128,
+      115,  114,  116,  110,  119,  126,  121,  116,  123,    0,
+      114,  121,   47,  107,  111,  107,    0,  104,    0,  101,
+        0,  104,  111,    0,   95,    0,  104,   93,  103,   88,
+       90,  104,  104,   88,   90,   86,   89,   85,  100,   85,
+        0,   98,    0,   97,   79,    0,   92,    0,   78,    0,
+       89,   73,    0,   87,   77,   72,   80,   83,   75,   72,
+       73,   66,    0,   78,   62,    0,   64,    0,    0,   61,
+       58,   68,    0,    0,    0,   55,    0,   69,   55,   51,
+
+        0,   49,    0,  231,    0,   40,   34,   34,    0,   48,
+        0,  231,   82,   86,   46,   90,   94
+    } ;
+
+static yyconst short int yy_def[218] =
+    {   0,
+      212,    1,  213,  213,  214,  214,  212,  212,  212,  212,
+      212,  212,  212,  212,  212,  212,  212,  212,  212,  212,
+      212,  215,  212,  212,  215,  215,  215,  215,  215,  215,
+      215,  215,  215,  215,  215,  215,  215,  215,  216,  212,
+      212,  217,  212,  217,  212,  212,  212,  212,  212,  215,
+      215,  215,  215,  215,  215,  215,  215,  215,  215,  215,
+      215,  215,  215,  215,  215,  215,  215,  215,  215,  215,
+      215,  215,  216,  212,  217,  217,  212,  215,  215,  215,
+      215,  215,  215,  215,  215,  215,  215,  215,  215,  215,
+      215,  215,  215,  215,  215,  215,  215,  215,  215,  215,
+
+      215,  215,  215,  217,  215,  215,  215,  215,  215,  215,
+      215,  215,  215,  215,  215,  215,  215,  215,  215,  215,
+      215,  215,  215,  215,  215,  215,  215,  215,  215,  215,
+      215,  217,  215,  215,  215,  215,  215,  215,  215,  215,
+      215,  215,  215,  215,  215,  215,  215,  215,  215,  215,
+      215,  215,  215,  215,  215,  217,  215,  215,  215,  215,
+      215,  215,  215,  215,  215,  215,  215,  215,  215,  215,
+      215,  215,  215,  215,  215,  217,  215,  215,  215,  215,
+      215,  215,  215,  215,  215,  215,  215,  215,  215,  217,
+      215,  215,  215,  215,  215,  215,  215,  215,  215,  217,
+
+      215,  215,  215,  212,  215,  217,  215,  217,  215,  217,
+      217,    0,  212,  212,  212,  212,  212
+    } ;
+
+static yyconst short int yy_nxt[273] =
+    {   0,
+        8,    9,   10,   11,   12,   13,   14,   15,   16,   17,
+       18,   19,   20,   21,   22,   22,   23,   24,    8,   22,
+       22,   25,   26,   27,   28,   29,   22,   30,   22,   22,
+       31,   32,   33,   34,   35,   36,   37,   22,   22,   38,
+       22,   40,   40,   43,   41,   41,   43,   54,   56,   50,
+       64,   60,   67,   57,   86,   61,   95,   96,   55,   62,
+      211,   65,  157,  116,   44,   66,   87,   44,   68,   97,
+      117,   69,  210,   98,  209,  208,  207,  206,  205,   99,
+      204,  158,   39,   39,   39,   39,   42,   42,   42,   42,
+       73,  203,  202,   73,   75,  201,   75,   75,  200,  199,
+
+      198,  197,  196,  195,  194,  193,  192,  191,  190,  189,
+      188,  187,  186,  185,  184,  183,  182,  181,  180,  179,
+      178,  177,  176,  175,  174,  173,  172,  171,  170,  169,
+      168,  167,  166,  165,  164,  163,  162,  161,  160,  159,
+      156,  155,  154,  153,  152,  151,  150,  149,  148,  147,
+      146,  145,  144,  143,  142,  141,  140,  139,  138,  137,
+      136,  135,  134,  133,  132,  131,  130,  129,  128,  127,
+      126,  125,  124,  123,  122,  121,  120,  119,  118,  115,
+      114,  113,  112,  111,  110,  109,  108,  107,  106,  105,
+      104,  103,  102,  101,  100,   94,   93,   92,   91,   90,
+
+       89,   88,   85,   84,   83,   82,   81,   80,   79,   78,
+       49,   77,   45,   76,   74,   72,   71,   70,   63,   59,
+       58,   53,   52,   51,   49,   48,   47,   46,   45,  212,
+        7,  212,  212,  212,  212,  212,  212,  212,  212,  212,
+      212,  212,  212,  212,  212,  212,  212,  212,  212,  212,
+      212,  212,  212,  212,  212,  212,  212,  212,  212,  212,
+      212,  212,  212,  212,  212,  212,  212,  212,  212,  212,
+      212,  212
+    } ;
+
+static yyconst short int yy_chk[273] =
+    {   0,
+        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
+        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
+        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
+        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
+        1,    3,    4,    5,    3,    4,    6,   28,   29,  215,
+       34,   32,   35,   29,   59,   32,   67,   67,   28,   32,
+      210,   34,  133,   89,    5,   34,   59,    6,   35,   68,
+       89,   35,  208,   68,  207,  206,  202,  200,  199,   68,
+      198,  133,  213,  213,  213,  213,  214,  214,  214,  214,
+      216,  196,  192,  216,  217,  191,  217,  217,  190,  187,
+
+      185,  184,  182,  181,  180,  179,  178,  177,  176,  175,
+      174,  172,  171,  169,  167,  165,  164,  162,  160,  159,
+      158,  157,  156,  155,  154,  153,  152,  151,  150,  149,
+      148,  147,  145,  143,  142,  140,  138,  136,  135,  134,
+      132,  131,  129,  128,  127,  126,  125,  124,  123,  122,
+      121,  120,  118,  117,  116,  115,  114,  113,  112,  111,
+      110,  109,  107,  105,  104,  103,  102,  101,  100,   99,
+       98,   97,   96,   95,   94,   93,   92,   91,   90,   88,
+       87,   86,   85,   84,   83,   82,   81,   80,   79,   78,
+       76,   72,   71,   70,   69,   66,   65,   64,   63,   62,
+
+       61,   60,   58,   57,   56,   55,   54,   53,   52,   51,
+       49,   47,   45,   44,   41,   38,   37,   36,   33,   31,
+       30,   27,   26,   25,   18,   17,   16,   15,    9,    7,
+      212,  212,  212,  212,  212,  212,  212,  212,  212,  212,
+      212,  212,  212,  212,  212,  212,  212,  212,  212,  212,
+      212,  212,  212,  212,  212,  212,  212,  212,  212,  212,
+      212,  212,  212,  212,  212,  212,  212,  212,  212,  212,
+      212,  212
+    } ;
+
+static yy_state_type yy_last_accepting_state;
+static char *yy_last_accepting_cpos;
+
+/* The intent behind this definition is that it'll catch
+ * any uses of REJECT which flex missed.
+ */
+#define REJECT reject_used_but_not_detected
+#define yymore() yymore_used_but_not_detected
+#define YY_MORE_ADJ 0
+#define YY_RESTORE_YY_MORE_OFFSET
+char *yytext;
+#line 1 "scanner.ll"
+#define INITIAL 0
+#line 2 "scanner.ll"
+
+#include <stdio.h>  // fopen
+#include <stdlib.h> // malloc, free, realloc
+#include <string.h> // strcat
+
+#include <emitlib.h>
+
+#include "gramma.yy.tab.h"
+
+int trace=1;
+int lineno=1, column=0;
+char comment[16384]; // handle with -C
+char passthru[32768]; // handle with -S
+
+#define IN_CPP_COMMENT 1
+
+#define IN_PASSTHRU 2
+
+#line 516 "lex.yy.c"
+
+/* Macros after this point can all be overridden by user definitions in
+ * section 1.
+ */
+
+#ifndef YY_SKIP_YYWRAP
+#ifdef __cplusplus
+extern "C" int yywrap YY_PROTO(( void ));
+#else
+extern int yywrap YY_PROTO(( void ));
+#endif
+#endif
+
+#ifndef YY_NO_UNPUT
+static void yyunput YY_PROTO(( int c, char *buf_ptr ));
+#endif
+
+#ifndef yytext_ptr
+static void yy_flex_strncpy YY_PROTO(( char *, yyconst char *, int ));
+#endif
+
+#ifdef YY_NEED_STRLEN
+static int yy_flex_strlen YY_PROTO(( yyconst char * ));
+#endif
+
+#ifndef YY_NO_INPUT
+#ifdef __cplusplus
+static int yyinput YY_PROTO(( void ));
+#else
+static int input YY_PROTO(( void ));
+#endif
+#endif
+
+#if YY_STACK_USED
+static int yy_start_stack_ptr = 0;
+static int yy_start_stack_depth = 0;
+static int *yy_start_stack = 0;
+#ifndef YY_NO_PUSH_STATE
+static void yy_push_state YY_PROTO(( int new_state ));
+#endif
+#ifndef YY_NO_POP_STATE
+static void yy_pop_state YY_PROTO(( void ));
+#endif
+#ifndef YY_NO_TOP_STATE
+static int yy_top_state YY_PROTO(( void ));
+#endif
+
+#else
+#define YY_NO_PUSH_STATE 1
+#define YY_NO_POP_STATE 1
+#define YY_NO_TOP_STATE 1
+#endif
+
+#ifdef YY_MALLOC_DECL
+YY_MALLOC_DECL
+#else
+#if __STDC__
+#ifndef __cplusplus
+#include <stdlib.h>
+#endif
+#else
+/* Just try to get by without declaring the routines.  This will fail
+ * miserably on non-ANSI systems for which sizeof(size_t) != sizeof(int)
+ * or sizeof(void*) != sizeof(int).
+ */
+#endif
+#endif
+
+/* Amount of stuff to slurp up with each read. */
+#ifndef YY_READ_BUF_SIZE
+#define YY_READ_BUF_SIZE 8192
+#endif
+
+/* Copy whatever the last rule matched to the standard output. */
+
+#ifndef ECHO
+/* This used to be an fputs(), but since the string might contain NUL's,
+ * we now use fwrite().
+ */
+#define ECHO (void) fwrite( yytext, yyleng, 1, yyout )
+#endif
+
+/* Gets input and stuffs it into "buf".  number of characters read, or YY_NULL,
+ * is returned in "result".
+ */
+#ifndef YY_INPUT
+#define YY_INPUT(buf,result,max_size) \
+	if ( yy_current_buffer->yy_is_interactive ) \
+		{ \
+		int c = '*', n; \
+		for ( n = 0; n < max_size && \
+			     (c = getc( yyin )) != EOF && c != '\n'; ++n ) \
+			buf[n] = (char) c; \
+		if ( c == '\n' ) \
+			buf[n++] = (char) c; \
+		if ( c == EOF && ferror( yyin ) ) \
+			YY_FATAL_ERROR( "input in flex scanner failed" ); \
+		result = n; \
+		} \
+	else if ( ((result = fread( buf, 1, max_size, yyin )) == 0) \
+		  && ferror( yyin ) ) \
+		YY_FATAL_ERROR( "input in flex scanner failed" );
+#endif
+
+/* No semi-colon after return; correct usage is to write "yyterminate();" -
+ * we don't want an extra ';' after the "return" because that will cause
+ * some compilers to complain about unreachable statements.
+ */
+#ifndef yyterminate
+#define yyterminate() return YY_NULL
+#endif
+
+/* Number of entries by which start-condition stack grows. */
+#ifndef YY_START_STACK_INCR
+#define YY_START_STACK_INCR 25
+#endif
+
+/* Report a fatal error. */
+#ifndef YY_FATAL_ERROR
+#define YY_FATAL_ERROR(msg) yy_fatal_error( msg )
+#endif
+
+/* Default declaration of generated scanner - a define so the user can
+ * easily add parameters.
+ */
+#ifndef YY_DECL
+#define YY_DECL int yylex YY_PROTO(( void ))
+#endif
+
+/* Code executed at the beginning of each rule, after yytext and yyleng
+ * have been set up.
+ */
+#ifndef YY_USER_ACTION
+#define YY_USER_ACTION
+#endif
+
+/* Code executed at the end of each rule. */
+#ifndef YY_BREAK
+#define YY_BREAK break;
+#endif
+
+#define YY_RULE_SETUP \
+	YY_USER_ACTION
+
+YY_DECL
+	{
+	register yy_state_type yy_current_state;
+	register char *yy_cp, *yy_bp;
+	register int yy_act;
+
+#line 22 "scanner.ll"
+
+
+#line 670 "lex.yy.c"
+
+	if ( yy_init )
+		{
+		yy_init = 0;
+
+#ifdef YY_USER_INIT
+		YY_USER_INIT;
+#endif
+
+		if ( ! yy_start )
+			yy_start = 1;	/* first start state */
+
+		if ( ! yyin )
+			yyin = stdin;
+
+		if ( ! yyout )
+			yyout = stdout;
+
+		if ( ! yy_current_buffer )
+			yy_current_buffer =
+				yy_create_buffer( yyin, YY_BUF_SIZE );
+
+		yy_load_buffer_state();
+		}
+
+	while ( 1 )		/* loops until end-of-file is reached */
+		{
+		yy_cp = yy_c_buf_p;
+
+		/* Support of yytext. */
+		*yy_cp = yy_hold_char;
+
+		/* yy_bp points to the position in yy_ch_buf of the start of
+		 * the current run.
+		 */
+		yy_bp = yy_cp;
+
+		yy_current_state = yy_start;
+yy_match:
+		do
+			{
+			register YY_CHAR yy_c = yy_ec[YY_SC_TO_UI(*yy_cp)];
+			if ( yy_accept[yy_current_state] )
+				{
+				yy_last_accepting_state = yy_current_state;
+				yy_last_accepting_cpos = yy_cp;
+				}
+			while ( yy_chk[yy_base[yy_current_state] + yy_c] != yy_current_state )
+				{
+				yy_current_state = (int) yy_def[yy_current_state];
+				if ( yy_current_state >= 213 )
+					yy_c = yy_meta[(unsigned int) yy_c];
+				}
+			yy_current_state = yy_nxt[yy_base[yy_current_state] + (unsigned int) yy_c];
+			++yy_cp;
+			}
+		while ( yy_base[yy_current_state] != 231 );
+
+yy_find_action:
+		yy_act = yy_accept[yy_current_state];
+		if ( yy_act == 0 )
+			{ /* have to back up */
+			yy_cp = yy_last_accepting_cpos;
+			yy_current_state = yy_last_accepting_state;
+			yy_act = yy_accept[yy_current_state];
+			}
+
+		YY_DO_BEFORE_ACTION;
+
+
+do_action:	/* This label is used only to access EOF actions. */
+
+
+		switch ( yy_act )
+	{ /* beginning of action switch */
+			case 0: /* must back up */
+			/* undo the effects of YY_DO_BEFORE_ACTION */
+			*yy_cp = yy_hold_char;
+			yy_cp = yy_last_accepting_cpos;
+			yy_current_state = yy_last_accepting_state;
+			goto yy_find_action;
+
+
+case 1:
+YY_RULE_SETUP
+#line 25 "scanner.ll"
+{BEGIN(IN_CPP_COMMENT); comment[0]=0x0; }
+	YY_BREAK
+case 2:
+YY_RULE_SETUP
+#line 26 "scanner.ll"
+{BEGIN(IN_PASSTHRU); passthru[0]=0x0;}
+	YY_BREAK
+
+
+case 3:
+YY_RULE_SETUP
+#line 30 "scanner.ll"
+{ BEGIN(INITIAL); yylval.stval=strdup(comment); return T_COMMENT; }
+	YY_BREAK
+case 4:
+YY_RULE_SETUP
+#line 31 "scanner.ll"
+{ strcat(comment, yytext); }
+	YY_BREAK
+case 5:
+YY_RULE_SETUP
+#line 32 "scanner.ll"
+// eat the lone star
+	YY_BREAK
+case 6:
+YY_RULE_SETUP
+#line 33 "scanner.ll"
+{ strcat(comment, "\n"); lineno++; }
+	YY_BREAK
+
+
+case 7:
+YY_RULE_SETUP
+#line 37 "scanner.ll"
+{BEGIN(INITIAL);}
+	YY_BREAK
+case 8:
+YY_RULE_SETUP
+#line 38 "scanner.ll"
+{ strcat(passthru, yytext);}
+	YY_BREAK
+case 9:
+YY_RULE_SETUP
+#line 39 "scanner.ll"
+{ strcat(passthru, "\n"); lineno++; }
+	YY_BREAK
+
+case 10:
+YY_RULE_SETUP
+#line 42 "scanner.ll"
+{if (trace) ECHO; column+=yyleng; yylval.ival=atoi(yytext); return T_CONSTANT;}
+	YY_BREAK
+case 11:
+YY_RULE_SETUP
+#line 43 "scanner.ll"
+{if (trace) ECHO; column+=yyleng; return T_COLON;            }
+	YY_BREAK
+case 12:
+YY_RULE_SETUP
+#line 44 "scanner.ll"
+{if (trace) ECHO; column+=yyleng; return T_SEMICOLON;        }
+	YY_BREAK
+case 13:
+YY_RULE_SETUP
+#line 45 "scanner.ll"
+{if (trace) ECHO; column+=yyleng; return T_COMMA;            }
+	YY_BREAK
+case 14:
+YY_RULE_SETUP
+#line 46 "scanner.ll"
+{if (trace) ECHO; column+=yyleng; return T_EQUAL;            }
+	YY_BREAK
+case 15:
+YY_RULE_SETUP
+#line 47 "scanner.ll"
+{if (trace) ECHO; column+=yyleng; return T_DASHES;           }
+	YY_BREAK
+case 16:
+YY_RULE_SETUP
+#line 48 "scanner.ll"
+{if (trace) ECHO; column+=yyleng; return T_ELLIPSIS;         }
+	YY_BREAK
+case 17:
+YY_RULE_SETUP
+#line 49 "scanner.ll"
+{if (trace) ECHO; column+=yyleng; yylval.stval=strdup(yytext); return T_STAR; }
+	YY_BREAK
+case 18:
+YY_RULE_SETUP
+#line 50 "scanner.ll"
+{if (trace) ECHO; column+=yyleng; return T_LEFTPARENTHESIS;  }
+	YY_BREAK
+case 19:
+YY_RULE_SETUP
+#line 51 "scanner.ll"
+{if (trace) ECHO; column+=yyleng; return T_RIGHTPARENTHESIS; }
+	YY_BREAK
+case 20:
+YY_RULE_SETUP
+#line 52 "scanner.ll"
+{if (trace) ECHO; column+=yyleng; return T_LEFTSQUAREBRACKET;  }
+	YY_BREAK
+case 21:
+YY_RULE_SETUP
+#line 53 "scanner.ll"
+{if (trace) ECHO; column+=yyleng; return T_RIGHTSQUAREBRACKET; }
+	YY_BREAK
+case 22:
+YY_RULE_SETUP
+#line 54 "scanner.ll"
+{if (trace) ECHO; column+=yyleng; return T_CLASS;            }
+	YY_BREAK
+case 23:
+YY_RULE_SETUP
+#line 55 "scanner.ll"
+{if (trace) ECHO; column+=yyleng; return T_FILE;             }
+	YY_BREAK
+case 24:
+YY_RULE_SETUP
+#line 56 "scanner.ll"
+{if (trace) ECHO; column+=yyleng; return T_STEM;             }
+	YY_BREAK
+case 25:
+YY_RULE_SETUP
+#line 57 "scanner.ll"
+{if (trace) ECHO; column+=yyleng; return T_FUNCTION;         }
+	YY_BREAK
+case 26:
+YY_RULE_SETUP
+#line 58 "scanner.ll"
+{if (trace) ECHO; column+=yyleng; return T_PREFIX;           }
+	YY_BREAK
+case 27:
+YY_RULE_SETUP
+#line 59 "scanner.ll"
+{if (trace) ECHO; column+=yyleng; return T_CLASSPREFIX;      }
+	YY_BREAK
+case 28:
+YY_RULE_SETUP
+#line 60 "scanner.ll"
+{if (trace) ECHO; column+=yyleng; return T_MAJOR;            }
+	YY_BREAK
+case 29:
+YY_RULE_SETUP
+#line 61 "scanner.ll"
+{if (trace) ECHO; column+=yyleng; return T_MINOR;            }
+	YY_BREAK
+case 30:
+YY_RULE_SETUP
+#line 62 "scanner.ll"
+{if (trace) ECHO; column+=yyleng; return T_VERSION;          }
+	YY_BREAK
+case 31:
+YY_RULE_SETUP
+#line 63 "scanner.ll"
+{if (trace) ECHO; column+=yyleng; return T_GLOBAL;           }
+	YY_BREAK
+case 32:
+YY_RULE_SETUP
+#line 64 "scanner.ll"
+{if (trace) ECHO; column+=yyleng; return T_LOCAL;            }
+	YY_BREAK
+case 33:
+YY_RULE_SETUP
+#line 65 "scanner.ll"
+{if (trace) ECHO; column+=yyleng; return T_CLASSINIT;        }
+	YY_BREAK
+case 34:
+YY_RULE_SETUP
+#line 66 "scanner.ll"
+{if (trace) ECHO; column+=yyleng; return T_RELEASE;          }
+	YY_BREAK
+case 35:
+YY_RULE_SETUP
+#line 67 "scanner.ll"
+{if (trace) ECHO; column+=yyleng; return T_ORDER;            }
+	YY_BREAK
+case 36:
+YY_RULE_SETUP
+#line 68 "scanner.ll"
+{if (trace) ECHO; column+=yyleng; return T_METACLASS;        }
+	YY_BREAK
+case 37:
+YY_RULE_SETUP
+#line 69 "scanner.ll"
+{if (trace) ECHO; column+=yyleng; return T_PARENT;           }
+	YY_BREAK
+case 38:
+YY_RULE_SETUP
+#line 70 "scanner.ll"
+{if (trace) ECHO; column+=yyleng; return T_DATA;             }
+	YY_BREAK
+case 39:
+YY_RULE_SETUP
+#line 71 "scanner.ll"
+{if (trace) ECHO; column+=yyleng; return T_PRIVATE;          }
+	YY_BREAK
+case 40:
+YY_RULE_SETUP
+#line 72 "scanner.ll"
+{if (trace) ECHO; column+=yyleng; return T_PUBLIC;           }
+	YY_BREAK
+case 41:
+YY_RULE_SETUP
+#line 73 "scanner.ll"
+{if (trace) ECHO; column+=yyleng; return T_INTERNAL;         }
+	YY_BREAK
+case 42:
+YY_RULE_SETUP
+#line 74 "scanner.ll"
+{if (trace) ECHO; column+=yyleng; return T_METHODS;          }
+	YY_BREAK
+case 43:
+YY_RULE_SETUP
+#line 75 "scanner.ll"
+{if (trace) ECHO; column+=yyleng; return T_GROUP;            }
+	YY_BREAK
+case 44:
+YY_RULE_SETUP
+#line 76 "scanner.ll"
+{if (trace) ECHO; column+=yyleng; return T_METHOD;           }
+	YY_BREAK
+case 45:
+YY_RULE_SETUP
+#line 77 "scanner.ll"
+{if (trace) ECHO; column+=yyleng; return T_PROCEDURE;        }
+	YY_BREAK
+case 46:
+YY_RULE_SETUP
+#line 78 "scanner.ll"
+{if (trace) ECHO; column+=yyleng; return T_OFFSET;           }
+	YY_BREAK
+case 47:
+YY_RULE_SETUP
+#line 79 "scanner.ll"
+{if (trace) ECHO; column+=yyleng; return T_NAME;             }
+	YY_BREAK
+case 48:
+YY_RULE_SETUP
+#line 80 "scanner.ll"
+{if (trace) ECHO; column+=yyleng; return T_LOOKUP;           }
+	YY_BREAK
+case 49:
+YY_RULE_SETUP
+#line 81 "scanner.ll"
+{if (trace) ECHO; column+=yyleng; return T_EXTERNAL;         }
+	YY_BREAK
+case 50:
+YY_RULE_SETUP
+#line 82 "scanner.ll"
+{if (trace) ECHO; column+=yyleng; return T_OVERRIDE;         }
+	YY_BREAK
+case 51:
+YY_RULE_SETUP
+#line 83 "scanner.ll"
+{if (trace) ECHO; column+=yyleng; yylval.stval=strdup(yytext); return T_IDENTIFIER;   }
+	YY_BREAK
+case 52:
+YY_RULE_SETUP
+#line 84 "scanner.ll"
+{ column++;                                                  }
+	YY_BREAK
+case 53:
+YY_RULE_SETUP
+#line 85 "scanner.ll"
+{ lineno++;                                                  }
+	YY_BREAK
+case 54:
+YY_RULE_SETUP
+#line 86 "scanner.ll"
+{ printf("ERROR"); };
+	YY_BREAK
+case 55:
+YY_RULE_SETUP
+#line 88 "scanner.ll"
+ECHO;
+	YY_BREAK
+#line 1034 "lex.yy.c"
+case YY_STATE_EOF(INITIAL):
+case YY_STATE_EOF(IN_CPP_COMMENT):
+case YY_STATE_EOF(IN_PASSTHRU):
+	yyterminate();
+
+	case YY_END_OF_BUFFER:
+		{
+		/* Amount of text matched not including the EOB char. */
+		int yy_amount_of_matched_text = (int) (yy_cp - yytext_ptr) - 1;
+
+		/* Undo the effects of YY_DO_BEFORE_ACTION. */
+		*yy_cp = yy_hold_char;
+		YY_RESTORE_YY_MORE_OFFSET
+
+		if ( yy_current_buffer->yy_buffer_status == YY_BUFFER_NEW )
+			{
+			/* We're scanning a new file or input source.  It's
+			 * possible that this happened because the user
+			 * just pointed yyin at a new source and called
+			 * yylex().  If so, then we have to assure
+			 * consistency between yy_current_buffer and our
+			 * globals.  Here is the right place to do so, because
+			 * this is the first action (other than possibly a
+			 * back-up) that will match for the new input source.
+			 */
+			yy_n_chars = yy_current_buffer->yy_n_chars;
+			yy_current_buffer->yy_input_file = yyin;
+			yy_current_buffer->yy_buffer_status = YY_BUFFER_NORMAL;
+			}
+
+		/* Note that here we test for yy_c_buf_p "<=" to the position
+		 * of the first EOB in the buffer, since yy_c_buf_p will
+		 * already have been incremented past the NUL character
+		 * (since all states make transitions on EOB to the
+		 * end-of-buffer state).  Contrast this with the test
+		 * in input().
+		 */
+		if ( yy_c_buf_p <= &yy_current_buffer->yy_ch_buf[yy_n_chars] )
+			{ /* This was really a NUL. */
+			yy_state_type yy_next_state;
+
+			yy_c_buf_p = yytext_ptr + yy_amount_of_matched_text;
+
+			yy_current_state = yy_get_previous_state();
+
+			/* Okay, we're now positioned to make the NUL
+			 * transition.  We couldn't have
+			 * yy_get_previous_state() go ahead and do it
+			 * for us because it doesn't know how to deal
+			 * with the possibility of jamming (and we don't
+			 * want to build jamming into it because then it
+			 * will run more slowly).
+			 */
+
+			yy_next_state = yy_try_NUL_trans( yy_current_state );
+
+			yy_bp = yytext_ptr + YY_MORE_ADJ;
+
+			if ( yy_next_state )
+				{
+				/* Consume the NUL. */
+				yy_cp = ++yy_c_buf_p;
+				yy_current_state = yy_next_state;
+				goto yy_match;
+				}
+
+			else
+				{
+				yy_cp = yy_c_buf_p;
+				goto yy_find_action;
+				}
+			}
+
+		else switch ( yy_get_next_buffer() )
+			{
+			case EOB_ACT_END_OF_FILE:
+				{
+				yy_did_buffer_switch_on_eof = 0;
+
+				if ( yywrap() )
+					{
+					/* Note: because we've taken care in
+					 * yy_get_next_buffer() to have set up
+					 * yytext, we can now set up
+					 * yy_c_buf_p so that if some total
+					 * hoser (like flex itself) wants to
+					 * call the scanner after we return the
+					 * YY_NULL, it'll still work - another
+					 * YY_NULL will get returned.
+					 */
+					yy_c_buf_p = yytext_ptr + YY_MORE_ADJ;
+
+					yy_act = YY_STATE_EOF(YY_START);
+					goto do_action;
+					}
+
+				else
+					{
+					if ( ! yy_did_buffer_switch_on_eof )
+						YY_NEW_FILE;
+					}
+				break;
+				}
+
+			case EOB_ACT_CONTINUE_SCAN:
+				yy_c_buf_p =
+					yytext_ptr + yy_amount_of_matched_text;
+
+				yy_current_state = yy_get_previous_state();
+
+				yy_cp = yy_c_buf_p;
+				yy_bp = yytext_ptr + YY_MORE_ADJ;
+				goto yy_match;
+
+			case EOB_ACT_LAST_MATCH:
+				yy_c_buf_p =
+				&yy_current_buffer->yy_ch_buf[yy_n_chars];
+
+				yy_current_state = yy_get_previous_state();
+
+				yy_cp = yy_c_buf_p;
+				yy_bp = yytext_ptr + YY_MORE_ADJ;
+				goto yy_find_action;
+			}
+		break;
+		}
+
+	default:
+		YY_FATAL_ERROR(
+			"fatal flex scanner internal error--no action found" );
+	} /* end of action switch */
+		} /* end of scanning one token */
+	} /* end of yylex */
+
+
+/* yy_get_next_buffer - try to read in a new buffer
+ *
+ * Returns a code representing an action:
+ *	EOB_ACT_LAST_MATCH -
+ *	EOB_ACT_CONTINUE_SCAN - continue scanning from current position
+ *	EOB_ACT_END_OF_FILE - end of file
+ */
+
+static int yy_get_next_buffer()
+	{
+	register char *dest = yy_current_buffer->yy_ch_buf;
+	register char *source = yytext_ptr;
+	register int number_to_move, i;
+	int ret_val;
+
+	if ( yy_c_buf_p > &yy_current_buffer->yy_ch_buf[yy_n_chars + 1] )
+		YY_FATAL_ERROR(
+		"fatal flex scanner internal error--end of buffer missed" );
+
+	if ( yy_current_buffer->yy_fill_buffer == 0 )
+		{ /* Don't try to fill the buffer, so this is an EOF. */
+		if ( yy_c_buf_p - yytext_ptr - YY_MORE_ADJ == 1 )
+			{
+			/* We matched a single character, the EOB, so
+			 * treat this as a final EOF.
+			 */
+			return EOB_ACT_END_OF_FILE;
+			}
+
+		else
+			{
+			/* We matched some text prior to the EOB, first
+			 * process it.
+			 */
+			return EOB_ACT_LAST_MATCH;
+			}
+		}
+
+	/* Try to read more data. */
+
+	/* First move last chars to start of buffer. */
+	number_to_move = (int) (yy_c_buf_p - yytext_ptr) - 1;
+
+	for ( i = 0; i < number_to_move; ++i )
+		*(dest++) = *(source++);
+
+	if ( yy_current_buffer->yy_buffer_status == YY_BUFFER_EOF_PENDING )
+		/* don't do the read, it's not guaranteed to return an EOF,
+		 * just force an EOF
+		 */
+		yy_current_buffer->yy_n_chars = yy_n_chars = 0;
+
+	else
+		{
+		int num_to_read =
+			yy_current_buffer->yy_buf_size - number_to_move - 1;
+
+		while ( num_to_read <= 0 )
+			{ /* Not enough room in the buffer - grow it. */
+#ifdef YY_USES_REJECT
+			YY_FATAL_ERROR(
+"input buffer overflow, can't enlarge buffer because scanner uses REJECT" );
+#else
+
+			/* just a shorter name for the current buffer */
+			YY_BUFFER_STATE b = yy_current_buffer;
+
+			int yy_c_buf_p_offset =
+				(int) (yy_c_buf_p - b->yy_ch_buf);
+
+			if ( b->yy_is_our_buffer )
+				{
+				int new_size = b->yy_buf_size * 2;
+
+				if ( new_size <= 0 )
+					b->yy_buf_size += b->yy_buf_size / 8;
+				else
+					b->yy_buf_size *= 2;
+
+				b->yy_ch_buf = (char *)
+					/* Include room in for 2 EOB chars. */
+					yy_flex_realloc( (void *) b->yy_ch_buf,
+							 b->yy_buf_size + 2 );
+				}
+			else
+				/* Can't grow it, we don't own it. */
+				b->yy_ch_buf = 0;
+
+			if ( ! b->yy_ch_buf )
+				YY_FATAL_ERROR(
+				"fatal error - scanner input buffer overflow" );
+
+			yy_c_buf_p = &b->yy_ch_buf[yy_c_buf_p_offset];
+
+			num_to_read = yy_current_buffer->yy_buf_size -
+						number_to_move - 1;
+#endif
+			}
+
+		if ( num_to_read > YY_READ_BUF_SIZE )
+			num_to_read = YY_READ_BUF_SIZE;
+
+		/* Read in more data. */
+		YY_INPUT( (&yy_current_buffer->yy_ch_buf[number_to_move]),
+			yy_n_chars, num_to_read );
+
+		yy_current_buffer->yy_n_chars = yy_n_chars;
+		}
+
+	if ( yy_n_chars == 0 )
+		{
+		if ( number_to_move == YY_MORE_ADJ )
+			{
+			ret_val = EOB_ACT_END_OF_FILE;
+			yyrestart( yyin );
+			}
+
+		else
+			{
+			ret_val = EOB_ACT_LAST_MATCH;
+			yy_current_buffer->yy_buffer_status =
+				YY_BUFFER_EOF_PENDING;
+			}
+		}
+
+	else
+		ret_val = EOB_ACT_CONTINUE_SCAN;
+
+	yy_n_chars += number_to_move;
+	yy_current_buffer->yy_ch_buf[yy_n_chars] = YY_END_OF_BUFFER_CHAR;
+	yy_current_buffer->yy_ch_buf[yy_n_chars + 1] = YY_END_OF_BUFFER_CHAR;
+
+	yytext_ptr = &yy_current_buffer->yy_ch_buf[0];
+
+	return ret_val;
+	}
+
+
+/* yy_get_previous_state - get the state just before the EOB char was reached */
+
+static yy_state_type yy_get_previous_state()
+	{
+	register yy_state_type yy_current_state;
+	register char *yy_cp;
+
+	yy_current_state = yy_start;
+
+	for ( yy_cp = yytext_ptr + YY_MORE_ADJ; yy_cp < yy_c_buf_p; ++yy_cp )
+		{
+		register YY_CHAR yy_c = (*yy_cp ? yy_ec[YY_SC_TO_UI(*yy_cp)] : 1);
+		if ( yy_accept[yy_current_state] )
+			{
+			yy_last_accepting_state = yy_current_state;
+			yy_last_accepting_cpos = yy_cp;
+			}
+		while ( yy_chk[yy_base[yy_current_state] + yy_c] != yy_current_state )
+			{
+			yy_current_state = (int) yy_def[yy_current_state];
+			if ( yy_current_state >= 213 )
+				yy_c = yy_meta[(unsigned int) yy_c];
+			}
+		yy_current_state = yy_nxt[yy_base[yy_current_state] + (unsigned int) yy_c];
+		}
+
+	return yy_current_state;
+	}
+
+
+/* yy_try_NUL_trans - try to make a transition on the NUL character
+ *
+ * synopsis
+ *	next_state = yy_try_NUL_trans( current_state );
+ */
+
+#ifdef YY_USE_PROTOS
+static yy_state_type yy_try_NUL_trans( yy_state_type yy_current_state )
+#else
+static yy_state_type yy_try_NUL_trans( yy_current_state )
+yy_state_type yy_current_state;
+#endif
+	{
+	register int yy_is_jam;
+	register char *yy_cp = yy_c_buf_p;
+
+	register YY_CHAR yy_c = 1;
+	if ( yy_accept[yy_current_state] )
+		{
+		yy_last_accepting_state = yy_current_state;
+		yy_last_accepting_cpos = yy_cp;
+		}
+	while ( yy_chk[yy_base[yy_current_state] + yy_c] != yy_current_state )
+		{
+		yy_current_state = (int) yy_def[yy_current_state];
+		if ( yy_current_state >= 213 )
+			yy_c = yy_meta[(unsigned int) yy_c];
+		}
+	yy_current_state = yy_nxt[yy_base[yy_current_state] + (unsigned int) yy_c];
+	yy_is_jam = (yy_current_state == 212);
+
+	return yy_is_jam ? 0 : yy_current_state;
+	}
+
+
+#ifndef YY_NO_UNPUT
+#ifdef YY_USE_PROTOS
+static void yyunput( int c, register char *yy_bp )
+#else
+static void yyunput( c, yy_bp )
+int c;
+register char *yy_bp;
+#endif
+	{
+	register char *yy_cp = yy_c_buf_p;
+
+	/* undo effects of setting up yytext */
+	*yy_cp = yy_hold_char;
+
+	if ( yy_cp < yy_current_buffer->yy_ch_buf + 2 )
+		{ /* need to shift things up to make room */
+		/* +2 for EOB chars. */
+		register int number_to_move = yy_n_chars + 2;
+		register char *dest = &yy_current_buffer->yy_ch_buf[
+					yy_current_buffer->yy_buf_size + 2];
+		register char *source =
+				&yy_current_buffer->yy_ch_buf[number_to_move];
+
+		while ( source > yy_current_buffer->yy_ch_buf )
+			*--dest = *--source;
+
+		yy_cp += (int) (dest - source);
+		yy_bp += (int) (dest - source);
+		yy_current_buffer->yy_n_chars =
+			yy_n_chars = yy_current_buffer->yy_buf_size;
+
+		if ( yy_cp < yy_current_buffer->yy_ch_buf + 2 )
+			YY_FATAL_ERROR( "flex scanner push-back overflow" );
+		}
+
+	*--yy_cp = (char) c;
+
+
+	yytext_ptr = yy_bp;
+	yy_hold_char = *yy_cp;
+	yy_c_buf_p = yy_cp;
+	}
+#endif	/* ifndef YY_NO_UNPUT */
+
+
+#ifdef __cplusplus
+static int yyinput()
+#else
+static int input()
+#endif
+	{
+	int c;
+
+	*yy_c_buf_p = yy_hold_char;
+
+	if ( *yy_c_buf_p == YY_END_OF_BUFFER_CHAR )
+		{
+		/* yy_c_buf_p now points to the character we want to return.
+		 * If this occurs *before* the EOB characters, then it's a
+		 * valid NUL; if not, then we've hit the end of the buffer.
+		 */
+		if ( yy_c_buf_p < &yy_current_buffer->yy_ch_buf[yy_n_chars] )
+			/* This was really a NUL. */
+			*yy_c_buf_p = '\0';
+
+		else
+			{ /* need more input */
+			int offset = yy_c_buf_p - yytext_ptr;
+			++yy_c_buf_p;
+
+			switch ( yy_get_next_buffer() )
+				{
+				case EOB_ACT_LAST_MATCH:
+					/* This happens because yy_g_n_b()
+					 * sees that we've accumulated a
+					 * token and flags that we need to
+					 * try matching the token before
+					 * proceeding.  But for input(),
+					 * there's no matching to consider.
+					 * So convert the EOB_ACT_LAST_MATCH
+					 * to EOB_ACT_END_OF_FILE.
+					 */
+
+					/* Reset buffer status. */
+					yyrestart( yyin );
+
+					/* fall through */
+
+				case EOB_ACT_END_OF_FILE:
+					{
+					if ( yywrap() )
+						return EOF;
+
+					if ( ! yy_did_buffer_switch_on_eof )
+						YY_NEW_FILE;
+#ifdef __cplusplus
+					return yyinput();
+#else
+					return input();
+#endif
+					}
+
+				case EOB_ACT_CONTINUE_SCAN:
+					yy_c_buf_p = yytext_ptr + offset;
+					break;
+				}
+			}
+		}
+
+	c = *(unsigned char *) yy_c_buf_p;	/* cast for 8-bit char's */
+	*yy_c_buf_p = '\0';	/* preserve yytext */
+	yy_hold_char = *++yy_c_buf_p;
+
+
+	return c;
+	}
+
+
+#ifdef YY_USE_PROTOS
+void yyrestart( FILE *input_file )
+#else
+void yyrestart( input_file )
+FILE *input_file;
+#endif
+	{
+	if ( ! yy_current_buffer )
+		yy_current_buffer = yy_create_buffer( yyin, YY_BUF_SIZE );
+
+	yy_init_buffer( yy_current_buffer, input_file );
+	yy_load_buffer_state();
+	}
+
+
+#ifdef YY_USE_PROTOS
+void yy_switch_to_buffer( YY_BUFFER_STATE new_buffer )
+#else
+void yy_switch_to_buffer( new_buffer )
+YY_BUFFER_STATE new_buffer;
+#endif
+	{
+	if ( yy_current_buffer == new_buffer )
+		return;
+
+	if ( yy_current_buffer )
+		{
+		/* Flush out information for old buffer. */
+		*yy_c_buf_p = yy_hold_char;
+		yy_current_buffer->yy_buf_pos = yy_c_buf_p;
+		yy_current_buffer->yy_n_chars = yy_n_chars;
+		}
+
+	yy_current_buffer = new_buffer;
+	yy_load_buffer_state();
+
+	/* We don't actually know whether we did this switch during
+	 * EOF (yywrap()) processing, but the only time this flag
+	 * is looked at is after yywrap() is called, so it's safe
+	 * to go ahead and always set it.
+	 */
+	yy_did_buffer_switch_on_eof = 1;
+	}
+
+
+#ifdef YY_USE_PROTOS
+void yy_load_buffer_state( void )
+#else
+void yy_load_buffer_state()
+#endif
+	{
+	yy_n_chars = yy_current_buffer->yy_n_chars;
+	yytext_ptr = yy_c_buf_p = yy_current_buffer->yy_buf_pos;
+	yyin = yy_current_buffer->yy_input_file;
+	yy_hold_char = *yy_c_buf_p;
+	}
+
+
+#ifdef YY_USE_PROTOS
+YY_BUFFER_STATE yy_create_buffer( FILE *file, int size )
+#else
+YY_BUFFER_STATE yy_create_buffer( file, size )
+FILE *file;
+int size;
+#endif
+	{
+	YY_BUFFER_STATE b;
+
+	b = (YY_BUFFER_STATE) yy_flex_alloc( sizeof( struct yy_buffer_state ) );
+	if ( ! b )
+		YY_FATAL_ERROR( "out of dynamic memory in yy_create_buffer()" );
+
+	b->yy_buf_size = size;
+
+	/* yy_ch_buf has to be 2 characters longer than the size given because
+	 * we need to put in 2 end-of-buffer characters.
+	 */
+	b->yy_ch_buf = (char *) yy_flex_alloc( b->yy_buf_size + 2 );
+	if ( ! b->yy_ch_buf )
+		YY_FATAL_ERROR( "out of dynamic memory in yy_create_buffer()" );
+
+	b->yy_is_our_buffer = 1;
+
+	yy_init_buffer( b, file );
+
+	return b;
+	}
+
+
+#ifdef YY_USE_PROTOS
+void yy_delete_buffer( YY_BUFFER_STATE b )
+#else
+void yy_delete_buffer( b )
+YY_BUFFER_STATE b;
+#endif
+	{
+	if ( ! b )
+		return;
+
+	if ( b == yy_current_buffer )
+		yy_current_buffer = (YY_BUFFER_STATE) 0;
+
+	if ( b->yy_is_our_buffer )
+		yy_flex_free( (void *) b->yy_ch_buf );
+
+	yy_flex_free( (void *) b );
+	}
+
+
+#ifndef YY_ALWAYS_INTERACTIVE
+#ifndef YY_NEVER_INTERACTIVE
+extern int isatty YY_PROTO(( int ));
+#endif
+#endif
+
+#ifdef YY_USE_PROTOS
+void yy_init_buffer( YY_BUFFER_STATE b, FILE *file )
+#else
+void yy_init_buffer( b, file )
+YY_BUFFER_STATE b;
+FILE *file;
+#endif
+
+
+	{
+	yy_flush_buffer( b );
+
+	b->yy_input_file = file;
+	b->yy_fill_buffer = 1;
+
+#if YY_ALWAYS_INTERACTIVE
+	b->yy_is_interactive = 1;
+#else
+#if YY_NEVER_INTERACTIVE
+	b->yy_is_interactive = 0;
+#else
+	b->yy_is_interactive = file ? (isatty( fileno(file) ) > 0) : 0;
+#endif
+#endif
+	}
+
+
+#ifdef YY_USE_PROTOS
+void yy_flush_buffer( YY_BUFFER_STATE b )
+#else
+void yy_flush_buffer( b )
+YY_BUFFER_STATE b;
+#endif
+
+	{
+	if ( ! b )
+		return;
+
+	b->yy_n_chars = 0;
+
+	/* We always need two end-of-buffer characters.  The first causes
+	 * a transition to the end-of-buffer state.  The second causes
+	 * a jam in that state.
+	 */
+	b->yy_ch_buf[0] = YY_END_OF_BUFFER_CHAR;
+	b->yy_ch_buf[1] = YY_END_OF_BUFFER_CHAR;
+
+	b->yy_buf_pos = &b->yy_ch_buf[0];
+
+	b->yy_at_bol = 1;
+	b->yy_buffer_status = YY_BUFFER_NEW;
+
+	if ( b == yy_current_buffer )
+		yy_load_buffer_state();
+	}
+
+
+#ifndef YY_NO_SCAN_BUFFER
+#ifdef YY_USE_PROTOS
+YY_BUFFER_STATE yy_scan_buffer( char *base, yy_size_t size )
+#else
+YY_BUFFER_STATE yy_scan_buffer( base, size )
+char *base;
+yy_size_t size;
+#endif
+	{
+	YY_BUFFER_STATE b;
+
+	if ( size < 2 ||
+	     base[size-2] != YY_END_OF_BUFFER_CHAR ||
+	     base[size-1] != YY_END_OF_BUFFER_CHAR )
+		/* They forgot to leave room for the EOB's. */
+		return 0;
+
+	b = (YY_BUFFER_STATE) yy_flex_alloc( sizeof( struct yy_buffer_state ) );
+	if ( ! b )
+		YY_FATAL_ERROR( "out of dynamic memory in yy_scan_buffer()" );
+
+	b->yy_buf_size = size - 2;	/* "- 2" to take care of EOB's */
+	b->yy_buf_pos = b->yy_ch_buf = base;
+	b->yy_is_our_buffer = 0;
+	b->yy_input_file = 0;
+	b->yy_n_chars = b->yy_buf_size;
+	b->yy_is_interactive = 0;
+	b->yy_at_bol = 1;
+	b->yy_fill_buffer = 0;
+	b->yy_buffer_status = YY_BUFFER_NEW;
+
+	yy_switch_to_buffer( b );
+
+	return b;
+	}
+#endif
+
+
+#ifndef YY_NO_SCAN_STRING
+#ifdef YY_USE_PROTOS
+YY_BUFFER_STATE yy_scan_string( yyconst char *yy_str )
+#else
+YY_BUFFER_STATE yy_scan_string( yy_str )
+yyconst char *yy_str;
+#endif
+	{
+	int len;
+	for ( len = 0; yy_str[len]; ++len )
+		;
+
+	return yy_scan_bytes( yy_str, len );
+	}
+#endif
+
+
+#ifndef YY_NO_SCAN_BYTES
+#ifdef YY_USE_PROTOS
+YY_BUFFER_STATE yy_scan_bytes( yyconst char *bytes, int len )
+#else
+YY_BUFFER_STATE yy_scan_bytes( bytes, len )
+yyconst char *bytes;
+int len;
+#endif
+	{
+	YY_BUFFER_STATE b;
+	char *buf;
+	yy_size_t n;
+	int i;
+
+	/* Get memory for full buffer, including space for trailing EOB's. */
+	n = len + 2;
+	buf = (char *) yy_flex_alloc( n );
+	if ( ! buf )
+		YY_FATAL_ERROR( "out of dynamic memory in yy_scan_bytes()" );
+
+	for ( i = 0; i < len; ++i )
+		buf[i] = bytes[i];
+
+	buf[len] = buf[len+1] = YY_END_OF_BUFFER_CHAR;
+
+	b = yy_scan_buffer( buf, n );
+	if ( ! b )
+		YY_FATAL_ERROR( "bad buffer in yy_scan_bytes()" );
+
+	/* It's okay to grow etc. this buffer, and we should throw it
+	 * away when we're done.
+	 */
+	b->yy_is_our_buffer = 1;
+
+	return b;
+	}
+#endif
+
+
+#ifndef YY_NO_PUSH_STATE
+#ifdef YY_USE_PROTOS
+static void yy_push_state( int new_state )
+#else
+static void yy_push_state( new_state )
+int new_state;
+#endif
+	{
+	if ( yy_start_stack_ptr >= yy_start_stack_depth )
+		{
+		yy_size_t new_size;
+
+		yy_start_stack_depth += YY_START_STACK_INCR;
+		new_size = yy_start_stack_depth * sizeof( int );
+
+		if ( ! yy_start_stack )
+			yy_start_stack = (int *) yy_flex_alloc( new_size );
+
+		else
+			yy_start_stack = (int *) yy_flex_realloc(
+					(void *) yy_start_stack, new_size );
+
+		if ( ! yy_start_stack )
+			YY_FATAL_ERROR(
+			"out of memory expanding start-condition stack" );
+		}
+
+	yy_start_stack[yy_start_stack_ptr++] = YY_START;
+
+	BEGIN(new_state);
+	}
+#endif
+
+
+#ifndef YY_NO_POP_STATE
+static void yy_pop_state()
+	{
+	if ( --yy_start_stack_ptr < 0 )
+		YY_FATAL_ERROR( "start-condition stack underflow" );
+
+	BEGIN(yy_start_stack[yy_start_stack_ptr]);
+	}
+#endif
+
+
+#ifndef YY_NO_TOP_STATE
+static int yy_top_state()
+	{
+	return yy_start_stack[yy_start_stack_ptr - 1];
+	}
+#endif
+
+#ifndef YY_EXIT_FAILURE
+#define YY_EXIT_FAILURE 2
+#endif
+
+#ifdef YY_USE_PROTOS
+static void yy_fatal_error( yyconst char msg[] )
+#else
+static void yy_fatal_error( msg )
+char msg[];
+#endif
+	{
+	(void) fprintf( stderr, "%s\n", msg );
+	exit( YY_EXIT_FAILURE );
+	}
+
+
+
+/* Redefine yyless() so it works in section 3 code. */
+
+#undef yyless
+#define yyless(n) \
+	do \
+		{ \
+		/* Undo effects of setting up yytext. */ \
+		yytext[yyleng] = yy_hold_char; \
+		yy_c_buf_p = yytext + n; \
+		yy_hold_char = *yy_c_buf_p; \
+		*yy_c_buf_p = '\0'; \
+		yyleng = n; \
+		} \
+	while ( 0 )
+
+
+/* Internal utility routines. */
+
+#ifndef yytext_ptr
+#ifdef YY_USE_PROTOS
+static void yy_flex_strncpy( char *s1, yyconst char *s2, int n )
+#else
+static void yy_flex_strncpy( s1, s2, n )
+char *s1;
+yyconst char *s2;
+int n;
+#endif
+	{
+	register int i;
+	for ( i = 0; i < n; ++i )
+		s1[i] = s2[i];
+	}
+#endif
+
+#ifdef YY_NEED_STRLEN
+#ifdef YY_USE_PROTOS
+static int yy_flex_strlen( yyconst char *s )
+#else
+static int yy_flex_strlen( s )
+yyconst char *s;
+#endif
+	{
+	register int n;
+	for ( n = 0; s[n]; ++n )
+		;
+
+	return n;
+	}
+#endif
+
+
+#ifdef YY_USE_PROTOS
+static void *yy_flex_alloc( yy_size_t size )
+#else
+static void *yy_flex_alloc( size )
+yy_size_t size;
+#endif
+	{
+	return (void *) malloc( size );
+	}
+
+#ifdef YY_USE_PROTOS
+static void *yy_flex_realloc( void *ptr, yy_size_t size )
+#else
+static void *yy_flex_realloc( ptr, size )
+void *ptr;
+yy_size_t size;
+#endif
+	{
+	/* The cast to (char *) in the following accommodates both
+	 * implementations that use char* generic pointers, and those
+	 * that use void* generic pointers.  It works with the latter
+	 * because both ANSI C and C++ allow castless assignment from
+	 * any pointer type to void*, and deal with argument conversions
+	 * as though doing an assignment.
+	 */
+	return (void *) realloc( (char *) ptr, size );
+	}
+
+#ifdef YY_USE_PROTOS
+static void yy_flex_free( void *ptr )
+#else
+static void yy_flex_free( ptr )
+void *ptr;
+#endif
+	{
+	free( ptr );
+	}
+
+#if YY_MAIN
+int main()
+	{
+	yylex();
+	return 0;
+	}
+#endif
+#line 88 "scanner.ll"
+
+/* "use"             {if (trace) ECHO; column+=yyleng; return T_USE;              } */
diff -urN somfree\somopc\src\scanner.ll newsomfree3\somopc\src\scanner.ll
--- somfree\somopc\src\scanner.ll	Thu Jan 01 07:00:00 1970
+++ newsomfree3\somopc\src\scanner.ll	Sat Mar 16 14:09:28 2024
@@ -0,0 +1,90 @@
+%{
+
+#include <stdio.h>  // fopen
+#include <stdlib.h> // malloc, free, realloc
+#include <string.h> // strcat
+
+#include <emitlib.h>
+
+#include "gramma.yy.tab.h"
+
+int trace=1;
+int lineno=1, column=0;
+char comment[16384]; // handle with -C
+char passthru[32768]; // handle with -S
+
+%}
+
+
+%x IN_CPP_COMMENT
+%x IN_PASSTHRU
+
+%%
+
+<INITIAL>{
+  "/*"             {BEGIN(IN_CPP_COMMENT); comment[0]=0x0; }
+  "passthru:"       {BEGIN(IN_PASSTHRU); passthru[0]=0x0;}
+}
+
+<IN_CPP_COMMENT>{
+  "*/"      { BEGIN(INITIAL); yylval.stval=strdup(comment); return T_COMMENT; }
+  [^*\n]+   { strcat(comment, yytext); }
+  "*"       // eat the lone star
+  \n        { strcat(comment, "\n"); lineno++; }
+}
+
+<IN_PASSTHRU>{
+  "endpassthru;"  {BEGIN(INITIAL);}
+  [^\n]+    { strcat(passthru, yytext);}
+  \n        { strcat(passthru, "\n"); lineno++; }
+}
+
+[0-9]+	 	  {if (trace) ECHO; column+=yyleng; yylval.ival=atoi(yytext); return T_CONSTANT;}
+:                 {if (trace) ECHO; column+=yyleng; return T_COLON;            }
+;                 {if (trace) ECHO; column+=yyleng; return T_SEMICOLON;        }
+,                 {if (trace) ECHO; column+=yyleng; return T_COMMA;            }
+=                 {if (trace) ECHO; column+=yyleng; return T_EQUAL;            }
+--                {if (trace) ECHO; column+=yyleng; return T_DASHES;           }
+"..."             {if (trace) ECHO; column+=yyleng; return T_ELLIPSIS;         }
+"*"               {if (trace) ECHO; column+=yyleng; yylval.stval=strdup(yytext); return T_STAR; }
+"("               {if (trace) ECHO; column+=yyleng; return T_LEFTPARENTHESIS;  }
+")"               {if (trace) ECHO; column+=yyleng; return T_RIGHTPARENTHESIS; }
+"["               {if (trace) ECHO; column+=yyleng; return T_LEFTSQUAREBRACKET;  }
+"]"               {if (trace) ECHO; column+=yyleng; return T_RIGHTSQUAREBRACKET; }
+^#line            {if (trace) ECHO; column+=yyleng; return T_LINE;             }
+class             {if (trace) ECHO; column+=yyleng; return T_CLASS;            }
+file              {if (trace) ECHO; column+=yyleng; return T_FILE;             }
+stem              {if (trace) ECHO; column+=yyleng; return T_STEM;             }
+function          {if (trace) ECHO; column+=yyleng; return T_FUNCTION;         }
+prefix            {if (trace) ECHO; column+=yyleng; return T_PREFIX;           }
+classprefix       {if (trace) ECHO; column+=yyleng; return T_CLASSPREFIX;      }
+major             {if (trace) ECHO; column+=yyleng; return T_MAJOR;            }
+minor             {if (trace) ECHO; column+=yyleng; return T_MINOR;            }
+version           {if (trace) ECHO; column+=yyleng; return T_VERSION;          }
+global            {if (trace) ECHO; column+=yyleng; return T_GLOBAL;           }
+local             {if (trace) ECHO; column+=yyleng; return T_LOCAL;            }
+classInit         {if (trace) ECHO; column+=yyleng; return T_CLASSINIT;        }
+release           {if (trace) ECHO; column+=yyleng; return T_RELEASE;          }
+order             {if (trace) ECHO; column+=yyleng; return T_ORDER;            }
+metaclass         {if (trace) ECHO; column+=yyleng; return T_METACLASS;        }
+parent            {if (trace) ECHO; column+=yyleng; return T_PARENT;           }
+data              {if (trace) ECHO; column+=yyleng; return T_DATA;             }
+private           {if (trace) ECHO; column+=yyleng; return T_PRIVATE;          }
+public            {if (trace) ECHO; column+=yyleng; return T_PUBLIC;           }
+internal          {if (trace) ECHO; column+=yyleng; return T_INTERNAL;         }
+methods           {if (trace) ECHO; column+=yyleng; return T_METHODS;          }
+group             {if (trace) ECHO; column+=yyleng; return T_GROUP;            }
+method            {if (trace) ECHO; column+=yyleng; return T_METHOD;           }
+procedure         {if (trace) ECHO; column+=yyleng; return T_PROCEDURE;        }
+offset            {if (trace) ECHO; column+=yyleng; return T_OFFSET;           }
+name              {if (trace) ECHO; column+=yyleng; return T_NAME;             }
+lookup            {if (trace) ECHO; column+=yyleng; return T_LOOKUP;           }
+external          {if (trace) ECHO; column+=yyleng; return T_EXTERNAL;         }
+override          {if (trace) ECHO; column+=yyleng; return T_OVERRIDE;         }
+[A-Za-z][_0-9A-Za-z]* {if (trace) ECHO; column+=yyleng; yylval.stval=strdup(yytext); return T_IDENTIFIER;   }
+[ \t]+            { column++;                                                  }
+\n                { lineno++;                                                  }
+.                 { printf("ERROR"); };
+
+%%
+/* "use"             {if (trace) ECHO; column+=yyleng; return T_USE;              } */
diff -urN somfree\somopc\src\vector.csc newsomfree3\somopc\src\vector.csc
--- somfree\somopc\src\vector.csc	Thu Jan 01 07:00:00 1970
+++ newsomfree3\somopc\src\vector.csc	Sat Mar 16 14:09:28 2024
@@ -0,0 +1,109 @@
+class: Vector,
+	file stem = vector,
+	external prefix = vect,
+	classprefix = mvec,
+	major version = 1,
+	minor version = 9 ;
+
+/*-- Demo class definition that implements a simple vector-of-integers
+-- object . Vector elements are numbered from 0. The size of the
+-- vector must be set before using the array (otherwise it raises an
+-- error) and cannot be changed once it is set.
+-- This is a comment.
+*/
+
+parent: SOMObject;
+
+/* parent is SOMObject */
+
+passthru: C.h;
+/* something to put in the VECTOR.H file */
+endpassthru;
+passthru: C.ph;
+/* something to put in the VECTOR.PH file */
+endpassthru;
+passthru: C.ih;
+/* something to put in the VECTOR.IH file */
+endpassthru;
+
+data:
+	integer4 (*body)[], public;
+
+/*	-- <body> is a public instance variable, and therefore accessible in
+	-- any code that has access to this class. It is accessed via a macro
+	-- of the form get_body (obj} where obj is the object whose instance of
+	-- body you are accessing. The macro expression can be used on the
+	-- right- or left-hand side of an assignment.
+*/
+	int size;
+
+/*	-- <size> is a private instance variable, and therefore accessible
+	-- only in the code that participates in the implementation of this
+	-- class.
+*/
+
+methods :
+SOMAny *newVectorOfSize(int size), class;
+
+/* -- Creates a new instance of Vector and sets its size to <size>. */
+
+integer4 get(int i);
+
+/*
+-- Returns the <i>th element in the vector. Raises an error if
+-- this vector does not have an <i>th element.
+*/
+
+void set(int i, integer4 value);
+
+/*
+-- Set the <i>th element of this vector. Raises an error if
+-- this vector does not have an <i>th element.
+*/
+
+void setMany(int start, int num, ...) ;
+
+/*
+-- Set several elements at once. You must provide <num> elements, and
+-- they will be assigned to vector elements starting with <start>.
+-- Raises an error if this vector does not include each of the positions
+-- covered by the assignment.
+*/
+
+void setAll(integer4 value),
+	private ;
+
+/*
+-- Sets all the elements in this vector to <value>.
+-- Note : This is a private method and is not available for use unless
+-- one has access to the private header file. It would not appear in
+-- the VECTOR.SC file.
+*/
+
+void setSize(int size);
+
+/*
+-- Set the size of a vector;
+-- Use this method to establish the capacity of any Vector instance
+-- created by the VectorNew macro (as opposed to instances created
+-- with the newVectorOfSize constructor), before putting anything in
+-- the vector.
+*/
+
+override somInit;
+
+/*
+-- Method prototype:
+-- void somInit(Vector *somSelf);
+-- Add initialization of the vector instance data.
+*/
+
+override somDumpSelfInt;
+
+/*
+-- Method prototype:
+-- void somDumpSelfInt (Vector *somSelf, int level);
+-- Add output of the vector instance data.
+*/
+
+release order : somDumpSelfInt, somInit;
diff -urN somfree\somopc\win32\link386.c newsomfree3\somopc\win32\link386.c
--- somfree\somopc\win32\link386.c	Thu Jan 01 07:00:00 1970
+++ newsomfree3\somopc\win32\link386.c	Sat Mar 16 14:09:28 2024
@@ -0,0 +1,24 @@
+/**************************************************************************
+ *
+ *  Copyright 2008, Roger Brown
+ *
+ *  This file is part of Roger Brown's Toolkit.
+ *
+ *  This program is free software: you can redistribute it and/or modify it
+ *  under the terms of the GNU Lesser General Public License as published by the
+ *  Free Software Foundation, either version 3 of the License, or (at your
+ *  option) any later version.
+ * 
+ *  This program is distributed in the hope that it will be useful, but WITHOUT
+ *  ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ *  FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for
+ *  more details.
+ *
+ *  You should have received a copy of the GNU Lesser General Public License
+ *  along with this program.  If not, see <http://www.gnu.org/licenses/>
+ *
+ */
+
+#define LINK386_SOMC
+
+#include <link386.h>
diff -urN somfree\somopc\win32\somopc.mak newsomfree3\somopc\win32\somopc.mak
--- somfree\somopc\win32\somopc.mak	Thu Jan 01 07:00:00 1970
+++ newsomfree3\somopc\win32\somopc.mak	Sat Mar 16 14:09:28 2024
@@ -0,0 +1,85 @@
+#
+#  Copyright 2008, Roger Brown
+#
+#  This file is part of Roger Brown's Toolkit.
+#
+#  This program is free software: you can redistribute it and/or modify it
+#  under the terms of the GNU Lesser General Public License as published by the
+#  Free Software Foundation, either version 3 of the License, or (at your
+#  option) any later version.
+# 
+#  This program is distributed in the hope that it will be useful, but WITHOUT
+#  ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+#  FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for
+#  more details.
+#
+#  You should have received a copy of the GNU Lesser General Public License
+#  along with this program.  If not, see <http://www.gnu.org/licenses/>
+#
+#  $Id: somipc.mak 35 2020-06-07 02:05:42Z somtoolkit $
+
+!include $(MAKEDEFS)
+
+OUTDIR=$(OUTDIR_BIN)
+INTDIR=$(BUILDTYPE)
+
+APPNAME=somopc
+
+OBJS=	$(INTDIR)\gramma.yy.tab.obj		\
+		$(INTDIR)\lex.yy.obj		\
+		$(INTDIR)\link386.obj
+
+TARGET_EXE=$(OUTDIR)\$(APPNAME).exe
+TARGET_PDB=$(OUTDIR)\$(APPNAME).pdb
+
+PARTOPTS=	$(STDOPTXX)					\
+			/DHAVE_CONFIG_HPP			\
+			/D_CONSOLE					\
+			/DWIN32_LEAN_AND_MEAN		\
+			/I..\..\include\$(PLATFORM)	\
+			/I..\..\include\$(PLATFORM_DEF)	\
+			/I..\..\include				\
+			/I..\include				\
+			/I..\..\somidl\$(PLATFORM)	\
+			/I..\..\somkpub\include	\
+			/I..\..\somc\include	\
+			$(CC_OUT_PDB)$(TARGET_PDB)
+
+all: $(TARGET_EXE)
+
+clean:
+	$(CLEAN) $(TARGET_EXE)				\
+			 $(TARGET_PDB)				\
+			 $(OBJS)					\
+			 $(INTDIR)\$(APPNAME).res	\
+			 $(OUTDIR)\$(APPNAME).lib	\
+			 $(OUTDIR)\$(APPNAME).exp
+	
+$(TARGET_EXE): $(OBJS) $(OUTDIR) $(INTDIR)\$(APPNAME).res
+	$(CC) $(CC_OUT_EXE)$@ $(OBJS)		\
+		  $(CC_OUT_PDB)$(TARGET_PDB)	\
+		  $(CC_LINK)					\
+		  $(LD_SUBSYSTEM_CONSOLE)		\
+		  $(LD_ENTRY_MAIN) \
+		  $(LDFLAGS) $(INTDIR)\$(APPNAME).res
+	$(POSTLINK_EXE) $@
+
+$(INTDIR)\gramma.yy.tab.obj: ..\src\gramma.yy.tab.c $(INTDIR)
+	$(CC) /c $(PARTOPTS) $(CC_OUT_OBJ)$@ ..\src\gramma.yy.tab.c
+
+$(INTDIR)\lex.yy.obj: ..\src\lex.yy.c $(INTDIR)
+	$(CC) /c $(PARTOPTS) $(CC_OUT_OBJ)$@ ..\src\lex.yy.c
+
+$(INTDIR)\link386.obj: ..\win32\link386.c $(INTDIR)
+	$(CC) /c $(PARTOPTS) $(CC_OUT_OBJ)$@ ..\win32\link386.c
+
+$(INTDIR):
+	mkdir $@
+
+$(INTDIR)\$(APPNAME).res: ..\win32\$(APPNAME).rc
+	rc /nologo /r /I.. /I..\..\include\$(PLATFORM) /fo$@ ..\win32\$(APPNAME).rc
+
+dist:
+
+
+test:
diff -urN somfree\somopc\win32\somopc.rc newsomfree3\somopc\win32\somopc.rc
--- somfree\somopc\win32\somopc.rc	Thu Jan 01 07:00:00 1970
+++ newsomfree3\somopc\win32\somopc.rc	Sat Mar 16 14:09:28 2024
@@ -0,0 +1,38 @@
+#include "windows.h"
+#include <depvers.h>
+
+1 VERSIONINFO
+ FILEVERSION DEPVERS_somipc_INT4
+ PRODUCTVERSION DEPVERS_somtkpkg_INT4
+ FILEFLAGSMASK 0x3fL
+#ifdef _DEBUG
+ FILEFLAGS VS_FF_DEBUG|VS_FF_PRERELEASE
+#else
+ FILEFLAGS VS_FF_PRERELEASE
+#endif
+ FILEOS VOS_NT_WINDOWS32
+ FILETYPE VFT_APP
+ FILESUBTYPE 0x0L
+BEGIN
+    BLOCK "StringFileInfo"
+    BEGIN
+        BLOCK "140904e4" // New Zealand
+        BEGIN
+            VALUE "Comments", "SOM OIDL compiler\0"
+            VALUE "CompanyName", "Yuri Prokushev\0"
+            VALUE "FileDescription", "SOM OIDL compiler\0"
+            VALUE "FileVersion", DEPVERS_somipc_STR4
+            VALUE "InternalName", "somopc\0"
+            VALUE "LegalCopyright", "й Roger Brown. 2007\0"
+    	    VALUE "LegalTrademarks", "SOMobjects is a trademark of IBM\0"
+            VALUE "OriginalFilename", "SOMOPC.EXE\0"
+            VALUE "ProductName", DEPVERS_somtkpkg_PRODUCTNAME
+            VALUE "ProductVersion", DEPVERS_somtkpkg_STR4
+        END
+    END
+    BLOCK "VarFileInfo"
+    BEGIN
+        VALUE "Translation", 0x1409, 1252
+    END
+END
+
diff -urN somfree\somstars\os2\somstars.cmd newsomfree3\somstars\os2\somstars.cmd
--- somfree\somstars\os2\somstars.cmd	Thu Jan 01 07:00:00 1970
+++ newsomfree3\somstars\os2\somstars.cmd	Sat Mar 16 14:09:28 2024
@@ -0,0 +1,32 @@
+@echo off
+if "%SOMBASE%"=="" goto sombase
+
+if not exist somstars.gen goto normal
+echo Generating SOM C bindings in progress...
+goto end
+
+:normal
+echo Generating the SOM C Bindings:
+echo (Warning, these bindings are not CORBA-compliant)
+set SC=%SOMBASE%\bin\sc.exe
+cd %SOMBASE%\include
+attrib -r som.h
+attrib -r gen_c.efw
+attrib -r gen_emit.efw
+attrib -r gen_make.efw
+copy som.hs       som.h > NUL
+copy gen_c.efs    gen_c.efw  > NUL
+copy gen_emit_c.efs gen_emit_c.efw  > NUL
+copy gen_make_c.efs gen_make_c.efw > NUL
+echo somstars.gen > somstars.gen
+set SMNOADDSTAR=
+%SC% -%% -maddstar -mwinmult -mnochk -sh *.idl
+if not errorlevel 0 goto end
+if exist somdtype.idl %SC% -maddstar -mwinmult -mnochk -sh -DEMIT_SOMDTYPES somdtype.idl
+goto end
+
+:sombase
+echo SOMBASE should be set before running somstars.
+goto end
+
+:end
diff -urN somfree\somstars\win32\somstars.cmd newsomfree3\somstars\win32\somstars.cmd
--- somfree\somstars\win32\somstars.cmd	Thu Jan 01 07:00:00 1970
+++ newsomfree3\somstars\win32\somstars.cmd	Sat Mar 16 14:09:28 2024
@@ -0,0 +1,40 @@
+@echo off
+
+if "%ProgramFiles%\somtk\bin\" == "%~dp0" set SOMBASE=%ProgramFiles%\somtk
+if "%ProgramFiles(x86)%\somtk\bin\" == "%~dp0" set SOMBASE=%ProgramFiles(x86)%\somtk
+if "%ProgramFiles(Arm)%\somtk\bin\" == "%~dp0" set SOMBASE=%ProgramFiles(Arm)%\somtk
+if "%ProgramW6432%\somtk\bin\" == "%~dp0" set SOMBASE=%ProgramW6432%\somtk
+
+if "%SOMBASE%x" == "x" if exist "%ProgramFiles%\somtk" set SOMBASE=%ProgramFiles%\somtk
+
+if "%SOMBASE%"=="" goto sombase
+
+if not exist somstars.gen goto normal
+echo Generating SOM C bindings in progress...
+goto end
+
+:normal
+echo Generating the SOM C Bindings:
+echo (Warning, these bindings are not CORBA-compliant)
+set SC=%SOMBASE%\bin\sc.exe
+cd %SOMBASE%\include
+attrib -r som.h
+attrib -r gen_c.efw
+attrib -r gen_emit.efw
+attrib -r gen_make.efw
+copy som.hs       som.h > NUL
+copy gen_c.efs    gen_c.efw  > NUL
+copy gen_emit_c.efs gen_emit_c.efw  > NUL
+copy gen_make_c.efs gen_make_c.efw > NUL
+echo somstars.gen > somstars.gen
+set SMNOADDSTAR=
+%SC% -%% -maddstar -mwinmult -mnochk -sh *.idl
+if not errorlevel 0 goto end
+if exist somdtype.idl %SC% -maddstar -mwinmult -mnochk -sh -DEMIT_SOMDTYPES somdtype.idl
+goto end
+
+:sombase
+echo SOMBASE should be set before running somstars.
+goto end
+
+:end
diff -urN somfree\somtklib\win32\somtklib.mak newsomfree3\somtklib\win32\somtklib.mak
--- somfree\somtklib\win32\somtklib.mak	Sun Mar 17 21:36:12 2024
+++ newsomfree3\somtklib\win32\somtklib.mak	Sat Mar 16 14:09:28 2024
@@ -16,7 +16,7 @@
 #  You should have received a copy of the GNU Lesser General Public License
 #  along with this program.  If not, see <http://www.gnu.org/licenses/>
 #
-#  $Id$
+#  $Id: somtklib.mak 35 2020-06-07 02:05:42Z somtoolkit $
 
 !include $(MAKEDEFS)
 
@@ -39,7 +39,9 @@
 		$(OUTDIR_DLL)\somem.lib \
 		$(OUTDIR_DLL)\somp.lib \
 		$(OUTDIR_DLL)\somnmf.lib \
-		$(OUTDIR_DLL)\soms.lib 
+		$(OUTDIR_DLL)\soms.lib \
+		$(OUTDIR_DLL)\somc.lib \
+		$(OUTDIR_DLL)\some.lib 
 
 $(SOMTKLIB): $(SOMLIBS)
 	if exist $@ del $@
diff -urN somfree\somwm35i\include\optlink.h newsomfree3\somwm35i\include\optlink.h
--- somfree\somwm35i\include\optlink.h	Thu Jan 01 07:00:00 1970
+++ newsomfree3\somwm35i\include\optlink.h	Sat Mar 16 14:09:28 2024
@@ -0,0 +1,46 @@
+/**************************************************************************
+ *
+ *  Copyright 2022, Yuri Prokushev
+ *
+ *  This file is part of osFree project
+ *
+ *  This program is free software: you can redistribute it and/or modify it
+ *  under the terms of the GNU Lesser General Public License as published by the
+ *  Free Software Foundation, either version 3 of the License, or (at your
+ *  option) any later version.
+ * 
+ *  This program is distributed in the hope that it will be useful, but WITHOUT
+ *  ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ *  FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for
+ *  more details.
+ *
+ *  You should have received a copy of the GNU Lesser General Public License
+ *  along with this program.  If not, see <http://www.gnu.org/licenses/>
+ *
+ */
+
+// OPTLINK emulation for MSVC
+#if defined(_WIN32) && defined(_M_IX86) && !defined(_WIN64)
+        #define OPTLINK_3ARGS(a,b,c)            \
+                        __asm { mov             a,eax   }       \
+                        __asm { mov             b,edx   }       \
+                        __asm { mov             c,ecx   }
+        #define OPTLINK_2ARGS(a,b)            \
+                        __asm { mov             a,eax   }       \
+                        __asm { mov             b,edx   }       
+	#define OPTLINK_2ARGS_DWORD_BYTE(a,b)            \
+                        __asm { mov             a,eax   }       \
+                        __asm { mov             b,dl    }       
+        #define OPTLINK_1ARG(a)            \
+                        __asm { mov             a,eax   }
+        #define OPTLINK_1ARG_BYTE(a)            \
+                        __asm { mov             a,al   }
+        #define OPTLINK_DECL    __cdecl
+#else
+        #define OPTLINK_3ARGS(a,b,c)
+        #define OPTLINK_2ARGS(a,b)
+	#define OPTLINK_2ARGS_DWORD_BYTE(a,b)
+        #define OPTLINK_1ARG(a)
+        #define OPTLINK_1ARG_BYTE(a)
+        #define OPTLINK_DECL
+#endif
diff -urN somfree\somwm35i\makedefs.cf newsomfree3\somwm35i\makedefs.cf
--- somfree\somwm35i\makedefs.cf	Thu Jan 01 07:00:00 1970
+++ newsomfree3\somwm35i\makedefs.cf	Sat Mar 16 14:09:28 2024
@@ -0,0 +1,3 @@
+NAME somwm35i
+DEPENDS config depversh
+PROVIDES somwm35i
diff -urN somfree\somwm35i\src\somwm35i.c newsomfree3\somwm35i\src\somwm35i.c
--- somfree\somwm35i\src\somwm35i.c	Thu Jan 01 07:00:00 1970
+++ newsomfree3\somwm35i\src\somwm35i.c	Sat Mar 16 14:09:28 2024
@@ -0,0 +1,377 @@
+/**************************************************************************
+ *
+ *  Copyright 2022, Yuri Prokushev
+ *
+ *  This file is part of osFree project
+ *
+ *  This program is free software: you can redistribute it and/or modify it
+ *  under the terms of the GNU Lesser General Public License as published by the
+ *  Free Software Foundation, either version 3 of the License, or (at your
+ *  option) any later version.
+ * 
+ *  This program is distributed in the hope that it will be useful, but WITHOUT
+ *  ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ *  FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for
+ *  more details.
+ *
+ *  You should have received a copy of the GNU Lesser General Public License
+ *  along with this program.  If not, see <http://www.gnu.org/licenses/>
+ *
+ */
+
+/*
+
+  This is VAC++ 3.5 C Run-time compatibility library.
+
+  It is used for support IBM SOM 3.0 emitters which compiled with Dynamic C Run-time.
+  Only subset of functions are implemented which was found in emitters.
+
+  Only IBM SOM 3.0 for NT emitters requires this library.
+
+  All functions here just handle Optlink convention and call corresponding C functions. 
+  Because no any function is used for development, no header file provided. All function
+  names has "sr" prefix to resolve conflicts with C names, but exported without this prefix.
+
+*/
+
+#ifndef _WIN32
+#  error This library for Win32 only
+#endif
+
+#include <windows.h>
+
+#include <stdio.h>
+#include <stdlib.h>
+#include <string.h>
+#include <ctype.h>
+
+#include <optlink.h>
+
+// This is array variable. Need to explore
+const unsigned short* sr_ctype;
+
+// Just export it
+FILE * srstderr;
+
+int _cdecl sr_CRT_init(void)
+{
+  return 0;
+}
+
+void _cdecl sr_CRT_term(void)
+{
+}
+
+int _cdecl sr_abort_in_progress(void)
+{
+  return 0;
+}
+
+void _cdecl sr_exception_dllinit(void)
+{
+}         
+
+void _cdecl sr_matherr(void)
+{
+  
+}
+
+int _cdecl sr_fprintfieee(FILE * stream, char * format, ...)
+{
+  int rc;
+  va_list args;
+
+  OPTLINK_2ARGS(stream, format);
+
+  va_start(args, format);
+  rc=vfprintf(stream, format, args);
+  va_end(args);
+
+  return rc;
+}
+
+int _cdecl sr_sprintfieee(char * sstr, char * format, ...)
+{
+  int rc;
+  va_list args;
+
+  OPTLINK_2ARGS(sstr, format);
+
+  va_start(args, format);
+  rc=vsprintf(sstr, format, args);
+  va_end(args);
+
+  return rc;
+}
+
+int _cdecl sr_printfieee(char * format, ...)
+{
+  int rc;
+  va_list args;
+
+  OPTLINK_1ARG(format);
+
+  va_start(args, format);
+  rc=vprintf(format, args);
+  va_end(args);
+
+  return rc;
+}
+
+int _cdecl sr_sscanfieee(char *buf, char *format, ...)
+{
+  int rc;
+  va_list args;
+
+  OPTLINK_2ARGS(buf, format);
+
+  va_start(args, format);
+  rc=vsscanf(buf, format, args);
+  va_end(args);
+
+  return rc;
+}
+
+int _cdecl sr_putenv(char *evar)
+{
+  OPTLINK_1ARG(evar);
+  return putenv(evar);
+}
+
+char * _cdecl srgetenv(char *name)
+{
+  OPTLINK_1ARG(name);
+  return getenv(name);
+}
+
+// @todo
+void _cdecl sr_terminate(void)
+{
+}
+
+// @todo
+void _cdecl sr_PrintErrMsg(void)
+{
+}
+
+// @todo
+void _cdecl sr_SysFindFirst(void)
+{
+}
+
+// @todo
+void _cdecl sr_SysFindNext(void)
+{
+}
+
+// @todo
+void _cdecl sr_SysFindClose(void)
+{
+}
+
+int _cdecl srfclose(FILE *stream)
+{
+  OPTLINK_1ARG(stream);
+  return fclose(stream);
+}
+
+int _cdecl srfeof(FILE *stream)
+{
+  OPTLINK_1ARG(stream);
+  return feof(stream);
+}
+
+int _cdecl srfgetc(FILE *stream)
+{
+  OPTLINK_1ARG(stream);
+  return fgetc(stream);
+}
+
+char * _cdecl srfgets(char *sstr, int num, FILE *stream)
+{
+  OPTLINK_3ARGS(sstr, num, stream);
+  return fgets(sstr, num, stream);
+}
+
+int _cdecl srfputs(char *sstr, FILE *stream)
+{
+  OPTLINK_2ARGS(sstr, stream);
+  return fputs(sstr, stream);
+}
+
+size_t _cdecl srfread(void *buf, size_t ssize, size_t count, FILE *stream)
+{
+  OPTLINK_3ARGS(buf, ssize, count);
+  return fread(buf, ssize, count, stream);
+}
+
+int _cdecl srfseek(FILE *stream, long soffset, int origin)
+{
+  OPTLINK_3ARGS(stream, soffset, origin);
+  return fseek(stream, soffset, origin);
+}
+
+size_t _cdecl srfwrite(void *buf, size_t ssize, size_t count, FILE *stream)
+{
+  OPTLINK_3ARGS(buf, ssize, count);
+  return fwrite(buf, ssize, count, stream);
+}
+
+int _cdecl srremove(char *fname)
+{
+  OPTLINK_1ARG(fname);
+  return remove(fname);
+}
+
+int _cdecl srrename(char *oldfname, char *newfname)
+{
+  OPTLINK_2ARGS(oldfname, newfname);
+  return rename(oldfname, newfname);
+}
+
+void _cdecl srrewind(FILE *stream)
+{
+  OPTLINK_1ARG(stream);
+  rewind(stream);
+}
+
+int _cdecl srstrcmp(char *str1, char *str2)
+{
+  OPTLINK_2ARGS(str1, str2);
+  return strcmp(str1, str2);
+}
+
+char * _cdecl srstrstr(char *str1, char *str2)
+{
+  OPTLINK_2ARGS(str1, str2);
+  return strstr(str1, str2);
+}
+
+size_t _cdecl srstrlen(char *sstr)
+{
+  OPTLINK_1ARG(sstr);
+  return strlen(sstr);
+}
+
+void * _cdecl srmemmove(void *dest, void *source, size_t count)
+{
+  OPTLINK_3ARGS(dest, source, count);
+  return memmove(dest, source, count);
+}
+
+void * _cdecl srmemset(void *buf, int cch, size_t count)
+{
+  OPTLINK_3ARGS(buf, cch, count);
+  return memset(buf, cch, count);
+}
+
+char * _cdecl srstrchr(char *sstr, int cch)
+{
+  OPTLINK_2ARGS(sstr, cch);
+  return strchr(sstr, cch);
+}
+
+char * _cdecl srstrcpy(char *str1, char *str2)
+{
+  OPTLINK_2ARGS(str1, str2);
+  return strcpy(str1, str2);
+}
+
+int _cdecl srstrncmp(char *str1, char *str2, size_t count)
+{
+  OPTLINK_3ARGS(str1, str2, count);
+  return strncmp(str1, str2, count);
+}
+
+char * _cdecl srstrncpy(char *dest, char *source, size_t count)
+{
+  OPTLINK_3ARGS(dest, source, count);
+  return strncpy(dest, source, count);
+}
+
+char * _cdecl srstrrchr(char *sstr, int cch)
+{
+  OPTLINK_2ARGS(sstr, cch);
+  return strrchr(sstr, cch);
+}
+
+char * _cdecl srstrtok(char *str1, char *str2)
+{
+  OPTLINK_2ARGS(str1, str2);
+  return strtok(str1, str2);
+}
+
+int _cdecl srtolower(int cch)
+{
+  OPTLINK_1ARG(cch);
+  return tolower(cch);
+}
+
+void * _cdecl srmemcpy(void *dest, void *source, size_t count)
+{
+  OPTLINK_3ARGS(dest, source, count);
+  return memcpy(dest, source, count);
+}
+
+char * _cdecl srstrcat(char *str1, char *str2)
+{
+  OPTLINK_2ARGS(str1, str2);
+  return strcat(str1, str2);
+}
+
+char * _cdecl srstrdup(char *sstr)
+{
+  OPTLINK_1ARG(sstr);
+  return strdup(sstr);
+}
+
+char * _cdecl srstrpbrk(char *str1, char *str2)
+{
+  OPTLINK_2ARGS(str1, str2);
+  return strpbrk(str1, str2);
+}
+
+void * _cdecl srmalloc(size_t ssize)
+{
+  OPTLINK_1ARG(ssize);
+  return malloc(ssize);
+}
+
+void _cdecl srfree(void *pptr)
+{
+  OPTLINK_1ARG(pptr);
+  free(pptr);
+}
+
+void _cdecl srexit(int sstatus)
+{
+  OPTLINK_1ARG(sstatus);
+  exit(sstatus);
+}
+
+extern BOOL WINAPI DllMain (
+    HINSTANCE const instance,  // handle to DLL module
+    DWORD     const reason,    // reason for calling function
+    LPVOID    const reserved)  // reserved
+{
+    // Perform actions based on the reason for calling.
+    switch (reason)
+    {
+    case DLL_PROCESS_ATTACH:
+        srstderr=stderr;
+        break;
+
+    case DLL_THREAD_ATTACH:
+        // Do thread-specific initialization.
+        break;
+
+    case DLL_THREAD_DETACH:
+        // Do thread-specific cleanup.
+        break;
+
+    case DLL_PROCESS_DETACH:
+        // Perform any necessary cleanup.
+        break;
+    }
+    return TRUE;  // Successful DLL_PROCESS_ATTACH.
+}
diff -urN somfree\somwm35i\win32\somwm35i.def newsomfree3\somwm35i\win32\somwm35i.def
--- somfree\somwm35i\win32\somwm35i.def	Thu Jan 01 07:00:00 1970
+++ newsomfree3\somwm35i\win32\somwm35i.def	Sat Mar 16 14:09:28 2024
@@ -0,0 +1,70 @@
+;
+; Copyright 2022, Yuri Prokushev
+;
+; This file is part of osFree project
+;
+; This program is free software: you can redistribute it and/or modify it
+; under the terms of the GNU Lesser General Public License as published by the
+; Free Software Foundation, either version 3 of the License, or (at your
+; option) any later version.
+; 
+; This program is distributed in the hope that it will be useful, but WITHOUT
+; ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+; FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for
+; more details.
+;
+; You should have received a copy of the GNU Lesser General Public License
+; along with this program.  If not, see <http://www.gnu.org/licenses/>
+;
+
+LIBRARY		SOMWM35I
+VERSION		1.0
+EXPORTS
+  _ctype=sr_ctype DATA
+  stderr=srstderr DATA
+  _CRT_init=sr_CRT_init         
+  _CRT_term=sr_CRT_term
+  _abort_in_progress=sr_abort_in_progress
+  _exception_dllinit=sr_exception_dllinit
+  _matherr=sr_matherr
+  _fprintfieee=sr_fprintfieee
+  _sprintfieee=sr_sprintfieee
+  _printfieee=sr_printfieee
+  _sscanfieee=sr_sscanfieee
+  _putenv=sr_putenv
+  getenv=srgetenv
+  _terminate=sr_terminate
+  _PrintErrMsg=sr_PrintErrMsg
+  _SysFindFirst=sr_SysFindFirst
+  _SysFindNext=sr_SysFindNext
+  _SysFindClose=sr_SysFindClose
+  fclose=srfclose
+  feof=srfeof
+  fgetc=srfgetc
+  fgets=srfgets
+  fputs=srfputs
+  fread=srfread
+  fseek=srfseek
+  fwrite=srfwrite
+  remove=srremove
+  rename=srrename
+  rewind=srrewind
+  strcmp=srstrcmp
+  strstr=srstrstr
+  strlen=srstrlen
+  memmove=srmemmove
+  memset=srmemset
+  strchr=srstrchr
+  strcpy=srstrcpy
+  strncmp=srstrncmp
+  strncpy=srstrncpy
+  strrchr=srstrrchr
+  strtok=srstrtok
+  tolower=srtolower
+  memcpy=srmemcpy
+  strcat=srstrcat
+  strdup=srstrdup
+  strpbrk=srstrpbrk
+  malloc=srmalloc
+  free=srfree
+  exit=srexit
diff -urN somfree\somwm35i\win32\somwm35i.mak newsomfree3\somwm35i\win32\somwm35i.mak
--- somfree\somwm35i\win32\somwm35i.mak	Thu Jan 01 07:00:00 1970
+++ newsomfree3\somwm35i\win32\somwm35i.mak	Sat Mar 16 14:09:28 2024
@@ -0,0 +1,73 @@
+#
+#  Copyright 2022, Yuri Prokushev
+#
+#  This file is part of osFree project
+#
+#  This program is free software: you can redistribute it and/or modify it
+#  under the terms of the GNU Lesser General Public License as published by the
+#  Free Software Foundation, either version 3 of the License, or (at your
+#  option) any later version.
+# 
+#  This program is distributed in the hope that it will be useful, but WITHOUT
+#  ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+#  FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for
+#  more details.
+#
+#  You should have received a copy of the GNU Lesser General Public License
+#  along with this program.  If not, see <http://www.gnu.org/licenses/>
+#
+
+!include $(MAKEDEFS)
+
+OUTDIR=$(OUTDIR_BIN)
+INTDIR=$(BUILDTYPE)
+
+DLLNAME=somwm35i
+
+TARGET_DLL=$(OUTDIR)\$(DLLNAME).dll
+TARGET_PDB=$(OUTDIR)\$(DLLNAME).pdb
+TARGET_MAP=$(INTDIR)\$(DLLNAME).map
+TARGET_DEF=..\$(PLATFORM_DEF)\$(DLLNAME).def
+
+PARTOPTS=	$(STDOPT)								\
+			/DWIN32_LEAN_AND_MEAN 					\
+			/DHAVE_CONFIG_H							\
+			/I$(INTDIR)								\
+			/I..\win32								\
+			/I..\include							\
+			/I..\src								\
+			/I..\..\include\$(PLATFORM)				\
+			/I..\..\include\$(PLATFORM_DEF)			\
+			/I..\..\include							\
+			$(CC_OUT_PDB)$(TARGET_PDB)	
+
+OBJS=	$(INTDIR)\somwm35i.obj
+
+all: $(TARGET_DLL)
+
+clean:
+	$(CLEAN) $(TARGET_DLL) $(TARGET_PDB) $(TARGET_MAP) $(OBJS) $(INTDIR)\$(DLLNAME).res $(OUTDIR)\$(DLLNAME).exp $(OUTDIR)\$(DLLNAME).lib
+	
+$(TARGET_DLL): $(OBJS) $(OUTDIR) $(TARGET_DEF) $(INTDIR)\$(DLLNAME).res
+	$(CC) $(CC_OUT_DLL)$@ $(OBJS)		\
+			$(INTDIR)\$(DLLNAME).res	\
+			$(CC_OUT_PDB)$(TARGET_PDB)	\
+			$(CC_LINK)					\
+			$(LDFLAGS)					\
+			$(LD_DEF)$(TARGET_DEF)
+	$(POSTLINK_DLL) $@
+
+$(INTDIR)\somwm35i.obj: ..\src\somwm35i.c $(INTDIR)
+	$(CC) /c $(PARTOPTS) $(CC_OUT_OBJ)$@ ..\src\somwm35i.c
+
+$(INTDIR):
+	mkdir $@
+
+$(INTDIR)\$(DLLNAME).res: ..\win32\$(DLLNAME).rc
+	rc /nologo /r /I.. /I..\..\include\$(PLATFORM) /fo$@ ..\win32\$(DLLNAME).rc
+
+dist:
+
+
+test:
+
diff -urN somfree\somwm35i\win32\somwm35i.rc newsomfree3\somwm35i\win32\somwm35i.rc
--- somfree\somwm35i\win32\somwm35i.rc	Thu Jan 01 07:00:00 1970
+++ newsomfree3\somwm35i\win32\somwm35i.rc	Sat Mar 16 14:09:28 2024
@@ -0,0 +1,50 @@
+/**************************************************************************
+ *
+ *  Copyright 2022, Yuri Prokushev
+ *
+ *  This file is part of osFree project
+ *
+ *  This program is free software: you can redistribute it and/or modify it
+ *  under the terms of the GNU Lesser General Public License as published by the
+ *  Free Software Foundation, either version 3 of the License, or (at your
+ *  option) any later version.
+ * 
+ *  This program is distributed in the hope that it will be useful, but WITHOUT
+ *  ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ *  FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for
+ *  more details.
+ *
+ *  You should have received a copy of the GNU Lesser General Public License
+ *  along with this program.  If not, see <http://www.gnu.org/licenses/>
+ *
+ */
+
+#include <windows.h>
+#include <depvers.h>
+
+1 VERSIONINFO
+	PRODUCTVERSION DEPVERS_somtkpkg_INT4
+	FILEOS VOS__WINDOWS32
+	FILEVERSION DEPVERS_somwm35i_INT4
+	FILETYPE VFT_DLL
+BEGIN
+	BLOCK "StringFileInfo"
+	BEGIN
+		BLOCK "140904E4"
+		BEGIN
+			VALUE "CompanyName","Yuri Prokushev\000\000"
+			VALUE "LegalCopyright","Copyright й Yuri Prokushev 2022\000\000"
+			VALUE "ProductName",DEPVERS_somtkpkg_PRODUCTNAME
+			VALUE "ProductVersion",DEPVERS_somtkpkg_STR4
+			VALUE "Comments","Uncontrolled Release\000\000"
+			VALUE "FileDescription","IBM SOM 3.0 NT Compatibility Library\000\000"
+			VALUE "FileVersion",DEPVERS_somwm35i_STR4
+			VALUE "InternalName","somwm35i\000\000"
+			VALUE "OriginalFilename","SOMWM35I.DLL\000\000"
+		END
+	END
+    BLOCK "VarFileInfo"
+    BEGIN
+        VALUE "Translation", 0x1409, 1252
+    END
+END
diff -urN somfree\somxh\os2\somxh.cmd newsomfree3\somxh\os2\somxh.cmd
--- somfree\somxh\os2\somxh.cmd	Thu Jan 01 07:00:00 1970
+++ newsomfree3\somxh\os2\somxh.cmd	Sat Mar 16 14:09:28 2024
@@ -0,0 +1,25 @@
+@echo off
+
+if "%SOMBASE%"=="" goto sombase
+
+if not exist %SOMBASE%\include\somxh.gen goto normal
+echo Generating C++ bindings in progress...
+goto end
+
+:normal
+echo Generating the SOM C++ Bindings:
+set SC=%SOMBASE%\bin\sc.exe
+cd %SOMBASE%\include
+set SMNOADDSTAR=
+echo somxh.gen > somxh.gen
+%SC% -%% -sxh -mwinmult -mnochk *.idl
+if not errorlevel 0 GOTO end
+if exist somdtype.idl %SC% -mwinmult -mnochk -sxh -DEMIT_SOMDTYPES somdtype.idl
+if exist somxh.gen del somxh.gen
+goto end
+
+:sombase
+echo SOMBASE should be set before running somxh.
+goto end
+
+:end
diff -urN somfree\somxh\win32\somxh.cmd newsomfree3\somxh\win32\somxh.cmd
--- somfree\somxh\win32\somxh.cmd	Thu Jan 01 07:00:00 1970
+++ newsomfree3\somxh\win32\somxh.cmd	Sat Mar 16 14:09:28 2024
@@ -0,0 +1,32 @@
+@echo off
+
+if "%ProgramFiles%\somtk\bin\" == "%~dp0" set SOMBASE=%ProgramFiles%\somtk
+if "%ProgramFiles(x86)%\somtk\bin\" == "%~dp0" set SOMBASE=%ProgramFiles(x86)%\somtk
+if "%ProgramFiles(Arm)%\somtk\bin\" == "%~dp0" set SOMBASE=%ProgramFiles(Arm)%\somtk
+if "%ProgramW6432%\somtk\bin\" == "%~dp0" set SOMBASE=%ProgramW6432%\somtk
+
+if "%SOMBASE%x" == "x" if exist "%ProgramFiles%\somtk" set SOMBASE=%ProgramFiles%\somtk
+
+if "%SOMBASE%"=="" goto sombase
+
+if not exist %SOMBASE%\include\somxh.gen goto normal
+echo Generating C++ bindings in progress...
+goto end
+
+:normal
+echo Generating the SOM C++ Bindings:
+set SC=%SOMBASE%\bin\sc.exe
+cd %SOMBASE%\include
+set SMNOADDSTAR=
+echo somxh.gen > somxh.gen
+%SC% -%% -sxh -mwinmult -mnochk *.idl
+if not errorlevel 0 GOTO end
+if exist somdtype.idl %SC% -mwinmult -mnochk -sxh -DEMIT_SOMDTYPES somdtype.idl
+if exist somxh.gen del somxh.gen
+goto end
+
+:sombase
+echo SOMBASE should be set before running somxh.
+goto end
+
+:end
diff -urN somfree\somxml\dom.idl newsomfree3\somxml\dom.idl
--- somfree\somxml\dom.idl	Thu Jan 01 07:00:00 1970
+++ newsomfree3\somxml\dom.idl	Sat Mar 16 14:09:29 2024
@@ -0,0 +1,554 @@
+/*
+ * Copyright (c) 2004 World Wide Web Consortium,
+ *
+ * (Massachusetts Institute of Technology, European Research Consortium for
+ * Informatics and Mathematics, Keio University). All Rights Reserved. This
+ * work is distributed under the W3C(r) Software License [1] in the hope that
+ * it will be useful, but WITHOUT ANY WARRANTY; without even the implied
+ * warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
+ *
+ * [1] http://www.w3.org/Consortium/Legal/2002/copyright-software-20021231
+ */
+
+// File: http://www.w3.org/TR/2004/REC-DOM-Level-3-Core-20040407/dom.idl
+
+#ifndef _DOM_IDL_
+#define _DOM_IDL_
+
+#include <corba.idl>
+
+#pragma prefix "w3c.org"
+module dom
+{
+
+//  valuetype DOMString sequence<unsigned short>;
+  typedef  unsigned short us;
+  typedef  sequence<us> DOMString;
+
+//  typedef   unsigned long long DOMTimeStamp;
+  typedef   unsigned long DOMTimeStamp;
+
+  typedef   any DOMUserData;
+
+  typedef   CORBA::Object DOMObject;
+
+  interface DOMImplementation;
+  interface DocumentType;
+  interface Document;
+  interface NodeList;
+  interface NamedNodeMap;
+  interface UserDataHandler;
+  interface Element;
+  interface TypeInfo;
+  interface DOMLocator;
+
+  exception DOMException {
+    unsigned short   code;
+  };
+  // ExceptionCode
+  const unsigned short      INDEX_SIZE_ERR                 = 1;
+  const unsigned short      DOMSTRING_SIZE_ERR             = 2;
+  const unsigned short      HIERARCHY_REQUEST_ERR          = 3;
+  const unsigned short      WRONG_DOCUMENT_ERR             = 4;
+  const unsigned short      INVALID_CHARACTER_ERR          = 5;
+  const unsigned short      NO_DATA_ALLOWED_ERR            = 6;
+  const unsigned short      NO_MODIFICATION_ALLOWED_ERR    = 7;
+  const unsigned short      NOT_FOUND_ERR                  = 8;
+  const unsigned short      NOT_SUPPORTED_ERR              = 9;
+  const unsigned short      INUSE_ATTRIBUTE_ERR            = 10;
+  // Introduced in DOM Level 2:
+  const unsigned short      INVALID_STATE_ERR              = 11;
+  // Introduced in DOM Level 2:
+  const unsigned short      SYNTAX_ERR                     = 12;
+  // Introduced in DOM Level 2:
+  const unsigned short      INVALID_MODIFICATION_ERR       = 13;
+  // Introduced in DOM Level 2:
+  const unsigned short      NAMESPACE_ERR                  = 14;
+  // Introduced in DOM Level 2:
+  const unsigned short      INVALID_ACCESS_ERR             = 15;
+  // Introduced in DOM Level 3:
+  const unsigned short      VALIDATION_ERR                 = 16;
+  // Introduced in DOM Level 3:
+  const unsigned short      TYPE_MISMATCH_ERR              = 17;
+
+
+  // Introduced in DOM Level 3:
+  interface DOMStringList {
+    DOMString          item(in unsigned long index);
+    readonly attribute unsigned long   length;
+    boolean            contains(in DOMString str);
+  };
+
+  // Introduced in DOM Level 3:
+  interface NameList {
+    DOMString          getName(in unsigned long index);
+    DOMString          getNamespaceURI(in unsigned long index);
+    readonly attribute unsigned long   length;
+    boolean            contains(in DOMString str);
+    boolean            containsNS(in DOMString namespaceURI, 
+                                  in DOMString name);
+  };
+
+  // Introduced in DOM Level 3:
+  interface DOMImplementationList {
+    DOMImplementation  item(in unsigned long index);
+    readonly attribute unsigned long   length;
+  };
+
+  // Introduced in DOM Level 3:
+  interface DOMImplementationSource {
+    DOMImplementation  getDOMImplementation(in DOMString features);
+    DOMImplementationList getDOMImplementationList(in DOMString features);
+  };
+
+  interface DOMImplementation {
+    boolean            hasFeature(in DOMString feature, 
+                                  in DOMString version);
+    // Introduced in DOM Level 2:
+    DocumentType       createDocumentType(in DOMString qualifiedName, 
+                                          in DOMString publicId, 
+                                          in DOMString systemId)
+                                        raises(DOMException);
+    // Introduced in DOM Level 2:
+    Document           createDocument(in DOMString namespaceURI, 
+                                      in DOMString qualifiedName, 
+                                      in DocumentType doctype)
+                                        raises(DOMException);
+    // Introduced in DOM Level 3:
+    DOMObject          getFeature(in DOMString feature, 
+                                  in DOMString version);
+  };
+
+  interface Node {
+
+    // NodeType
+    const unsigned short      ELEMENT_NODE                   = 1;
+    const unsigned short      ATTRIBUTE_NODE                 = 2;
+    const unsigned short      TEXT_NODE                      = 3;
+    const unsigned short      CDATA_SECTION_NODE             = 4;
+    const unsigned short      ENTITY_REFERENCE_NODE          = 5;
+    const unsigned short      ENTITY_NODE                    = 6;
+    const unsigned short      PROCESSING_INSTRUCTION_NODE    = 7;
+    const unsigned short      COMMENT_NODE                   = 8;
+    const unsigned short      DOCUMENT_NODE                  = 9;
+    const unsigned short      DOCUMENT_TYPE_NODE             = 10;
+    const unsigned short      DOCUMENT_FRAGMENT_NODE         = 11;
+    const unsigned short      NOTATION_NODE                  = 12;
+
+    readonly attribute DOMString       nodeName;
+             attribute DOMString       nodeValue;
+                                        // raises(DOMException) on setting
+                                        // raises(DOMException) on retrieval
+
+    readonly attribute unsigned short  nodeType;
+    readonly attribute Node            parentNode;
+    readonly attribute NodeList        childNodes;
+    readonly attribute Node            firstChild;
+    readonly attribute Node            lastChild;
+    readonly attribute Node            previousSibling;
+    readonly attribute Node            nextSibling;
+    readonly attribute NamedNodeMap    attributes;
+    // Modified in DOM Level 2:
+    readonly attribute Document        ownerDocument;
+    // Modified in DOM Level 3:
+    Node               insertBefore(in Node newChild, 
+                                    in Node refChild)
+                                        raises(DOMException);
+    // Modified in DOM Level 3:
+    Node               replaceChild(in Node newChild, 
+                                    in Node oldChild)
+                                        raises(DOMException);
+    // Modified in DOM Level 3:
+    Node               removeChild(in Node oldChild)
+                                        raises(DOMException);
+    // Modified in DOM Level 3:
+    Node               appendChild(in Node newChild)
+                                        raises(DOMException);
+    boolean            hasChildNodes();
+    Node               cloneNode(in boolean deep);
+    // Modified in DOM Level 3:
+    void               normalize();
+    // Introduced in DOM Level 2:
+    boolean            isSupported(in DOMString feature, 
+                                   in DOMString version);
+    // Introduced in DOM Level 2:
+    readonly attribute DOMString       namespaceURI;
+    // Introduced in DOM Level 2:
+             attribute DOMString       prefix;
+                                        // raises(DOMException) on setting
+
+    // Introduced in DOM Level 2:
+    readonly attribute DOMString       localName;
+    // Introduced in DOM Level 2:
+    boolean            hasAttributes();
+    // Introduced in DOM Level 3:
+    readonly attribute DOMString       baseURI;
+
+    // DocumentPosition
+    const unsigned short      DOCUMENT_POSITION_DISCONNECTED = 0x01;
+    const unsigned short      DOCUMENT_POSITION_PRECEDING    = 0x02;
+    const unsigned short      DOCUMENT_POSITION_FOLLOWING    = 0x04;
+    const unsigned short      DOCUMENT_POSITION_CONTAINS     = 0x08;
+    const unsigned short      DOCUMENT_POSITION_CONTAINED_BY = 0x10;
+    const unsigned short      DOCUMENT_POSITION_IMPLEMENTATION_SPECIFIC = 0x20;
+
+    // Introduced in DOM Level 3:
+    unsigned short     compareDocumentPosition(in Node other)
+                                        raises(DOMException);
+    // Introduced in DOM Level 3:
+             attribute DOMString       textContent;
+                                        // raises(DOMException) on setting
+                                        // raises(DOMException) on retrieval
+
+    // Introduced in DOM Level 3:
+    boolean            isSameNode(in Node other);
+    // Introduced in DOM Level 3:
+    DOMString          lookupPrefix(in DOMString namespaceURI);
+    // Introduced in DOM Level 3:
+    boolean            isDefaultNamespace(in DOMString namespaceURI);
+    // Introduced in DOM Level 3:
+    DOMString          lookupNamespaceURI(in DOMString prefix);
+    // Introduced in DOM Level 3:
+    boolean            isEqualNode(in Node arg);
+    // Introduced in DOM Level 3:
+    DOMObject          getFeature(in DOMString feature, 
+                                  in DOMString version);
+    // Introduced in DOM Level 3:
+    DOMUserData        setUserData(in DOMString key, 
+                                   in DOMUserData data, 
+                                   in UserDataHandler handler);
+    // Introduced in DOM Level 3:
+    DOMUserData        getUserData(in DOMString key);
+  };
+
+  interface NodeList {
+    Node               item(in unsigned long index);
+    readonly attribute unsigned long   length;
+  };
+
+  interface NamedNodeMap {
+    Node               getNamedItem(in DOMString name);
+    Node               setNamedItem(in Node arg)
+                                        raises(DOMException);
+    Node               removeNamedItem(in DOMString name)
+                                        raises(DOMException);
+    Node               item(in unsigned long index);
+    readonly attribute unsigned long   length;
+    // Introduced in DOM Level 2:
+    Node               getNamedItemNS(in DOMString namespaceURI, 
+                                      in DOMString localName)
+                                        raises(DOMException);
+    // Introduced in DOM Level 2:
+    Node               setNamedItemNS(in Node arg)
+                                        raises(DOMException);
+    // Introduced in DOM Level 2:
+    Node               removeNamedItemNS(in DOMString namespaceURI, 
+                                         in DOMString localName)
+                                        raises(DOMException);
+  };
+
+  interface CharacterData : Node {
+             attribute DOMString       data;
+                                        // raises(DOMException) on setting
+                                        // raises(DOMException) on retrieval
+
+    readonly attribute unsigned long   length;
+    DOMString          substringData(in unsigned long offset, 
+                                     in unsigned long count)
+                                        raises(DOMException);
+    void               appendData(in DOMString arg)
+                                        raises(DOMException);
+    void               insertData(in unsigned long offset, 
+                                  in DOMString arg)
+                                        raises(DOMException);
+    void               deleteData(in unsigned long offset, 
+                                  in unsigned long count)
+                                        raises(DOMException);
+    void               replaceData(in unsigned long offset, 
+                                   in unsigned long count, 
+                                   in DOMString arg)
+                                        raises(DOMException);
+  };
+
+  interface Attr : Node {
+    readonly attribute DOMString       name;
+    readonly attribute boolean         specified;
+             attribute DOMString       value;
+                                        // raises(DOMException) on setting
+
+    // Introduced in DOM Level 2:
+    readonly attribute Element         ownerElement;
+    // Introduced in DOM Level 3:
+    readonly attribute TypeInfo        schemaTypeInfo;
+    // Introduced in DOM Level 3:
+    readonly attribute boolean         isId;
+  };
+
+  interface Element : Node {
+    readonly attribute DOMString       tagName;
+    DOMString          getAttribute(in DOMString name);
+    void               setAttribute(in DOMString name, 
+                                    in DOMString value)
+                                        raises(DOMException);
+    void               removeAttribute(in DOMString name)
+                                        raises(DOMException);
+    Attr               getAttributeNode(in DOMString name);
+    Attr               setAttributeNode(in Attr newAttr)
+                                        raises(DOMException);
+    Attr               removeAttributeNode(in Attr oldAttr)
+                                        raises(DOMException);
+    NodeList           getElementsByTagName(in DOMString name);
+    // Introduced in DOM Level 2:
+    DOMString          getAttributeNS(in DOMString namespaceURI, 
+                                      in DOMString localName)
+                                        raises(DOMException);
+    // Introduced in DOM Level 2:
+    void               setAttributeNS(in DOMString namespaceURI, 
+                                      in DOMString qualifiedName, 
+                                      in DOMString value)
+                                        raises(DOMException);
+    // Introduced in DOM Level 2:
+    void               removeAttributeNS(in DOMString namespaceURI, 
+                                         in DOMString localName)
+                                        raises(DOMException);
+    // Introduced in DOM Level 2:
+    Attr               getAttributeNodeNS(in DOMString namespaceURI, 
+                                          in DOMString localName)
+                                        raises(DOMException);
+    // Introduced in DOM Level 2:
+    Attr               setAttributeNodeNS(in Attr newAttr)
+                                        raises(DOMException);
+    // Introduced in DOM Level 2:
+    NodeList           getElementsByTagNameNS(in DOMString namespaceURI, 
+                                              in DOMString localName)
+                                        raises(DOMException);
+    // Introduced in DOM Level 2:
+    boolean            hasAttribute(in DOMString name);
+    // Introduced in DOM Level 2:
+    boolean            hasAttributeNS(in DOMString namespaceURI, 
+                                      in DOMString localName)
+                                        raises(DOMException);
+    // Introduced in DOM Level 3:
+    readonly attribute TypeInfo        schemaTypeInfo;
+    // Introduced in DOM Level 3:
+    void               setIdAttribute(in DOMString name, 
+                                      in boolean isId)
+                                        raises(DOMException);
+    // Introduced in DOM Level 3:
+    void               setIdAttributeNS(in DOMString namespaceURI, 
+                                        in DOMString localName, 
+                                        in boolean isId)
+                                        raises(DOMException);
+    // Introduced in DOM Level 3:
+    void               setIdAttributeNode(in Attr idAttr, 
+                                          in boolean isId)
+                                        raises(DOMException);
+  };
+
+  interface Text : CharacterData {
+    Text               splitText(in unsigned long offset)
+                                        raises(DOMException);
+    // Introduced in DOM Level 3:
+    readonly attribute boolean         isElementContentWhitespace;
+    // Introduced in DOM Level 3:
+    readonly attribute DOMString       wholeText;
+    // Introduced in DOM Level 3:
+    Text               replaceWholeText(in DOMString content)
+                                        raises(DOMException);
+  };
+
+  interface Comment : CharacterData {
+  };
+
+  // Introduced in DOM Level 3:
+  interface TypeInfo {
+    readonly attribute DOMString       typeName;
+    readonly attribute DOMString       typeNamespace;
+
+    // DerivationMethods
+    const unsigned long       DERIVATION_RESTRICTION         = 0x00000001;
+    const unsigned long       DERIVATION_EXTENSION           = 0x00000002;
+    const unsigned long       DERIVATION_UNION               = 0x00000004;
+    const unsigned long       DERIVATION_LIST                = 0x00000008;
+
+    boolean            isDerivedFrom(in DOMString typeNamespaceArg, 
+                                     in DOMString typeNameArg, 
+                                     in unsigned long derivationMethod);
+  };
+
+  // Introduced in DOM Level 3:
+  interface UserDataHandler {
+
+    // OperationType
+    const unsigned short      NODE_CLONED                    = 1;
+    const unsigned short      NODE_IMPORTED                  = 2;
+    const unsigned short      NODE_DELETED                   = 3;
+    const unsigned short      NODE_RENAMED                   = 4;
+    const unsigned short      NODE_ADOPTED                   = 5;
+
+    void               handle(in unsigned short operation, 
+                              in DOMString key, 
+                              in DOMUserData data, 
+                              in Node src, 
+                              in Node dst);
+  };
+
+  // Introduced in DOM Level 3:
+  interface DOMError {
+
+    // ErrorSeverity
+    const unsigned short      SEVERITY_WARNING               = 1;
+    const unsigned short      SEVERITY_ERROR                 = 2;
+    const unsigned short      SEVERITY_FATAL_ERROR           = 3;
+
+    readonly attribute unsigned short  severity;
+    readonly attribute DOMString       message;
+    readonly attribute DOMString       type;
+    readonly attribute DOMObject       relatedException;
+    readonly attribute DOMObject       relatedData;
+    readonly attribute DOMLocator      location;
+  };
+
+  // Introduced in DOM Level 3:
+  interface DOMErrorHandler {
+    boolean            handleError(in DOMError error);
+  };
+
+  // Introduced in DOM Level 3:
+  interface DOMLocator {
+    readonly attribute long            lineNumber;
+    readonly attribute long            columnNumber;
+    readonly attribute long            byteOffset;
+    readonly attribute long            utf16Offset;
+    readonly attribute Node            relatedNode;
+    readonly attribute DOMString       uri;
+  };
+
+  // Introduced in DOM Level 3:
+  interface DOMConfiguration {
+    void               setParameter(in DOMString name, 
+                                    in DOMUserData value)
+                                        raises(DOMException);
+    DOMUserData        getParameter(in DOMString name)
+                                        raises(DOMException);
+    boolean            canSetParameter(in DOMString name, 
+                                       in DOMUserData value);
+    readonly attribute DOMStringList   parameterNames;
+  };
+
+  interface CDATASection : Text {
+  };
+
+  interface DocumentType : Node {
+    readonly attribute DOMString       name;
+    readonly attribute NamedNodeMap    entities;
+    readonly attribute NamedNodeMap    notations;
+    // Introduced in DOM Level 2:
+    readonly attribute DOMString       publicId;
+    // Introduced in DOM Level 2:
+    readonly attribute DOMString       systemId;
+    // Introduced in DOM Level 2:
+    readonly attribute DOMString       internalSubset;
+  };
+
+  interface Notation : Node {
+    readonly attribute DOMString       publicId;
+    readonly attribute DOMString       systemId;
+  };
+
+  interface Entity : Node {
+    readonly attribute DOMString       publicId;
+    readonly attribute DOMString       systemId;
+    readonly attribute DOMString       notationName;
+    // Introduced in DOM Level 3:
+    readonly attribute DOMString       inputEncoding;
+    // Introduced in DOM Level 3:
+    readonly attribute DOMString       xmlEncoding;
+    // Introduced in DOM Level 3:
+    readonly attribute DOMString       xmlVersion;
+  };
+
+  interface EntityReference : Node {
+  };
+
+  interface ProcessingInstruction : Node {
+    readonly attribute DOMString       target;
+             attribute DOMString       data;
+                                        // raises(DOMException) on setting
+
+  };
+
+  interface DocumentFragment : Node {
+  };
+
+  interface Document : Node {
+    // Modified in DOM Level 3:
+    readonly attribute DocumentType    doctype;
+//    readonly attribute DOMImplementation implementation;
+    readonly attribute DOMImplementation implementation_;
+    readonly attribute Element         documentElement;
+    Element            createElement(in DOMString tagName)
+                                        raises(DOMException);
+    DocumentFragment   createDocumentFragment();
+    Text               createTextNode(in DOMString data);
+    Comment            createComment(in DOMString data);
+    CDATASection       createCDATASection(in DOMString data)
+                                        raises(DOMException);
+    ProcessingInstruction createProcessingInstruction(in DOMString target, 
+                                                      in DOMString data)
+                                        raises(DOMException);
+    Attr               createAttribute(in DOMString name)
+                                        raises(DOMException);
+    EntityReference    createEntityReference(in DOMString name)
+                                        raises(DOMException);
+    NodeList           getElementsByTagName(in DOMString tagname);
+    // Introduced in DOM Level 2:
+    Node               importNode(in Node importedNode, 
+                                  in boolean deep)
+                                        raises(DOMException);
+    // Introduced in DOM Level 2:
+    Element            createElementNS(in DOMString namespaceURI, 
+                                       in DOMString qualifiedName)
+                                        raises(DOMException);
+    // Introduced in DOM Level 2:
+    Attr               createAttributeNS(in DOMString namespaceURI, 
+                                         in DOMString qualifiedName)
+                                        raises(DOMException);
+    // Introduced in DOM Level 2:
+    NodeList           getElementsByTagNameNS(in DOMString namespaceURI, 
+                                              in DOMString localName);
+    // Introduced in DOM Level 2:
+    Element            getElementById(in DOMString elementId);
+    // Introduced in DOM Level 3:
+    readonly attribute DOMString       inputEncoding;
+    // Introduced in DOM Level 3:
+    readonly attribute DOMString       xmlEncoding;
+    // Introduced in DOM Level 3:
+             attribute boolean         xmlStandalone;
+                                        // raises(DOMException) on setting
+
+    // Introduced in DOM Level 3:
+             attribute DOMString       xmlVersion;
+                                        // raises(DOMException) on setting
+
+    // Introduced in DOM Level 3:
+             attribute boolean         strictErrorChecking;
+    // Introduced in DOM Level 3:
+             attribute DOMString       documentURI;
+    // Introduced in DOM Level 3:
+    Node               adoptNode(in Node source)
+                                        raises(DOMException);
+    // Introduced in DOM Level 3:
+    readonly attribute DOMConfiguration domConfig;
+    // Introduced in DOM Level 3:
+    void               normalizeDocument();
+    // Introduced in DOM Level 3:
+    Node               renameNode(in Node n, 
+                                  in DOMString namespaceURI, 
+                                  in DOMString qualifiedName)
+                                        raises(DOMException);
+  };
+};
+
+#endif // _DOM_IDL_
+
diff -urN somfree\somxml\events.idl newsomfree3\somxml\events.idl
--- somfree\somxml\events.idl	Thu Jan 01 07:00:00 1970
+++ newsomfree3\somxml\events.idl	Sat Mar 16 14:09:29 2024
@@ -0,0 +1,298 @@
+/*
+ * Copyright (c) 2003 World Wide Web Consortium,
+ *
+ * (Massachusetts Institute of Technology, European Research Consortium for
+ * Informatics and Mathematics, Keio University). All Rights Reserved. This
+ * work is distributed under the W3C(r) Software License [1] in the hope that
+ * it will be useful, but WITHOUT ANY WARRANTY; without even the implied
+ * warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
+ *
+ * [1] http://www.w3.org/Consortium/Legal/2002/copyright-software-20021231
+ */
+
+// File: http://www.w3.org/TR/2003/NOTE-DOM-Level-3-Events-20031107/events.idl
+
+#ifndef _EVENTS_IDL_
+#define _EVENTS_IDL_
+
+#include "dom.idl"
+#include "views.idl"
+
+#pragma prefix "dom.w3c.org"
+module events
+{
+
+  typedef dom::DOMString DOMString;
+  typedef dom::DOMTimeStamp DOMTimeStamp;
+  typedef dom::DOMObject DOMObject;
+  typedef dom::Node Node;
+
+  interface EventTarget;
+  interface EventListener;
+
+  // Introduced in DOM Level 2:
+  exception EventException {
+    unsigned short   code;
+  };
+  // EventExceptionCode
+  const unsigned short      UNSPECIFIED_EVENT_TYPE_ERR     = 0;
+  // Introduced in DOM Level 3:
+  const unsigned short      DISPATCH_REQUEST_ERR           = 1;
+
+
+  // Introduced in DOM Level 2:
+  interface Event {
+
+    // PhaseType
+    const unsigned short      CAPTURING_PHASE                = 1;
+    const unsigned short      AT_TARGET                      = 2;
+    const unsigned short      BUBBLING_PHASE                 = 3;
+
+    readonly attribute DOMString       type;
+    readonly attribute EventTarget     target;
+    readonly attribute EventTarget     currentTarget;
+    readonly attribute unsigned short  eventPhase;
+    readonly attribute boolean         bubbles;
+    readonly attribute boolean         cancelable;
+    readonly attribute DOMTimeStamp    timeStamp;
+    void               stopPropagation();
+    void               preventDefault();
+    void               initEvent(in DOMString eventTypeArg, 
+                                 in boolean canBubbleArg, 
+                                 in boolean cancelableArg);
+    // Introduced in DOM Level 3:
+    readonly attribute DOMString       namespaceURI;
+    // Introduced in DOM Level 3:
+    boolean            isCustom();
+    // Introduced in DOM Level 3:
+    void               stopImmediatePropagation();
+    // Introduced in DOM Level 3:
+    boolean            isDefaultPrevented();
+    // Introduced in DOM Level 3:
+    void               initEventNS(in DOMString namespaceURIArg, 
+                                   in DOMString eventTypeArg, 
+                                   in boolean canBubbleArg, 
+                                   in boolean cancelableArg);
+  };
+
+  // Introduced in DOM Level 2:
+  interface EventTarget {
+    void               addEventListener(in DOMString type, 
+                                        in EventListener listener, 
+                                        in boolean useCapture);
+    void               removeEventListener(in DOMString type, 
+                                           in EventListener listener, 
+                                           in boolean useCapture);
+    // Modified in DOM Level 3:
+    boolean            dispatchEvent(in Event evt)
+                                        raises(EventException);
+    // Introduced in DOM Level 3:
+    void               addEventListenerNS(in DOMString namespaceURI, 
+                                          in DOMString type, 
+                                          in EventListener listener, 
+                                          in boolean useCapture, 
+                                          in DOMObject evtGroup);
+    // Introduced in DOM Level 3:
+    void               removeEventListenerNS(in DOMString namespaceURI, 
+                                             in DOMString type, 
+                                             in EventListener listener, 
+                                             in boolean useCapture);
+    // Introduced in DOM Level 3:
+    boolean            willTriggerNS(in DOMString namespaceURI, 
+                                     in DOMString type);
+    // Introduced in DOM Level 3:
+    boolean            hasEventListenerNS(in DOMString namespaceURI, 
+                                          in DOMString type);
+  };
+
+  // Introduced in DOM Level 2:
+  interface EventListener {
+    void               handleEvent(in Event evt);
+  };
+
+  // Introduced in DOM Level 2:
+  interface DocumentEvent {
+    Event              createEvent(in DOMString eventType)
+                                        raises(dom::DOMException);
+    // Introduced in DOM Level 3:
+    boolean            canDispatch(in DOMString namespaceURI, 
+                                   in DOMString type);
+  };
+
+  // Introduced in DOM Level 3:
+  interface CustomEvent : Event {
+    void               setDispatchState(in EventTarget target, 
+                                        in unsigned short phase);
+    boolean            isPropagationStopped();
+    boolean            isImmediatePropagationStopped();
+  };
+
+  // Introduced in DOM Level 2:
+  interface UIEvent : Event {
+    readonly attribute views::AbstractView view;
+    readonly attribute long            detail;
+    void               initUIEvent(in DOMString typeArg, 
+                                   in boolean canBubbleArg, 
+                                   in boolean cancelableArg, 
+                                   in views::AbstractView viewArg, 
+                                   in long detailArg);
+    // Introduced in DOM Level 3:
+    void               initUIEventNS(in DOMString namespaceURI, 
+                                     in DOMString typeArg, 
+                                     in boolean canBubbleArg, 
+                                     in boolean cancelableArg, 
+                                     in views::AbstractView viewArg, 
+                                     in long detailArg);
+  };
+
+  // Introduced in DOM Level 3:
+  interface TextEvent : UIEvent {
+    readonly attribute DOMString       data;
+    void               initTextEvent(in DOMString typeArg, 
+                                     in boolean canBubbleArg, 
+                                     in boolean cancelableArg, 
+                                     in views::AbstractView viewArg, 
+                                     in DOMString dataArg);
+    void               initTextEventNS(in DOMString namespaceURI, 
+                                       in DOMString type, 
+                                       in boolean canBubbleArg, 
+                                       in boolean cancelableArg, 
+                                       in views::AbstractView viewArg, 
+                                       in DOMString dataArg);
+  };
+
+  // Introduced in DOM Level 2:
+  interface MouseEvent : UIEvent {
+    readonly attribute long            screenX;
+    readonly attribute long            screenY;
+    readonly attribute long            clientX;
+    readonly attribute long            clientY;
+    readonly attribute boolean         ctrlKey;
+    readonly attribute boolean         shiftKey;
+    readonly attribute boolean         altKey;
+    readonly attribute boolean         metaKey;
+    readonly attribute unsigned short  button;
+    readonly attribute EventTarget     relatedTarget;
+    void               initMouseEvent(in DOMString typeArg, 
+                                      in boolean canBubbleArg, 
+                                      in boolean cancelableArg, 
+                                      in views::AbstractView viewArg, 
+                                      in long detailArg, 
+                                      in long screenXArg, 
+                                      in long screenYArg, 
+                                      in long clientXArg, 
+                                      in long clientYArg, 
+                                      in boolean ctrlKeyArg, 
+                                      in boolean altKeyArg, 
+                                      in boolean shiftKeyArg, 
+                                      in boolean metaKeyArg, 
+                                      in unsigned short buttonArg, 
+                                      in EventTarget relatedTargetArg);
+    // Introduced in DOM Level 3:
+    boolean            getModifierState(in DOMString keyIdentifierArg);
+    // Introduced in DOM Level 3:
+    void               initMouseEventNS(in DOMString namespaceURI, 
+                                        in DOMString typeArg, 
+                                        in boolean canBubbleArg, 
+                                        in boolean cancelableArg, 
+                                        in views::AbstractView viewArg, 
+                                        in long detailArg, 
+                                        in long screenXArg, 
+                                        in long screenYArg, 
+                                        in long clientXArg, 
+                                        in long clientYArg, 
+                                        in unsigned short buttonArg, 
+                                        in EventTarget relatedTargetArg, 
+                                        in DOMString modifiersList);
+  };
+
+  // Introduced in DOM Level 3:
+  interface KeyboardEvent : UIEvent {
+
+    // KeyLocationCode
+    const unsigned long       DOM_KEY_LOCATION_STANDARD      = 0x00;
+    const unsigned long       DOM_KEY_LOCATION_LEFT          = 0x01;
+    const unsigned long       DOM_KEY_LOCATION_RIGHT         = 0x02;
+    const unsigned long       DOM_KEY_LOCATION_NUMPAD        = 0x03;
+
+    readonly attribute DOMString       keyIdentifier;
+    readonly attribute unsigned long   keyLocation;
+    readonly attribute boolean         ctrlKey;
+    readonly attribute boolean         shiftKey;
+    readonly attribute boolean         altKey;
+    readonly attribute boolean         metaKey;
+    boolean            getModifierState(in DOMString keyIdentifierArg);
+    void               initKeyboardEvent(in DOMString typeArg, 
+                                         in boolean canBubbleArg, 
+                                         in boolean cancelableArg, 
+                                         in views::AbstractView viewArg, 
+                                         in DOMString keyIdentifierArg, 
+                                         in unsigned long keyLocationArg, 
+                                         in DOMString modifiersList);
+    void               initKeyboardEventNS(in DOMString namespaceURI, 
+                                           in DOMString typeArg, 
+                                           in boolean canBubbleArg, 
+                                           in boolean cancelableArg, 
+                                           in views::AbstractView viewArg, 
+                                           in DOMString keyIdentifierArg, 
+                                           in unsigned long keyLocationArg, 
+                                           in DOMString modifiersList);
+  };
+
+  // Introduced in DOM Level 2:
+  interface MutationEvent : Event {
+
+    // attrChangeType
+    const unsigned short      MODIFICATION                   = 1;
+    const unsigned short      ADDITION                       = 2;
+    const unsigned short      REMOVAL                        = 3;
+
+    readonly attribute Node            relatedNode;
+    readonly attribute DOMString       prevValue;
+    readonly attribute DOMString       newValue;
+    readonly attribute DOMString       attrName;
+    readonly attribute unsigned short  attrChange;
+    void               initMutationEvent(in DOMString typeArg, 
+                                         in boolean canBubbleArg, 
+                                         in boolean cancelableArg, 
+                                         in Node relatedNodeArg, 
+                                         in DOMString prevValueArg, 
+                                         in DOMString newValueArg, 
+                                         in DOMString attrNameArg, 
+                                         in unsigned short attrChangeArg);
+    // Introduced in DOM Level 3:
+    void               initMutationEventNS(in DOMString namespaceURI, 
+                                           in DOMString typeArg, 
+                                           in boolean canBubbleArg, 
+                                           in boolean cancelableArg, 
+                                           in Node relatedNodeArg, 
+                                           in DOMString prevValueArg, 
+                                           in DOMString newValueArg, 
+                                           in DOMString attrNameArg, 
+                                           in unsigned short attrChangeArg);
+  };
+
+  // Introduced in DOM Level 3:
+  interface MutationNameEvent : MutationEvent {
+    readonly attribute DOMString       prevNamespaceURI;
+    readonly attribute DOMString       prevNodeName;
+    // Introduced in DOM Level 3:
+    void               initMutationNameEvent(in DOMString typeArg, 
+                                             in boolean canBubbleArg, 
+                                             in boolean cancelableArg, 
+                                             in Node relatedNodeArg, 
+                                             in DOMString prevNamespaceURIArg, 
+                                             in DOMString prevNodeNameArg);
+    // Introduced in DOM Level 3:
+    void               initMutationNameEventNS(in DOMString namespaceURI, 
+                                               in DOMString typeArg, 
+                                               in boolean canBubbleArg, 
+                                               in boolean cancelableArg, 
+                                               in Node relatedNodeArg, 
+                                               in DOMString prevNamespaceURIArg, 
+                                               in DOMString prevNodeNameArg);
+  };
+};
+
+#endif // _EVENTS_IDL_
+
diff -urN somfree\somxml\ls.idl newsomfree3\somxml\ls.idl
--- somfree\somxml\ls.idl	Thu Jan 01 07:00:00 1970
+++ newsomfree3\somxml\ls.idl	Sat Mar 16 14:09:29 2024
@@ -0,0 +1,171 @@
+/*
+ * Copyright (c) 2004 World Wide Web Consortium,
+ *
+ * (Massachusetts Institute of Technology, European Research Consortium for
+ * Informatics and Mathematics, Keio University). All Rights Reserved. This
+ * work is distributed under the W3C(r) Software License [1] in the hope that
+ * it will be useful, but WITHOUT ANY WARRANTY; without even the implied
+ * warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
+ *
+ * [1] http://www.w3.org/Consortium/Legal/2002/copyright-software-20021231
+ */
+
+// File: http://www.w3.org/TR/2004/REC-DOM-Level-3-LS-20040407/ls.idl
+
+#ifndef _LS_IDL_
+#define _LS_IDL_
+
+#include "dom.idl"
+#include "events.idl"
+#include "traversal.idl"
+
+#pragma prefix "dom.w3c.org"
+module ls
+{
+
+  typedef   CORBA::Object LSInputStream;
+
+  typedef   CORBA::Object LSOutputStream;
+
+  typedef   CORBA::Object LSReader;
+
+  typedef   CORBA::Object LSWriter;
+
+  typedef dom::DOMString DOMString;
+  typedef dom::DOMConfiguration DOMConfiguration;
+  typedef dom::Node Node;
+  typedef dom::Document Document;
+  typedef dom::Element Element;
+
+  interface LSParser;
+  interface LSSerializer;
+  interface LSInput;
+  interface LSOutput;
+  interface LSParserFilter;
+  interface LSSerializerFilter;
+
+  exception LSException {
+    unsigned short   code;
+  };
+  // LSExceptionCode
+  const unsigned short      PARSE_ERR                      = 81;
+  const unsigned short      SERIALIZE_ERR                  = 82;
+
+
+  interface DOMImplementationLS {
+
+    // DOMImplementationLSMode
+    const unsigned short      MODE_SYNCHRONOUS               = 1;
+    const unsigned short      MODE_ASYNCHRONOUS              = 2;
+
+    LSParser           createLSParser(in unsigned short mode, 
+                                      in DOMString schemaType)
+                                        raises(dom::DOMException);
+    LSSerializer       createLSSerializer();
+    LSInput            createLSInput();
+    LSOutput           createLSOutput();
+  };
+
+  interface LSParser {
+    readonly attribute DOMConfiguration domConfig;
+             attribute LSParserFilter  filter;
+    readonly attribute boolean         async;
+    readonly attribute boolean         busy;
+    Document           parse(in LSInput input)
+                                        raises(dom::DOMException, 
+                                               LSException);
+    Document           parseURI(in DOMString uri)
+                                        raises(dom::DOMException, 
+                                               LSException);
+
+    // ACTION_TYPES
+    const unsigned short      ACTION_APPEND_AS_CHILDREN      = 1;
+    const unsigned short      ACTION_REPLACE_CHILDREN        = 2;
+    const unsigned short      ACTION_INSERT_BEFORE           = 3;
+    const unsigned short      ACTION_INSERT_AFTER            = 4;
+    const unsigned short      ACTION_REPLACE                 = 5;
+
+    Node               parseWithContext(in LSInput input, 
+                                        in Node contextArg, 
+                                        in unsigned short action)
+                                        raises(dom::DOMException, 
+                                               LSException);
+    void               abort();
+  };
+
+  interface LSInput {
+    // Depending on the language binding in use,
+    // this attribute may not be available.
+             attribute LSReader        characterStream;
+             attribute LSInputStream   byteStream;
+             attribute DOMString       stringData;
+             attribute DOMString       systemId;
+             attribute DOMString       publicId;
+             attribute DOMString       baseURI;
+             attribute DOMString       encoding;
+             attribute boolean         certifiedText;
+  };
+
+  interface LSResourceResolver {
+    LSInput            resolveResource(in DOMString type, 
+                                       in DOMString namespaceURI, 
+                                       in DOMString publicId, 
+                                       in DOMString systemId, 
+                                       in DOMString baseURI);
+  };
+
+  interface LSParserFilter {
+
+    // Constants returned by startElement and acceptNode
+    const short               FILTER_ACCEPT                  = 1;
+    const short               FILTER_REJECT                  = 2;
+    const short               FILTER_SKIP                    = 3;
+    const short               FILTER_INTERRUPT               = 4;
+
+    unsigned short     startElement(in Element elementArg);
+    unsigned short     acceptNode(in Node nodeArg);
+    readonly attribute unsigned long   whatToShow;
+  };
+
+  interface LSSerializer {
+    readonly attribute DOMConfiguration domConfig;
+             attribute DOMString       newLine;
+             attribute LSSerializerFilter filter;
+    boolean            write(in Node nodeArg, 
+                             in LSOutput destination)
+                                        raises(LSException);
+    boolean            writeToURI(in Node nodeArg, 
+                                  in DOMString uri)
+                                        raises(LSException);
+    DOMString          writeToString(in Node nodeArg)
+                                        raises(dom::DOMException, 
+                                               LSException);
+  };
+
+  interface LSOutput {
+    // Depending on the language binding in use,
+    // this attribute may not be available.
+             attribute LSWriter        characterStream;
+             attribute LSOutputStream  byteStream;
+             attribute DOMString       systemId;
+             attribute DOMString       encoding;
+  };
+
+  interface LSProgressEvent : events::Event {
+    readonly attribute LSInput         input;
+    readonly attribute unsigned long   position;
+    readonly attribute unsigned long   totalSize;
+  };
+
+  interface LSLoadEvent : events::Event {
+    readonly attribute Document        newDocument;
+    readonly attribute LSInput         input;
+  };
+
+  interface LSSerializerFilter : traversal::NodeFilter {
+    readonly attribute unsigned long   whatToShow;
+  };
+};
+
+#endif // _LS_IDL_
+
diff -urN somfree\somxml\makedefs.cf newsomfree3\somxml\makedefs.cf
--- somfree\somxml\makedefs.cf	Thu Jan 01 07:00:00 1970
+++ newsomfree3\somxml\makedefs.cf	Sat Mar 16 14:09:29 2024
@@ -0,0 +1,3 @@
+NAME somxml
+DEPENDS somcorba
+PROVIDES somxml
diff -urN somfree\somxml\traversal.idl newsomfree3\somxml\traversal.idl
--- somfree\somxml\traversal.idl	Thu Jan 01 07:00:00 1970
+++ newsomfree3\somxml\traversal.idl	Sat Mar 16 14:09:29 2024
@@ -0,0 +1,102 @@
+/*
+ * Copyright (c) 2000 World Wide Web Consortium,
+ * (Massachusetts Institute of Technology, Institut National de
+ * Recherche en Informatique et en Automatique, Keio University). All
+ * Rights Reserved. This program is distributed under the W3C's Software
+ * Intellectual Property License. This program is distributed in the
+ * hope that it will be useful, but WITHOUT ANY WARRANTY; without even
+ * the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR
+ * PURPOSE.
+ * See W3C License http://www.w3.org/Consortium/Legal/ for more details.
+ */
+
+// File: http://www.w3.org/TR/2000/REC-DOM-Level-2-Traversal-Range-20001113/traversal.idl
+
+#ifndef _TRAVERSAL_IDL_
+#define _TRAVERSAL_IDL_
+
+#include "dom.idl"
+
+#pragma prefix "dom.w3c.org"
+module traversal
+{
+
+  typedef dom::Node Node;
+
+  interface NodeFilter;
+
+  // Introduced in DOM Level 2:
+  interface NodeIterator {
+    readonly attribute Node             root;
+    readonly attribute unsigned long    whatToShow;
+    readonly attribute NodeFilter       filter;
+    readonly attribute boolean          expandEntityReferences;
+    Node               nextNode()
+                                        raises(dom::DOMException);
+    Node               previousNode()
+                                        raises(dom::DOMException);
+    void               detach();
+  };
+
+  // Introduced in DOM Level 2:
+  interface NodeFilter {
+
+    // Constants returned by acceptNode
+    const short               FILTER_ACCEPT                  = 1;
+    const short               FILTER_REJECT                  = 2;
+    const short               FILTER_SKIP                    = 3;
+
+
+    // Constants for whatToShow
+    const unsigned long       SHOW_ALL                       = 0xFFFFFFFF;
+    const unsigned long       SHOW_ELEMENT                   = 0x00000001;
+    const unsigned long       SHOW_ATTRIBUTE                 = 0x00000002;
+    const unsigned long       SHOW_TEXT                      = 0x00000004;
+    const unsigned long       SHOW_CDATA_SECTION             = 0x00000008;
+    const unsigned long       SHOW_ENTITY_REFERENCE          = 0x00000010;
+    const unsigned long       SHOW_ENTITY                    = 0x00000020;
+    const unsigned long       SHOW_PROCESSING_INSTRUCTION    = 0x00000040;
+    const unsigned long       SHOW_COMMENT                   = 0x00000080;
+    const unsigned long       SHOW_DOCUMENT                  = 0x00000100;
+    const unsigned long       SHOW_DOCUMENT_TYPE             = 0x00000200;
+    const unsigned long       SHOW_DOCUMENT_FRAGMENT         = 0x00000400;
+    const unsigned long       SHOW_NOTATION                  = 0x00000800;
+
+    short              acceptNode(in Node n);
+  };
+
+  // Introduced in DOM Level 2:
+  interface TreeWalker {
+    readonly attribute Node             root;
+    readonly attribute unsigned long    whatToShow;
+    readonly attribute NodeFilter       filter;
+    readonly attribute boolean          expandEntityReferences;
+             attribute Node             currentNode;
+                                        // raises(dom::DOMException) on setting
+
+    Node               parentNode();
+    Node               firstChild();
+    Node               lastChild();
+    Node               previousSibling();
+    Node               nextSibling();
+    Node               previousNode();
+    Node               nextNode();
+  };
+
+  // Introduced in DOM Level 2:
+  interface DocumentTraversal {
+    NodeIterator       createNodeIterator(in Node root, 
+                                          in unsigned long whatToShow, 
+                                          in NodeFilter filter, 
+                                          in boolean entityReferenceExpansion)
+                                        raises(dom::DOMException);
+    TreeWalker         createTreeWalker(in Node root, 
+                                        in unsigned long whatToShow, 
+                                        in NodeFilter filter, 
+                                        in boolean entityReferenceExpansion)
+                                        raises(dom::DOMException);
+  };
+};
+
+#endif // _TRAVERSAL_IDL_
+
diff -urN somfree\somxml\views.idl newsomfree3\somxml\views.idl
--- somfree\somxml\views.idl	Thu Jan 01 07:00:00 1970
+++ newsomfree3\somxml\views.idl	Sat Mar 16 14:09:29 2024
@@ -0,0 +1,38 @@
+/*
+ * Copyright (c) 2000 World Wide Web Consortium,
+ * (Massachusetts Institute of Technology, Institut National de
+ * Recherche en Informatique et en Automatique, Keio University). All
+ * Rights Reserved. This program is distributed under the W3C's Software
+ * Intellectual Property License. This program is distributed in the
+ * hope that it will be useful, but WITHOUT ANY WARRANTY; without even
+ * the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR
+ * PURPOSE.
+ * See W3C License http://www.w3.org/Consortium/Legal/ for more details.
+ */
+
+// File: http://www.w3.org/TR/2000/REC-DOM-Level-2-Views-20001113/views.idl
+
+#ifndef _VIEWS_IDL_
+#define _VIEWS_IDL_
+
+#include "dom.idl"
+
+#pragma prefix "dom.w3c.org"
+module views
+{
+
+  interface DocumentView;
+
+  // Introduced in DOM Level 2:
+  interface AbstractView {
+    readonly attribute DocumentView     document;
+  };
+
+  // Introduced in DOM Level 2:
+  interface DocumentView {
+    readonly attribute AbstractView     defaultView;
+  };
+};
+
+#endif // _VIEWS_IDL_
+
diff -urN somfree\somxml\win32\somxml.mak newsomfree3\somxml\win32\somxml.mak
--- somfree\somxml\win32\somxml.mak	Thu Jan 01 07:00:00 1970
+++ newsomfree3\somxml\win32\somxml.mak	Sat Mar 16 14:09:29 2024
@@ -0,0 +1,135 @@
+#
+#  Copyright 2022, Yuri Prokushev
+#
+#  This file is part of osFree project
+#
+#  This program is free software: you can redistribute it and/or modify it
+#  under the terms of the GNU Lesser General Public License as published by the
+#  Free Software Foundation, either version 3 of the License, or (at your
+#  option) any later version.
+# 
+#  This program is distributed in the hope that it will be useful, but WITHOUT
+#  ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+#  FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for
+#  more details.
+#
+#  You should have received a copy of the GNU Lesser General Public License
+#  along with this program.  If not, see <http://www.gnu.org/licenses/>
+#
+
+!include $(MAKEDEFS)
+
+OUTDIR=$(OUTDIR_BIN)
+INTDIR=$(BUILDTYPE)
+
+DLLNAME=somxml
+
+IDLTOOL=$(RHBTOOLS_BIN)\idltool.exe
+SC=$(SOMTOOLS_BIN)\sc.exe
+PDL=$(SOMTOOLS_BIN)\pdl.exe
+SOMIDL_IDL=..\..\somidl
+SOMIDL_HEADERS=$(SOMIDL_IDL)\$(PLATFORM)
+
+EMIT_DIR=..\..\somxml
+SOME_DIR=..\..\some
+SOMC_DIR=..\..\somc
+EMIT_INTDIR=$(INTDIR)
+
+TARGET_DLL=$(OUTDIR)\$(DLLNAME).dll
+TARGET_PDB=$(OUTDIR)\$(DLLNAME).pdb
+TARGET_MAP=$(INTDIR)\$(DLLNAME).map
+TARGET_DEF=..\$(PLATFORM_DEF)\$(DLLNAME).def
+
+PARTOPTS=	$(STDOPT)								\
+			/DWIN32_LEAN_AND_MEAN 					\
+			/DHAVE_CONFIG_HPP							\
+			/I$(INTDIR)								\
+			/I..\win32								\
+			/I..\include							\
+			/I..\src								\
+			/I..\..\include\$(PLATFORM)				\
+			/I..\..\include\$(PLATFORM_DEF)			\
+			/I..\..\include							\
+			/I..\..\somidl\$(PLATFORM)				\
+			/I..\..\somkpub\include					\
+			$(CC_OUT_PDB)$(TARGET_PDB)	
+
+OBJS=	$(INTDIR)\emitdef.obj	\
+	$(INTDIR)\defemit.obj	\
+	$(INTDIR)\link386.obj
+
+PUBLIC_IDLS=$(SOMIDL_IDL)\dom.idl	\
+		$(SOMIDL_IDL)\traversal.idl	\
+		$(SOMIDL_IDL)\views.idl	\
+		$(SOMIDL_IDL)\events.idl	\
+		$(SOMIDL_IDL)\ls.idl
+
+EMIT_IH=	$(EMIT_INTDIR)\dom.h	\
+		$(EMIT_INTDIR)\dom.ih	\
+		$(EMIT_INTDIR)\dom.xh	\
+		$(EMIT_INTDIR)\dom.xih	\
+		$(EMIT_INTDIR)\traversal.h	\
+		$(EMIT_INTDIR)\traversal.ih	\
+		$(EMIT_INTDIR)\traversal.xh	\
+		$(EMIT_INTDIR)\traversal.xih	\
+		$(EMIT_INTDIR)\views.h	\
+		$(EMIT_INTDIR)\views.ih	\
+		$(EMIT_INTDIR)\views.xh	\
+		$(EMIT_INTDIR)\views.xih	\
+		$(EMIT_INTDIR)\events.h	\
+		$(EMIT_INTDIR)\events.ih	\
+		$(EMIT_INTDIR)\events.xh	\
+		$(EMIT_INTDIR)\events.xih	\
+		$(EMIT_INTDIR)\ls.h	\
+		$(EMIT_INTDIR)\ls.ih	\
+		$(EMIT_INTDIR)\ls.xh	\
+		$(EMIT_INTDIR)\ls.xih
+
+
+all: $(INTDIR) $(PUBLIC_IDLS) $(EMIT_IH) # $(TARGET_DLL)
+
+clean:
+	$(CLEAN) $(PUBLIC_IDLS) $(EMIT_IH) $(TARGET_DLL) $(TARGET_PDB) $(TARGET_MAP) $(OBJS) $(INTDIR)\$(DLLNAME).res $(OUTDIR)\$(DLLNAME).exp $(OUTDIR)\$(DLLNAME).lib
+	
+$(TARGET_DLL): $(OBJS) $(OUTDIR) $(TARGET_DEF) $(INTDIR)\$(DLLNAME).res
+	$(CC) $(CC_OUT_DLL)$@ $(OBJS)		\
+			$(INTDIR)\$(DLLNAME).res	\
+			$(CC_OUT_PDB)$(TARGET_PDB)	\
+			$(CC_LINK)					\
+			$(LDFLAGS)					\
+			$(LD_DEF)$(TARGET_DEF)
+	$(POSTLINK_DLL) $@
+
+
+$(INTDIR)\emitdef.obj: ..\src\emitdef.cpp $(INTDIR)
+	$(CXX) /c $(PARTOPTS) $(CC_OUT_OBJ)$@ ..\src\emitdef.cpp
+
+$(INTDIR)\defemit.obj: ..\src\defemit.cpp $(INTDIR)
+	$(CXX) /c $(PARTOPTS) $(CC_OUT_OBJ)$@ ..\src\defemit.cpp
+
+$(INTDIR)\link386.obj: ..\win32\link386.c $(INTDIR)
+	$(CC) /c $(PARTOPTS) $(CC_OUT_OBJ)$@ ..\win32\link386.c
+
+$(INTDIR):
+	mkdir $@
+
+$(INTDIR)\$(DLLNAME).res: ..\win32\$(DLLNAME).rc
+	rc /nologo /r /I.. /I..\..\include\$(PLATFORM) /fo$@ ..\win32\$(DLLNAME).rc
+
+$(PUBLIC_IDLS):
+	"$(IDLTOOL)" "$(PDL)"		\
+		$(EMIT_DIR)			\
+		-o $@
+
+$(EMIT_IH): 
+	"$(IDLTOOL)" "$(SC)" $(EMIT_DIR)	\
+					-o $@ -p -I$(EMIT_DIR) -I$(SOMIDL_IDL) -I$(SOMC_DIR)\include
+
+
+dist:
+
+
+
+
+test:
+
diff -urN somfree\spp\makedefs.cf newsomfree3\spp\makedefs.cf
--- somfree\spp\makedefs.cf	Thu Jan 01 07:00:00 1970
+++ newsomfree3\spp\makedefs.cf	Sat Mar 16 14:09:29 2024
@@ -0,0 +1,3 @@
+NAME spp
+DEPENDS somc
+PROVIDES spp
diff -urN somfree\spp\src\graduate.sc newsomfree3\spp\src\graduate.sc
--- somfree\spp\src\graduate.sc	Thu Jan 01 07:00:00 1970
+++ newsomfree3\spp\src\graduate.sc	Sat Mar 16 14:09:29 2024
@@ -0,0 +1,15 @@
+include <student.sc>
+
+class:
+    GraduateStudent;
+
+parent:
+    Student;
+
+data:
+    char thesis[128];  /* thesis title */
+    char degree[16];   /* graduate degree type */
+methods:
+    override printStudentInfo;
+    override getStudentType;
+    void setUpGraduateStudent(char *id, char *name, char *thesis, char *degree);
diff -urN somfree\spp\src\note.txt newsomfree3\spp\src\note.txt
--- somfree\spp\src\note.txt	Thu Jan 01 07:00:00 1970
+++ newsomfree3\spp\src\note.txt	Sat Mar 16 14:09:29 2024
@@ -0,0 +1,13 @@
+use
+
+lex.exe -ospp.c spp.ll
+
+to produce spp.c file from flex file
+
+
+
+Seems standard SPP produces not #line pragma, but
+
+@ <lineno> "filename" "filename"
+
+Need to check how it works.
diff -urN somfree\spp\src\spp.c newsomfree3\spp\src\spp.c
--- somfree\spp\src\spp.c	Thu Jan 01 07:00:00 1970
+++ newsomfree3\spp\src\spp.c	Sat Mar 16 14:09:29 2024
@@ -0,0 +1,1690 @@
+#line 2 "spp.c"
+/* A lexical scanner generated by flex */
+
+/* Scanner skeleton version:
+ * $Header: /home/daffy/u0/vern/flex/RCS/flex.skl,v 2.91 96/09/10 16:58:48 vern Exp $
+ */
+
+#define FLEX_SCANNER
+#define YY_FLEX_MAJOR_VERSION 2
+#define YY_FLEX_MINOR_VERSION 5
+
+#ifdef __CRTRSXNT__
+#include <crtrsxnt.h>
+#endif
+#include <stdio.h>
+
+
+/* cfront 1.2 defines "c_plusplus" instead of "__cplusplus" */
+#ifdef c_plusplus
+#ifndef __cplusplus
+#define __cplusplus
+#endif
+#endif
+
+
+#ifdef __cplusplus
+
+#include <stdlib.h>
+#include <unistd.h>
+
+/* Use prototypes in function declarations. */
+#define YY_USE_PROTOS
+
+/* The "const" storage-class-modifier is valid. */
+#define YY_USE_CONST
+
+#else	/* ! __cplusplus */
+
+#if __STDC__
+
+#define YY_USE_PROTOS
+#define YY_USE_CONST
+
+#endif	/* __STDC__ */
+#endif	/* ! __cplusplus */
+
+#ifdef __TURBOC__
+ #pragma warn -rch
+ #pragma warn -use
+#include <io.h>
+#include <stdlib.h>
+#define YY_USE_CONST
+#define YY_USE_PROTOS
+#endif
+
+#ifdef YY_USE_CONST
+#define yyconst const
+#else
+#define yyconst
+#endif
+
+
+#ifdef YY_USE_PROTOS
+#define YY_PROTO(proto) proto
+#else
+#define YY_PROTO(proto) ()
+#endif
+
+/* Returned upon end-of-file. */
+#define YY_NULL 0
+
+/* Promotes a possibly negative, possibly signed char to an unsigned
+ * integer for use as an array index.  If the signed char is negative,
+ * we want to instead treat it as an 8-bit unsigned char, hence the
+ * double cast.
+ */
+#define YY_SC_TO_UI(c) ((unsigned int) (unsigned char) c)
+
+/* Enter a start condition.  This macro really ought to take a parameter,
+ * but we do it the disgusting crufty way forced on us by the ()-less
+ * definition of BEGIN.
+ */
+#define BEGIN yy_start = 1 + 2 *
+
+/* Translate the current start state into a value that can be later handed
+ * to BEGIN to return to the state.  The YYSTATE alias is for lex
+ * compatibility.
+ */
+#define YY_START ((yy_start - 1) / 2)
+#define YYSTATE YY_START
+
+/* Action number for EOF rule of a given start state. */
+#define YY_STATE_EOF(state) (YY_END_OF_BUFFER + state + 1)
+
+/* Special action meaning "start processing a new file". */
+#define YY_NEW_FILE yyrestart( yyin )
+
+#define YY_END_OF_BUFFER_CHAR 0
+
+/* Size of default input buffer. */
+#define YY_BUF_SIZE 16384
+
+typedef struct yy_buffer_state *YY_BUFFER_STATE;
+
+extern int yyleng;
+extern FILE *yyin, *yyout;
+
+#define EOB_ACT_CONTINUE_SCAN 0
+#define EOB_ACT_END_OF_FILE 1
+#define EOB_ACT_LAST_MATCH 2
+
+/* The funky do-while in the following #define is used to turn the definition
+ * int a single C statement (which needs a semi-colon terminator).  This
+ * avoids problems with code like:
+ *
+ * 	if ( condition_holds )
+ *		yyless( 5 );
+ *	else
+ *		do_something_else();
+ *
+ * Prior to using the do-while the compiler would get upset at the
+ * "else" because it interpreted the "if" statement as being all
+ * done when it reached the ';' after the yyless() call.
+ */
+
+/* Return all but the first 'n' matched characters back to the input stream. */
+
+#define yyless(n) \
+	do \
+		{ \
+		/* Undo effects of setting up yytext. */ \
+		*yy_cp = yy_hold_char; \
+		YY_RESTORE_YY_MORE_OFFSET \
+		yy_c_buf_p = yy_cp = yy_bp + n - YY_MORE_ADJ; \
+		YY_DO_BEFORE_ACTION; /* set up yytext again */ \
+		} \
+	while ( 0 )
+
+#define unput(c) yyunput( c, yytext_ptr )
+
+/* The following is because we cannot portably get our hands on size_t
+ * (without autoconf's help, which isn't available because we want
+ * flex-generated scanners to compile on their own).
+ */
+typedef unsigned int yy_size_t;
+
+
+struct yy_buffer_state
+	{
+	FILE *yy_input_file;
+
+	char *yy_ch_buf;		/* input buffer */
+	char *yy_buf_pos;		/* current position in input buffer */
+
+	/* Size of input buffer in bytes, not including room for EOB
+	 * characters.
+	 */
+	yy_size_t yy_buf_size;
+
+	/* Number of characters read into yy_ch_buf, not including EOB
+	 * characters.
+	 */
+	int yy_n_chars;
+
+	/* Whether we "own" the buffer - i.e., we know we created it,
+	 * and can realloc() it to grow it, and should free() it to
+	 * delete it.
+	 */
+	int yy_is_our_buffer;
+
+	/* Whether this is an "interactive" input source; if so, and
+	 * if we're using stdio for input, then we want to use getc()
+	 * instead of fread(), to make sure we stop fetching input after
+	 * each newline.
+	 */
+	int yy_is_interactive;
+
+	/* Whether we're considered to be at the beginning of a line.
+	 * If so, '^' rules will be active on the next match, otherwise
+	 * not.
+	 */
+	int yy_at_bol;
+
+	/* Whether to try to fill the input buffer when we reach the
+	 * end of it.
+	 */
+	int yy_fill_buffer;
+
+	int yy_buffer_status;
+#define YY_BUFFER_NEW 0
+#define YY_BUFFER_NORMAL 1
+	/* When an EOF's been seen but there's still some text to process
+	 * then we mark the buffer as YY_EOF_PENDING, to indicate that we
+	 * shouldn't try reading from the input source any more.  We might
+	 * still have a bunch of tokens to match, though, because of
+	 * possible backing-up.
+	 *
+	 * When we actually see the EOF, we change the status to "new"
+	 * (via yyrestart()), so that the user can continue scanning by
+	 * just pointing yyin at a new input file.
+	 */
+#define YY_BUFFER_EOF_PENDING 2
+	};
+
+static YY_BUFFER_STATE yy_current_buffer = 0;
+
+/* We provide macros for accessing buffer states in case in the
+ * future we want to put the buffer states in a more general
+ * "scanner state".
+ */
+#define YY_CURRENT_BUFFER yy_current_buffer
+
+
+/* yy_hold_char holds the character lost when yytext is formed. */
+static char yy_hold_char;
+
+static int yy_n_chars;		/* number of characters read into yy_ch_buf */
+
+
+int yyleng;
+
+/* Points to current character in buffer. */
+static char *yy_c_buf_p = (char *) 0;
+static int yy_init = 1;		/* whether we need to initialize */
+static int yy_start = 0;	/* start state number */
+
+/* Flag which is used to allow yywrap()'s to do buffer switches
+ * instead of setting up a fresh yyin.  A bit of a hack ...
+ */
+static int yy_did_buffer_switch_on_eof;
+
+void yyrestart YY_PROTO(( FILE *input_file ));
+
+void yy_switch_to_buffer YY_PROTO(( YY_BUFFER_STATE new_buffer ));
+void yy_load_buffer_state YY_PROTO(( void ));
+YY_BUFFER_STATE yy_create_buffer YY_PROTO(( FILE *file, int size ));
+void yy_delete_buffer YY_PROTO(( YY_BUFFER_STATE b ));
+void yy_init_buffer YY_PROTO(( YY_BUFFER_STATE b, FILE *file ));
+void yy_flush_buffer YY_PROTO(( YY_BUFFER_STATE b ));
+#define YY_FLUSH_BUFFER yy_flush_buffer( yy_current_buffer )
+
+YY_BUFFER_STATE yy_scan_buffer YY_PROTO(( char *base, yy_size_t size ));
+YY_BUFFER_STATE yy_scan_string YY_PROTO(( yyconst char *yy_str ));
+YY_BUFFER_STATE yy_scan_bytes YY_PROTO(( yyconst char *bytes, int len ));
+
+static void *yy_flex_alloc YY_PROTO(( yy_size_t ));
+static void *yy_flex_realloc YY_PROTO(( void *, yy_size_t ));
+static void yy_flex_free YY_PROTO(( void * ));
+
+#define yy_new_buffer yy_create_buffer
+
+#define yy_set_interactive(is_interactive) \
+	{ \
+	if ( ! yy_current_buffer ) \
+		yy_current_buffer = yy_create_buffer( yyin, YY_BUF_SIZE ); \
+	yy_current_buffer->yy_is_interactive = is_interactive; \
+	}
+
+#define yy_set_bol(at_bol) \
+	{ \
+	if ( ! yy_current_buffer ) \
+		yy_current_buffer = yy_create_buffer( yyin, YY_BUF_SIZE ); \
+	yy_current_buffer->yy_at_bol = at_bol; \
+	}
+
+#define YY_AT_BOL() (yy_current_buffer->yy_at_bol)
+
+typedef unsigned char YY_CHAR;
+FILE *yyin = (FILE *) 0, *yyout = (FILE *) 0;
+typedef int yy_state_type;
+extern char *yytext;
+#define yytext_ptr yytext
+
+static yy_state_type yy_get_previous_state YY_PROTO(( void ));
+static yy_state_type yy_try_NUL_trans YY_PROTO(( yy_state_type current_state ));
+static int yy_get_next_buffer YY_PROTO(( void ));
+static void yy_fatal_error YY_PROTO(( yyconst char msg[] ));
+
+/* Done after the current pattern has been matched and before the
+ * corresponding action - sets up yytext.
+ */
+#define YY_DO_BEFORE_ACTION \
+	yytext_ptr = yy_bp; \
+	yyleng = (int) (yy_cp - yy_bp); \
+	yy_hold_char = *yy_cp; \
+	*yy_cp = '\0'; \
+	yy_c_buf_p = yy_cp;
+
+#define YY_NUM_RULES 7
+#define YY_END_OF_BUFFER 8
+static yyconst short int yy_accept[34] =
+    {   0,
+        4,    4,    5,    5,    8,    4,    4,    3,    4,    3,
+        6,    5,    7,    4,    4,    3,    0,    3,    6,    5,
+        0,    3,    0,    3,    0,    3,    0,    3,    0,    3,
+        1,    2,    0
+    } ;
+
+static yyconst int yy_ec[256] =
+    {   0,
+        1,    1,    1,    1,    1,    1,    1,    1,    2,    3,
+        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
+        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
+        1,    4,    1,    1,    5,    1,    1,    1,    1,    1,
+        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
+        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
+        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
+        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
+        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
+        1,    1,    1,    1,    1,    1,    6,    6,    7,    8,
+
+        9,    6,    6,    6,   10,    6,    6,   11,    6,   12,
+        6,    6,    6,    6,    6,    6,   13,    6,    6,    6,
+        6,    6,    1,    1,    1,    1,    1,    1,    1,    1,
+        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
+        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
+        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
+        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
+        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
+        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
+        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
+
+        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
+        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
+        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
+        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
+        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
+        1,    1,    1,    1,    1
+    } ;
+
+static yyconst int yy_meta[14] =
+    {   0,
+        1,    2,    3,    2,    1,    4,    4,    4,    4,    4,
+        4,    4,    4
+    } ;
+
+static yyconst short int yy_base[40] =
+    {   0,
+        0,    5,   14,   17,   50,   46,   51,    0,   19,   36,
+        0,    0,   51,   44,   51,    0,   34,   38,    0,    0,
+       36,   31,   17,   14,   13,   17,   16,   14,    5,    9,
+       51,   51,   51,   29,   33,   37,    8,   40,    9
+    } ;
+
+static yyconst short int yy_def[40] =
+    {   0,
+       34,   34,   35,   35,   33,   36,   33,   37,   36,   37,
+       38,   39,   33,   36,   33,   37,   33,   37,   38,   39,
+       33,   37,   33,   37,   33,   37,   33,   37,   33,   37,
+       33,   33,    0,   33,   33,   33,   33,   33,   33
+    } ;
+
+static yyconst short int yy_nxt[65] =
+    {   0,
+        6,    6,    7,    6,    6,    6,    6,    7,    6,    9,
+       20,   16,   32,   31,   10,   12,   13,   12,   12,   13,
+       12,   15,   30,   29,   28,   27,   26,   25,   17,    8,
+        8,    8,    8,   11,   11,   11,   11,   14,   14,   14,
+       19,   24,   23,   19,   22,   21,   15,   18,   15,   33,
+        5,   33,   33,   33,   33,   33,   33,   33,   33,   33,
+       33,   33,   33,   33
+    } ;
+
+static yyconst short int yy_chk[65] =
+    {   0,
+        1,    1,    1,    1,    1,    2,    2,    2,    2,    2,
+       39,   37,   30,   29,    2,    3,    3,    3,    4,    4,
+        4,    9,   28,   27,   26,   25,   24,   23,    9,   34,
+       34,   34,   34,   35,   35,   35,   35,   36,   36,   36,
+       38,   22,   21,   38,   18,   17,   14,   10,    6,    5,
+       33,   33,   33,   33,   33,   33,   33,   33,   33,   33,
+       33,   33,   33,   33
+    } ;
+
+static yy_state_type yy_last_accepting_state;
+static char *yy_last_accepting_cpos;
+
+/* The intent behind this definition is that it'll catch
+ * any uses of REJECT which flex missed.
+ */
+#define REJECT reject_used_but_not_detected
+#define yymore() yymore_used_but_not_detected
+#define YY_MORE_ADJ 0
+#define YY_RESTORE_YY_MORE_OFFSET
+char *yytext;
+#line 1 "spp.ll"
+#define INITIAL 0
+/**************************************************************************
+ *
+ *  Copyright 2022, Yuri Prokushev
+ *
+ *  This file is part of osFree project
+ *
+ *  This program is free software: you can redistribute it and/or modify it
+ *  under the terms of the GNU Lesser General Public License as published by the
+ *  Free Software Foundation, either version 3 of the License, or (at your
+ *  option) any later version.
+ * 
+ *  This program is distributed in the hope that it will be useful, but WITHOUT
+ *  ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ *  FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for
+ *  more details.
+ *
+ *  You should have received a copy of the GNU Lesser General Public License
+ *  along with this program.  If not, see <http://www.gnu.org/licenses/>
+ *
+ */
+/*
+
+  SOM Preprocessor SPP is a original SOM Preprocessor of OIDL files.
+  Tested on all csc/sc files found by me. Not sure it will work as
+  drop-in replacement of original SPP.
+
+  @todo Add passthrow section skip
+  @todo Add loop include control.
+*/
+/* the "incl" state is used for picking up the name
+ * of an include file
+ */
+#define incl 1
+
+#line 38 "spp.ll"
+#include <stdlib.h>
+#include <string.h>
+#include <direct.h>
+#include <io.h>
+
+#include <emitlib.h>
+
+#define YY_NEVER_INTERACTIVE 1
+
+#define MAX_INCLUDE_DEPTH 20
+struct {
+  YY_BUFFER_STATE state;
+  char * filename;
+  int lineno;
+} include_stack[MAX_INCLUDE_DEPTH];
+int include_stack_ptr = 0;
+#line 440 "spp.c"
+
+/* Macros after this point can all be overridden by user definitions in
+ * section 1.
+ */
+
+#ifndef YY_SKIP_YYWRAP
+#ifdef __cplusplus
+extern "C" int yywrap YY_PROTO(( void ));
+#else
+extern int yywrap YY_PROTO(( void ));
+#endif
+#endif
+
+#ifndef YY_NO_UNPUT
+static void yyunput YY_PROTO(( int c, char *buf_ptr ));
+#endif
+
+#ifndef yytext_ptr
+static void yy_flex_strncpy YY_PROTO(( char *, yyconst char *, int ));
+#endif
+
+#ifdef YY_NEED_STRLEN
+static int yy_flex_strlen YY_PROTO(( yyconst char * ));
+#endif
+
+#ifndef YY_NO_INPUT
+#ifdef __cplusplus
+static int yyinput YY_PROTO(( void ));
+#else
+static int input YY_PROTO(( void ));
+#endif
+#endif
+
+#if YY_STACK_USED
+static int yy_start_stack_ptr = 0;
+static int yy_start_stack_depth = 0;
+static int *yy_start_stack = 0;
+#ifndef YY_NO_PUSH_STATE
+static void yy_push_state YY_PROTO(( int new_state ));
+#endif
+#ifndef YY_NO_POP_STATE
+static void yy_pop_state YY_PROTO(( void ));
+#endif
+#ifndef YY_NO_TOP_STATE
+static int yy_top_state YY_PROTO(( void ));
+#endif
+
+#else
+#define YY_NO_PUSH_STATE 1
+#define YY_NO_POP_STATE 1
+#define YY_NO_TOP_STATE 1
+#endif
+
+#ifdef YY_MALLOC_DECL
+YY_MALLOC_DECL
+#else
+#if __STDC__
+#ifndef __cplusplus
+#include <stdlib.h>
+#endif
+#else
+/* Just try to get by without declaring the routines.  This will fail
+ * miserably on non-ANSI systems for which sizeof(size_t) != sizeof(int)
+ * or sizeof(void*) != sizeof(int).
+ */
+#endif
+#endif
+
+/* Amount of stuff to slurp up with each read. */
+#ifndef YY_READ_BUF_SIZE
+#define YY_READ_BUF_SIZE 8192
+#endif
+
+/* Copy whatever the last rule matched to the standard output. */
+
+#ifndef ECHO
+/* This used to be an fputs(), but since the string might contain NUL's,
+ * we now use fwrite().
+ */
+#define ECHO (void) fwrite( yytext, yyleng, 1, yyout )
+#endif
+
+/* Gets input and stuffs it into "buf".  number of characters read, or YY_NULL,
+ * is returned in "result".
+ */
+#ifndef YY_INPUT
+#define YY_INPUT(buf,result,max_size) \
+	if ( yy_current_buffer->yy_is_interactive ) \
+		{ \
+		int c = '*', n; \
+		for ( n = 0; n < max_size && \
+			     (c = getc( yyin )) != EOF && c != '\n'; ++n ) \
+			buf[n] = (char) c; \
+		if ( c == '\n' ) \
+			buf[n++] = (char) c; \
+		if ( c == EOF && ferror( yyin ) ) \
+			YY_FATAL_ERROR( "input in flex scanner failed" ); \
+		result = n; \
+		} \
+	else if ( ((result = fread( buf, 1, max_size, yyin )) == 0) \
+		  && ferror( yyin ) ) \
+		YY_FATAL_ERROR( "input in flex scanner failed" );
+#endif
+
+/* No semi-colon after return; correct usage is to write "yyterminate();" -
+ * we don't want an extra ';' after the "return" because that will cause
+ * some compilers to complain about unreachable statements.
+ */
+#ifndef yyterminate
+#define yyterminate() return YY_NULL
+#endif
+
+/* Number of entries by which start-condition stack grows. */
+#ifndef YY_START_STACK_INCR
+#define YY_START_STACK_INCR 25
+#endif
+
+/* Report a fatal error. */
+#ifndef YY_FATAL_ERROR
+#define YY_FATAL_ERROR(msg) yy_fatal_error( msg )
+#endif
+
+/* Default declaration of generated scanner - a define so the user can
+ * easily add parameters.
+ */
+#ifndef YY_DECL
+#define YY_DECL int yylex YY_PROTO(( void ))
+#endif
+
+/* Code executed at the beginning of each rule, after yytext and yyleng
+ * have been set up.
+ */
+#ifndef YY_USER_ACTION
+#define YY_USER_ACTION
+#endif
+
+/* Code executed at the end of each rule. */
+#ifndef YY_BREAK
+#define YY_BREAK break;
+#endif
+
+#define YY_RULE_SETUP \
+	if ( yyleng > 0 ) \
+		yy_current_buffer->yy_at_bol = \
+				(yytext[yyleng - 1] == '\n'); \
+	YY_USER_ACTION
+
+YY_DECL
+	{
+	register yy_state_type yy_current_state;
+	register char *yy_cp, *yy_bp;
+	register int yy_act;
+
+#line 56 "spp.ll"
+
+#line 596 "spp.c"
+
+	if ( yy_init )
+		{
+		yy_init = 0;
+
+#ifdef YY_USER_INIT
+		YY_USER_INIT;
+#endif
+
+		if ( ! yy_start )
+			yy_start = 1;	/* first start state */
+
+		if ( ! yyin )
+			yyin = stdin;
+
+		if ( ! yyout )
+			yyout = stdout;
+
+		if ( ! yy_current_buffer )
+			yy_current_buffer =
+				yy_create_buffer( yyin, YY_BUF_SIZE );
+
+		yy_load_buffer_state();
+		}
+
+	while ( 1 )		/* loops until end-of-file is reached */
+		{
+		yy_cp = yy_c_buf_p;
+
+		/* Support of yytext. */
+		*yy_cp = yy_hold_char;
+
+		/* yy_bp points to the position in yy_ch_buf of the start of
+		 * the current run.
+		 */
+		yy_bp = yy_cp;
+
+		yy_current_state = yy_start;
+		yy_current_state += YY_AT_BOL();
+yy_match:
+		do
+			{
+			register YY_CHAR yy_c = yy_ec[YY_SC_TO_UI(*yy_cp)];
+			if ( yy_accept[yy_current_state] )
+				{
+				yy_last_accepting_state = yy_current_state;
+				yy_last_accepting_cpos = yy_cp;
+				}
+			while ( yy_chk[yy_base[yy_current_state] + yy_c] != yy_current_state )
+				{
+				yy_current_state = (int) yy_def[yy_current_state];
+				if ( yy_current_state >= 34 )
+					yy_c = yy_meta[(unsigned int) yy_c];
+				}
+			yy_current_state = yy_nxt[yy_base[yy_current_state] + (unsigned int) yy_c];
+			++yy_cp;
+			}
+		while ( yy_base[yy_current_state] != 51 );
+
+yy_find_action:
+		yy_act = yy_accept[yy_current_state];
+		if ( yy_act == 0 )
+			{ /* have to back up */
+			yy_cp = yy_last_accepting_cpos;
+			yy_current_state = yy_last_accepting_state;
+			yy_act = yy_accept[yy_current_state];
+			}
+
+		YY_DO_BEFORE_ACTION;
+
+
+do_action:	/* This label is used only to access EOF actions. */
+
+
+		switch ( yy_act )
+	{ /* beginning of action switch */
+			case 0: /* must back up */
+			/* undo the effects of YY_DO_BEFORE_ACTION */
+			*yy_cp = yy_hold_char;
+			yy_cp = yy_last_accepting_cpos;
+			yy_current_state = yy_last_accepting_state;
+			goto yy_find_action;
+
+case 1:
+YY_RULE_SETUP
+#line 57 "spp.ll"
+{ BEGIN(incl); }
+	YY_BREAK
+case 2:
+YY_RULE_SETUP
+#line 58 "spp.ll"
+{ BEGIN(incl); }
+	YY_BREAK
+case 3:
+YY_RULE_SETUP
+#line 60 "spp.ll"
+{ ECHO; }
+	YY_BREAK
+case 4:
+YY_RULE_SETUP
+#line 61 "spp.ll"
+{ ECHO; include_stack[include_stack_ptr].lineno++; }
+	YY_BREAK
+case 5:
+YY_RULE_SETUP
+#line 63 "spp.ll"
+{ /* eat the whitespace */ }
+	YY_BREAK
+case 6:
+YY_RULE_SETUP
+#line 64 "spp.ll"
+{ /* got the include file name */
+		if (include_stack_ptr >= MAX_INCLUDE_DEPTH)
+		{
+                  fprintf(stderr, "Includes nested too deeply");
+		  exit( 1 );
+		}
+
+		include_stack[include_stack_ptr].state = YY_CURRENT_BUFFER;
+
+		include_stack_ptr++;
+
+		include_stack[include_stack_ptr].filename=strdup(yytext+1);
+		include_stack[include_stack_ptr].filename[strlen(include_stack[include_stack_ptr].filename)-1]=0x0;
+		if (yytext[0]=='<')
+		{
+		  char fullpath[260];
+		  somtsearchFileSL(include_stack[include_stack_ptr].filename, fullpath, "SMINCLUDE");
+		  free(include_stack[include_stack_ptr].filename);
+		  include_stack[include_stack_ptr].filename=strdup(fullpath);
+		}
+
+		yyin = fopen(include_stack[include_stack_ptr].filename, "r");
+
+		if (!yyin)
+		{
+		  fprintf(stderr, "fopen %s error", include_stack[include_stack_ptr].filename);
+		  exit(1);
+		}
+
+		fprintf(yyout, "#line 1 \"%s\"\n", include_stack[include_stack_ptr].filename);
+		yy_switch_to_buffer(yy_create_buffer(yyin, YY_BUF_SIZE));
+
+		BEGIN(INITIAL);
+	   }
+	YY_BREAK
+case YY_STATE_EOF(INITIAL):
+case YY_STATE_EOF(incl):
+#line 99 "spp.ll"
+{
+	   if (	--include_stack_ptr < 0	)
+	       {
+	       yyterminate();
+	       }
+
+	   else
+	       {
+		yy_delete_buffer( YY_CURRENT_BUFFER );
+		yy_switch_to_buffer(include_stack[include_stack_ptr].state);
+		fprintf(yyout, "#line %d \"%s\"\n", include_stack[include_stack_ptr].lineno, include_stack[include_stack_ptr].filename);
+	       }
+
+	   }
+	YY_BREAK
+case 7:
+YY_RULE_SETUP
+#line 114 "spp.ll"
+ECHO;
+	YY_BREAK
+#line 766 "spp.c"
+
+	case YY_END_OF_BUFFER:
+		{
+		/* Amount of text matched not including the EOB char. */
+		int yy_amount_of_matched_text = (int) (yy_cp - yytext_ptr) - 1;
+
+		/* Undo the effects of YY_DO_BEFORE_ACTION. */
+		*yy_cp = yy_hold_char;
+		YY_RESTORE_YY_MORE_OFFSET
+
+		if ( yy_current_buffer->yy_buffer_status == YY_BUFFER_NEW )
+			{
+			/* We're scanning a new file or input source.  It's
+			 * possible that this happened because the user
+			 * just pointed yyin at a new source and called
+			 * yylex().  If so, then we have to assure
+			 * consistency between yy_current_buffer and our
+			 * globals.  Here is the right place to do so, because
+			 * this is the first action (other than possibly a
+			 * back-up) that will match for the new input source.
+			 */
+			yy_n_chars = yy_current_buffer->yy_n_chars;
+			yy_current_buffer->yy_input_file = yyin;
+			yy_current_buffer->yy_buffer_status = YY_BUFFER_NORMAL;
+			}
+
+		/* Note that here we test for yy_c_buf_p "<=" to the position
+		 * of the first EOB in the buffer, since yy_c_buf_p will
+		 * already have been incremented past the NUL character
+		 * (since all states make transitions on EOB to the
+		 * end-of-buffer state).  Contrast this with the test
+		 * in input().
+		 */
+		if ( yy_c_buf_p <= &yy_current_buffer->yy_ch_buf[yy_n_chars] )
+			{ /* This was really a NUL. */
+			yy_state_type yy_next_state;
+
+			yy_c_buf_p = yytext_ptr + yy_amount_of_matched_text;
+
+			yy_current_state = yy_get_previous_state();
+
+			/* Okay, we're now positioned to make the NUL
+			 * transition.  We couldn't have
+			 * yy_get_previous_state() go ahead and do it
+			 * for us because it doesn't know how to deal
+			 * with the possibility of jamming (and we don't
+			 * want to build jamming into it because then it
+			 * will run more slowly).
+			 */
+
+			yy_next_state = yy_try_NUL_trans( yy_current_state );
+
+			yy_bp = yytext_ptr + YY_MORE_ADJ;
+
+			if ( yy_next_state )
+				{
+				/* Consume the NUL. */
+				yy_cp = ++yy_c_buf_p;
+				yy_current_state = yy_next_state;
+				goto yy_match;
+				}
+
+			else
+				{
+				yy_cp = yy_c_buf_p;
+				goto yy_find_action;
+				}
+			}
+
+		else switch ( yy_get_next_buffer() )
+			{
+			case EOB_ACT_END_OF_FILE:
+				{
+				yy_did_buffer_switch_on_eof = 0;
+
+				if ( yywrap() )
+					{
+					/* Note: because we've taken care in
+					 * yy_get_next_buffer() to have set up
+					 * yytext, we can now set up
+					 * yy_c_buf_p so that if some total
+					 * hoser (like flex itself) wants to
+					 * call the scanner after we return the
+					 * YY_NULL, it'll still work - another
+					 * YY_NULL will get returned.
+					 */
+					yy_c_buf_p = yytext_ptr + YY_MORE_ADJ;
+
+					yy_act = YY_STATE_EOF(YY_START);
+					goto do_action;
+					}
+
+				else
+					{
+					if ( ! yy_did_buffer_switch_on_eof )
+						YY_NEW_FILE;
+					}
+				break;
+				}
+
+			case EOB_ACT_CONTINUE_SCAN:
+				yy_c_buf_p =
+					yytext_ptr + yy_amount_of_matched_text;
+
+				yy_current_state = yy_get_previous_state();
+
+				yy_cp = yy_c_buf_p;
+				yy_bp = yytext_ptr + YY_MORE_ADJ;
+				goto yy_match;
+
+			case EOB_ACT_LAST_MATCH:
+				yy_c_buf_p =
+				&yy_current_buffer->yy_ch_buf[yy_n_chars];
+
+				yy_current_state = yy_get_previous_state();
+
+				yy_cp = yy_c_buf_p;
+				yy_bp = yytext_ptr + YY_MORE_ADJ;
+				goto yy_find_action;
+			}
+		break;
+		}
+
+	default:
+		YY_FATAL_ERROR(
+			"fatal flex scanner internal error--no action found" );
+	} /* end of action switch */
+		} /* end of scanning one token */
+	} /* end of yylex */
+
+
+/* yy_get_next_buffer - try to read in a new buffer
+ *
+ * Returns a code representing an action:
+ *	EOB_ACT_LAST_MATCH -
+ *	EOB_ACT_CONTINUE_SCAN - continue scanning from current position
+ *	EOB_ACT_END_OF_FILE - end of file
+ */
+
+static int yy_get_next_buffer()
+	{
+	register char *dest = yy_current_buffer->yy_ch_buf;
+	register char *source = yytext_ptr;
+	register int number_to_move, i;
+	int ret_val;
+
+	if ( yy_c_buf_p > &yy_current_buffer->yy_ch_buf[yy_n_chars + 1] )
+		YY_FATAL_ERROR(
+		"fatal flex scanner internal error--end of buffer missed" );
+
+	if ( yy_current_buffer->yy_fill_buffer == 0 )
+		{ /* Don't try to fill the buffer, so this is an EOF. */
+		if ( yy_c_buf_p - yytext_ptr - YY_MORE_ADJ == 1 )
+			{
+			/* We matched a single character, the EOB, so
+			 * treat this as a final EOF.
+			 */
+			return EOB_ACT_END_OF_FILE;
+			}
+
+		else
+			{
+			/* We matched some text prior to the EOB, first
+			 * process it.
+			 */
+			return EOB_ACT_LAST_MATCH;
+			}
+		}
+
+	/* Try to read more data. */
+
+	/* First move last chars to start of buffer. */
+	number_to_move = (int) (yy_c_buf_p - yytext_ptr) - 1;
+
+	for ( i = 0; i < number_to_move; ++i )
+		*(dest++) = *(source++);
+
+	if ( yy_current_buffer->yy_buffer_status == YY_BUFFER_EOF_PENDING )
+		/* don't do the read, it's not guaranteed to return an EOF,
+		 * just force an EOF
+		 */
+		yy_current_buffer->yy_n_chars = yy_n_chars = 0;
+
+	else
+		{
+		int num_to_read =
+			yy_current_buffer->yy_buf_size - number_to_move - 1;
+
+		while ( num_to_read <= 0 )
+			{ /* Not enough room in the buffer - grow it. */
+#ifdef YY_USES_REJECT
+			YY_FATAL_ERROR(
+"input buffer overflow, can't enlarge buffer because scanner uses REJECT" );
+#else
+
+			/* just a shorter name for the current buffer */
+			YY_BUFFER_STATE b = yy_current_buffer;
+
+			int yy_c_buf_p_offset =
+				(int) (yy_c_buf_p - b->yy_ch_buf);
+
+			if ( b->yy_is_our_buffer )
+				{
+				int new_size = b->yy_buf_size * 2;
+
+				if ( new_size <= 0 )
+					b->yy_buf_size += b->yy_buf_size / 8;
+				else
+					b->yy_buf_size *= 2;
+
+				b->yy_ch_buf = (char *)
+					/* Include room in for 2 EOB chars. */
+					yy_flex_realloc( (void *) b->yy_ch_buf,
+							 b->yy_buf_size + 2 );
+				}
+			else
+				/* Can't grow it, we don't own it. */
+				b->yy_ch_buf = 0;
+
+			if ( ! b->yy_ch_buf )
+				YY_FATAL_ERROR(
+				"fatal error - scanner input buffer overflow" );
+
+			yy_c_buf_p = &b->yy_ch_buf[yy_c_buf_p_offset];
+
+			num_to_read = yy_current_buffer->yy_buf_size -
+						number_to_move - 1;
+#endif
+			}
+
+		if ( num_to_read > YY_READ_BUF_SIZE )
+			num_to_read = YY_READ_BUF_SIZE;
+
+		/* Read in more data. */
+		YY_INPUT( (&yy_current_buffer->yy_ch_buf[number_to_move]),
+			yy_n_chars, num_to_read );
+
+		yy_current_buffer->yy_n_chars = yy_n_chars;
+		}
+
+	if ( yy_n_chars == 0 )
+		{
+		if ( number_to_move == YY_MORE_ADJ )
+			{
+			ret_val = EOB_ACT_END_OF_FILE;
+			yyrestart( yyin );
+			}
+
+		else
+			{
+			ret_val = EOB_ACT_LAST_MATCH;
+			yy_current_buffer->yy_buffer_status =
+				YY_BUFFER_EOF_PENDING;
+			}
+		}
+
+	else
+		ret_val = EOB_ACT_CONTINUE_SCAN;
+
+	yy_n_chars += number_to_move;
+	yy_current_buffer->yy_ch_buf[yy_n_chars] = YY_END_OF_BUFFER_CHAR;
+	yy_current_buffer->yy_ch_buf[yy_n_chars + 1] = YY_END_OF_BUFFER_CHAR;
+
+	yytext_ptr = &yy_current_buffer->yy_ch_buf[0];
+
+	return ret_val;
+	}
+
+
+/* yy_get_previous_state - get the state just before the EOB char was reached */
+
+static yy_state_type yy_get_previous_state()
+	{
+	register yy_state_type yy_current_state;
+	register char *yy_cp;
+
+	yy_current_state = yy_start;
+	yy_current_state += YY_AT_BOL();
+
+	for ( yy_cp = yytext_ptr + YY_MORE_ADJ; yy_cp < yy_c_buf_p; ++yy_cp )
+		{
+		register YY_CHAR yy_c = (*yy_cp ? yy_ec[YY_SC_TO_UI(*yy_cp)] : 1);
+		if ( yy_accept[yy_current_state] )
+			{
+			yy_last_accepting_state = yy_current_state;
+			yy_last_accepting_cpos = yy_cp;
+			}
+		while ( yy_chk[yy_base[yy_current_state] + yy_c] != yy_current_state )
+			{
+			yy_current_state = (int) yy_def[yy_current_state];
+			if ( yy_current_state >= 34 )
+				yy_c = yy_meta[(unsigned int) yy_c];
+			}
+		yy_current_state = yy_nxt[yy_base[yy_current_state] + (unsigned int) yy_c];
+		}
+
+	return yy_current_state;
+	}
+
+
+/* yy_try_NUL_trans - try to make a transition on the NUL character
+ *
+ * synopsis
+ *	next_state = yy_try_NUL_trans( current_state );
+ */
+
+#ifdef YY_USE_PROTOS
+static yy_state_type yy_try_NUL_trans( yy_state_type yy_current_state )
+#else
+static yy_state_type yy_try_NUL_trans( yy_current_state )
+yy_state_type yy_current_state;
+#endif
+	{
+	register int yy_is_jam;
+	register char *yy_cp = yy_c_buf_p;
+
+	register YY_CHAR yy_c = 1;
+	if ( yy_accept[yy_current_state] )
+		{
+		yy_last_accepting_state = yy_current_state;
+		yy_last_accepting_cpos = yy_cp;
+		}
+	while ( yy_chk[yy_base[yy_current_state] + yy_c] != yy_current_state )
+		{
+		yy_current_state = (int) yy_def[yy_current_state];
+		if ( yy_current_state >= 34 )
+			yy_c = yy_meta[(unsigned int) yy_c];
+		}
+	yy_current_state = yy_nxt[yy_base[yy_current_state] + (unsigned int) yy_c];
+	yy_is_jam = (yy_current_state == 33);
+
+	return yy_is_jam ? 0 : yy_current_state;
+	}
+
+
+#ifndef YY_NO_UNPUT
+#ifdef YY_USE_PROTOS
+static void yyunput( int c, register char *yy_bp )
+#else
+static void yyunput( c, yy_bp )
+int c;
+register char *yy_bp;
+#endif
+	{
+	register char *yy_cp = yy_c_buf_p;
+
+	/* undo effects of setting up yytext */
+	*yy_cp = yy_hold_char;
+
+	if ( yy_cp < yy_current_buffer->yy_ch_buf + 2 )
+		{ /* need to shift things up to make room */
+		/* +2 for EOB chars. */
+		register int number_to_move = yy_n_chars + 2;
+		register char *dest = &yy_current_buffer->yy_ch_buf[
+					yy_current_buffer->yy_buf_size + 2];
+		register char *source =
+				&yy_current_buffer->yy_ch_buf[number_to_move];
+
+		while ( source > yy_current_buffer->yy_ch_buf )
+			*--dest = *--source;
+
+		yy_cp += (int) (dest - source);
+		yy_bp += (int) (dest - source);
+		yy_current_buffer->yy_n_chars =
+			yy_n_chars = yy_current_buffer->yy_buf_size;
+
+		if ( yy_cp < yy_current_buffer->yy_ch_buf + 2 )
+			YY_FATAL_ERROR( "flex scanner push-back overflow" );
+		}
+
+	*--yy_cp = (char) c;
+
+
+	yytext_ptr = yy_bp;
+	yy_hold_char = *yy_cp;
+	yy_c_buf_p = yy_cp;
+	}
+#endif	/* ifndef YY_NO_UNPUT */
+
+
+#ifdef __cplusplus
+static int yyinput()
+#else
+static int input()
+#endif
+	{
+	int c;
+
+	*yy_c_buf_p = yy_hold_char;
+
+	if ( *yy_c_buf_p == YY_END_OF_BUFFER_CHAR )
+		{
+		/* yy_c_buf_p now points to the character we want to return.
+		 * If this occurs *before* the EOB characters, then it's a
+		 * valid NUL; if not, then we've hit the end of the buffer.
+		 */
+		if ( yy_c_buf_p < &yy_current_buffer->yy_ch_buf[yy_n_chars] )
+			/* This was really a NUL. */
+			*yy_c_buf_p = '\0';
+
+		else
+			{ /* need more input */
+			int offset = yy_c_buf_p - yytext_ptr;
+			++yy_c_buf_p;
+
+			switch ( yy_get_next_buffer() )
+				{
+				case EOB_ACT_LAST_MATCH:
+					/* This happens because yy_g_n_b()
+					 * sees that we've accumulated a
+					 * token and flags that we need to
+					 * try matching the token before
+					 * proceeding.  But for input(),
+					 * there's no matching to consider.
+					 * So convert the EOB_ACT_LAST_MATCH
+					 * to EOB_ACT_END_OF_FILE.
+					 */
+
+					/* Reset buffer status. */
+					yyrestart( yyin );
+
+					/* fall through */
+
+				case EOB_ACT_END_OF_FILE:
+					{
+					if ( yywrap() )
+						return EOF;
+
+					if ( ! yy_did_buffer_switch_on_eof )
+						YY_NEW_FILE;
+#ifdef __cplusplus
+					return yyinput();
+#else
+					return input();
+#endif
+					}
+
+				case EOB_ACT_CONTINUE_SCAN:
+					yy_c_buf_p = yytext_ptr + offset;
+					break;
+				}
+			}
+		}
+
+	c = *(unsigned char *) yy_c_buf_p;	/* cast for 8-bit char's */
+	*yy_c_buf_p = '\0';	/* preserve yytext */
+	yy_hold_char = *++yy_c_buf_p;
+
+	yy_current_buffer->yy_at_bol = (c == '\n');
+
+	return c;
+	}
+
+
+#ifdef YY_USE_PROTOS
+void yyrestart( FILE *input_file )
+#else
+void yyrestart( input_file )
+FILE *input_file;
+#endif
+	{
+	if ( ! yy_current_buffer )
+		yy_current_buffer = yy_create_buffer( yyin, YY_BUF_SIZE );
+
+	yy_init_buffer( yy_current_buffer, input_file );
+	yy_load_buffer_state();
+	}
+
+
+#ifdef YY_USE_PROTOS
+void yy_switch_to_buffer( YY_BUFFER_STATE new_buffer )
+#else
+void yy_switch_to_buffer( new_buffer )
+YY_BUFFER_STATE new_buffer;
+#endif
+	{
+	if ( yy_current_buffer == new_buffer )
+		return;
+
+	if ( yy_current_buffer )
+		{
+		/* Flush out information for old buffer. */
+		*yy_c_buf_p = yy_hold_char;
+		yy_current_buffer->yy_buf_pos = yy_c_buf_p;
+		yy_current_buffer->yy_n_chars = yy_n_chars;
+		}
+
+	yy_current_buffer = new_buffer;
+	yy_load_buffer_state();
+
+	/* We don't actually know whether we did this switch during
+	 * EOF (yywrap()) processing, but the only time this flag
+	 * is looked at is after yywrap() is called, so it's safe
+	 * to go ahead and always set it.
+	 */
+	yy_did_buffer_switch_on_eof = 1;
+	}
+
+
+#ifdef YY_USE_PROTOS
+void yy_load_buffer_state( void )
+#else
+void yy_load_buffer_state()
+#endif
+	{
+	yy_n_chars = yy_current_buffer->yy_n_chars;
+	yytext_ptr = yy_c_buf_p = yy_current_buffer->yy_buf_pos;
+	yyin = yy_current_buffer->yy_input_file;
+	yy_hold_char = *yy_c_buf_p;
+	}
+
+
+#ifdef YY_USE_PROTOS
+YY_BUFFER_STATE yy_create_buffer( FILE *file, int size )
+#else
+YY_BUFFER_STATE yy_create_buffer( file, size )
+FILE *file;
+int size;
+#endif
+	{
+	YY_BUFFER_STATE b;
+
+	b = (YY_BUFFER_STATE) yy_flex_alloc( sizeof( struct yy_buffer_state ) );
+	if ( ! b )
+		YY_FATAL_ERROR( "out of dynamic memory in yy_create_buffer()" );
+
+	b->yy_buf_size = size;
+
+	/* yy_ch_buf has to be 2 characters longer than the size given because
+	 * we need to put in 2 end-of-buffer characters.
+	 */
+	b->yy_ch_buf = (char *) yy_flex_alloc( b->yy_buf_size + 2 );
+	if ( ! b->yy_ch_buf )
+		YY_FATAL_ERROR( "out of dynamic memory in yy_create_buffer()" );
+
+	b->yy_is_our_buffer = 1;
+
+	yy_init_buffer( b, file );
+
+	return b;
+	}
+
+
+#ifdef YY_USE_PROTOS
+void yy_delete_buffer( YY_BUFFER_STATE b )
+#else
+void yy_delete_buffer( b )
+YY_BUFFER_STATE b;
+#endif
+	{
+	if ( ! b )
+		return;
+
+	if ( b == yy_current_buffer )
+		yy_current_buffer = (YY_BUFFER_STATE) 0;
+
+	if ( b->yy_is_our_buffer )
+		yy_flex_free( (void *) b->yy_ch_buf );
+
+	yy_flex_free( (void *) b );
+	}
+
+
+#ifndef YY_ALWAYS_INTERACTIVE
+#ifndef YY_NEVER_INTERACTIVE
+extern int isatty YY_PROTO(( int ));
+#endif
+#endif
+
+#ifdef YY_USE_PROTOS
+void yy_init_buffer( YY_BUFFER_STATE b, FILE *file )
+#else
+void yy_init_buffer( b, file )
+YY_BUFFER_STATE b;
+FILE *file;
+#endif
+
+
+	{
+	yy_flush_buffer( b );
+
+	b->yy_input_file = file;
+	b->yy_fill_buffer = 1;
+
+#if YY_ALWAYS_INTERACTIVE
+	b->yy_is_interactive = 1;
+#else
+#if YY_NEVER_INTERACTIVE
+	b->yy_is_interactive = 0;
+#else
+	b->yy_is_interactive = file ? (isatty( fileno(file) ) > 0) : 0;
+#endif
+#endif
+	}
+
+
+#ifdef YY_USE_PROTOS
+void yy_flush_buffer( YY_BUFFER_STATE b )
+#else
+void yy_flush_buffer( b )
+YY_BUFFER_STATE b;
+#endif
+
+	{
+	if ( ! b )
+		return;
+
+	b->yy_n_chars = 0;
+
+	/* We always need two end-of-buffer characters.  The first causes
+	 * a transition to the end-of-buffer state.  The second causes
+	 * a jam in that state.
+	 */
+	b->yy_ch_buf[0] = YY_END_OF_BUFFER_CHAR;
+	b->yy_ch_buf[1] = YY_END_OF_BUFFER_CHAR;
+
+	b->yy_buf_pos = &b->yy_ch_buf[0];
+
+	b->yy_at_bol = 1;
+	b->yy_buffer_status = YY_BUFFER_NEW;
+
+	if ( b == yy_current_buffer )
+		yy_load_buffer_state();
+	}
+
+
+#ifndef YY_NO_SCAN_BUFFER
+#ifdef YY_USE_PROTOS
+YY_BUFFER_STATE yy_scan_buffer( char *base, yy_size_t size )
+#else
+YY_BUFFER_STATE yy_scan_buffer( base, size )
+char *base;
+yy_size_t size;
+#endif
+	{
+	YY_BUFFER_STATE b;
+
+	if ( size < 2 ||
+	     base[size-2] != YY_END_OF_BUFFER_CHAR ||
+	     base[size-1] != YY_END_OF_BUFFER_CHAR )
+		/* They forgot to leave room for the EOB's. */
+		return 0;
+
+	b = (YY_BUFFER_STATE) yy_flex_alloc( sizeof( struct yy_buffer_state ) );
+	if ( ! b )
+		YY_FATAL_ERROR( "out of dynamic memory in yy_scan_buffer()" );
+
+	b->yy_buf_size = size - 2;	/* "- 2" to take care of EOB's */
+	b->yy_buf_pos = b->yy_ch_buf = base;
+	b->yy_is_our_buffer = 0;
+	b->yy_input_file = 0;
+	b->yy_n_chars = b->yy_buf_size;
+	b->yy_is_interactive = 0;
+	b->yy_at_bol = 1;
+	b->yy_fill_buffer = 0;
+	b->yy_buffer_status = YY_BUFFER_NEW;
+
+	yy_switch_to_buffer( b );
+
+	return b;
+	}
+#endif
+
+
+#ifndef YY_NO_SCAN_STRING
+#ifdef YY_USE_PROTOS
+YY_BUFFER_STATE yy_scan_string( yyconst char *yy_str )
+#else
+YY_BUFFER_STATE yy_scan_string( yy_str )
+yyconst char *yy_str;
+#endif
+	{
+	int len;
+	for ( len = 0; yy_str[len]; ++len )
+		;
+
+	return yy_scan_bytes( yy_str, len );
+	}
+#endif
+
+
+#ifndef YY_NO_SCAN_BYTES
+#ifdef YY_USE_PROTOS
+YY_BUFFER_STATE yy_scan_bytes( yyconst char *bytes, int len )
+#else
+YY_BUFFER_STATE yy_scan_bytes( bytes, len )
+yyconst char *bytes;
+int len;
+#endif
+	{
+	YY_BUFFER_STATE b;
+	char *buf;
+	yy_size_t n;
+	int i;
+
+	/* Get memory for full buffer, including space for trailing EOB's. */
+	n = len + 2;
+	buf = (char *) yy_flex_alloc( n );
+	if ( ! buf )
+		YY_FATAL_ERROR( "out of dynamic memory in yy_scan_bytes()" );
+
+	for ( i = 0; i < len; ++i )
+		buf[i] = bytes[i];
+
+	buf[len] = buf[len+1] = YY_END_OF_BUFFER_CHAR;
+
+	b = yy_scan_buffer( buf, n );
+	if ( ! b )
+		YY_FATAL_ERROR( "bad buffer in yy_scan_bytes()" );
+
+	/* It's okay to grow etc. this buffer, and we should throw it
+	 * away when we're done.
+	 */
+	b->yy_is_our_buffer = 1;
+
+	return b;
+	}
+#endif
+
+
+#ifndef YY_NO_PUSH_STATE
+#ifdef YY_USE_PROTOS
+static void yy_push_state( int new_state )
+#else
+static void yy_push_state( new_state )
+int new_state;
+#endif
+	{
+	if ( yy_start_stack_ptr >= yy_start_stack_depth )
+		{
+		yy_size_t new_size;
+
+		yy_start_stack_depth += YY_START_STACK_INCR;
+		new_size = yy_start_stack_depth * sizeof( int );
+
+		if ( ! yy_start_stack )
+			yy_start_stack = (int *) yy_flex_alloc( new_size );
+
+		else
+			yy_start_stack = (int *) yy_flex_realloc(
+					(void *) yy_start_stack, new_size );
+
+		if ( ! yy_start_stack )
+			YY_FATAL_ERROR(
+			"out of memory expanding start-condition stack" );
+		}
+
+	yy_start_stack[yy_start_stack_ptr++] = YY_START;
+
+	BEGIN(new_state);
+	}
+#endif
+
+
+#ifndef YY_NO_POP_STATE
+static void yy_pop_state()
+	{
+	if ( --yy_start_stack_ptr < 0 )
+		YY_FATAL_ERROR( "start-condition stack underflow" );
+
+	BEGIN(yy_start_stack[yy_start_stack_ptr]);
+	}
+#endif
+
+
+#ifndef YY_NO_TOP_STATE
+static int yy_top_state()
+	{
+	return yy_start_stack[yy_start_stack_ptr - 1];
+	}
+#endif
+
+#ifndef YY_EXIT_FAILURE
+#define YY_EXIT_FAILURE 2
+#endif
+
+#ifdef YY_USE_PROTOS
+static void yy_fatal_error( yyconst char msg[] )
+#else
+static void yy_fatal_error( msg )
+char msg[];
+#endif
+	{
+	(void) fprintf( stderr, "%s\n", msg );
+	exit( YY_EXIT_FAILURE );
+	}
+
+
+
+/* Redefine yyless() so it works in section 3 code. */
+
+#undef yyless
+#define yyless(n) \
+	do \
+		{ \
+		/* Undo effects of setting up yytext. */ \
+		yytext[yyleng] = yy_hold_char; \
+		yy_c_buf_p = yytext + n; \
+		yy_hold_char = *yy_c_buf_p; \
+		*yy_c_buf_p = '\0'; \
+		yyleng = n; \
+		} \
+	while ( 0 )
+
+
+/* Internal utility routines. */
+
+#ifndef yytext_ptr
+#ifdef YY_USE_PROTOS
+static void yy_flex_strncpy( char *s1, yyconst char *s2, int n )
+#else
+static void yy_flex_strncpy( s1, s2, n )
+char *s1;
+yyconst char *s2;
+int n;
+#endif
+	{
+	register int i;
+	for ( i = 0; i < n; ++i )
+		s1[i] = s2[i];
+	}
+#endif
+
+#ifdef YY_NEED_STRLEN
+#ifdef YY_USE_PROTOS
+static int yy_flex_strlen( yyconst char *s )
+#else
+static int yy_flex_strlen( s )
+yyconst char *s;
+#endif
+	{
+	register int n;
+	for ( n = 0; s[n]; ++n )
+		;
+
+	return n;
+	}
+#endif
+
+
+#ifdef YY_USE_PROTOS
+static void *yy_flex_alloc( yy_size_t size )
+#else
+static void *yy_flex_alloc( size )
+yy_size_t size;
+#endif
+	{
+	return (void *) malloc( size );
+	}
+
+#ifdef YY_USE_PROTOS
+static void *yy_flex_realloc( void *ptr, yy_size_t size )
+#else
+static void *yy_flex_realloc( ptr, size )
+void *ptr;
+yy_size_t size;
+#endif
+	{
+	/* The cast to (char *) in the following accommodates both
+	 * implementations that use char* generic pointers, and those
+	 * that use void* generic pointers.  It works with the latter
+	 * because both ANSI C and C++ allow castless assignment from
+	 * any pointer type to void*, and deal with argument conversions
+	 * as though doing an assignment.
+	 */
+	return (void *) realloc( (char *) ptr, size );
+	}
+
+#ifdef YY_USE_PROTOS
+static void yy_flex_free( void *ptr )
+#else
+static void yy_flex_free( ptr )
+void *ptr;
+#endif
+	{
+	free( ptr );
+	}
+
+#if YY_MAIN
+int main()
+	{
+	yylex();
+	return 0;
+	}
+#endif
+#line 114 "spp.ll"
+
+
+
+int yywrap()
+{
+  return 1;
+}
+
+
+void showVersion()
+{
+  printf("SOM Preprocessor v1.0\n");
+}
+
+void showUsage()
+{
+}
+
+int main(int argc, char *argv[])
+{
+  if (argc)
+  {
+    if (!strcmp(argv[1], "-V")) showVersion();
+  }
+  else
+  {
+    showUsage();
+    return 0;
+  }
+
+  yyin=fopen(argv[1],"r");
+
+  include_stack[include_stack_ptr].filename=strdup(argv[1]);
+  include_stack[include_stack_ptr].lineno=1;
+
+  yylex();
+
+  return 0;
+}
diff -urN somfree\spp\src\spp.ll newsomfree3\spp\src\spp.ll
--- somfree\spp\src\spp.ll	Thu Jan 01 07:00:00 1970
+++ newsomfree3\spp\src\spp.ll	Sat Mar 16 14:09:29 2024
@@ -0,0 +1,152 @@
+/**************************************************************************
+ *
+ *  Copyright 2022, Yuri Prokushev
+ *
+ *  This file is part of osFree project
+ *
+ *  This program is free software: you can redistribute it and/or modify it
+ *  under the terms of the GNU Lesser General Public License as published by the
+ *  Free Software Foundation, either version 3 of the License, or (at your
+ *  option) any later version.
+ * 
+ *  This program is distributed in the hope that it will be useful, but WITHOUT
+ *  ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ *  FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for
+ *  more details.
+ *
+ *  You should have received a copy of the GNU Lesser General Public License
+ *  along with this program.  If not, see <http://www.gnu.org/licenses/>
+ *
+ */
+
+/*
+
+  SOM Preprocessor SPP is a original SOM Preprocessor of OIDL files.
+  Tested on all csc/sc files found by me. Not sure it will work as
+  drop-in replacement of original SPP.
+
+  @todo Add passthrow section skip
+  @todo Add loop include control.
+*/
+
+/* the "incl" state is used for picking up the name
+ * of an include file
+ */
+%x incl
+
+%{
+#include <stdlib.h>
+#include <string.h>
+#include <direct.h>
+#include <io.h>
+
+#include <emitlib.h>
+
+#define YY_NEVER_INTERACTIVE 1
+
+#define MAX_INCLUDE_DEPTH 20
+struct {
+  YY_BUFFER_STATE state;
+  char * filename;
+  int lineno;
+} include_stack[MAX_INCLUDE_DEPTH];
+int include_stack_ptr = 0;
+%}
+
+%%
+^#include	{ BEGIN(incl); }
+^"include "	{ BEGIN(incl); }
+
+[a-z]+		{ ECHO; }
+[^a-z\n]*\n?	{ ECHO; include_stack[include_stack_ptr].lineno++; }
+
+<incl>[ \t]*	{ /* eat the whitespace */ }
+<incl>[^ \t\n]+	{ /* got the include file name */
+		if (include_stack_ptr >= MAX_INCLUDE_DEPTH)
+		{
+                  fprintf(stderr, "Includes nested too deeply");
+		  exit( 1 );
+		}
+
+		include_stack[include_stack_ptr].state = YY_CURRENT_BUFFER;
+
+		include_stack_ptr++;
+
+		include_stack[include_stack_ptr].filename=strdup(yytext+1);
+		include_stack[include_stack_ptr].filename[strlen(include_stack[include_stack_ptr].filename)-1]=0x0;
+		if (yytext[0]=='<')
+		{
+		  char fullpath[260];
+		  somtsearchFileSL(include_stack[include_stack_ptr].filename, fullpath, "SMINCLUDE");
+		  free(include_stack[include_stack_ptr].filename);
+		  include_stack[include_stack_ptr].filename=strdup(fullpath);
+		}
+
+		yyin = fopen(include_stack[include_stack_ptr].filename, "r");
+
+		if (!yyin)
+		{
+		  fprintf(stderr, "fopen %s error", include_stack[include_stack_ptr].filename);
+		  exit(1);
+		}
+
+		fprintf(yyout, "#line 1 \"%s\"\n", include_stack[include_stack_ptr].filename);
+		yy_switch_to_buffer(yy_create_buffer(yyin, YY_BUF_SIZE));
+
+		BEGIN(INITIAL);
+	   }
+
+<<EOF>> {
+	   if (	--include_stack_ptr < 0	)
+	       {
+	       yyterminate();
+	       }
+
+	   else
+	       {
+		yy_delete_buffer( YY_CURRENT_BUFFER );
+		yy_switch_to_buffer(include_stack[include_stack_ptr].state);
+		fprintf(yyout, "#line %d \"%s\"\n", include_stack[include_stack_ptr].lineno, include_stack[include_stack_ptr].filename);
+	       }
+
+	   }
+
+%%
+
+
+int yywrap()
+{
+  return 1;
+}
+
+
+void showVersion()
+{
+  printf("SOM Preprocessor v1.0\n");
+}
+
+void showUsage()
+{
+}
+
+int main(int argc, char *argv[])
+{
+  if (argc)
+  {
+    if (!strcmp(argv[1], "-V")) showVersion();
+  }
+  else
+  {
+    showUsage();
+    return 0;
+  }
+
+  yyin=fopen(argv[1],"r");
+
+  include_stack[include_stack_ptr].filename=strdup(argv[1]);
+  include_stack[include_stack_ptr].lineno=1;
+
+  yylex();
+
+  return 0;
+}
diff -urN somfree\spp\src\student.sc newsomfree3\spp\src\student.sc
--- somfree\spp\src\student.sc	Thu Jan 01 07:00:00 1970
+++ newsomfree3\spp\src\student.sc	Sat Mar 16 14:09:29 2024
@@ -0,0 +1,28 @@
+include <somobj.sc>
+
+class:
+    Student;
+
+-- "Student" class provides a base class to generate more specialized
+-- students like "GraduateStudent" and "UnderGraduateStudent"
+
+parent:
+    SOMObject;
+
+data:
+    char id[16];    /* student id */
+    char name[32];  /* student name */
+
+methods:
+
+    void setUpStudent(char *id, char *name);
+    -- sets up a new student
+
+    void printStudentInfo();
+    -- prints the student information
+
+    char *getStudentType();
+    -- returns the student type
+
+    char *getStudentId();
+    -- returns the student ID
diff -urN somfree\spp\win32\link386.c newsomfree3\spp\win32\link386.c
--- somfree\spp\win32\link386.c	Thu Jan 01 07:00:00 1970
+++ newsomfree3\spp\win32\link386.c	Sat Mar 16 14:09:29 2024
@@ -0,0 +1,25 @@
+/**************************************************************************
+ *
+ *  Copyright 2008, Roger Brown
+ *
+ *  This file is part of Roger Brown's Toolkit.
+ *
+ *  This program is free software: you can redistribute it and/or modify it
+ *  under the terms of the GNU Lesser General Public License as published by the
+ *  Free Software Foundation, either version 3 of the License, or (at your
+ *  option) any later version.
+ * 
+ *  This program is distributed in the hope that it will be useful, but WITHOUT
+ *  ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ *  FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for
+ *  more details.
+ *
+ *  You should have received a copy of the GNU Lesser General Public License
+ *  along with this program.  If not, see <http://www.gnu.org/licenses/>
+ *
+ */
+
+#define LINK386_SOM
+#define LINK386_SOMC
+
+#include <link386.h>
diff -urN somfree\spp\win32\spp.def newsomfree3\spp\win32\spp.def
--- somfree\spp\win32\spp.def	Thu Jan 01 07:00:00 1970
+++ newsomfree3\spp\win32\spp.def	Sat Mar 16 14:09:29 2024
@@ -0,0 +1,2 @@
+NAME	SPP
+VERSION	1.0
diff -urN somfree\spp\win32\spp.mak newsomfree3\spp\win32\spp.mak
--- somfree\spp\win32\spp.mak	Thu Jan 01 07:00:00 1970
+++ newsomfree3\spp\win32\spp.mak	Sat Mar 16 14:09:29 2024
@@ -0,0 +1,68 @@
+#
+#  Copyright 2022, Yuri Prokushev
+#
+#  This file is part of osFree project
+#
+#  This program is free software: you can redistribute it and/or modify it
+#  under the terms of the GNU Lesser General Public License as published by the
+#  Free Software Foundation, either version 3 of the License, or (at your
+#  option) any later version.
+# 
+#  This program is distributed in the hope that it will be useful, but WITHOUT
+#  ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+#  FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for
+#  more details.
+#
+#  You should have received a copy of the GNU Lesser General Public License
+#  along with this program.  If not, see <http://www.gnu.org/licenses/>
+#
+
+!include $(MAKEDEFS)
+
+OUTDIR=$(OUTDIR_BIN)
+INTDIR=$(BUILDTYPE)
+
+APPNAME=spp
+
+OBJS=$(INTDIR)\$(APPNAME).obj $(INTDIR)\link386.obj
+
+TARGET_EXE=$(OUTDIR)\$(APPNAME).exe
+TARGET_PDB=$(OUTDIR)\$(APPNAME).pdb
+
+PARTOPTS=	$(STDOPT)						\
+			/DHAVE_CONFIG_H					\
+			/D_CONSOLE						\
+			/DWIN32_LEAN_AND_MEAN			\
+			/I..\..\include\$(PLATFORM)		\
+			/I..\..\include\$(PLATFORM_DEF)			\
+			/I..\..\include					\
+			/I..\..\somidl\$(PLATFORM)				\
+			/I..\..\somc\include					\
+			/I..\..\somkpub\include					\
+			$(CC_OUT_PDB)$(TARGET_PDB)		
+
+all: $(TARGET_EXE)
+
+clean:
+	$(CLEAN) $(TARGET_EXE) $(TARGET_PDB) $(OBJS) $(OUTDIR)\$(APPNAME).exp $(OUTDIR)\$(APPNAME).lib $(INTDIR)\$(APPNAME).res
+	
+$(TARGET_EXE): $(OBJS) $(OUTDIR) $(INTDIR)\$(APPNAME).res
+	$(CC) $(CC_OUT_EXE)$@ $(OBJS) $(CC_OUT_PDB)$(TARGET_PDB) $(CC_LINK) $(LD_SUBSYSTEM_CONSOLE) $(LDFLAGS) $(INTDIR)\$(APPNAME).res
+	$(POSTLINK_EXE) $@
+
+$(INTDIR)\$(APPNAME).obj: ..\src\$(APPNAME).c $(INTDIR)
+	$(CC) /c $(PARTOPTS) $(CC_OUT_OBJ)$@ ..\src\$(APPNAME).c
+
+$(INTDIR)\link386.obj: ..\win32\link386.c $(INTDIR)
+	$(CC) /c $(PARTOPTS) $(CC_OUT_OBJ)$@ ..\win32\link386.c
+
+$(INTDIR):
+	mkdir $@
+
+$(INTDIR)\$(APPNAME).res: ..\win32\$(APPNAME).rc
+	rc /nologo $(RCFLAGS) /r /I.. /I..\..\include\$(PLATFORM) /fo$@ ..\win32\$(APPNAME).rc
+
+dist:
+
+
+test:
diff -urN somfree\spp\win32\spp.rc newsomfree3\spp\win32\spp.rc
--- somfree\spp\win32\spp.rc	Thu Jan 01 07:00:00 1970
+++ newsomfree3\spp\win32\spp.rc	Sat Mar 16 14:09:29 2024
@@ -0,0 +1,58 @@
+/**************************************************************************
+ *
+ *  Copyright 2022, Yuri Prokushev
+ *
+ *  This file is part of osFree project
+ *
+ *  This program is free software: you can redistribute it and/or modify it
+ *  under the terms of the GNU Lesser General Public License as published by the
+ *  Free Software Foundation, either version 3 of the License, or (at your
+ *  option) any later version.
+ * 
+ *  This program is distributed in the hope that it will be useful, but WITHOUT
+ *  ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ *  FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for
+ *  more details.
+ *
+ *  You should have received a copy of the GNU Lesser General Public License
+ *  along with this program.  If not, see <http://www.gnu.org/licenses/>
+ *
+ */
+
+#include "windows.h"
+#include <depvers.h>
+
+1 VERSIONINFO
+ FILEVERSION DEPVERS_spp_INT4
+ PRODUCTVERSION DEPVERS_somtkpkg_INT4
+ FILEFLAGSMASK 0x3fL
+#ifdef _DEBUG
+ FILEFLAGS VS_FF_DEBUG|VS_FF_PRERELEASE
+#else
+ FILEFLAGS VS_FF_PRERELEASE
+#endif
+ FILEOS VOS_NT_WINDOWS32
+ FILETYPE VFT_APP
+ FILESUBTYPE 0x0L
+BEGIN
+    BLOCK "StringFileInfo"
+    BEGIN
+        BLOCK "140904e4" // New Zealand
+        BEGIN
+            VALUE "Comments", "SPP\0"
+            VALUE "CompanyName", "Yuri Prokushev\0"
+            VALUE "FileDescription", "SPP\0"
+            VALUE "FileVersion", DEPVERS_spp_STR4
+            VALUE "InternalName", "spp\0"
+            VALUE "LegalCopyright", "й Yuri Prokushev. 2020\0"
+            VALUE "OriginalFilename", "SPP.EXE\0"
+            VALUE "ProductName", DEPVERS_somtkpkg_PRODUCTNAME
+            VALUE "ProductVersion", DEPVERS_somtkpkg_STR4
+        END
+    END
+    BLOCK "VarFileInfo"
+    BEGIN
+        VALUE "Translation", 0x1409, 1252
+    END
+END
+
