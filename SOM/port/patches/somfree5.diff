diff -urN somfree/sc/src/sc.c newsomfree/sc/src/sc.c
--- somfree/sc/src/sc.c	2024-07-09 11:20:22.000000000 +0800
+++ newsomfree/sc/src/sc.c	2024-07-09 09:50:30.000000000 +0800
@@ -10,7 +10,7 @@
  *  under the terms of the GNU Lesser General Public License as published by the
  *  Free Software Foundation, either version 3 of the License, or (at your
  *  option) any later version.
- * 
+ *
  *  This program is distributed in the hope that it will be useful, but WITHOUT
  *  ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  *  FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for
@@ -50,188 +50,194 @@
 #include <windows.h>
 #endif
 
+#ifdef __OS2__
+#define INCL_DOSPROCESS
+#define INCL_DOSMODULEMGR
+#include <os2.h>
+#endif
+
 //#define _USE_PIPES_
 
-typedef struct 
+typedef struct
 {
-	size_t _length,_maximum;
-	char *_buffer;
+        size_t _length,_maximum;
+        char *_buffer;
 } _IDL_SEQUENCE_char;
 
 static int has_spaces(const char *p,size_t len)
 {
-	while (len--)
-	{
-		char c=*p++;
+        while (len--)
+        {
+                char c=*p++;
 
-		if ((c=='\t')||(c==' ')) return 1;
-	}
+                if ((c=='\t')||(c==' ')) return 1;
+        }
 
-	return 0;
+        return 0;
 }
 
 static void add_seq(_IDL_SEQUENCE_char *seq,_IDL_SEQUENCE_char *more)
 {
-	if (more->_length)
-	{
-		size_t len=more->_length+seq->_length;
-
-		if (len > seq->_maximum)
-		{
-			seq->_maximum=len+512;
-			seq->_buffer=realloc(seq->_buffer,seq->_maximum);
-		}
-
-		memcpy(seq->_buffer+seq->_length,more->_buffer,more->_length);
-		seq->_length+=more->_length;
-	}
+        if (more->_length)
+        {
+                size_t len=more->_length+seq->_length;
+
+                if (len > seq->_maximum)
+                {
+                        seq->_maximum=len+512;
+                        seq->_buffer=realloc(seq->_buffer,seq->_maximum);
+                }
+
+                memcpy(seq->_buffer+seq->_length,more->_buffer,more->_length);
+                seq->_length+=more->_length;
+        }
 }
 
 static void add_str(_IDL_SEQUENCE_char *seq,char *p)
 {
-	_IDL_SEQUENCE_char data={0,0,NULL};
-	data._buffer=p;
-	data._length=strlen(p);
-	data._maximum=data._length;
-	add_seq(seq,&data);
+        _IDL_SEQUENCE_char data={0,0,NULL};
+        data._buffer=p;
+        data._length=strlen(p);
+        data._maximum=data._length;
+        add_seq(seq,&data);
 }
 
 typedef struct item
 {
-	struct item *next;
-	_IDL_SEQUENCE_char data;
+        struct item *next;
+        _IDL_SEQUENCE_char data;
 } item;
 
 static item *itemNew(char *data,size_t len)
 {
-	item *p=calloc(1,sizeof(*p));
-	_IDL_SEQUENCE_char d={0,0,NULL};
-	d._buffer=data;
-	d._length=len;
-	add_seq(&p->data,&d);
-	return p;
+        item *p=calloc(1,sizeof(*p));
+        _IDL_SEQUENCE_char d={0,0,NULL};
+        d._buffer=data;
+        d._length=len;
+        add_seq(&p->data,&d);
+        return p;
 }
 
 static void add_many(item **h,char *p)
 {
-	if (!p)
-	{
-		fprintf(stderr,"%s:%d, NULL arg in addmany()\n",__FILE__,__LINE__);
+        if (!p)
+        {
+                fprintf(stderr,"%s:%d, NULL arg in addmany()\n",__FILE__,__LINE__);
 
 #ifdef _M_IX86
-		__asm int 3
+                __asm int 3
 #else
-		exit(1);
+                exit(1);
 #endif
-		return;
-	}
+                return;
+        }
 
-	while (*p)
-	{
-		unsigned long len=0;
-		
-		while (p[len])
-		{
-			if (p[len]==
+        while (*p)
+        {
+                unsigned long len=0;
+
+                while (p[len])
+                {
+                        if (p[len]==
 #if defined(_WIN32) || defined(__OS2__) || defined(__DOS__)
-				';'
+                                ';'
 #else
-				':'
+                                ':'
 #endif
-				)
-			{
-				break;
-			}
-			len++;
-		}
-
-		if (len)
-		{
-			item *t=itemNew(p,len);
-
-			if (*h)
-			{
-				item *p=*h;
-				while (p->next) p=p->next;
-				p->next=t;
-			}
-			else
-			{
-				*h=t;
-			}
+                                )
+                        {
+                                break;
+                        }
+                        len++;
+                }
+
+                if (len)
+                {
+                        item *t=itemNew(p,len);
+
+                        if (*h)
+                        {
+                                item *p=*h;
+                                while (p->next) p=p->next;
+                                p->next=t;
+                        }
+                        else
+                        {
+                                *h=t;
+                        }
 
-			p+=len;
-		}
+                        p+=len;
+                }
 
-		if (*p) p++;
-	}
+                if (*p) p++;
+        }
 }
 
 #ifdef _USE_PIPES_
 static BOOL shareable(HANDLE *ph)
 {
-	return DuplicateHandle(
-		GetCurrentProcess(),
-		*ph,
-		GetCurrentProcess(),
-		ph,
-		0,
-		TRUE,
-		DUPLICATE_SAME_ACCESS|DUPLICATE_CLOSE_SOURCE);
+        return DuplicateHandle(
+                GetCurrentProcess(),
+                *ph,
+                GetCurrentProcess(),
+                ph,
+                0,
+                TRUE,
+                DUPLICATE_SAME_ACCESS|DUPLICATE_CLOSE_SOURCE);
 }
 #endif
 
 static int load_somir(const char *app,const char *f)
 {
-	int retVal=1;
+        int retVal=1;
 #ifdef _WIN32
-	HMODULE hMod=GetModuleHandle(NULL);
-	if (hMod)
-	{
-		HRSRC info=FindResource(hMod,"som.ir","SC");
-		if (info)
-		{
-			DWORD dw=SizeofResource(hMod,info);
-
-			if (dw)
-			{
-				HGLOBAL res=LoadResource(hMod,info);
-				if (res)
-				{
-					LPVOID lp=LockResource(res);
-
-					if (lp)
-					{
-						HANDLE fd=CreateFile(f,
-							GENERIC_WRITE,0,NULL,
-							CREATE_NEW,
-							FILE_ATTRIBUTE_NORMAL,
-							NULL);
-
-						if (fd!=INVALID_HANDLE_VALUE)
-						{
-							DWORD dw2;
-
-							if (WriteFile(fd,lp,dw,&dw2,NULL))
-							{
-								retVal=0;
-							}
-
-							CloseHandle(fd);
-						}
-					}
-				}
-			}
-		}
-	}
-
-	if (retVal)
-	{
-		fprintf(stderr,"%s: failed to create \"%s\"\n",app,f);
-	}
+        HMODULE hMod=GetModuleHandle(NULL);
+        if (hMod)
+        {
+                HRSRC info=FindResource(hMod,"som.ir","SC");
+                if (info)
+                {
+                        DWORD dw=SizeofResource(hMod,info);
+
+                        if (dw)
+                        {
+                                HGLOBAL res=LoadResource(hMod,info);
+                                if (res)
+                                {
+                                        LPVOID lp=LockResource(res);
+
+                                        if (lp)
+                                        {
+                                                HANDLE fd=CreateFile(f,
+                                                        GENERIC_WRITE,0,NULL,
+                                                        CREATE_NEW,
+                                                        FILE_ATTRIBUTE_NORMAL,
+                                                        NULL);
+
+                                                if (fd!=INVALID_HANDLE_VALUE)
+                                                {
+                                                        DWORD dw2;
+
+                                                        if (WriteFile(fd,lp,dw,&dw2,NULL))
+                                                        {
+                                                                retVal=0;
+                                                        }
+
+                                                        CloseHandle(fd);
+                                                }
+                                        }
+                                }
+                        }
+                }
+        }
+
+        if (retVal)
+        {
+                fprintf(stderr,"%s: failed to create \"%s\"\n",app,f);
+        }
 #else
 #endif
-	return retVal;
+        return retVal;
 }
 
 /*
@@ -303,711 +309,726 @@
 
 int main(int argc,char **argv)
 {
-	item *emitters=NULL;
-	item *idls=NULL;
-	char *outputDir=NULL;
-	item *includes=NULL;
-	item *defines=NULL;
-	item *undefines=NULL;
-	item *modifiers=NULL;
-	int i=1;
-	int update=0;
-	int verbose=1;
-	int warnings=0;
-	int releaseorder=0;
-	int nocomments=1;
-	int showpercent=0;
-	char *app=argv[0];
-	static _IDL_SEQUENCE_char zero={1,1,""};
+        item *emitters=NULL;
+        item *idls=NULL;
+        char *outputDir=NULL;
+        item *includes=NULL;
+        item *defines=NULL;
+        item *undefines=NULL;
+        item *modifiers=NULL;
+        int i=1;
+        int update=0;
+        int verbose=1;
+        int warnings=0;
+        int releaseorder=0;
+        int nocomments=1;
+        int showpercent=0;
+        char *app=argv[0];
+        static _IDL_SEQUENCE_char zero={1,1,""};
 
-	add_many(&defines,"__SOMIDL__");
+        add_many(&defines,"__SOMIDL__");
 
 #ifdef _PLATFORM_WIN32_
-	add_many(&defines,"_PLATFORM_WIN32_");
-	add_many(&defines,"_WIN32");
+        add_many(&defines,"_PLATFORM_WIN32_");
+        add_many(&defines,"_WIN32");
 #endif
 
 #ifdef _PLATFORM_UNIX_
-	add_many(&defines,"_PLATFORM_UNIX_");
+        add_many(&defines,"_PLATFORM_UNIX_");
 #endif
 
 #ifdef _PLATFORM_X11_
-	add_many(&defines,"_PLATFORM_X11_");
+        add_many(&defines,"_PLATFORM_X11_");
 #endif
 
-	add_many(&defines,"__SOMIDL_VERSION_1__");
+        add_many(&defines,"__SOMIDL_VERSION_1__");
 
-	while (i < argc)
-	{
-		char *p=argv[i++];
+        while (i < argc)
+        {
+                char *p=argv[i++];
 
-		if ((*p=='-')
+                if ((*p=='-')
 #ifdef _WIN32
-			||(*p=='/')
+                        ||(*p=='/')
 #endif
-			)
-		{
-			switch (p[1])
-			{
-			case 'p': // Alias for -D__PRIVATE__
-				add_many(&defines,"__PRIVATE__");
-				break;
-			case 'E': // Set environment variable
-				if (p[2])
-				{
-					setenv(p+2,"1",1);
-				}
-				else
-				{
-					setenv(argv[i++],"1",1);
-				}
-				break;
-			case 'D': // DEFINE
-				if (p[2])
-				{
-					add_many(&defines,p+2);
-				}
-				else
-				{
-					add_many(&defines,argv[i++]);
-				}
-				break;
-			case 'U': // UNDEFINE
-				if (p[2])
-				{
-					add_many(&undefines,p+2);
-				}
-				else
-				{
-					add_many(&undefines,argv[i++]);
-				}
-				break;
-			case 'a': // Undocumented. Same as -m. Comes from SOM 1.0 Compiler and was named as global attribute.
-			case 'm': // Global modifier
-				if (p[2])
-				{
-					add_many(&modifiers,p+2);
-				}
-				else
-				{
-					add_many(&modifiers,argv[i++]);
-				}
-				break;
-			case 'I': // Includes
-				if (p[2])
-				{
-					add_many(&includes,p+2);
-				}
-				else
-				{
-					add_many(&includes,argv[i++]);
-				}
-				break;
-			case 's': // Emitters list
-			case 'e': // Seems to be this option used by original SOM Compiler for another tasks
-				if (p[2])
-				{
-					add_many(&emitters,p+2);
-				}
-				else
-				{
-					add_many(&emitters,argv[i++]);
-				}
-				break;
-			case 'd': // Output directory
-			case 'o': // Output directory
-				if (outputDir)
-				{
-					fprintf(stderr,"%s: output dir already set\n",app);
-					return 1;
-				}
-				if (p[2])
-				{
-					outputDir=p+2;
-				}
-				else
-				{
-					outputDir=argv[i++];
-				}
-				break;
-			case 'u': // update IR
-				update=1;
-				add_many(&emitters,"ir");
-				add_many(&modifiers,"updateir");
-				break;
-			case 'h': // Help
-			case 'H': // Help
-			case '?': // Help
-				usage();
-				return 0;
-			case 'q': // unknown. Seems to be passed to somipc
-				break;
-			case 0x01: // Easter egg. Info about authors
-				printf("somFree Compiler\n");
-				break;
-			case 'C': // comment buffer //ignored
-				break;
-			case 'S': // string buffer //ignored
-				break;
-			case 'v': // verbose mode
-				verbose=1;
-				break;
-			case 'w': // show warnings
-				warnings=1;
-				break;
-			case '%': // show percent
-				showpercent=1;
-				break;
-			case 'c': // ignore all comments
-				nocomments=1;
-				break;
-			case 'r': // check releaseorder
-				releaseorder=1;
-				break;
-			case 'V':
-				printf("somFree Compiler: 'sc', Version: 1.00.\n");
-				printf("Copyright 2008, Roger Brown\n");
-				printf("Copyright 2022, Yuri Prokushev\n");
-				printf("This file is part of Roger Brown's Toolkit.\n");
-				printf("This file is part of osFree project.\n");
-				printf("Date Last Compiled: [" __DATE__ "]\n");
-				return 0;
-			case 'i':
-/*				item *t=itemNew(p,strlen(p));
-				if (idls)
-				{
-					item *p=idls;
-					while (p->next) p=p->next;
-					p->next=t;
-				}
-				else
-				{
-					idls=t;
-				}*/
-				break;
-			default:
-				fprintf(stderr,"%s: unknown switch - \"%s\"\n",app,p);
-				usage();
-				return 1;
-			}
-		}
-		else
-		{
-			item *t=itemNew(p,strlen(p));
-			if (idls)
-			{
-				item *p=idls;
-				while (p->next) p=p->next;
-				p->next=t;
-			}
-			else
-			{
-				idls=t;
-			}
-		}
-	}
-
-	if (!emitters)
-	{
-		char *p=getenv("SMEMIT");
-
-		if (!p)
-		{
-			p="h;ih";
-		}
-
-		add_many(&emitters,p);
-	}
-
-	{
-		char *p=getenv("SMINCLUDE");
-
-		if (p)
-		{
-			add_many(&includes,p);
-		}
-	}
-
-	if (idls)
-	{
-		item *idl=idls;
-
-		while (idl)
-		{
-			item *emitter=emitters;
-
-			while (emitter)
-			{
-				_IDL_SEQUENCE_char somcpp={0,0,NULL};	// SOM IDL Pre-Processor
-				_IDL_SEQUENCE_char somipc={0,0,NULL};	// SOM IDL Compiler (no Emitter Framework)
-				_IDL_SEQUENCE_char somipc2={0,0,NULL};	// SOM IDL Compiler (Emitter Framework) 
-				_IDL_SEQUENCE_char spp={0,0,NULL};	// SOM OIDL Pre-Processor
-				_IDL_SEQUENCE_char somopc={0,0,NULL};	// SOM OIDL Compiler (CSC to IDL converter)
-				_IDL_SEQUENCE_char idlname={0,0,NULL};	// IDL FQFN
-				char buf[512];
+                        )
+                {
+                        switch (p[1])
+                        {
+                        case 'p': // Alias for -D__PRIVATE__
+                                add_many(&defines,"__PRIVATE__");
+                                break;
+                        case 'E': // Set environment variable
+                                if (p[2])
+                                {
+                                        setenv(p+2,"1",1);
+                                }
+                                else
+                                {
+                                        setenv(argv[i++],"1",1);
+                                }
+                                break;
+                        case 'D': // DEFINE
+                                if (p[2])
+                                {
+                                        add_many(&defines,p+2);
+                                }
+                                else
+                                {
+                                        add_many(&defines,argv[i++]);
+                                }
+                                break;
+                        case 'U': // UNDEFINE
+                                if (p[2])
+                                {
+                                        add_many(&undefines,p+2);
+                                }
+                                else
+                                {
+                                        add_many(&undefines,argv[i++]);
+                                }
+                                break;
+                        case 'a': // Undocumented. Same as -m. Comes from SOM 1.0 Compiler and was named as global attribute.
+                        case 'm': // Global modifier
+                                if (p[2])
+                                {
+                                        add_many(&modifiers,p+2);
+                                }
+                                else
+                                {
+                                        add_many(&modifiers,argv[i++]);
+                                }
+                                break;
+                        case 'I': // Includes
+                                if (p[2])
+                                {
+                                        add_many(&includes,p+2);
+                                }
+                                else
+                                {
+                                        add_many(&includes,argv[i++]);
+                                }
+                                break;
+                        case 's': // Emitters list
+                        case 'e': // Seems to be this option used by original SOM Compiler for another tasks
+                                if (p[2])
+                                {
+                                        add_many(&emitters,p+2);
+                                }
+                                else
+                                {
+                                        add_many(&emitters,argv[i++]);
+                                }
+                                break;
+                        case 'd': // Output directory
+                        case 'o': // Output directory
+                                if (outputDir)
+                                {
+                                        fprintf(stderr,"%s: output dir already set\n",app);
+                                        return 1;
+                                }
+                                if (p[2])
+                                {
+                                        outputDir=p+2;
+                                }
+                                else
+                                {
+                                        outputDir=argv[i++];
+                                }
+                                break;
+                        case 'u': // update IR
+                                update=1;
+                                add_many(&emitters,"ir");
+                                add_many(&modifiers,"updateir");
+                                break;
+                        case 'h': // Help
+                        case 'H': // Help
+                        case '?': // Help
+                                usage();
+                                return 0;
+                        case 'q': // unknown. Seems to be passed to somipc
+                                break;
+                        case 0x01: // Easter egg. Info about authors
+                                printf("somFree Compiler\n");
+                                break;
+                        case 'C': // comment buffer //ignored
+                                break;
+                        case 'S': // string buffer //ignored
+                                break;
+                        case 'v': // verbose mode
+                                verbose=1;
+                                break;
+                        case 'w': // show warnings
+                                warnings=1;
+                                break;
+                        case '%': // show percent
+                                showpercent=1;
+                                break;
+                        case 'c': // ignore all comments
+                                nocomments=1;
+                                break;
+                        case 'r': // check releaseorder
+                                releaseorder=1;
+                                break;
+                        case 'V':
+                                printf("somFree Compiler: 'sc', Version: 1.00.\n");
+                                printf("Copyright 2008, Roger Brown\n");
+                                printf("Copyright 2022, Yuri Prokushev\n");
+                                printf("This file is part of Roger Brown's Toolkit.\n");
+                                printf("This file is part of osFree project.\n");
+                                printf("Date Last Compiled: [" __DATE__ "]\n");
+                                return 0;
+                        case 'i':
+/*                              item *t=itemNew(p,strlen(p));
+                                if (idls)
+                                {
+                                        item *p=idls;
+                                        while (p->next) p=p->next;
+                                        p->next=t;
+                                }
+                                else
+                                {
+                                        idls=t;
+                                }*/
+                                break;
+                        default:
+                                fprintf(stderr,"%s: unknown switch - \"%s\"\n",app,p);
+                                usage();
+                                return 1;
+                        }
+                }
+                else
+                {
+                        item *t=itemNew(p,strlen(p));
+                        if (idls)
+                        {
+                                item *p=idls;
+                                while (p->next) p=p->next;
+                                p->next=t;
+                        }
+                        else
+                        {
+                                idls=t;
+                        }
+                }
+        }
+
+        if (!emitters)
+        {
+                char *p=getenv("SMEMIT");
+
+                if (!p)
+                {
+                        p="h;ih";
+                }
+
+                add_many(&emitters,p);
+        }
+
+        {
+                char *p=getenv("SMINCLUDE");
+
+                if (p)
+                {
+                        add_many(&includes,p);
+                }
+        }
+
+        if (idls)
+        {
+                item *idl=idls;
+
+                while (idl)
+                {
+                        item *emitter=emitters;
+
+                        while (emitter)
+                        {
+                                _IDL_SEQUENCE_char somcpp={0,0,NULL};   // SOM IDL Pre-Processor
+                                _IDL_SEQUENCE_char somipc={0,0,NULL};   // SOM IDL Compiler (no Emitter Framework)
+                                _IDL_SEQUENCE_char somipc2={0,0,NULL};  // SOM IDL Compiler (Emitter Framework)
+                                _IDL_SEQUENCE_char spp={0,0,NULL};      // SOM OIDL Pre-Processor
+                                _IDL_SEQUENCE_char somopc={0,0,NULL};   // SOM OIDL Compiler (CSC to IDL converter)
+                                _IDL_SEQUENCE_char idlname={0,0,NULL};  // IDL FQFN
+                                char buf[512];
+                                item *t;
+                                size_t ul=0,ul2=0;
+                                int appPathSpaces=0;
+                                long len;
 #ifdef _WIN32
-				long len=GetModuleFileName(NULL,buf,sizeof(buf));
+                                len=GetModuleFileName(NULL,buf,sizeof(buf));
+#elif __OS2__
+                                PTIB ptib;
+                                PPIB ppib;
+
+                                if ( !(DosGetInfoBlocks(&ptib, &ppib)) )
+                                   DosQueryModuleName(ppib->pib_hmte, sizeof(buf), buf);
+
+                                len=strlen(buf);
 #else
-				long len=1;
+                                len=1;
 #endif
-				item *t;
-				size_t ul=0,ul2=0;
-				int appPathSpaces=has_spaces(buf,len);
 
-#ifndef _WIN32
-				buf[0]=0x0;
+#if !defined(_WIN32) && !defined(__OS2__)
+                                buf[0]=0x0;
 #endif
 
-				/* get to start of file name */
+                                appPathSpaces=has_spaces(buf,len);
+
+                                /* get to start of file name */
 
-				while (len--)
-				{
-					if (
+                                while (len--)
+                                {
+                                        if (
 #if defined(_WIN32) || defined(__OS2__) || defined(__DOS__)
-						(buf[len]=='/')||
+                                                (buf[len]=='/')||
 #endif
-						(buf[len]=='\\'))
-					{
-						len++;
-						break;
-					}
-				}
-
-				if (appPathSpaces)
-				{
-					add_str(&somipc2,"\"");
-					add_str(&somipc,"\"");
-					add_str(&somcpp,"\"");
-				}
-
-				strncpy(buf+len,"somipc2.exe",sizeof(buf)-len);
-				add_str(&somipc2,buf);
-
-				strncpy(buf+len,"somipc.exe",sizeof(buf)-len);
-				add_str(&somipc,buf);
-
-				strncpy(buf+len,"somcpp.exe",sizeof(buf)-len);
-
-				add_str(&somcpp,buf);
-
-				if (appPathSpaces)
-				{
-					add_str(&somipc2,"\"");
-					add_str(&somipc,"\"");
-					add_str(&somcpp,"\"");
-				}
-
-				ul=idl->data._length;
-
-				while (ul)
-				{
-					ul--;
-
-					if ((idl->data._buffer[ul]=='/')
-						||
-						(idl->data._buffer[ul]=='\\'))
-					{
-						ul++;
-						break;
-					}
-				}
-
-				while ((ul+ul2) < idl->data._length)
-				{
-					if (idl->data._buffer[ul+ul2]=='.')
-					{
-						break;
-					}
-
-					ul2++;
-				}
-
-				if (ul2)
-				{
-					_IDL_SEQUENCE_char d={0,0,NULL};
-					d._length=ul2;
-					d._buffer=idl->data._buffer+ul;
-
-					add_seq(&idlname,&d);
-				}
-
-				t=defines;
-
-				while (t)
-				{
-					add_str(&somcpp," -D");
-					add_seq(&somcpp,&t->data);
-
-					t=t->next;
-				}
-
-				t=undefines;
-
-				while (t)
-				{
-					add_str(&somcpp," -U");
-					add_seq(&somcpp,&t->data);
-
-					t=t->next;
-				}
-
-				t=includes;
-
-				while (t)
-				{
-					int x=has_spaces(t->data._buffer,t->data._length);
-					add_str(&somcpp," ");
-					if (x) add_str(&somcpp,"\"");
-					add_str(&somcpp,"-I");
-					add_seq(&somcpp,&t->data);
-					if (x) add_str(&somcpp,"\"");
-
-					t=t->next;
-				}
-
-				{
-					add_str(&somipc2," -s");
-					add_str(&somipc," -s");
-					add_seq(&somipc2,&emitter->data);
-					add_seq(&somipc,&emitter->data);
-				}
-
-				if (verbose)
-				{
-					add_str(&somipc2," -v ");
-					add_str(&somipc," -v ");
-				}
-
-				if (warnings)
-				{
-					add_str(&somipc2," -w ");
-					add_str(&somipc," -w ");
-				}
-
-				if (releaseorder)
-				{
-					add_str(&somipc2," -r ");
-					add_str(&somipc," -r ");
-				}
-
-				if (nocomments)
-				{
-					add_str(&somipc2," -c ");
-					add_str(&somipc," -c ");
-				} else {
-					add_str(&somcpp," -C ");
-				}
-
-				add_str(&somipc2," -o ");
-				add_str(&somipc," -o ");
-
-				if ((emitter->data._length==2)&&(!memcmp(emitter->data._buffer,"ir",2)))
-				{
-					char *ir=getenv("SOMIR");
-					char *filename;
-
-					if (!ir) 
-					{
-						ir="som.ir";
-						fprintf(stderr,"%s: warning, SOMIR not set, defaulting to \"%s\"\n",app,ir);
-					}
-
-					filename=ir+strlen(ir);
-
-					while (filename > ir)
-					{
-						filename--;
-						if (filename[0]==';') { filename++; break; }
-					}
+                                                (buf[len]=='\\'))
+                                        {
+                                                len++;
+                                                break;
+                                        }
+                                }
+
+                                if (appPathSpaces)
+                                {
+                                        add_str(&somipc2,"\"");
+                                        add_str(&somipc,"\"");
+                                        add_str(&somcpp,"\"");
+                                }
+
+                                strncpy(buf+len,"somipc2.exe",sizeof(buf)-len);
+                                add_str(&somipc2,buf);
+
+                                strncpy(buf+len,"somipc.exe",sizeof(buf)-len);
+                                add_str(&somipc,buf);
+
+                                strncpy(buf+len,"somcpp.exe",sizeof(buf)-len);
+                                add_str(&somcpp,buf);
+
+                                if (appPathSpaces)
+                                {
+                                        add_str(&somipc2,"\"");
+                                        add_str(&somipc,"\"");
+                                        add_str(&somcpp,"\"");
+                                }
+
+                                ul=idl->data._length;
+
+                                while (ul)
+                                {
+                                        ul--;
+
+                                        if ((idl->data._buffer[ul]=='/')
+                                                ||
+                                                (idl->data._buffer[ul]=='\\'))
+                                        {
+                                                ul++;
+                                                break;
+                                        }
+                                }
+
+                                while ((ul+ul2) < idl->data._length)
+                                {
+                                        if (idl->data._buffer[ul+ul2]=='.')
+                                        {
+                                                break;
+                                        }
+
+                                        ul2++;
+                                }
+
+                                if (ul2)
+                                {
+                                        _IDL_SEQUENCE_char d={0,0,NULL};
+                                        d._length=ul2;
+                                        d._buffer=idl->data._buffer+ul;
+
+                                        add_seq(&idlname,&d);
+                                }
+
+                                t=defines;
+
+                                while (t)
+                                {
+                                        add_str(&somcpp," -D");
+                                        add_seq(&somcpp,&t->data);
+
+                                        t=t->next;
+                                }
+
+                                t=undefines;
+
+                                while (t)
+                                {
+                                        add_str(&somcpp," -U");
+                                        add_seq(&somcpp,&t->data);
+
+                                        t=t->next;
+                                }
+
+                                t=includes;
+
+                                while (t)
+                                {
+                                        int x=has_spaces(t->data._buffer,t->data._length);
+                                        add_str(&somcpp," ");
+                                        if (x) add_str(&somcpp,"\"");
+                                        add_str(&somcpp,"-I");
+                                        add_seq(&somcpp,&t->data);
+                                        if (x) add_str(&somcpp,"\"");
+
+                                        t=t->next;
+                                }
+
+                                {
+                                        add_str(&somipc2," -s");
+                                        add_str(&somipc," -s");
+                                        add_seq(&somipc2,&emitter->data);
+                                        add_seq(&somipc,&emitter->data);
+                                }
+
+                                if (verbose)
+                                {
+                                        add_str(&somipc2," -v ");
+                                        add_str(&somipc," -v ");
+                                }
+
+                                if (warnings)
+                                {
+                                        add_str(&somipc2," -w ");
+                                        add_str(&somipc," -w ");
+                                }
+
+                                if (releaseorder)
+                                {
+                                        add_str(&somipc2," -r ");
+                                        add_str(&somipc," -r ");
+                                }
+
+                                if (nocomments)
+                                {
+                                        add_str(&somipc2," -c ");
+                                        add_str(&somipc," -c ");
+                                } else {
+                                        add_str(&somcpp," -C ");
+                                }
+
+                                add_str(&somipc2," -o ");
+                                add_str(&somipc," -o ");
+
+                                if ((emitter->data._length==2)&&(!memcmp(emitter->data._buffer,"ir",2)))
+                                {
+                                        char *ir=getenv("SOMIR");
+                                        char *filename;
+
+                                        if (!ir)
+                                        {
+                                                ir="som.ir";
+                                                fprintf(stderr,"%s: warning, SOMIR not set, defaulting to \"%s\"\n",app,ir);
+                                        }
+
+                                        filename=ir+strlen(ir);
+
+                                        while (filename > ir)
+                                        {
+                                                filename--;
+                                                if (filename[0]==';') { filename++; break; }
+                                        }
 
-/*					fprintf(stderr,"%s: ir output file is \"%s\"\n",app,filename);*/
+/*                                      fprintf(stderr,"%s: ir output file is \"%s\"\n",app,filename);*/
 
 #if 0
-					{
-					long attr;
+                                        {
+                                        long attr;
 
-					attr=GetFileAttributes(filename);
+                                        attr=GetFileAttributes(filename);
 
-					if (attr < 0)
-					{
-						fprintf(stderr,"%s,\"%s\" does not exist\n",app,filename);
-
-						if (load_somir(app,filename))
-						{
-							return 1;
-						}
-					}
-					}
+                                        if (attr < 0)
+                                        {
+                                                fprintf(stderr,"%s,\"%s\" does not exist\n",app,filename);
+
+                                                if (load_somir(app,filename))
+                                                {
+                                                        return 1;
+                                                }
+                                        }
+                                        }
 #else
-					{
-					struct stat   buffer;
+                                        {
+                                        struct stat   buffer;
 
-					if (!(stat(filename, &buffer) == 0))
-					{
-						fprintf(stderr,"%s,\"%s\" does not exist\n",app,filename);
-
-						if (load_somir(app,filename))
-						{
-							return 1;
-						}
-					}
-					}
-#endif
-					add_str(&somipc2,filename);
-					add_str(&somipc,filename);
-					add_str(&somipc2," ");
-					add_str(&somipc," ");
-				}
-				else
-				{
-					if (outputDir)
-					{
-						add_str(&somipc2,outputDir);
-						add_str(&somipc,outputDir);
+                                        if (!(stat(filename, &buffer) == 0))
+                                        {
+                                                fprintf(stderr,"%s,\"%s\" does not exist\n",app,filename);
+
+                                                if (load_somir(app,filename))
+                                                {
+                                                        return 1;
+                                                }
+                                        }
+                                        }
+#endif
+                                        add_str(&somipc2,filename);
+                                        add_str(&somipc,filename);
+                                        add_str(&somipc2," ");
+                                        add_str(&somipc," ");
+                                }
+                                else
+                                {
+                                        if (outputDir)
+                                        {
+                                                add_str(&somipc2,outputDir);
+                                                add_str(&somipc,outputDir);
 #if defined(_WIN32) || defined(__OS2__) || defined(__DOS__)
-						add_str(&somipc2,"\\");
-						add_str(&somipc,"\\");
+                                                add_str(&somipc2,"\\");
+                                                add_str(&somipc,"\\");
 #else
-						add_str(&somipc2,"/");
-						add_str(&somipc,"/");
+                                                add_str(&somipc2,"/");
+                                                add_str(&somipc,"/");
 #endif
-					}
+                                        }
 
-					add_seq(&somipc2,&idlname);
-					add_seq(&somipc,&idlname);
-					add_str(&somipc2,".");
-					add_str(&somipc,".");
-					add_seq(&somipc2,&emitter->data);
-					add_seq(&somipc,&emitter->data);
-				}
-
-				t=modifiers;
-
-				while (t)
-				{
-					add_str(&somipc2," -m ");
-					add_str(&somipc," -m ");
-					add_seq(&somipc2,&t->data);
-					add_seq(&somipc,&t->data);
+                                        add_seq(&somipc2,&idlname);
+                                        add_seq(&somipc,&idlname);
+                                        add_str(&somipc2,".");
+                                        add_str(&somipc,".");
+                                        add_seq(&somipc2,&emitter->data);
+                                        add_seq(&somipc,&emitter->data);
+                                }
+
+                                t=modifiers;
+
+                                while (t)
+                                {
+                                        add_str(&somipc2," -m ");
+                                        add_str(&somipc," -m ");
+                                        add_seq(&somipc2,&t->data);
+                                        add_seq(&somipc,&t->data);
 
-					t=t->next;
-				}
+                                        t=t->next;
+                                }
 
 #ifdef _USE_PIPES_
-				{
-				add_seq(&somcpp,&zero);
-					add_seq(&somipc2,&zero);
-				add_seq(&somipc,&zero);
-					STARTUPINFO cpp_startup,somipc_startup;
-					PROCESS_INFORMATION cpp_pinfo={0,0,0,0},somipc_pinfo={0,0,0,0};
-					BOOL b=TRUE;
-					HANDLE hSource=INVALID_HANDLE_VALUE;
-					DWORD err=0;
-					DWORD cppExitCode=1;
-
-					memset(&cpp_startup,0,sizeof(cpp_startup));
-					memset(&somipc_startup,0,sizeof(somipc_startup));
-
-					cpp_startup.cb=sizeof(cpp_startup);
-					cpp_startup.dwFlags=STARTF_USESTDHANDLES;
-					cpp_startup.hStdInput=GetStdHandle(STD_INPUT_HANDLE);
-					cpp_startup.hStdOutput=GetStdHandle(STD_OUTPUT_HANDLE);
-					cpp_startup.hStdError=GetStdHandle(STD_ERROR_HANDLE);
-
-					somipc_startup.cb=sizeof(somipc_startup);
-					somipc_startup.dwFlags=STARTF_USESTDHANDLES;
-					somipc_startup.hStdInput=GetStdHandle(STD_INPUT_HANDLE);
-					somipc_startup.hStdOutput=GetStdHandle(STD_OUTPUT_HANDLE);
-					somipc_startup.hStdError=GetStdHandle(STD_ERROR_HANDLE);
-
-					b=CreatePipe(&cpp_startup.hStdInput,
-						         &hSource,
-								 NULL,
-								 4096);
-
-					b=CreatePipe(&somipc_startup.hStdInput,
-						         &cpp_startup.hStdOutput,
-								 NULL,
-								 4096);
-
-					b=shareable(&cpp_startup.hStdInput);
-					b=shareable(&cpp_startup.hStdOutput);
-
-					b=CreateProcess(NULL,somcpp._buffer,NULL,NULL,TRUE,0,NULL,NULL,
-								&cpp_startup,&cpp_pinfo);
-
-					if (!b)
-					{
-						err=GetLastError();
-					}
-
-					CloseHandle(cpp_startup.hStdInput);
-					CloseHandle(cpp_startup.hStdOutput);
-
-					if (!b)
-					{
-						CloseHandle(hSource);
-						CloseHandle(somipc_startup.hStdInput);
-
-						fprintf(stderr,"%s: exec(%s) failed\n",app,somcpp._buffer);
-						return 1;
-					}
-
-					b=shareable(&somipc_startup.hStdInput);
-
-					b=CreateProcess(NULL,somipc._buffer,NULL,NULL,TRUE,0,NULL,NULL,
-						&somipc_startup,&somipc_pinfo);
-
-					if (!b)
-					{
-						err=GetLastError();
-					}
-
-					CloseHandle(somipc_startup.hStdInput);
-
-					if (b)
-					{
-						_IDL_SEQUENCE_char source={0,0,NULL};
-						DWORD ul=0;
-
-						add_str(&source,"#include \"");
-						add_seq(&source,&idl->data);
-						add_str(&source,"\"\r\n");
-
-						while (ul < source._length)
-						{
-							if (source._buffer[ul]=='\\')
-							{
-								source._buffer[ul]='/';
-							}
-							ul++;
-						}
-
-/*						WriteFile(GetStdHandle(STD_OUTPUT_HANDLE),
-									source._buffer,source._length,&ul,NULL);*/
-						WriteFile(hSource,source._buffer,(DWORD)source._length,&ul,NULL);
-					}
-
-					CloseHandle(hSource);
-
-					WaitForSingleObject(cpp_pinfo.hProcess,INFINITE);
-					GetExitCodeProcess(cpp_pinfo.hProcess,&cppExitCode);
-					CloseHandle(cpp_pinfo.hProcess);
-					CloseHandle(cpp_pinfo.hThread);
-
-					if (b)
-					{
-						DWORD somipcExitCode=1;
-						WaitForSingleObject(somipc_pinfo.hProcess,INFINITE);
-						GetExitCodeProcess(somipc_pinfo.hProcess,&somipcExitCode);
-						CloseHandle(somipc_pinfo.hProcess);
-						CloseHandle(somipc_pinfo.hThread);
-
-						if (somipcExitCode || cppExitCode)
-						{
-							return cppExitCode ? cppExitCode : somipcExitCode;
-						}
-					}
-					else
-					{
-						fprintf(stderr,"%s: exec(%s) failed\n",app,somipc._buffer);
-
-						return 1;
-					}
-				}
+                                {
+                                add_seq(&somcpp,&zero);
+                                        add_seq(&somipc2,&zero);
+                                add_seq(&somipc,&zero);
+                                        STARTUPINFO cpp_startup,somipc_startup;
+                                        PROCESS_INFORMATION cpp_pinfo={0,0,0,0},somipc_pinfo={0,0,0,0};
+                                        BOOL b=TRUE;
+                                        HANDLE hSource=INVALID_HANDLE_VALUE;
+                                        DWORD err=0;
+                                        DWORD cppExitCode=1;
+
+                                        memset(&cpp_startup,0,sizeof(cpp_startup));
+                                        memset(&somipc_startup,0,sizeof(somipc_startup));
+
+                                        cpp_startup.cb=sizeof(cpp_startup);
+                                        cpp_startup.dwFlags=STARTF_USESTDHANDLES;
+                                        cpp_startup.hStdInput=GetStdHandle(STD_INPUT_HANDLE);
+                                        cpp_startup.hStdOutput=GetStdHandle(STD_OUTPUT_HANDLE);
+                                        cpp_startup.hStdError=GetStdHandle(STD_ERROR_HANDLE);
+
+                                        somipc_startup.cb=sizeof(somipc_startup);
+                                        somipc_startup.dwFlags=STARTF_USESTDHANDLES;
+                                        somipc_startup.hStdInput=GetStdHandle(STD_INPUT_HANDLE);
+                                        somipc_startup.hStdOutput=GetStdHandle(STD_OUTPUT_HANDLE);
+                                        somipc_startup.hStdError=GetStdHandle(STD_ERROR_HANDLE);
+
+                                        b=CreatePipe(&cpp_startup.hStdInput,
+                                                         &hSource,
+                                                                 NULL,
+                                                                 4096);
+
+                                        b=CreatePipe(&somipc_startup.hStdInput,
+                                                         &cpp_startup.hStdOutput,
+                                                                 NULL,
+                                                                 4096);
+
+                                        b=shareable(&cpp_startup.hStdInput);
+                                        b=shareable(&cpp_startup.hStdOutput);
+
+                                        b=CreateProcess(NULL,somcpp._buffer,NULL,NULL,TRUE,0,NULL,NULL,
+                                                                &cpp_startup,&cpp_pinfo);
+
+                                        if (!b)
+                                        {
+                                                err=GetLastError();
+                                        }
+
+                                        CloseHandle(cpp_startup.hStdInput);
+                                        CloseHandle(cpp_startup.hStdOutput);
+
+                                        if (!b)
+                                        {
+                                                CloseHandle(hSource);
+                                                CloseHandle(somipc_startup.hStdInput);
+
+                                                fprintf(stderr,"%s: exec(%s) failed\n",app,somcpp._buffer);
+                                                return 1;
+                                        }
+
+                                        b=shareable(&somipc_startup.hStdInput);
+
+                                        b=CreateProcess(NULL,somipc._buffer,NULL,NULL,TRUE,0,NULL,NULL,
+                                                &somipc_startup,&somipc_pinfo);
+
+                                        if (!b)
+                                        {
+                                                err=GetLastError();
+                                        }
+
+                                        CloseHandle(somipc_startup.hStdInput);
+
+                                        if (b)
+                                        {
+                                                _IDL_SEQUENCE_char source={0,0,NULL};
+                                                DWORD ul=0;
+
+                                                add_str(&source,"#include \"");
+                                                add_seq(&source,&idl->data);
+                                                add_str(&source,"\"\r\n");
+
+                                                while (ul < source._length)
+                                                {
+                                                        if (source._buffer[ul]=='\\')
+                                                        {
+                                                                source._buffer[ul]='/';
+                                                        }
+                                                        ul++;
+                                                }
+
+/*                                              WriteFile(GetStdHandle(STD_OUTPUT_HANDLE),
+                                                                        source._buffer,source._length,&ul,NULL);*/
+                                                WriteFile(hSource,source._buffer,(DWORD)source._length,&ul,NULL);
+                                        }
+
+                                        CloseHandle(hSource);
+
+                                        WaitForSingleObject(cpp_pinfo.hProcess,INFINITE);
+                                        GetExitCodeProcess(cpp_pinfo.hProcess,&cppExitCode);
+                                        CloseHandle(cpp_pinfo.hProcess);
+                                        CloseHandle(cpp_pinfo.hThread);
+
+                                        if (b)
+                                        {
+                                                DWORD somipcExitCode=1;
+                                                WaitForSingleObject(somipc_pinfo.hProcess,INFINITE);
+                                                GetExitCodeProcess(somipc_pinfo.hProcess,&somipcExitCode);
+                                                CloseHandle(somipc_pinfo.hProcess);
+                                                CloseHandle(somipc_pinfo.hThread);
+
+                                                if (somipcExitCode || cppExitCode)
+                                                {
+                                                        return cppExitCode ? cppExitCode : somipcExitCode;
+                                                }
+                                        }
+                                        else
+                                        {
+                                                fprintf(stderr,"%s: exec(%s) failed\n",app,somipc._buffer);
+
+                                                return 1;
+                                        }
+                                }
 #else
-				{
-					char name2[L_tmpnam];
-					int cppExitCode;
-					int somipcExitCode;
-					_IDL_SEQUENCE_char tmpf={0,0,NULL};
-					char *tmpdir = "/tmp";		// Default value for most UNIXes
-
-					tmpnam(name2);
+                                {
+                                        char name2[L_tmpnam];
+                                        int cppExitCode;
+                                        int somipcExitCode;
+                                        _IDL_SEQUENCE_char tmpf={0,0,NULL};
+                                        char *tmpdir = "/tmp";          // Default value for most UNIXes
+#ifdef __OS2__
+                                        struct stat   buffer;
+#endif
+                                        tmpnam(name2);
 #if defined(_WIN32) || defined(__OS2__) || defined(__DOS__)
-					tmpdir = getenv("TMP");
+                                        tmpdir = getenv("TMP");
 #endif
-					add_str(&tmpf, tmpdir);
+                                        add_str(&tmpf, tmpdir);
 #if defined(_WIN32) || defined(__OS2__) || defined(__DOS__)
-					add_str(&tmpf,"\\");
+                                        add_str(&tmpf,"\\");
+#else
+                                        add_str(&tmpf,"/");
+#endif
+                                        add_str(&tmpf,&name2);
+
+                                        add_str(&somcpp," ");
+                                        add_seq(&somcpp,&idl->data);
+                                        add_str(&somcpp," > ");
+                                        add_seq(&somcpp,&tmpf);
+
+                                        add_str(&somipc2," ");
+                                        add_str(&somipc," ");
+                                        add_seq(&somipc2,&tmpf);
+                                        add_seq(&somipc,&tmpf);
+
+                                        add_seq(&somcpp,&zero);
+                                        add_seq(&somipc2,&zero);
+                                        add_seq(&somipc,&zero);
+
+                                        if (verbose)
+                                        {
+                                                add_str(&somipc2," -v ");
+                                                add_str(&somipc," -v ");
+
+                                                printf("Running shell command:\n");
+                                                printf("%s\n",somcpp._buffer);
+                                        }
+
+                                        cppExitCode=system(somcpp._buffer);
+
+#ifndef __OS2__
+
+                                        if (verbose)
+                                        {
+                                                printf("%s\n",somipc2._buffer);
+                                        }
+                                        somipcExitCode=system(somipc2._buffer);
+                                        #ifdef __LINUX__
+                                        if (somipcExitCode==127)
+                                        #endif
+                                        #ifdef _WIN32
+                                        if (somipcExitCode==1)
+                                        #endif
 #else
-					add_str(&tmpf,"/");
+
+                                        if (!(stat(somipc2._buffer, &buffer) == 0))
+#endif
+                                        {
+                                                if (verbose)
+                                                {
+                                                        printf("%s\n",somipc._buffer);
+                                                }
+                                                somipcExitCode=system(somipc._buffer);
+                                        }
+                                        if (verbose)
+                                        {
+                                                if (somipcExitCode)
+                                                {
+                                                        printf("Status: %d\n", somipcExitCode);
+                                                }
+                                        }
+
+                                        unlink(tmpf._buffer);
+                                        if (verbose)
+                                        {
+                                                printf("Removed  \"%s\"\n", tmpf._buffer);
+                                        }
+
+                                        if (somipcExitCode || cppExitCode)
+                                        {
+                                                return cppExitCode ? cppExitCode : somipcExitCode;
+                                        }
+
+                                }
 #endif
-					add_str(&tmpf,&name2);
+                                emitter=emitter->next;
+                        }
 
-					add_str(&somcpp," ");
-					add_seq(&somcpp,&idl->data);
-					add_str(&somcpp," > ");
-					add_seq(&somcpp,&tmpf);
-
-					add_str(&somipc2," ");
-					add_str(&somipc," ");
-					add_seq(&somipc2,&tmpf);
-					add_seq(&somipc,&tmpf);
-
-					add_seq(&somcpp,&zero);
-					add_seq(&somipc2,&zero);
-					add_seq(&somipc,&zero);
-
-					if (verbose)
-					{
-						add_str(&somipc2," -v ");
-						add_str(&somipc," -v ");
-
-						printf("Running shell command:\n");
-						printf("%s\n",somcpp._buffer);
-					}
-
-					cppExitCode=system(somcpp._buffer);
-
-					if (verbose)
-					{
-						printf("%s\n",somipc2._buffer);
-					}
-					somipcExitCode=system(somipc2._buffer);
-					#ifdef __LINUX__
-					if (somipcExitCode==127)
-					#endif
-					#ifdef _WIN32
-					if (somipcExitCode==1)
-					#endif
-					#ifdef __OS2__
-					if (somipcExitCode==1041)
-					#endif
-					{
-						if (verbose)
-						{
-							printf("%s\n",somipc._buffer);
-						}
-						somipcExitCode=system(somipc._buffer);
-					}
-					if (verbose)
-					{
-						if (somipcExitCode)
-						{
-							printf("Status: %d\n", somipcExitCode);
-						}
-					}
-
-					unlink(tmpf._buffer);
-					if (verbose)
-					{
-						printf("Removed  \"%s\"\n", tmpf._buffer);
-					}
-
-					if (somipcExitCode || cppExitCode)
-					{
-						return cppExitCode ? cppExitCode : somipcExitCode;
-					}
-
-				}
-#endif
-				emitter=emitter->next;
-			}
-
-			idl=idl->next;
-		}
-	}
+                        idl=idl->next;
+                }
+        }
 
-	return 0;
+        return 0;
 }
