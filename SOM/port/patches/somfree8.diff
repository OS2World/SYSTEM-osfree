diff -urN somfree-old/sc/src/sc.c somfree/sc/src/sc.c
--- somfree-old/sc/src/sc.c	2024-09-13 06:03:41.214811143 +0300
+++ somfree/sc/src/sc.c	2024-09-13 05:56:58.362026992 +0300
@@ -581,9 +581,9 @@
 				{
 					if (
 #if defined(_WIN32) || defined(__OS2__) || defined(__DOS__)
-						(buf[len]=='/')||
+						(buf[len]=='\\')||
 #endif
-						(buf[len]=='\\'))
+						(buf[len]=='/'))
 					{
 						len++;
 						break;
@@ -597,6 +597,9 @@
 					add_str(&somcpp,"\"");
 				}
 
+
+				if (len < 0) len=0;
+
                                 strncpy(buf+len,"somipc2.exe",sizeof(buf)-len);
                                 add_str(&somipc2,buf);
 
diff -urN somfree-old/somc/include/emitlib.h somfree/somc/include/emitlib.h
--- somfree-old/somc/include/emitlib.h	2024-09-13 06:03:41.198811111 +0300
+++ somfree/somc/include/emitlib.h	2024-09-13 05:56:58.362026992 +0300
@@ -24,7 +24,9 @@
 #ifdef _WIN32
 #include <windows.h>
 #endif
+#ifndef __LINUX__
 #include <io.h>	
+#endif
 #include <stdio.h>
 #include <stdlib.h>
 
diff -urN somfree-old/somc/src/somc.c somfree/somc/src/somc.c
--- somfree-old/somc/src/somc.c	2024-09-13 06:03:41.202811119 +0300
+++ somfree/somc/src/somc.c	2024-09-13 05:56:58.362026992 +0300
@@ -22,7 +22,9 @@
 #define global
 #include <emitlib.h>
 
+#ifndef __LINUX__
 #include <direct.h> // _getcwd
+#endif
 #include <ctype.h> // tolower, toupper
 
 // Use IBM SOM 3.0 ABI for non SOMLINK functions (1) or IBM SOM 2.1 ABI (0)
diff -urN somfree-old/somopc/src/oidl.l somfree/somopc/src/oidl.l
--- somfree-old/somopc/src/oidl.l	2024-09-13 06:03:41.210811136 +0300
+++ somfree/somopc/src/oidl.l	2024-09-13 06:04:33.030915742 +0300
@@ -1,90 +1,90 @@
-%{
-
-#include <stdio.h>  // fopen
-#include <stdlib.h> // malloc, free, realloc
-#include <string.h> // strcat
-
-#include <emitlib.h>
-
-#include "oidl.h"
-
-int trace=1;
-int lineno=1, column=0;
-char comment[16384]; // handle with -C
-char passthru[32768]; // handle with -S
-
-%}
-
-
-%x IN_CPP_COMMENT
-%x IN_PASSTHRU
-
-%%
-
-<INITIAL>{
-  "/*"             {BEGIN(IN_CPP_COMMENT); comment[0]=0x0; }
-  "passthru:"       {BEGIN(IN_PASSTHRU); passthru[0]=0x0;}
-}
-
-<IN_CPP_COMMENT>{
-  "*/"      { BEGIN(INITIAL); yylval.stval=strdup(comment); return T_COMMENT; }
-  [^*\n]+   { strcat(comment, yytext); }
-  "*"       // eat the lone star
-  \n        { strcat(comment, "\n"); lineno++; }
-}
-
-<IN_PASSTHRU>{
-  "endpassthru;"  {BEGIN(INITIAL);}
-  [^\n]+    { strcat(passthru, yytext);}
-  \n        { strcat(passthru, "\n"); lineno++; }
-}
-
-[0-9]+	 	  {if (trace) ECHO; column+=yyleng; yylval.ival=atoi(yytext); return T_CONSTANT;}
-:                 {if (trace) ECHO; column+=yyleng; return T_COLON;            }
-;                 {if (trace) ECHO; column+=yyleng; return T_SEMICOLON;        }
-,                 {if (trace) ECHO; column+=yyleng; return T_COMMA;            }
-=                 {if (trace) ECHO; column+=yyleng; return T_EQUAL;            }
---                {if (trace) ECHO; column+=yyleng; return T_DASHES;           }
-"..."             {if (trace) ECHO; column+=yyleng; return T_ELLIPSIS;         }
-"*"               {if (trace) ECHO; column+=yyleng; yylval.stval=strdup(yytext); return T_STAR; }
-"("               {if (trace) ECHO; column+=yyleng; return T_LEFTPARENTHESIS;  }
-")"               {if (trace) ECHO; column+=yyleng; return T_RIGHTPARENTHESIS; }
-"["               {if (trace) ECHO; column+=yyleng; return T_LEFTSQUAREBRACKET;  }
-"]"               {if (trace) ECHO; column+=yyleng; return T_RIGHTSQUAREBRACKET; }
-^#line            {if (trace) ECHO; column+=yyleng; return T_LINE;             }
-class             {if (trace) ECHO; column+=yyleng; return T_CLASS;            }
-file              {if (trace) ECHO; column+=yyleng; return T_FILE;             }
-stem              {if (trace) ECHO; column+=yyleng; return T_STEM;             }
-function          {if (trace) ECHO; column+=yyleng; return T_FUNCTION;         }
-prefix            {if (trace) ECHO; column+=yyleng; return T_PREFIX;           }
-classprefix       {if (trace) ECHO; column+=yyleng; return T_CLASSPREFIX;      }
-major             {if (trace) ECHO; column+=yyleng; return T_MAJOR;            }
-minor             {if (trace) ECHO; column+=yyleng; return T_MINOR;            }
-version           {if (trace) ECHO; column+=yyleng; return T_VERSION;          }
-global            {if (trace) ECHO; column+=yyleng; return T_GLOBAL;           }
-local             {if (trace) ECHO; column+=yyleng; return T_LOCAL;            }
-classInit         {if (trace) ECHO; column+=yyleng; return T_CLASSINIT;        }
-release           {if (trace) ECHO; column+=yyleng; return T_RELEASE;          }
-order             {if (trace) ECHO; column+=yyleng; return T_ORDER;            }
-metaclass         {if (trace) ECHO; column+=yyleng; return T_METACLASS;        }
-parent            {if (trace) ECHO; column+=yyleng; return T_PARENT;           }
-data              {if (trace) ECHO; column+=yyleng; return T_DATA;             }
-private           {if (trace) ECHO; column+=yyleng; return T_PRIVATE;          }
-public            {if (trace) ECHO; column+=yyleng; return T_PUBLIC;           }
-internal          {if (trace) ECHO; column+=yyleng; return T_INTERNAL;         }
-methods           {if (trace) ECHO; column+=yyleng; return T_METHODS;          }
-group             {if (trace) ECHO; column+=yyleng; return T_GROUP;            }
-method            {if (trace) ECHO; column+=yyleng; return T_METHOD;           }
-procedure         {if (trace) ECHO; column+=yyleng; return T_PROCEDURE;        }
-offset            {if (trace) ECHO; column+=yyleng; return T_OFFSET;           }
-name              {if (trace) ECHO; column+=yyleng; return T_NAME;             }
-lookup            {if (trace) ECHO; column+=yyleng; return T_LOOKUP;           }
-external          {if (trace) ECHO; column+=yyleng; return T_EXTERNAL;         }
-override          {if (trace) ECHO; column+=yyleng; return T_OVERRIDE;         }
-[A-Za-z][_0-9A-Za-z]* {if (trace) ECHO; column+=yyleng; yylval.stval=strdup(yytext); return T_IDENTIFIER;   }
-[ \t]+            { column++;                                                  }
-\n                { lineno++;                                                  }
-.                 { printf("ERROR"); };
-
-%%
-/* "use"             {if (trace) ECHO; column+=yyleng; return T_USE;              } */
+%{
+
+#include <stdio.h>  // fopen
+#include <stdlib.h> // malloc, free, realloc
+#include <string.h> // strcat
+
+#include <emitlib.h>
+
+#include "oidl.h"
+
+int trace=1;
+int lineno=1, column=0;
+char comment[16384]; // handle with -C
+char passthru[32768]; // handle with -S
+
+%}
+
+
+%x IN_CPP_COMMENT
+%x IN_PASSTHRU
+
+%%
+
+<INITIAL>{
+  "/*"             {BEGIN(IN_CPP_COMMENT); comment[0]=0x0; }
+  "passthru:"       {BEGIN(IN_PASSTHRU); passthru[0]=0x0;}
+}
+
+<IN_CPP_COMMENT>{
+  "*/"      { BEGIN(INITIAL); yylval.stval=strdup(comment); return T_COMMENT; }
+  [^*\n]+   { strcat(comment, yytext); }
+  "*"       // eat the lone star
+  \n        { strcat(comment, "\n"); lineno++; }
+}
+
+<IN_PASSTHRU>{
+  "endpassthru;"  {BEGIN(INITIAL);}
+  [^\n]+    { strcat(passthru, yytext);}
+  \n        { strcat(passthru, "\n"); lineno++; }
+}
+
+[0-9]+	 	  {if (trace) ECHO; column+=yyleng; yylval.ival=atoi(yytext); return T_CONSTANT;}
+:                 {if (trace) ECHO; column+=yyleng; return T_COLON;            }
+;                 {if (trace) ECHO; column+=yyleng; return T_SEMICOLON;        }
+,                 {if (trace) ECHO; column+=yyleng; return T_COMMA;            }
+=                 {if (trace) ECHO; column+=yyleng; return T_EQUAL;            }
+--                {if (trace) ECHO; column+=yyleng; return T_DASHES;           }
+"..."             {if (trace) ECHO; column+=yyleng; return T_ELLIPSIS;         }
+"*"               {if (trace) ECHO; column+=yyleng; yylval.stval=strdup(yytext); return T_STAR; }
+"("               {if (trace) ECHO; column+=yyleng; return T_LEFTPARENTHESIS;  }
+")"               {if (trace) ECHO; column+=yyleng; return T_RIGHTPARENTHESIS; }
+"["               {if (trace) ECHO; column+=yyleng; return T_LEFTSQUAREBRACKET;  }
+"]"               {if (trace) ECHO; column+=yyleng; return T_RIGHTSQUAREBRACKET; }
+^#line            {if (trace) ECHO; column+=yyleng; return T_LINE;             }
+class             {if (trace) ECHO; column+=yyleng; return T_CLASS;            }
+file              {if (trace) ECHO; column+=yyleng; return T_FILE;             }
+stem              {if (trace) ECHO; column+=yyleng; return T_STEM;             }
+function          {if (trace) ECHO; column+=yyleng; return T_FUNCTION;         }
+prefix            {if (trace) ECHO; column+=yyleng; return T_PREFIX;           }
+classprefix       {if (trace) ECHO; column+=yyleng; return T_CLASSPREFIX;      }
+major             {if (trace) ECHO; column+=yyleng; return T_MAJOR;            }
+minor             {if (trace) ECHO; column+=yyleng; return T_MINOR;            }
+version           {if (trace) ECHO; column+=yyleng; return T_VERSION;          }
+global            {if (trace) ECHO; column+=yyleng; return T_GLOBAL;           }
+local             {if (trace) ECHO; column+=yyleng; return T_LOCAL;            }
+classInit         {if (trace) ECHO; column+=yyleng; return T_CLASSINIT;        }
+release           {if (trace) ECHO; column+=yyleng; return T_RELEASE;          }
+order             {if (trace) ECHO; column+=yyleng; return T_ORDER;            }
+metaclass         {if (trace) ECHO; column+=yyleng; return T_METACLASS;        }
+parent            {if (trace) ECHO; column+=yyleng; return T_PARENT;           }
+data              {if (trace) ECHO; column+=yyleng; return T_DATA;             }
+private           {if (trace) ECHO; column+=yyleng; return T_PRIVATE;          }
+public            {if (trace) ECHO; column+=yyleng; return T_PUBLIC;           }
+internal          {if (trace) ECHO; column+=yyleng; return T_INTERNAL;         }
+methods           {if (trace) ECHO; column+=yyleng; return T_METHODS;          }
+group             {if (trace) ECHO; column+=yyleng; return T_GROUP;            }
+method            {if (trace) ECHO; column+=yyleng; return T_METHOD;           }
+procedure         {if (trace) ECHO; column+=yyleng; return T_PROCEDURE;        }
+offset            {if (trace) ECHO; column+=yyleng; return T_OFFSET;           }
+name              {if (trace) ECHO; column+=yyleng; return T_NAME;             }
+lookup            {if (trace) ECHO; column+=yyleng; return T_LOOKUP;           }
+external          {if (trace) ECHO; column+=yyleng; return T_EXTERNAL;         }
+override          {if (trace) ECHO; column+=yyleng; return T_OVERRIDE;         }
+[A-Za-z][_0-9A-Za-z]* {if (trace) ECHO; column+=yyleng; yylval.stval=strdup(yytext); return T_IDENTIFIER;   }
+[ \t]+            { column++;                                                  }
+\n                { lineno++;                                                  }
+.                 { printf("ERROR"); };
+
+%%
+/* "use"             {if (trace) ECHO; column+=yyleng; return T_USE;              } */
diff -urN somfree-old/somopc/src/oidl.y somfree/somopc/src/oidl.y
--- somfree-old/somopc/src/oidl.y	2024-09-13 06:03:41.210811136 +0300
+++ somfree/somopc/src/oidl.y	2024-09-13 06:04:30.758911143 +0300
@@ -1,1128 +1,1128 @@
-%{
-#include <stdio.h> // fopen, fprintf
-#include <string.h>
-
-#include <emitlib.h>
-
-#define YYERROR_VERBOSE
-
-extern int lineno, column;
-
-Entry e;
-
-Entry *cls;	// Current Class Entry
-Entry *pcls;	// Parent Class Entry
-Entry *mcls;	// Meta Class Entry
-
-void yyerror(const char *str)
-{
-        fprintf(stderr,"\nerror: %s\n", str);
-}
- 
-int yywrap()
-{
-        return 1;
-} 
-  
-%}
-
-
-
-%start oidl
-
-%union{
- char *stval;
- int ival;
-}
-
-
-%type <stval> overridemethod_name
-
-%type <ival> T_CONSTANT
-
-%token T_COLON T_SEMICOLON T_COMMA T_STAR T_COMMENT T_IDENTIFIER
-%token T_EQUAL T_DASHES T_CONSTANT T_PERIOD  T_STRING
-%token T_ELLIPSIS T_LEFTPARENTHESIS T_RIGHTPARENTHESIS
-%token T_LEFTSQUAREBRACKET T_RIGHTSQUAREBRACKET
-
-%token T_VERSION T_GLOBAL T_LOCAL T_CLASSINIT T_RELEASE T_ORDER T_METACLASS T_PARENT
-%token T_CLASS T_LINE
-%token T_FILE T_STEM T_FUNCTION T_PREFIX T_CLASSPREFIX T_MAJOR T_MINOR
-%token T_PASSTHRU T_BEFORE T_AFTER T_ENDPASSTHRU T_DATA T_PRIVATE T_PUBLIC T_INTERNAL
-%token T_METHODS T_GROUP T_METHOD T_PROCEDURE T_OFFSET T_NAME T_LOOKUP T_EXTERNAL
-%token T_USE T_OVERRIDE
-
-%%
-
-oidl
-	:
-		{
-			if (somtg_f.verbose) printf("Parsing of \"%s\" started.\n", somtfilePath);
-			somtg_f._ERROR=0;   /* @todo subject to move to parse() */
-			somtg_f.WARN=0;   /* @todo subject to move to parse() */
-			somtg_f.FATAL=0;   /* @todo subject to move to parse() */
-			somtg_f.INTERNAL=0;   /* @todo subject to move to parse() */
-			somtg_buf=somtsmallocSL(somtg_f.commentsize, TRUE);   /* @todo subject to move to parse() */
-		}
-	  class_list
-		{
-			somtfree(somtg_buf);   /* @todo subject to move to parse() */
-			if (somtg_f.verbose) printf("Parsing of \"%s\" finished.\n", somtfilePath);
-		}
-	| line
-        ;
-
-line	: T_LINE T_CONSTANT T_STRING
-	;
-
-class_list
-	: class_definition
-	| class_list class_definition
-	;
-
-class_definition
-	:
-		{
-			cls=(Entry *)somtsmallocSL(sizeof(Entry), TRUE);
-			cls->atts=somtaddModifierSL(cls->atts, "callstyle", "oidl");
-			cls->type=SOMTClassE;
-			somtclassIdlCall=FALSE;
-			cls->u.c.file=strdup(somtfilePath);
-		}
-	  class_section section_list
-		{
-			somtaddEntrySL(somtstab, cls->name, cls);
-			somtfree(cls);
-		}
-	;
-
-section_list
-	: section
-        | section_list section
-        ;
-
-section
-	: releaseorder_section
-        | metaclass_section
-        |
-		{
-			pcls=(Entry *)somtsmallocSL(sizeof(Entry), TRUE);
-			pcls->atts=somtaddModifierSL(pcls->atts, "callstyle", "oidl");
-			pcls->type=SOMTBaseE;
-			somtclassIdlCall=FALSE;
-//			pcls->u.c.file=strdup(somtfilePath);
-		}
-	  parent_section
-		{
-			cls->u.c.parent=somtaddEntrySL(somtstab, pcls->name, pcls);
-			somtfree(pcls);
-		}
-        | passthru_section
-        | data_section
-	| methods_section
-	;
-
-class_section
-	: classdef 
-        | classdef description
-		{
-			cls->comment=$<stval>2;
-		}
-	;
-
-classdef
-	: class_header class_name T_SEMICOLON 
-	| class_header class_name class_attributes T_SEMICOLON
-        ;
-
-class_header
-	: T_CLASS T_COLON 
-	;
-
-class_name
-	: T_IDENTIFIER 
-		{
-			somtclassName=$<stval>1;
-			cls->lineno=lineno;                 
-			cls->name=$<stval>1;
-		}
-        ;
-
-class_attributes
-	: T_COMMA class_attribute
-	| class_attributes T_COMMA class_attribute
-        ;
-
-class_attribute
-	: T_FILE T_STEM T_EQUAL T_IDENTIFIER
-		{
-			cls->atts=somtaddModifierSL(cls->atts, "filestem", $<stval>4);
-		}
-        | T_EXTERNAL T_STEM T_EQUAL T_IDENTIFIER
-		{
-			cls->atts=somtaddModifierSL(cls->atts, "externalstem", $<stval>4);
-		}
-        | T_FUNCTION T_PREFIX T_EQUAL T_IDENTIFIER
-		{
-			cls->atts=somtaddModifierSL(cls->atts, "functionprefix", $<stval>4);
-		}
-        | T_EXTERNAL T_PREFIX T_EQUAL T_IDENTIFIER
-		{
-			cls->atts=somtaddModifierSL(cls->atts, "externalprefix", $<stval>4);
-		}
-        | T_CLASSPREFIX T_EQUAL T_IDENTIFIER
-		{
-			cls->atts=somtaddModifierSL(cls->atts, "classprefix", $<stval>3);
-		}
-        | T_MAJOR T_VERSION T_EQUAL T_CONSTANT
-		{
-			char *st=itoa($4, somtsmallocSL(sizeof(int)*8+1/*_MAX_ITOSTR_BASE10_COUNT*/, TRUE), 10);
-			cls->atts=somtaddModifierSL(cls->atts, "majorversion", st);
-			somtmajorVersion=strdup(st);
-			somtfree(st);
-		}
-        | T_MINOR T_VERSION T_EQUAL T_CONSTANT
-		{
-			char *st=itoa($4, somtsmallocSL(sizeof(int)*+1/*_MAX_ITOSTR_BASE10_COUNT*/, TRUE), 10);
-			cls->atts=somtaddModifierSL(cls->atts, "minorversion", st);
-			somtminorVersion=strdup(st);
-			somtfree(st);
-		}
-        | T_CLASSINIT T_EQUAL T_IDENTIFIER
-		{
-			cls->atts=somtaddModifierSL(cls->atts, "classInit", $<stval>3);
-		}
-	| visibility
-        ;
-
-visibility
-	: T_GLOBAL
-        | T_LOCAL
-	;
-
-releaseorder_section
-	: releaseorder_header release_list T_SEMICOLON
-		{
-			cls->atts=somtaddModifierSL(cls->atts, "releaseorder", $<stval>2);
-		}
-	;
-
-releaseorder_header
-	: T_RELEASE T_ORDER T_COLON
-	;
-
-release_list
-	: release
-		{ 
-			$<stval>$=strdup($<stval>1);
-		}
-	| release_list T_COMMA release
-		{
-			char *r=somtsmallocSL(strlen($<stval>1)+strlen($<stval>3)+2, TRUE);
-			strcat(strcat(strcat(r, $<stval>1), ","), $<stval>3);
-			$<stval>$=strdup(r);
-			somtfree(r);
-		}
-	;
-
-release
-	: T_IDENTIFIER
-		{
-			cls->u.c.release=somtaddModifierSL(cls->u.c.release, $<stval>1, NULL);
-			$<stval>$=$<stval>1;
-		}
-	;
-
-metaclass_section
-	: metaclassdef
-        | metaclassdef description
-		{
-			mcls->comment=$<stval>2;
-		}
-	;
-
-metaclassdef
-	: metaclass_header metaclass_name T_SEMICOLON
-        | metaclass_header metaclass_name metaclass_attributes T_SEMICOLON
-        ;
-
-metaclass_header
-	: T_METACLASS T_COLON
-        ;
-
-metaclass_name
-	: T_IDENTIFIER
-	;
-
-metaclass_attributes
-	: T_COMMA metaclass_attribute
-	| metaclass_attributes T_COMMA metaclass_attribute 
-	;
-
-metaclass_attribute
-	: T_FILE T_STEM T_EQUAL T_IDENTIFIER
-        | T_MAJOR T_VERSION T_EQUAL T_CONSTANT
-        | T_MINOR T_VERSION T_EQUAL T_CONSTANT
-        | visibility
-        ;
-
-parent_section
-	: parentdef
-        | parentdef description
-		{
-			pcls->comment=$<stval>2;
-		}
-	;
-
-
-parentdef
-	: parent_header parent_name T_SEMICOLON
-        | parent_header parent_name parent_attributes T_SEMICOLON
-        ;
-
-parent_header
-	: T_PARENT T_CLASS T_COLON
-        | T_PARENT T_COLON 
-        ;
-
-parent_name
-	: T_IDENTIFIER
-		{
-			pcls->lineno=lineno;  // @todo line of class definition?
-			pcls->name=$<stval>1;
-		}
-	;
-
-parent_attributes
-	: T_COMMA parent_attribute
-	| parent_attributes T_COMMA parent_attribute
-	;
-
-parent_attribute
-	: T_FILE T_STEM T_EQUAL T_IDENTIFIER
-        | T_MAJOR T_VERSION T_EQUAL T_CONSTANT
-        | T_MINOR T_VERSION T_EQUAL T_CONSTANT
-        | visibility
-        ;
-
-passthru_section
-	: T_PASSTHRU
-        ;
-
-data_section
-	: data_header variables
-	;
-
-data_header
-	: T_DATA T_COLON
-	;
-
-variables
-	: declaration
-        | declaration variables
-        ;
-
-declaration
-	: declarationdef T_SEMICOLON
-	| declarationdef T_SEMICOLON description
-		{
-//			cls->comment=$<stval>2;
-		}
-	;
-
-declarationdef
-	: declaration_specifiers
-	| declaration_specifiers data_attributes
-	;
-
-data_attributes
-	: T_COMMA data_attribute
-	| data_attributes T_COMMA data_attribute
-	;
-
-data_attribute
-	: T_PRIVATE
-	| T_PUBLIC
-	| T_INTERNAL
-	| T_CLASS
-	;
-
-declaration_specifiers
-	: type_specifier declarator
-	| type_specifier declarator declaration_specifiers
-	;
-
-type_specifier
-	: T_IDENTIFIER 
-		{
-			$<stval>$=$<stval>1;
-		}
-	;
-
-declarator
-	: pointer direct_declarator
-	| direct_declarator
-	;
-
-direct_declarator
-	: T_IDENTIFIER {printf("$<stval>1");}
-	| T_LEFTPARENTHESIS declarator T_RIGHTPARENTHESIS
-	| direct_declarator T_LEFTSQUAREBRACKET T_CONSTANT T_RIGHTSQUAREBRACKET
-	| direct_declarator T_LEFTSQUAREBRACKET T_RIGHTSQUAREBRACKET
-	| direct_declarator T_LEFTPARENTHESIS declaration_specifiers T_RIGHTPARENTHESIS
-	| direct_declarator T_LEFTPARENTHESIS T_RIGHTPARENTHESIS
-	;
-
-pointer
-	: T_STAR
-		{
-			$<stval>$=$<stval>1;
-		}
-	| pointer T_STAR
-		{
-			char *r=somtsmallocSL(strlen($<stval>1)+strlen($<stval>2)+1, TRUE);
-			strcat(r, $<stval>1);
-			strcat(r, $<stval>2);
-			free($<stval>1);
-			$<stval>$=strdup(r);
-			somtfree(r);
-		}
-	;
-
-
-methods_section
-	: method_header method_list
-	| method_header description method_list
-		{
-			e.comment=$<stval>2;
-		}
-	;
-
-method_header
-	: T_METHODS T_COLON
-	;
-
-method_list
-	: method 
-		{
-			cls->u.c.methodcnt++;
-			somtaddEntrySL(somtstab, e.name, &e);
-			memset(&e, 0, sizeof(Entry));
-		}
-	| method_list method 
-		{
-			cls->u.c.methodcnt++;
-			somtaddEntrySL(somtstab, e.name, &e);
-			memset(&e, 0, sizeof(Entry));
-		}
-        ;
-
-method
-	: methoddef T_SEMICOLON 
-	| methoddef T_SEMICOLON description 
-	;
-
-methoddef
-	: method_specifier
-	| method_specifier method_attributes
-	| overridemethod_specifier
-	;
-
-method_specifier
-	: method_type method_name T_LEFTPARENTHESIS parameter_list T_RIGHTPARENTHESIS 
-		{
-			e.u.m.type=strdup($<stval>1);
-		}
-	;                                             
-
-method_name
-	: T_IDENTIFIER 
-		{
-			char * desc=somtsmallocSL(MAX_DESCRIPTOR_LENGTH, TRUE);
-			e.type=SOMTNewMethodE;
-			e.lineno=lineno;
-			e.name=$<stval>1;
-			e.sname=&somtclassName;
-			strcat(desc, "::");
-			strcat(desc, $<stval>1);
-			strcat(desc, "::");
-			strcat(desc, somtclassName);
-			e.atts=somtaddModifierSL(e.atts, "descriptor", desc);
-			somtfree(desc);
-		}
-	;
-
-method_type
-	: type_specifier
-		{
-			$<stval>$=$<stval>1;
-		}
-	| type_specifier pointer
-		{
-			char *r=somtsmallocSL(strlen($<stval>1)+strlen($<stval>2)+1, TRUE);
-			strcat(r, $<stval>1);
-			strcat(r, $<stval>2);
-			free($<stval>1);
-			$<stval>$=strdup(r);
-			somtfree(r);
-		}
-	;
-
-overridemethod_specifier
-	: overridemethod_header overridemethod_name
-	| overridemethod_header overridemethod_name overridemethod_attributes
-	;                                             
-
-overridemethod_header
-	: T_OVERRIDE
-	| T_OVERRIDE T_COLON
-	;
-
-overridemethod_name
-	: T_IDENTIFIER 
-		{
-			char * desc=somtsmallocSL(MAX_DESCRIPTOR_LENGTH, TRUE);
-			e.type=SOMTOverrideMethodE;
-			e.lineno=lineno;
-			e.name=$<stval>1;
-			e.sname=&somtclassName;
-			strcat(strcat(strcat(strcat(desc ,"::"), $<stval>1), "::"), somtclassName);
-			e.atts=somtaddModifierSL(e.atts, "descriptor", desc);
-			somtfree(desc);
-		}
-	;
-
-parameter_list
-	: parameter
-	| parameter_list T_COMMA parameter
-	;
-
-parameter
-	: T_ELLIPSIS
-	| type_specifier declarator
-	;
-
-method_attributes
-	: T_COMMA method_attribute
-	| method_attributes T_COMMA method_attribute
-	;
-
-method_attribute
-	: T_PRIVATE
-	| T_PUBLIC
-	| T_METHOD
-	| T_PROCEDURE
-	| T_CLASS
-	| T_OFFSET
-	| T_NAME T_LOOKUP
-	| T_LOCAL
-	| T_EXTERNAL
-	| T_USE T_EQUAL T_IDENTIFIER
-	;
-
-/* descriptor */
-/* noset */
-/* original */
-
-overridemethod_attributes
-	: T_COMMA overridemethod_attribute
-	| overridemethod_attributes T_COMMA overridemethod_attribute
-	;
-
-overridemethod_attribute
-	: T_PRIVATE
-	| T_PUBLIC
-	| T_CLASS
-	| T_LOCAL
-	| T_EXTERNAL
-	| T_USE T_EQUAL T_IDENTIFIER
-	;
-
-description
-	: T_COMMENT 
-		{
-			$<stval>$=$<stval>1;
-		}
-        ;
-
-%%
-
-FILE *yyin;
-
-// Experimental replacement of somttype
-char * mysomttype(SOMTTypes ttype)
-{
-  char * result=NULL;
-  switch ( ttype )
-  {
-    case SOMTAnyBE:
-      result="SOMTAnyBE";
-      break;
-    case     SOMTArgumentE:
-      result="SOMTArgumentE";
-      break;
-    case     SOMTAttE:
-      result="SOMTAttE";
-      break;
-    case     SOMTBadEntryE:
-      result="SOMTBadEntryE";
-      break;
-    case     SOMTBaseE:
-      result="SOMTBaseE";
-      break;
-    case     SOMTBooleanBE:
-      result="SOMTBooleanBE";
-      break;
-    case     SOMTCaseEntryE:
-      result="SOMTCaseEntryE";
-      break;
-    case     SOMTCaseListE:
-      result="SOMTCaseListE";
-      break;
-    case     SOMTCaseSTME:
-      result="SOMTCaseSTME";
-      break;
-    case     SOMTCharBE:
-      result="SOMTCharBE";
-      break;
-    case     SOMTClassE:
-      result="SOMTClassE";
-      break;
-    case     SOMTConstE:
-      result="SOMTConstE";
-      break;
-    case     SOMTCopyrightE:
-      result="SOMTCopyrightE";
-      break;
-    case     SOMTDataE:
-      result="SOMTDataE";
-      break;
-    case     SOMTDclListE:
-      result="SOMTDclListE";
-      break;
-    case     SOMTDefaultE:
-      result="SOMTDefaultE";
-      break;
-    case     SOMTDoubleBE:
-      result="SOMTDoubleBE";
-      break;
-    case     SOMTEBaseE:
-      result="SOMTEBaseE";
-      break;
-    case     SOMTEEnumE:
-      result="SOMTEEnumE";
-      break;
-    case     SOMTEnumBE:
-      result="SOMTEnumBE";
-      break;
-    case     SOMTEnumE:
-      result="SOMTEnumE";
-      break;
-    case     SOMTEnumPE:
-      result="SOMTEnumPE";
-      break;
-    case     SOMTFloatBE:
-      result="SOMTFloatBE";
-      break;
-    case     SOMTGroupE:
-      result="SOMTGroupE";
-      break;
-    case     SOMTLongBE:
-      result="SOMTLongBE";
-      break;
-    case     SOMTMetaE:
-      result="SOMTMetaE";
-      break;
-    case     SOMTModuleE:
-      result="SOMTModuleE";
-      break;
-    case     SOMTNegativeBE:
-      result="SOMTNegativeBE";
-      break;
-    case     SOMTNewMethodE:
-      result="SOMTNewMethodE";
-      break;
-    case     SOMTOctetBE:
-      result="SOMTOctetBE";
-      break;
-    case     SOMTOverriddenMethodE:
-      result="SOMTOverriddenMethodE";
-      break;
-    case     SOMTOverrideMethodE:
-      result="SOMTOverrideMethodE";
-      break;
-    case     SOMTPassthruE:
-      result="SOMTPassthruE";
-      break;
-    case     SOMTSequenceE:
-      result="SOMTSequenceE";
-      break;
-    case     SOMTSequenceTDE:
-      result="SOMTSequenceTDE";
-      break;
-    case     SOMTShortBE:
-      result="SOMTShortBE";
-      break;
-    case     SOMTStringBE:
-      result="SOMTStringBE";
-      break;
-    case     SOMTStringE:
-      result="SOMTStringE";
-      break;
-    case     SOMTStructE:
-      result="SOMTStructE";
-      break;
-    case     SOMTStructPE:
-      result="SOMTStructPE";
-      break;
-    case     SOMTStructSE:
-      result="SOMTStructSE";
-      break;
-    case     SOMTTyDclE:
-      result="SOMTTyDclE";
-      break;
-    case     SOMTTypeCodeBE:
-      result="SOMTTypeCodeBE";
-      break;
-    case     SOMTTypedefBE:
-      result="SOMTTypedefBE";
-      break;
-    case     SOMTTypedefE:
-      result="SOMTTypedefE";
-      break;
-    case     SOMTUnionE:
-      result="SOMTUnionE";
-      break;
-    case     SOMTUnionPE:
-      result="SOMTUnionPE";
-      break;
-    case     SOMTUnionSE:
-      result="SOMTUnionSE";
-      break;
-    case     SOMTUnsignedLongBE:
-      result="SOMTUnsignedLongBE";
-      break;
-    case     SOMTUnsignedShortBE:
-      result="SOMTUnsignedShortBE";
-      break;
-    case     SOMTVoidBE:
-      result="SOMTVoidBE";
-      break;
-    case     SOMTVoidPtrBE:
-      result="SOMTVoidPtrBE";
-      break;
-// This is special case SOMTTypes used on call of emitter start and emitter end
-/*    case     SOMTEmitterBeginE:
-      result="SOMTEmitterBeginE";
-      break;
-    case     SOMTEmitterEndE:
-      result="SOMTEmitterEndE";
-      break; */
-    default:
-      printf("Unknown entry type: %d.\n", ttype);
-  }
-  return result;
-}
-
-void dumpReleaseOrder(char * name, AttList *ap)
-{
-  AttList *cur=ap;
-
-  for(; cur; cur = cur->next) 
-  {
-    printf("\t%s %s\n", name, cur->name);
-//    dumpAttrs("static", cur->staticlist);
-//    dumpAttrs("protectted", cur->protectedlist);
-//    dumpAttrs("public", cur->publiclist);
-//    dumpAttrs("private", cur->privatelist);
-  }
-}
-
-void dumpMethodOrData(Entry * ep)
-{
-  printf("\teptype = %08p\n", ep->u.m.eptype);
-  printf("\tptrs = %08p\n", ep->u.m.ptrs);
-  printf("\tarray = %08p\n", ep->u.m.array);
-  printf("\tarrays = %s\n", ep->u.m.arrays);
-  printf("\tdefn = %s\n", ep->u.m.defn);
-  printf("\ttype = %s\n", ep->u.m.type);
-  printf("\tvarargs = %s\n", ep->u.m.varargs ? "true" : "false");
-  printf("\tprivate = %s\n", ep->u.m.isprivate ? "true" : "false");
-  printf("\tinout = %d\n", ep->u.m.inoutmode);
-  printf("\tselfref = %s\n", ep->u.m.isselfref ? "true" : "false");
-  printf("\toneway = %s\n", ep->u.m.isoneway ? "true" : "false");
-  printf("\targcnt = %d\n", ep->u.m.argcnt);
-  printf("\targs = %08p\n", ep->u.m.args);
-  printf("\tomethod = %08p\n", ep->u.m.omethod);
-  printf("\toparent = %08p\n", ep->u.m.oparent);
-  printf("\tgroup = %08p\n", ep->u.m.group);
-  printf("\tnext = %08p\n", ep->u.m.next);
-  printf("\tctxsa = %08p\n", ep->u.m.ctxsa);
-  printf("\traiseslist = %08p\n", ep->u.m.raiseslist);
-}
-
-void mysomtShowEntry(Entry * ep)
-{
-  if (ep)
-  {
-    printf("      somtShowEntry: Entry at %08p, name = %s, type = %d\n", ep, ep->name, ep->type);
-    printf("\tlineno = %d\n", ep->lineno);
-    switch ( ep->type )
-    {
-      case SOMTAnyBE:
-        printf("\t SOMTAnyBE\n");
-        break;
-      case     SOMTArgumentE:
-        printf("\t SOMTArgumentE\n");
-        dumpMethodOrData(ep);
-        break;
-      case     SOMTAttE:
-        printf("\t SOMTAttE\n");
-        break;
-      case     SOMTBadEntryE:
-        printf("\t SOMTBadEntryE\n");
-        break;
-      case     SOMTBaseE:
-        printf("\t SOMTBaseE\n");
-        printf("\tparentdef = %08p\n", ep->u.p.parentdef);
-        break;
-      case     SOMTBooleanBE:
-        printf("\t SOMTBooleanBE\n");
-        break;
-      case     SOMTCaseEntryE:
-        printf("\t SOMTCaseEntryE\n");
-        break;
-      case     SOMTCaseListE:
-        printf("\t SOMTCaseListE\n");
-        break;
-      case     SOMTCaseSTME:
-        printf("\t SOMTCaseSTME\n");
-        break;
-      case     SOMTCharBE:
-        printf("\t SOMTCharBE\n");
-        break;
-      case     SOMTClassE:
-        printf("\tClass Definition Entry:\n");
-        printf("\tfile = %s\n", ep->u.c.file);
-        printf("\tmeta = %08p\n", ep->u.c.meta);
-        printf("\tparent = %08p\n", ep->u.c.parent);
-        printf("\tparents = %08p\n", ep->u.c.parents);
-        printf("\trelease = %08p\n", ep->u.c.release);
-	dumpReleaseOrder("\t", ep->u.c.release);
-        printf("\tpassthru = %08p\n", ep->u.c.passthrus);
-        printf("\tdata = %08p\n", ep->u.c.data);
-        printf("\ttc = %08p\n", ep->tc);
-        printf("\tmethodcnt = %08d\n", ep->u.c.methodcnt);
-        printf("\tmethods = %08p\n", ep->u.c.methods);
-        printf("\tinherited = %08p\n", ep->u.c.inherited);
-        printf("\tpubdefs = %08p\n", ep->u.c.pubdefs);
-        printf("\tmod = %08p\n", ep->u.c.mod);
-        printf("\tcls = %08p\n", ep->u.c.cls);
-        printf("\tforward = %s\n", ep->u.c.isforward ? "true" : "false");
-        break;
-      case     SOMTConstE:
-        printf("\t SOMTConstE\n");
-        break;
-      case     SOMTCopyrightE:
-        printf("\t SOMTCopyrightE\n");
-        break;
-      case     SOMTDataE:
-        printf("\t SOMTDataE\n");
-        dumpMethodOrData(ep);
-        break;
-      case     SOMTDclListE:
-        printf("\t SOMTDclListE\n");
-        break;
-      case     SOMTDefaultE:
-        printf("\t SOMTDefaultE\n");
-        break;
-      case     SOMTDoubleBE:
-        printf("\t SOMTDoubleBE\n");
-        break;
-      case     SOMTEBaseE:
-        printf("\t SOMTEBaseE\n");
-        break;
-      case     SOMTEEnumE:
-        printf("\t SOMTEEnumE\n");
-        break;
-      case     SOMTEnumBE:
-        printf("\t SOMTEnumBE\n");
-        break;
-      case     SOMTEnumE:
-        printf("\t SOMTEnumE\n");
-        break;
-      case     SOMTEnumPE:
-        printf("\t SOMTEnumPE\n");
-        break;
-      case     SOMTFloatBE:
-        printf("\t SOMTFloatBE\n");
-        break;
-      case     SOMTGroupE:
-        printf("\t SOMTGroupE\n");
-        break;
-      case     SOMTLongBE:
-        printf("\t SOMTLongBE\n");
-        break;
-      case     SOMTMetaE:
-        printf("\t SOMTMetaE\n");
-        break;
-      case     SOMTModuleE:
-        printf("\t SOMTModuleE\n");
-        break;
-      case     SOMTNegativeBE:
-        printf("\t SOMTNegativeBE\n");
-        break;
-      case     SOMTNewMethodE:
-        printf("\t SOMTNewMethodE\n");
-        dumpMethodOrData(ep);
-        break;
-      case     SOMTOctetBE:
-        printf("\t SOMTOctetBE\n");
-        break;
-      case     SOMTOverriddenMethodE:
-        printf("\t SOMTOverriddenMethodE\n");
-        dumpMethodOrData(ep);
-        break;
-      case     SOMTOverrideMethodE:
-        printf("\t SOMTOverrideMethodE\n");
-        dumpMethodOrData(ep);
-        break;
-      case     SOMTPassthruE:
-        printf("\t SOMTPassthruE\n");
-        break;
-      case     SOMTSequenceE:
-        printf("\t SOMTSequenceE\n");
-        break;
-      case     SOMTSequenceTDE:
-        printf("\t SOMTSequenceTDE\n");
-        break;
-      case     SOMTShortBE:
-        printf("\t SOMTShortBE\n");
-        break;
-      case     SOMTStringBE:
-        printf("\t SOMTStringBE\n");
-        break;
-      case     SOMTStringE:
-        printf("\t SOMTStringE\n");
-        break;
-      case     SOMTStructE:
-        printf("\t SOMTStructE\n");
-        break;
-      case     SOMTStructPE:
-        printf("\t SOMTStructPE\n");
-        break;
-      case     SOMTStructSE:
-        printf("\t SOMTStructSE\n");
-        printf("\tdcllist = %08p\n", ep->u.struc.dcllist);
-        printf("\tcls = %08p\n", ep->u.struc.cls);
-        printf("\texception = %s\n", ep->u.struc.isexcept ? "true" : "false");
-        printf("\tmutref = %s\n", ep->u.struc.ismutref ? "true" : "false");
-        break;
-      case     SOMTTyDclE:
-        printf("\t SOMTTyDclE\n");
-        break;
-      case     SOMTTypeCodeBE:
-        printf("\t SOMTTypeCodeBE\n");
-        break;
-      case     SOMTTypedefBE:
-        printf("\t SOMTTypedefBE\n");
-        dumpMethodOrData(ep);
-        break;
-      case     SOMTTypedefE:
-        printf("\t SOMTTypedefE\n");
-        break;
-      case     SOMTUnionE:
-        printf("\t SOMTUnionE\n");
-        break;
-      case     SOMTUnionPE:
-        printf("\t SOMTUnionPE\n");
-        break;
-      case     SOMTUnionSE:
-        printf("\t SOMTUnionSE\n");
-        break;
-      case     SOMTUnsignedLongBE:
-        printf("\t SOMTUnsignedLongBE\n");
-        break;
-      case     SOMTUnsignedShortBE:
-        printf("\t SOMTUnsignedShortBE\n");
-        break;
-      case     SOMTVoidBE:
-        printf("\t SOMTVoidBE\n");
-        break;
-      case     SOMTVoidPtrBE:
-        printf("\t SOMTVoidPtrBE\n");
-        dumpMethodOrData(ep);
-        break;
-  // This is special case SOMTTypes used on call of emitter start and emitter end
-  /*    case     SOMTEmitterBeginE:
-        result="SOMTEmitterBeginE";
-        break;
-      case     SOMTEmitterEndE:
-        result="SOMTEmitterEndE";
-        break; */
-      default:
-        printf("Error: somtShowEntry, bad entry type of %d", ep->type);
-//        SOM_Error(SOM_Fatal, __FILE__, __LINE__);
-//        SOMError(9, __FILE__, __LINE__);
-    }
-  }
-  else 
-  {
-    printf("somtShowEntry: NULL entry\n");
-  }
-}
-
-void dumpAttrs(AttList *ap)
-{
-  struct AttList *cur = ap;
-
-  for(cur = ap; cur; cur = cur->next) 
-  {
-    printf("\tModifier %s=%s\n", cur->name, cur->value);
-  }
-}
-
-
-void mydumpEntry(Entry * ep)
-{
-  printf("Entry at address %p\n", ep);
-  printf("--------------------------\n");
-  printf("Entry type: %s (%d)\n", mysomttype(ep->type), ep->type);
-//  printf("Entry type: %s (%d)\n", somtEntryTypeName(ep->type), ep->type);
-  if (ep->sname) printf("Scoped name: %s\n", *ep->sname);
-  if (ep->comment) printf("Comment associated with entry: %s\n", ep->comment);
-  printf("Modifiers: %p\n", ep->atts);
-  if (ep->atts) dumpAttrs(ep->atts);
-  printf("TypeCode: %p\n", ep->tc);
-  printf("Points to the object: %p\n", ep->objref);
-  printf("Reference to real type: %s\n", ep->isref ? "true" : "false");
-  printf("Entry union: %p\n", &ep->u);
-#ifdef __PRIVATE__
-//    RHBelement *data;
-//    char *filestem;
-#endif    
-  mysomtShowEntry(ep);
-//  somtShowEntry(ep);
-};
-
-void dumpSep(Sep * sep)
-{
-    printf("Linked list item at address %p\n", sep);
-    printf("---------------------------------------\n");
-    printf("Position number: %d\n", sep->posn);
-    printf("Address of Entry: %p\n", sep->ep);
-    printf("Next linked list item address: %p\n", sep->next);
-    if (sep->ep) 
-    {
-      mydumpEntry((Entry *)sep->ep);
-      dumpSep(sep->next);
-    }
-}
-
-void dumpStab(Stab * stab)
-{
-  unsigned int i;
-  printf("Basic Symbol Table/Hash table (STab) structure\n");
-  printf("----------------------------------------------\n");
-  printf("Size of buscet: %d\n", stab->size);
-  printf("Size of entry structure: %d\n", stab->entrysize);
-  printf("Number of elements: %d\n", stab->nelms);
-  printf("Address of base slot: %p\n", stab->base);
-  printf("Max address of slot: %p\n", stab->limit);
-  printf("Start address of slot buffer: %p\n", stab->buf);
-  printf("Address of MemBuf: %p\n", stab->membuf);
-  printf("Ignore case flag: %s\n", stab->ignorecase ? "true" : "false");
-  for(i=0; i<stab->size;i++)
-  {
-    printf("Linked list at slot %d at offset %08x at address %p\n", i, sizeof(Sep)*i, stab->buf+i);
-    printf("----------------------\n");
-    dumpSep(stab->buf+i);
-  }
-}
-
-
-void usage(void)
-{
-  printf("\nSC [-options] file[.CSC]\n");
-  printf("\n-C n\n\tset the size of the comment buffer (default: 16384)\n");
-  printf("\n-s n\n\tset the total amount of string space for names and passthru lines (default: 32768)\n");
-  printf("\n-V\n\tdisplay version information\n");
-  printf("\n-a name[=value]\n\tadd a global attribute. The currently supported attributes are defined below (at the end of this section)\n");
-  printf("\n-d directory\n\tspecify a directory where all files emitted during the execution of this command should be placed. If the -d option is not used, all emitted output files are placed in the same directory as the input .csc file\n");
-  printf("\n-h or ?\n\tprovide usage information for reference\n");
-  printf("\n-i filename\n\tspecify the name of the OIDL class definition file. Use this option to override the built-in assumption that the input file will have a .csc extension. Any filename you supply with the -i option is used exactly as you provide it\n");
-  printf("\n-r\n\tcheck that all release-order entries actually exist (default: FALSE)\n");
-  printf("\n-s string\n\tsubstitute string in place of the contents of the SMEMIT environment variable for the duration of the current SC command. If you supply a list of values, you\n");
-  printf("must enclose the list with double quotation marks (\" \"). You can use the -s option as a convenient way to override the SMEMIT environment variable. For example:\n\n");
-  printf("SC -s \"h;sc\" EXAMPLE\n\n");
-  printf("is equivalent to the following sequence of commands:\n\n");
-  printf("SET OLDSMEMIT = %%SMEMIT%%\n");
-  printf("SET SMEMIT = h;sc\n");
-  printf("SC EXAMPLE\n");
-  printf("SET SMEMIT = %%OLDSMEMIT%%\n");
-  printf("\n-w\n\tsuppress warning messages (default: FALSE)\n\n");
-  printf("The only global attributes currently supported by SC.EXE are:\n");
-  printf("\ncomment = comment string\n\twhere comment string can be one of the following: \"/*\", \"--\", or \"//\". This\n");
-  printf("indicates that comments marked in the indicated way are to be completely\n");
-  printf("ignored by SC.EXE and not retained for subsequent processing by one of the\n");
-  printf("emitters.\n");
-  printf("Note: Comments indicated by lines whose first non-white-space character is\n");
-  printf("a # are always ignored by SC.EXE. Also note that comments of any\n");
-  printf("form in passthru lines are passed through.\n");
-  printf("\ncstyle = comment style\n\tcontrols the form of emitted comments. Comment style must be one of s, c, or\n");
-  printf("+ to cause emitted comments to be in \"--\", \"/* */\", or \"//\" form , respectively\n");
-  printf("The default form is s\n");
-  printf("\nibmc\n\tcauses EMITC, EMITH, EMITIH, EMITPH, and EMITDEF to generate code with\n");
-  printf("pragmas specifically intended for the IBM C Set/2 Compiler. This attribute is\n");
-  printf("specified by default\n");
-  printf("\ncl386\n\tcauses EMITC, EMITH, EMITIH, EMITPH, and EMITDEF not to generate code\n");
-  printf("with pragmas specifically intended for the IBM C Set/2 Compiler\n");
-}
-
-void parse_file(char * file)
-{
-  // parser input stream
-  yyin=fopen(file,"r");
-
-  strcpy(somtfilePath, file);
-
-  // Initialize symbol table
-  somtstab=(Stab *)somtsmallocSL(sizeof(Stab), 0);
-  somtcreateStabSL(somtstab, HASH_SIZE, sizeof(Entry));
-
-  yyparse();
-
-  dumpStab(somtstab);
-}
-
-void emit_file(char * file)
-{
-   EmitFn proc;
-   FILE * fp;
-   HMODULE hmod;
-   Entry * root;
-   Stab * stab;
-
-   proc=somtloadSL("emitpsc.dll", "emitSL", (void**)&hmod);
-
-   fp=proc(file, root, stab);
-
-   if (fp) somtfcloseSL(fp);
-}
-
-void main(int argc, char *argv[])
-{
-#if YYDEBUG != 0
-   yydebug =1 ;
-#endif
-
-//   parse_args(argc, argv);
-
-   usage();
-
-   parse_file(argv[1]);
-
-//   dump();
-
-//   emit_file(argv[1]);
-}
+%{
+#include <stdio.h> // fopen, fprintf
+#include <string.h>
+
+#include <emitlib.h>
+
+#define YYERROR_VERBOSE
+
+extern int lineno, column;
+
+Entry e;
+
+Entry *cls;	// Current Class Entry
+Entry *pcls;	// Parent Class Entry
+Entry *mcls;	// Meta Class Entry
+
+void yyerror(const char *str)
+{
+        fprintf(stderr,"\nerror: %s\n", str);
+}
+ 
+int yywrap()
+{
+        return 1;
+} 
+  
+%}
+
+
+
+%start oidl
+
+%union{
+ char *stval;
+ int ival;
+}
+
+
+%type <stval> overridemethod_name
+
+%type <ival> T_CONSTANT
+
+%token T_COLON T_SEMICOLON T_COMMA T_STAR T_COMMENT T_IDENTIFIER
+%token T_EQUAL T_DASHES T_CONSTANT T_PERIOD  T_STRING
+%token T_ELLIPSIS T_LEFTPARENTHESIS T_RIGHTPARENTHESIS
+%token T_LEFTSQUAREBRACKET T_RIGHTSQUAREBRACKET
+
+%token T_VERSION T_GLOBAL T_LOCAL T_CLASSINIT T_RELEASE T_ORDER T_METACLASS T_PARENT
+%token T_CLASS T_LINE
+%token T_FILE T_STEM T_FUNCTION T_PREFIX T_CLASSPREFIX T_MAJOR T_MINOR
+%token T_PASSTHRU T_BEFORE T_AFTER T_ENDPASSTHRU T_DATA T_PRIVATE T_PUBLIC T_INTERNAL
+%token T_METHODS T_GROUP T_METHOD T_PROCEDURE T_OFFSET T_NAME T_LOOKUP T_EXTERNAL
+%token T_USE T_OVERRIDE
+
+%%
+
+oidl
+	:
+		{
+			if (somtg_f.verbose) printf("Parsing of \"%s\" started.\n", somtfilePath);
+			somtg_f._ERROR=0;   /* @todo subject to move to parse() */
+			somtg_f.WARN=0;   /* @todo subject to move to parse() */
+			somtg_f.FATAL=0;   /* @todo subject to move to parse() */
+			somtg_f.INTERNAL=0;   /* @todo subject to move to parse() */
+			somtg_buf=somtsmallocSL(somtg_f.commentsize, TRUE);   /* @todo subject to move to parse() */
+		}
+	  class_list
+		{
+			somtfree(somtg_buf);   /* @todo subject to move to parse() */
+			if (somtg_f.verbose) printf("Parsing of \"%s\" finished.\n", somtfilePath);
+		}
+	| line
+        ;
+
+line	: T_LINE T_CONSTANT T_STRING
+	;
+
+class_list
+	: class_definition
+	| class_list class_definition
+	;
+
+class_definition
+	:
+		{
+			cls=(Entry *)somtsmallocSL(sizeof(Entry), TRUE);
+			cls->atts=somtaddModifierSL(cls->atts, "callstyle", "oidl");
+			cls->type=SOMTClassE;
+			somtclassIdlCall=FALSE;
+			cls->u.c.file=strdup(somtfilePath);
+		}
+	  class_section section_list
+		{
+			somtaddEntrySL(somtstab, cls->name, cls);
+			somtfree(cls);
+		}
+	;
+
+section_list
+	: section
+        | section_list section
+        ;
+
+section
+	: releaseorder_section
+        | metaclass_section
+        |
+		{
+			pcls=(Entry *)somtsmallocSL(sizeof(Entry), TRUE);
+			pcls->atts=somtaddModifierSL(pcls->atts, "callstyle", "oidl");
+			pcls->type=SOMTBaseE;
+			somtclassIdlCall=FALSE;
+//			pcls->u.c.file=strdup(somtfilePath);
+		}
+	  parent_section
+		{
+			cls->u.c.parent=somtaddEntrySL(somtstab, pcls->name, pcls);
+			somtfree(pcls);
+		}
+        | passthru_section
+        | data_section
+	| methods_section
+	;
+
+class_section
+	: classdef 
+        | classdef description
+		{
+			cls->comment=$<stval>2;
+		}
+	;
+
+classdef
+	: class_header class_name T_SEMICOLON 
+	| class_header class_name class_attributes T_SEMICOLON
+        ;
+
+class_header
+	: T_CLASS T_COLON 
+	;
+
+class_name
+	: T_IDENTIFIER 
+		{
+			somtclassName=$<stval>1;
+			cls->lineno=lineno;                 
+			cls->name=$<stval>1;
+		}
+        ;
+
+class_attributes
+	: T_COMMA class_attribute
+	| class_attributes T_COMMA class_attribute
+        ;
+
+class_attribute
+	: T_FILE T_STEM T_EQUAL T_IDENTIFIER
+		{
+			cls->atts=somtaddModifierSL(cls->atts, "filestem", $<stval>4);
+		}
+        | T_EXTERNAL T_STEM T_EQUAL T_IDENTIFIER
+		{
+			cls->atts=somtaddModifierSL(cls->atts, "externalstem", $<stval>4);
+		}
+        | T_FUNCTION T_PREFIX T_EQUAL T_IDENTIFIER
+		{
+			cls->atts=somtaddModifierSL(cls->atts, "functionprefix", $<stval>4);
+		}
+        | T_EXTERNAL T_PREFIX T_EQUAL T_IDENTIFIER
+		{
+			cls->atts=somtaddModifierSL(cls->atts, "externalprefix", $<stval>4);
+		}
+        | T_CLASSPREFIX T_EQUAL T_IDENTIFIER
+		{
+			cls->atts=somtaddModifierSL(cls->atts, "classprefix", $<stval>3);
+		}
+        | T_MAJOR T_VERSION T_EQUAL T_CONSTANT
+		{
+			char *st=itoa($4, somtsmallocSL(sizeof(int)*8+1/*_MAX_ITOSTR_BASE10_COUNT*/, TRUE), 10);
+			cls->atts=somtaddModifierSL(cls->atts, "majorversion", st);
+			somtmajorVersion=strdup(st);
+			somtfree(st);
+		}
+        | T_MINOR T_VERSION T_EQUAL T_CONSTANT
+		{
+			char *st=itoa($4, somtsmallocSL(sizeof(int)*+1/*_MAX_ITOSTR_BASE10_COUNT*/, TRUE), 10);
+			cls->atts=somtaddModifierSL(cls->atts, "minorversion", st);
+			somtminorVersion=strdup(st);
+			somtfree(st);
+		}
+        | T_CLASSINIT T_EQUAL T_IDENTIFIER
+		{
+			cls->atts=somtaddModifierSL(cls->atts, "classInit", $<stval>3);
+		}
+	| visibility
+        ;
+
+visibility
+	: T_GLOBAL
+        | T_LOCAL
+	;
+
+releaseorder_section
+	: releaseorder_header release_list T_SEMICOLON
+		{
+			cls->atts=somtaddModifierSL(cls->atts, "releaseorder", $<stval>2);
+		}
+	;
+
+releaseorder_header
+	: T_RELEASE T_ORDER T_COLON
+	;
+
+release_list
+	: release
+		{ 
+			$<stval>$=strdup($<stval>1);
+		}
+	| release_list T_COMMA release
+		{
+			char *r=somtsmallocSL(strlen($<stval>1)+strlen($<stval>3)+2, TRUE);
+			strcat(strcat(strcat(r, $<stval>1), ","), $<stval>3);
+			$<stval>$=strdup(r);
+			somtfree(r);
+		}
+	;
+
+release
+	: T_IDENTIFIER
+		{
+			cls->u.c.release=somtaddModifierSL(cls->u.c.release, $<stval>1, NULL);
+			$<stval>$=$<stval>1;
+		}
+	;
+
+metaclass_section
+	: metaclassdef
+        | metaclassdef description
+		{
+			mcls->comment=$<stval>2;
+		}
+	;
+
+metaclassdef
+	: metaclass_header metaclass_name T_SEMICOLON
+        | metaclass_header metaclass_name metaclass_attributes T_SEMICOLON
+        ;
+
+metaclass_header
+	: T_METACLASS T_COLON
+        ;
+
+metaclass_name
+	: T_IDENTIFIER
+	;
+
+metaclass_attributes
+	: T_COMMA metaclass_attribute
+	| metaclass_attributes T_COMMA metaclass_attribute 
+	;
+
+metaclass_attribute
+	: T_FILE T_STEM T_EQUAL T_IDENTIFIER
+        | T_MAJOR T_VERSION T_EQUAL T_CONSTANT
+        | T_MINOR T_VERSION T_EQUAL T_CONSTANT
+        | visibility
+        ;
+
+parent_section
+	: parentdef
+        | parentdef description
+		{
+			pcls->comment=$<stval>2;
+		}
+	;
+
+
+parentdef
+	: parent_header parent_name T_SEMICOLON
+        | parent_header parent_name parent_attributes T_SEMICOLON
+        ;
+
+parent_header
+	: T_PARENT T_CLASS T_COLON
+        | T_PARENT T_COLON 
+        ;
+
+parent_name
+	: T_IDENTIFIER
+		{
+			pcls->lineno=lineno;  // @todo line of class definition?
+			pcls->name=$<stval>1;
+		}
+	;
+
+parent_attributes
+	: T_COMMA parent_attribute
+	| parent_attributes T_COMMA parent_attribute
+	;
+
+parent_attribute
+	: T_FILE T_STEM T_EQUAL T_IDENTIFIER
+        | T_MAJOR T_VERSION T_EQUAL T_CONSTANT
+        | T_MINOR T_VERSION T_EQUAL T_CONSTANT
+        | visibility
+        ;
+
+passthru_section
+	: T_PASSTHRU
+        ;
+
+data_section
+	: data_header variables
+	;
+
+data_header
+	: T_DATA T_COLON
+	;
+
+variables
+	: declaration
+        | declaration variables
+        ;
+
+declaration
+	: declarationdef T_SEMICOLON
+	| declarationdef T_SEMICOLON description
+		{
+//			cls->comment=$<stval>2;
+		}
+	;
+
+declarationdef
+	: declaration_specifiers
+	| declaration_specifiers data_attributes
+	;
+
+data_attributes
+	: T_COMMA data_attribute
+	| data_attributes T_COMMA data_attribute
+	;
+
+data_attribute
+	: T_PRIVATE
+	| T_PUBLIC
+	| T_INTERNAL
+	| T_CLASS
+	;
+
+declaration_specifiers
+	: type_specifier declarator
+	| type_specifier declarator declaration_specifiers
+	;
+
+type_specifier
+	: T_IDENTIFIER 
+		{
+			$<stval>$=$<stval>1;
+		}
+	;
+
+declarator
+	: pointer direct_declarator
+	| direct_declarator
+	;
+
+direct_declarator
+	: T_IDENTIFIER {printf("$<stval>1");}
+	| T_LEFTPARENTHESIS declarator T_RIGHTPARENTHESIS
+	| direct_declarator T_LEFTSQUAREBRACKET T_CONSTANT T_RIGHTSQUAREBRACKET
+	| direct_declarator T_LEFTSQUAREBRACKET T_RIGHTSQUAREBRACKET
+	| direct_declarator T_LEFTPARENTHESIS declaration_specifiers T_RIGHTPARENTHESIS
+	| direct_declarator T_LEFTPARENTHESIS T_RIGHTPARENTHESIS
+	;
+
+pointer
+	: T_STAR
+		{
+			$<stval>$=$<stval>1;
+		}
+	| pointer T_STAR
+		{
+			char *r=somtsmallocSL(strlen($<stval>1)+strlen($<stval>2)+1, TRUE);
+			strcat(r, $<stval>1);
+			strcat(r, $<stval>2);
+			free($<stval>1);
+			$<stval>$=strdup(r);
+			somtfree(r);
+		}
+	;
+
+
+methods_section
+	: method_header method_list
+	| method_header description method_list
+		{
+			e.comment=$<stval>2;
+		}
+	;
+
+method_header
+	: T_METHODS T_COLON
+	;
+
+method_list
+	: method 
+		{
+			cls->u.c.methodcnt++;
+			somtaddEntrySL(somtstab, e.name, &e);
+			memset(&e, 0, sizeof(Entry));
+		}
+	| method_list method 
+		{
+			cls->u.c.methodcnt++;
+			somtaddEntrySL(somtstab, e.name, &e);
+			memset(&e, 0, sizeof(Entry));
+		}
+        ;
+
+method
+	: methoddef T_SEMICOLON 
+	| methoddef T_SEMICOLON description 
+	;
+
+methoddef
+	: method_specifier
+	| method_specifier method_attributes
+	| overridemethod_specifier
+	;
+
+method_specifier
+	: method_type method_name T_LEFTPARENTHESIS parameter_list T_RIGHTPARENTHESIS 
+		{
+			e.u.m.type=strdup($<stval>1);
+		}
+	;                                             
+
+method_name
+	: T_IDENTIFIER 
+		{
+			char * desc=somtsmallocSL(MAX_DESCRIPTOR_LENGTH, TRUE);
+			e.type=SOMTNewMethodE;
+			e.lineno=lineno;
+			e.name=$<stval>1;
+			e.sname=&somtclassName;
+			strcat(desc, "::");
+			strcat(desc, $<stval>1);
+			strcat(desc, "::");
+			strcat(desc, somtclassName);
+			e.atts=somtaddModifierSL(e.atts, "descriptor", desc);
+			somtfree(desc);
+		}
+	;
+
+method_type
+	: type_specifier
+		{
+			$<stval>$=$<stval>1;
+		}
+	| type_specifier pointer
+		{
+			char *r=somtsmallocSL(strlen($<stval>1)+strlen($<stval>2)+1, TRUE);
+			strcat(r, $<stval>1);
+			strcat(r, $<stval>2);
+			free($<stval>1);
+			$<stval>$=strdup(r);
+			somtfree(r);
+		}
+	;
+
+overridemethod_specifier
+	: overridemethod_header overridemethod_name
+	| overridemethod_header overridemethod_name overridemethod_attributes
+	;                                             
+
+overridemethod_header
+	: T_OVERRIDE
+	| T_OVERRIDE T_COLON
+	;
+
+overridemethod_name
+	: T_IDENTIFIER 
+		{
+			char * desc=somtsmallocSL(MAX_DESCRIPTOR_LENGTH, TRUE);
+			e.type=SOMTOverrideMethodE;
+			e.lineno=lineno;
+			e.name=$<stval>1;
+			e.sname=&somtclassName;
+			strcat(strcat(strcat(strcat(desc ,"::"), $<stval>1), "::"), somtclassName);
+			e.atts=somtaddModifierSL(e.atts, "descriptor", desc);
+			somtfree(desc);
+		}
+	;
+
+parameter_list
+	: parameter
+	| parameter_list T_COMMA parameter
+	;
+
+parameter
+	: T_ELLIPSIS
+	| type_specifier declarator
+	;
+
+method_attributes
+	: T_COMMA method_attribute
+	| method_attributes T_COMMA method_attribute
+	;
+
+method_attribute
+	: T_PRIVATE
+	| T_PUBLIC
+	| T_METHOD
+	| T_PROCEDURE
+	| T_CLASS
+	| T_OFFSET
+	| T_NAME T_LOOKUP
+	| T_LOCAL
+	| T_EXTERNAL
+	| T_USE T_EQUAL T_IDENTIFIER
+	;
+
+/* descriptor */
+/* noset */
+/* original */
+
+overridemethod_attributes
+	: T_COMMA overridemethod_attribute
+	| overridemethod_attributes T_COMMA overridemethod_attribute
+	;
+
+overridemethod_attribute
+	: T_PRIVATE
+	| T_PUBLIC
+	| T_CLASS
+	| T_LOCAL
+	| T_EXTERNAL
+	| T_USE T_EQUAL T_IDENTIFIER
+	;
+
+description
+	: T_COMMENT 
+		{
+			$<stval>$=$<stval>1;
+		}
+        ;
+
+%%
+
+FILE *yyin;
+
+// Experimental replacement of somttype
+char * mysomttype(SOMTTypes ttype)
+{
+  char * result=NULL;
+  switch ( ttype )
+  {
+    case SOMTAnyBE:
+      result="SOMTAnyBE";
+      break;
+    case     SOMTArgumentE:
+      result="SOMTArgumentE";
+      break;
+    case     SOMTAttE:
+      result="SOMTAttE";
+      break;
+    case     SOMTBadEntryE:
+      result="SOMTBadEntryE";
+      break;
+    case     SOMTBaseE:
+      result="SOMTBaseE";
+      break;
+    case     SOMTBooleanBE:
+      result="SOMTBooleanBE";
+      break;
+    case     SOMTCaseEntryE:
+      result="SOMTCaseEntryE";
+      break;
+    case     SOMTCaseListE:
+      result="SOMTCaseListE";
+      break;
+    case     SOMTCaseSTME:
+      result="SOMTCaseSTME";
+      break;
+    case     SOMTCharBE:
+      result="SOMTCharBE";
+      break;
+    case     SOMTClassE:
+      result="SOMTClassE";
+      break;
+    case     SOMTConstE:
+      result="SOMTConstE";
+      break;
+    case     SOMTCopyrightE:
+      result="SOMTCopyrightE";
+      break;
+    case     SOMTDataE:
+      result="SOMTDataE";
+      break;
+    case     SOMTDclListE:
+      result="SOMTDclListE";
+      break;
+    case     SOMTDefaultE:
+      result="SOMTDefaultE";
+      break;
+    case     SOMTDoubleBE:
+      result="SOMTDoubleBE";
+      break;
+    case     SOMTEBaseE:
+      result="SOMTEBaseE";
+      break;
+    case     SOMTEEnumE:
+      result="SOMTEEnumE";
+      break;
+    case     SOMTEnumBE:
+      result="SOMTEnumBE";
+      break;
+    case     SOMTEnumE:
+      result="SOMTEnumE";
+      break;
+    case     SOMTEnumPE:
+      result="SOMTEnumPE";
+      break;
+    case     SOMTFloatBE:
+      result="SOMTFloatBE";
+      break;
+    case     SOMTGroupE:
+      result="SOMTGroupE";
+      break;
+    case     SOMTLongBE:
+      result="SOMTLongBE";
+      break;
+    case     SOMTMetaE:
+      result="SOMTMetaE";
+      break;
+    case     SOMTModuleE:
+      result="SOMTModuleE";
+      break;
+    case     SOMTNegativeBE:
+      result="SOMTNegativeBE";
+      break;
+    case     SOMTNewMethodE:
+      result="SOMTNewMethodE";
+      break;
+    case     SOMTOctetBE:
+      result="SOMTOctetBE";
+      break;
+    case     SOMTOverriddenMethodE:
+      result="SOMTOverriddenMethodE";
+      break;
+    case     SOMTOverrideMethodE:
+      result="SOMTOverrideMethodE";
+      break;
+    case     SOMTPassthruE:
+      result="SOMTPassthruE";
+      break;
+    case     SOMTSequenceE:
+      result="SOMTSequenceE";
+      break;
+    case     SOMTSequenceTDE:
+      result="SOMTSequenceTDE";
+      break;
+    case     SOMTShortBE:
+      result="SOMTShortBE";
+      break;
+    case     SOMTStringBE:
+      result="SOMTStringBE";
+      break;
+    case     SOMTStringE:
+      result="SOMTStringE";
+      break;
+    case     SOMTStructE:
+      result="SOMTStructE";
+      break;
+    case     SOMTStructPE:
+      result="SOMTStructPE";
+      break;
+    case     SOMTStructSE:
+      result="SOMTStructSE";
+      break;
+    case     SOMTTyDclE:
+      result="SOMTTyDclE";
+      break;
+    case     SOMTTypeCodeBE:
+      result="SOMTTypeCodeBE";
+      break;
+    case     SOMTTypedefBE:
+      result="SOMTTypedefBE";
+      break;
+    case     SOMTTypedefE:
+      result="SOMTTypedefE";
+      break;
+    case     SOMTUnionE:
+      result="SOMTUnionE";
+      break;
+    case     SOMTUnionPE:
+      result="SOMTUnionPE";
+      break;
+    case     SOMTUnionSE:
+      result="SOMTUnionSE";
+      break;
+    case     SOMTUnsignedLongBE:
+      result="SOMTUnsignedLongBE";
+      break;
+    case     SOMTUnsignedShortBE:
+      result="SOMTUnsignedShortBE";
+      break;
+    case     SOMTVoidBE:
+      result="SOMTVoidBE";
+      break;
+    case     SOMTVoidPtrBE:
+      result="SOMTVoidPtrBE";
+      break;
+// This is special case SOMTTypes used on call of emitter start and emitter end
+/*    case     SOMTEmitterBeginE:
+      result="SOMTEmitterBeginE";
+      break;
+    case     SOMTEmitterEndE:
+      result="SOMTEmitterEndE";
+      break; */
+    default:
+      printf("Unknown entry type: %d.\n", ttype);
+  }
+  return result;
+}
+
+void dumpReleaseOrder(char * name, AttList *ap)
+{
+  AttList *cur=ap;
+
+  for(; cur; cur = cur->next) 
+  {
+    printf("\t%s %s\n", name, cur->name);
+//    dumpAttrs("static", cur->staticlist);
+//    dumpAttrs("protectted", cur->protectedlist);
+//    dumpAttrs("public", cur->publiclist);
+//    dumpAttrs("private", cur->privatelist);
+  }
+}
+
+void dumpMethodOrData(Entry * ep)
+{
+  printf("\teptype = %08p\n", ep->u.m.eptype);
+  printf("\tptrs = %08p\n", ep->u.m.ptrs);
+  printf("\tarray = %08p\n", ep->u.m.array);
+  printf("\tarrays = %s\n", ep->u.m.arrays);
+  printf("\tdefn = %s\n", ep->u.m.defn);
+  printf("\ttype = %s\n", ep->u.m.type);
+  printf("\tvarargs = %s\n", ep->u.m.varargs ? "true" : "false");
+  printf("\tprivate = %s\n", ep->u.m.isprivate ? "true" : "false");
+  printf("\tinout = %d\n", ep->u.m.inoutmode);
+  printf("\tselfref = %s\n", ep->u.m.isselfref ? "true" : "false");
+  printf("\toneway = %s\n", ep->u.m.isoneway ? "true" : "false");
+  printf("\targcnt = %d\n", ep->u.m.argcnt);
+  printf("\targs = %08p\n", ep->u.m.args);
+  printf("\tomethod = %08p\n", ep->u.m.omethod);
+  printf("\toparent = %08p\n", ep->u.m.oparent);
+  printf("\tgroup = %08p\n", ep->u.m.group);
+  printf("\tnext = %08p\n", ep->u.m.next);
+  printf("\tctxsa = %08p\n", ep->u.m.ctxsa);
+  printf("\traiseslist = %08p\n", ep->u.m.raiseslist);
+}
+
+void mysomtShowEntry(Entry * ep)
+{
+  if (ep)
+  {
+    printf("      somtShowEntry: Entry at %08p, name = %s, type = %d\n", ep, ep->name, ep->type);
+    printf("\tlineno = %d\n", ep->lineno);
+    switch ( ep->type )
+    {
+      case SOMTAnyBE:
+        printf("\t SOMTAnyBE\n");
+        break;
+      case     SOMTArgumentE:
+        printf("\t SOMTArgumentE\n");
+        dumpMethodOrData(ep);
+        break;
+      case     SOMTAttE:
+        printf("\t SOMTAttE\n");
+        break;
+      case     SOMTBadEntryE:
+        printf("\t SOMTBadEntryE\n");
+        break;
+      case     SOMTBaseE:
+        printf("\t SOMTBaseE\n");
+        printf("\tparentdef = %08p\n", ep->u.p.parentdef);
+        break;
+      case     SOMTBooleanBE:
+        printf("\t SOMTBooleanBE\n");
+        break;
+      case     SOMTCaseEntryE:
+        printf("\t SOMTCaseEntryE\n");
+        break;
+      case     SOMTCaseListE:
+        printf("\t SOMTCaseListE\n");
+        break;
+      case     SOMTCaseSTME:
+        printf("\t SOMTCaseSTME\n");
+        break;
+      case     SOMTCharBE:
+        printf("\t SOMTCharBE\n");
+        break;
+      case     SOMTClassE:
+        printf("\tClass Definition Entry:\n");
+        printf("\tfile = %s\n", ep->u.c.file);
+        printf("\tmeta = %08p\n", ep->u.c.meta);
+        printf("\tparent = %08p\n", ep->u.c.parent);
+        printf("\tparents = %08p\n", ep->u.c.parents);
+        printf("\trelease = %08p\n", ep->u.c.release);
+	dumpReleaseOrder("\t", ep->u.c.release);
+        printf("\tpassthru = %08p\n", ep->u.c.passthrus);
+        printf("\tdata = %08p\n", ep->u.c.data);
+        printf("\ttc = %08p\n", ep->tc);
+        printf("\tmethodcnt = %08d\n", ep->u.c.methodcnt);
+        printf("\tmethods = %08p\n", ep->u.c.methods);
+        printf("\tinherited = %08p\n", ep->u.c.inherited);
+        printf("\tpubdefs = %08p\n", ep->u.c.pubdefs);
+        printf("\tmod = %08p\n", ep->u.c.mod);
+        printf("\tcls = %08p\n", ep->u.c.cls);
+        printf("\tforward = %s\n", ep->u.c.isforward ? "true" : "false");
+        break;
+      case     SOMTConstE:
+        printf("\t SOMTConstE\n");
+        break;
+      case     SOMTCopyrightE:
+        printf("\t SOMTCopyrightE\n");
+        break;
+      case     SOMTDataE:
+        printf("\t SOMTDataE\n");
+        dumpMethodOrData(ep);
+        break;
+      case     SOMTDclListE:
+        printf("\t SOMTDclListE\n");
+        break;
+      case     SOMTDefaultE:
+        printf("\t SOMTDefaultE\n");
+        break;
+      case     SOMTDoubleBE:
+        printf("\t SOMTDoubleBE\n");
+        break;
+      case     SOMTEBaseE:
+        printf("\t SOMTEBaseE\n");
+        break;
+      case     SOMTEEnumE:
+        printf("\t SOMTEEnumE\n");
+        break;
+      case     SOMTEnumBE:
+        printf("\t SOMTEnumBE\n");
+        break;
+      case     SOMTEnumE:
+        printf("\t SOMTEnumE\n");
+        break;
+      case     SOMTEnumPE:
+        printf("\t SOMTEnumPE\n");
+        break;
+      case     SOMTFloatBE:
+        printf("\t SOMTFloatBE\n");
+        break;
+      case     SOMTGroupE:
+        printf("\t SOMTGroupE\n");
+        break;
+      case     SOMTLongBE:
+        printf("\t SOMTLongBE\n");
+        break;
+      case     SOMTMetaE:
+        printf("\t SOMTMetaE\n");
+        break;
+      case     SOMTModuleE:
+        printf("\t SOMTModuleE\n");
+        break;
+      case     SOMTNegativeBE:
+        printf("\t SOMTNegativeBE\n");
+        break;
+      case     SOMTNewMethodE:
+        printf("\t SOMTNewMethodE\n");
+        dumpMethodOrData(ep);
+        break;
+      case     SOMTOctetBE:
+        printf("\t SOMTOctetBE\n");
+        break;
+      case     SOMTOverriddenMethodE:
+        printf("\t SOMTOverriddenMethodE\n");
+        dumpMethodOrData(ep);
+        break;
+      case     SOMTOverrideMethodE:
+        printf("\t SOMTOverrideMethodE\n");
+        dumpMethodOrData(ep);
+        break;
+      case     SOMTPassthruE:
+        printf("\t SOMTPassthruE\n");
+        break;
+      case     SOMTSequenceE:
+        printf("\t SOMTSequenceE\n");
+        break;
+      case     SOMTSequenceTDE:
+        printf("\t SOMTSequenceTDE\n");
+        break;
+      case     SOMTShortBE:
+        printf("\t SOMTShortBE\n");
+        break;
+      case     SOMTStringBE:
+        printf("\t SOMTStringBE\n");
+        break;
+      case     SOMTStringE:
+        printf("\t SOMTStringE\n");
+        break;
+      case     SOMTStructE:
+        printf("\t SOMTStructE\n");
+        break;
+      case     SOMTStructPE:
+        printf("\t SOMTStructPE\n");
+        break;
+      case     SOMTStructSE:
+        printf("\t SOMTStructSE\n");
+        printf("\tdcllist = %08p\n", ep->u.struc.dcllist);
+        printf("\tcls = %08p\n", ep->u.struc.cls);
+        printf("\texception = %s\n", ep->u.struc.isexcept ? "true" : "false");
+        printf("\tmutref = %s\n", ep->u.struc.ismutref ? "true" : "false");
+        break;
+      case     SOMTTyDclE:
+        printf("\t SOMTTyDclE\n");
+        break;
+      case     SOMTTypeCodeBE:
+        printf("\t SOMTTypeCodeBE\n");
+        break;
+      case     SOMTTypedefBE:
+        printf("\t SOMTTypedefBE\n");
+        dumpMethodOrData(ep);
+        break;
+      case     SOMTTypedefE:
+        printf("\t SOMTTypedefE\n");
+        break;
+      case     SOMTUnionE:
+        printf("\t SOMTUnionE\n");
+        break;
+      case     SOMTUnionPE:
+        printf("\t SOMTUnionPE\n");
+        break;
+      case     SOMTUnionSE:
+        printf("\t SOMTUnionSE\n");
+        break;
+      case     SOMTUnsignedLongBE:
+        printf("\t SOMTUnsignedLongBE\n");
+        break;
+      case     SOMTUnsignedShortBE:
+        printf("\t SOMTUnsignedShortBE\n");
+        break;
+      case     SOMTVoidBE:
+        printf("\t SOMTVoidBE\n");
+        break;
+      case     SOMTVoidPtrBE:
+        printf("\t SOMTVoidPtrBE\n");
+        dumpMethodOrData(ep);
+        break;
+  // This is special case SOMTTypes used on call of emitter start and emitter end
+  /*    case     SOMTEmitterBeginE:
+        result="SOMTEmitterBeginE";
+        break;
+      case     SOMTEmitterEndE:
+        result="SOMTEmitterEndE";
+        break; */
+      default:
+        printf("Error: somtShowEntry, bad entry type of %d", ep->type);
+//        SOM_Error(SOM_Fatal, __FILE__, __LINE__);
+//        SOMError(9, __FILE__, __LINE__);
+    }
+  }
+  else 
+  {
+    printf("somtShowEntry: NULL entry\n");
+  }
+}
+
+void dumpAttrs(AttList *ap)
+{
+  struct AttList *cur = ap;
+
+  for(cur = ap; cur; cur = cur->next) 
+  {
+    printf("\tModifier %s=%s\n", cur->name, cur->value);
+  }
+}
+
+
+void mydumpEntry(Entry * ep)
+{
+  printf("Entry at address %p\n", ep);
+  printf("--------------------------\n");
+  printf("Entry type: %s (%d)\n", mysomttype(ep->type), ep->type);
+//  printf("Entry type: %s (%d)\n", somtEntryTypeName(ep->type), ep->type);
+  if (ep->sname) printf("Scoped name: %s\n", *ep->sname);
+  if (ep->comment) printf("Comment associated with entry: %s\n", ep->comment);
+  printf("Modifiers: %p\n", ep->atts);
+  if (ep->atts) dumpAttrs(ep->atts);
+  printf("TypeCode: %p\n", ep->tc);
+  printf("Points to the object: %p\n", ep->objref);
+  printf("Reference to real type: %s\n", ep->isref ? "true" : "false");
+  printf("Entry union: %p\n", &ep->u);
+#ifdef __PRIVATE__
+//    RHBelement *data;
+//    char *filestem;
+#endif    
+  mysomtShowEntry(ep);
+//  somtShowEntry(ep);
+};
+
+void dumpSep(Sep * sep)
+{
+    printf("Linked list item at address %p\n", sep);
+    printf("---------------------------------------\n");
+    printf("Position number: %d\n", sep->posn);
+    printf("Address of Entry: %p\n", sep->ep);
+    printf("Next linked list item address: %p\n", sep->next);
+    if (sep->ep) 
+    {
+      mydumpEntry((Entry *)sep->ep);
+      dumpSep(sep->next);
+    }
+}
+
+void dumpStab(Stab * stab)
+{
+  unsigned int i;
+  printf("Basic Symbol Table/Hash table (STab) structure\n");
+  printf("----------------------------------------------\n");
+  printf("Size of buscet: %d\n", stab->size);
+  printf("Size of entry structure: %d\n", stab->entrysize);
+  printf("Number of elements: %d\n", stab->nelms);
+  printf("Address of base slot: %p\n", stab->base);
+  printf("Max address of slot: %p\n", stab->limit);
+  printf("Start address of slot buffer: %p\n", stab->buf);
+  printf("Address of MemBuf: %p\n", stab->membuf);
+  printf("Ignore case flag: %s\n", stab->ignorecase ? "true" : "false");
+  for(i=0; i<stab->size;i++)
+  {
+    printf("Linked list at slot %d at offset %08x at address %p\n", i, sizeof(Sep)*i, stab->buf+i);
+    printf("----------------------\n");
+    dumpSep(stab->buf+i);
+  }
+}
+
+
+void usage(void)
+{
+  printf("\nSC [-options] file[.CSC]\n");
+  printf("\n-C n\n\tset the size of the comment buffer (default: 16384)\n");
+  printf("\n-s n\n\tset the total amount of string space for names and passthru lines (default: 32768)\n");
+  printf("\n-V\n\tdisplay version information\n");
+  printf("\n-a name[=value]\n\tadd a global attribute. The currently supported attributes are defined below (at the end of this section)\n");
+  printf("\n-d directory\n\tspecify a directory where all files emitted during the execution of this command should be placed. If the -d option is not used, all emitted output files are placed in the same directory as the input .csc file\n");
+  printf("\n-h or ?\n\tprovide usage information for reference\n");
+  printf("\n-i filename\n\tspecify the name of the OIDL class definition file. Use this option to override the built-in assumption that the input file will have a .csc extension. Any filename you supply with the -i option is used exactly as you provide it\n");
+  printf("\n-r\n\tcheck that all release-order entries actually exist (default: FALSE)\n");
+  printf("\n-s string\n\tsubstitute string in place of the contents of the SMEMIT environment variable for the duration of the current SC command. If you supply a list of values, you\n");
+  printf("must enclose the list with double quotation marks (\" \"). You can use the -s option as a convenient way to override the SMEMIT environment variable. For example:\n\n");
+  printf("SC -s \"h;sc\" EXAMPLE\n\n");
+  printf("is equivalent to the following sequence of commands:\n\n");
+  printf("SET OLDSMEMIT = %%SMEMIT%%\n");
+  printf("SET SMEMIT = h;sc\n");
+  printf("SC EXAMPLE\n");
+  printf("SET SMEMIT = %%OLDSMEMIT%%\n");
+  printf("\n-w\n\tsuppress warning messages (default: FALSE)\n\n");
+  printf("The only global attributes currently supported by SC.EXE are:\n");
+  printf("\ncomment = comment string\n\twhere comment string can be one of the following: \"/*\", \"--\", or \"//\". This\n");
+  printf("indicates that comments marked in the indicated way are to be completely\n");
+  printf("ignored by SC.EXE and not retained for subsequent processing by one of the\n");
+  printf("emitters.\n");
+  printf("Note: Comments indicated by lines whose first non-white-space character is\n");
+  printf("a # are always ignored by SC.EXE. Also note that comments of any\n");
+  printf("form in passthru lines are passed through.\n");
+  printf("\ncstyle = comment style\n\tcontrols the form of emitted comments. Comment style must be one of s, c, or\n");
+  printf("+ to cause emitted comments to be in \"--\", \"/* */\", or \"//\" form , respectively\n");
+  printf("The default form is s\n");
+  printf("\nibmc\n\tcauses EMITC, EMITH, EMITIH, EMITPH, and EMITDEF to generate code with\n");
+  printf("pragmas specifically intended for the IBM C Set/2 Compiler. This attribute is\n");
+  printf("specified by default\n");
+  printf("\ncl386\n\tcauses EMITC, EMITH, EMITIH, EMITPH, and EMITDEF not to generate code\n");
+  printf("with pragmas specifically intended for the IBM C Set/2 Compiler\n");
+}
+
+void parse_file(char * file)
+{
+  // parser input stream
+  yyin=fopen(file,"r");
+
+  strcpy(somtfilePath, file);
+
+  // Initialize symbol table
+  somtstab=(Stab *)somtsmallocSL(sizeof(Stab), 0);
+  somtcreateStabSL(somtstab, HASH_SIZE, sizeof(Entry));
+
+  yyparse();
+
+  dumpStab(somtstab);
+}
+
+void emit_file(char * file)
+{
+   EmitFn proc;
+   FILE * fp;
+   HMODULE hmod;
+   Entry * root;
+   Stab * stab;
+
+   proc=somtloadSL("emitpsc.dll", "emitSL", (void**)&hmod);
+
+   fp=proc(file, root, stab);
+
+   if (fp) somtfcloseSL(fp);
+}
+
+void main(int argc, char *argv[])
+{
+#if YYDEBUG != 0
+   yydebug =1 ;
+#endif
+
+//   parse_args(argc, argv);
+
+   usage();
+
+   parse_file(argv[1]);
+
+//   dump();
+
+//   emit_file(argv[1]);
+}
diff -urN somfree-old/spp/src/spp.c somfree/spp/src/spp.c
--- somfree-old/spp/src/spp.c	2024-09-13 06:03:41.198811111 +0300
+++ somfree/spp/src/spp.c	2024-09-13 05:56:58.362026992 +0300
@@ -1,150 +1,187 @@
-#line 2 "spp.c"
-/* A lexical scanner generated by flex */
 
-/* Scanner skeleton version:
- * $Header: /home/daffy/u0/vern/flex/RCS/flex.skl,v 2.91 96/09/10 16:58:48 vern Exp $
- */
+#line 3 "lex.yy.c"
+
+#define  YY_INT_ALIGNED short int
+
+/* A lexical scanner generated by flex */
 
 #define FLEX_SCANNER
 #define YY_FLEX_MAJOR_VERSION 2
-#define YY_FLEX_MINOR_VERSION 5
-
-#ifdef __CRTRSXNT__
-#include <crtrsxnt.h>
-#endif
+#define YY_FLEX_MINOR_VERSION 6
+#define YY_FLEX_SUBMINOR_VERSION 4
+#if YY_FLEX_SUBMINOR_VERSION > 0
+#define FLEX_BETA
+#endif
+
+/* First, we deal with  platform-specific or compiler-specific issues. */
+
+/* begin standard C headers. */
 #include <stdio.h>
+#include <string.h>
+#include <errno.h>
+#include <stdlib.h>
+
+/* end standard C headers. */
+
+/* flex integer type definitions */
+
+#ifndef FLEXINT_H
+#define FLEXINT_H
+
+/* C99 systems have <inttypes.h>. Non-C99 systems may or may not. */
+
+#if defined (__STDC_VERSION__) && __STDC_VERSION__ >= 199901L
+
+/* C99 says to define __STDC_LIMIT_MACROS before including stdint.h,
+ * if you want the limit (max/min) macros for int types. 
+ */
+#ifndef __STDC_LIMIT_MACROS
+#define __STDC_LIMIT_MACROS 1
+#endif
+
+#include <inttypes.h>
+typedef int8_t flex_int8_t;
+typedef uint8_t flex_uint8_t;
+typedef int16_t flex_int16_t;
+typedef uint16_t flex_uint16_t;
+typedef int32_t flex_int32_t;
+typedef uint32_t flex_uint32_t;
+#else
+typedef signed char flex_int8_t;
+typedef short int flex_int16_t;
+typedef int flex_int32_t;
+typedef unsigned char flex_uint8_t; 
+typedef unsigned short int flex_uint16_t;
+typedef unsigned int flex_uint32_t;
+
+/* Limits of integral types. */
+#ifndef INT8_MIN
+#define INT8_MIN               (-128)
+#endif
+#ifndef INT16_MIN
+#define INT16_MIN              (-32767-1)
+#endif
+#ifndef INT32_MIN
+#define INT32_MIN              (-2147483647-1)
+#endif
+#ifndef INT8_MAX
+#define INT8_MAX               (127)
+#endif
+#ifndef INT16_MAX
+#define INT16_MAX              (32767)
+#endif
+#ifndef INT32_MAX
+#define INT32_MAX              (2147483647)
+#endif
+#ifndef UINT8_MAX
+#define UINT8_MAX              (255U)
+#endif
+#ifndef UINT16_MAX
+#define UINT16_MAX             (65535U)
+#endif
+#ifndef UINT32_MAX
+#define UINT32_MAX             (4294967295U)
+#endif
+
+#ifndef SIZE_MAX
+#define SIZE_MAX               (~(size_t)0)
+#endif
 
+#endif /* ! C99 */
 
-/* cfront 1.2 defines "c_plusplus" instead of "__cplusplus" */
-#ifdef c_plusplus
-#ifndef __cplusplus
-#define __cplusplus
-#endif
-#endif
-
-
-#ifdef __cplusplus
-
-#include <stdlib.h>
-#include <unistd.h>
-
-/* Use prototypes in function declarations. */
-#define YY_USE_PROTOS
-
-/* The "const" storage-class-modifier is valid. */
-#define YY_USE_CONST
+#endif /* ! FLEXINT_H */
 
-#else	/* ! __cplusplus */
+/* begin standard C++ headers. */
 
-#if __STDC__
-
-#define YY_USE_PROTOS
-#define YY_USE_CONST
-
-#endif	/* __STDC__ */
-#endif	/* ! __cplusplus */
-
-#ifdef __TURBOC__
- #pragma warn -rch
- #pragma warn -use
-#include <io.h>
-#include <stdlib.h>
-#define YY_USE_CONST
-#define YY_USE_PROTOS
-#endif
-
-#ifdef YY_USE_CONST
+/* TODO: this is always defined, so inline it */
 #define yyconst const
-#else
-#define yyconst
-#endif
 
-
-#ifdef YY_USE_PROTOS
-#define YY_PROTO(proto) proto
+#if defined(__GNUC__) && __GNUC__ >= 3
+#define yynoreturn __attribute__((__noreturn__))
 #else
-#define YY_PROTO(proto) ()
+#define yynoreturn
 #endif
 
 /* Returned upon end-of-file. */
 #define YY_NULL 0
 
-/* Promotes a possibly negative, possibly signed char to an unsigned
- * integer for use as an array index.  If the signed char is negative,
- * we want to instead treat it as an 8-bit unsigned char, hence the
- * double cast.
+/* Promotes a possibly negative, possibly signed char to an
+ *   integer in range [0..255] for use as an array index.
  */
-#define YY_SC_TO_UI(c) ((unsigned int) (unsigned char) c)
+#define YY_SC_TO_UI(c) ((YY_CHAR) (c))
 
 /* Enter a start condition.  This macro really ought to take a parameter,
  * but we do it the disgusting crufty way forced on us by the ()-less
  * definition of BEGIN.
  */
-#define BEGIN yy_start = 1 + 2 *
-
+#define BEGIN (yy_start) = 1 + 2 *
 /* Translate the current start state into a value that can be later handed
  * to BEGIN to return to the state.  The YYSTATE alias is for lex
  * compatibility.
  */
-#define YY_START ((yy_start - 1) / 2)
+#define YY_START (((yy_start) - 1) / 2)
 #define YYSTATE YY_START
-
 /* Action number for EOF rule of a given start state. */
 #define YY_STATE_EOF(state) (YY_END_OF_BUFFER + state + 1)
-
 /* Special action meaning "start processing a new file". */
 #define YY_NEW_FILE yyrestart( yyin )
-
 #define YY_END_OF_BUFFER_CHAR 0
 
 /* Size of default input buffer. */
+#ifndef YY_BUF_SIZE
+#ifdef __ia64__
+/* On IA-64, the buffer size is 16k, not 8k.
+ * Moreover, YY_BUF_SIZE is 2*YY_READ_BUF_SIZE in the general case.
+ * Ditto for the __ia64__ case accordingly.
+ */
+#define YY_BUF_SIZE 32768
+#else
 #define YY_BUF_SIZE 16384
+#endif /* __ia64__ */
+#endif
 
+/* The state buf must be large enough to hold one state per character in the main buffer.
+ */
+#define YY_STATE_BUF_SIZE   ((YY_BUF_SIZE + 2) * sizeof(yy_state_type))
+
+#ifndef YY_TYPEDEF_YY_BUFFER_STATE
+#define YY_TYPEDEF_YY_BUFFER_STATE
 typedef struct yy_buffer_state *YY_BUFFER_STATE;
+#endif
+
+#ifndef YY_TYPEDEF_YY_SIZE_T
+#define YY_TYPEDEF_YY_SIZE_T
+typedef size_t yy_size_t;
+#endif
 
 extern int yyleng;
+
 extern FILE *yyin, *yyout;
 
 #define EOB_ACT_CONTINUE_SCAN 0
 #define EOB_ACT_END_OF_FILE 1
 #define EOB_ACT_LAST_MATCH 2
 
-/* The funky do-while in the following #define is used to turn the definition
- * int a single C statement (which needs a semi-colon terminator).  This
- * avoids problems with code like:
- *
- * 	if ( condition_holds )
- *		yyless( 5 );
- *	else
- *		do_something_else();
- *
- * Prior to using the do-while the compiler would get upset at the
- * "else" because it interpreted the "if" statement as being all
- * done when it reached the ';' after the yyless() call.
- */
-
-/* Return all but the first 'n' matched characters back to the input stream. */
+    #define YY_LESS_LINENO(n)
+    #define YY_LINENO_REWIND_TO(ptr)
 
+/* Return all but the first "n" matched characters back to the input stream. */
 #define yyless(n) \
 	do \
 		{ \
 		/* Undo effects of setting up yytext. */ \
-		*yy_cp = yy_hold_char; \
+        int yyless_macro_arg = (n); \
+        YY_LESS_LINENO(yyless_macro_arg);\
+		*yy_cp = (yy_hold_char); \
 		YY_RESTORE_YY_MORE_OFFSET \
-		yy_c_buf_p = yy_cp = yy_bp + n - YY_MORE_ADJ; \
+		(yy_c_buf_p) = yy_cp = yy_bp + yyless_macro_arg - YY_MORE_ADJ; \
 		YY_DO_BEFORE_ACTION; /* set up yytext again */ \
 		} \
 	while ( 0 )
+#define unput(c) yyunput( c, (yytext_ptr)  )
 
-#define unput(c) yyunput( c, yytext_ptr )
-
-/* The following is because we cannot portably get our hands on size_t
- * (without autoconf's help, which isn't available because we want
- * flex-generated scanners to compile on their own).
- */
-typedef unsigned int yy_size_t;
-
-
+#ifndef YY_STRUCT_YY_BUFFER_STATE
+#define YY_STRUCT_YY_BUFFER_STATE
 struct yy_buffer_state
 	{
 	FILE *yy_input_file;
@@ -155,7 +192,7 @@
 	/* Size of input buffer in bytes, not including room for EOB
 	 * characters.
 	 */
-	yy_size_t yy_buf_size;
+	int yy_buf_size;
 
 	/* Number of characters read into yy_ch_buf, not including EOB
 	 * characters.
@@ -181,12 +218,16 @@
 	 */
 	int yy_at_bol;
 
+    int yy_bs_lineno; /**< The line count. */
+    int yy_bs_column; /**< The column count. */
+
 	/* Whether to try to fill the input buffer when we reach the
 	 * end of it.
 	 */
 	int yy_fill_buffer;
 
 	int yy_buffer_status;
+
 #define YY_BUFFER_NEW 0
 #define YY_BUFFER_NORMAL 1
 	/* When an EOF's been seen but there's still some text to process
@@ -200,28 +241,37 @@
 	 * just pointing yyin at a new input file.
 	 */
 #define YY_BUFFER_EOF_PENDING 2
+
 	};
+#endif /* !YY_STRUCT_YY_BUFFER_STATE */
 
-static YY_BUFFER_STATE yy_current_buffer = 0;
+/* Stack of input buffers. */
+static size_t yy_buffer_stack_top = 0; /**< index of top of stack. */
+static size_t yy_buffer_stack_max = 0; /**< capacity of stack. */
+static YY_BUFFER_STATE * yy_buffer_stack = NULL; /**< Stack as an array. */
 
 /* We provide macros for accessing buffer states in case in the
  * future we want to put the buffer states in a more general
  * "scanner state".
+ *
+ * Returns the top of the stack, or NULL.
  */
-#define YY_CURRENT_BUFFER yy_current_buffer
-
+#define YY_CURRENT_BUFFER ( (yy_buffer_stack) \
+                          ? (yy_buffer_stack)[(yy_buffer_stack_top)] \
+                          : NULL)
+/* Same as previous macro, but useful when we know that the buffer stack is not
+ * NULL or when we need an lvalue. For internal use only.
+ */
+#define YY_CURRENT_BUFFER_LVALUE (yy_buffer_stack)[(yy_buffer_stack_top)]
 
 /* yy_hold_char holds the character lost when yytext is formed. */
 static char yy_hold_char;
-
 static int yy_n_chars;		/* number of characters read into yy_ch_buf */
-
-
 int yyleng;
 
 /* Points to current character in buffer. */
-static char *yy_c_buf_p = (char *) 0;
-static int yy_init = 1;		/* whether we need to initialize */
+static char *yy_c_buf_p = NULL;
+static int yy_init = 0;		/* whether we need to initialize */
 static int yy_start = 0;	/* start state number */
 
 /* Flag which is used to allow yywrap()'s to do buffer switches
@@ -229,66 +279,88 @@
  */
 static int yy_did_buffer_switch_on_eof;
 
-void yyrestart YY_PROTO(( FILE *input_file ));
-
-void yy_switch_to_buffer YY_PROTO(( YY_BUFFER_STATE new_buffer ));
-void yy_load_buffer_state YY_PROTO(( void ));
-YY_BUFFER_STATE yy_create_buffer YY_PROTO(( FILE *file, int size ));
-void yy_delete_buffer YY_PROTO(( YY_BUFFER_STATE b ));
-void yy_init_buffer YY_PROTO(( YY_BUFFER_STATE b, FILE *file ));
-void yy_flush_buffer YY_PROTO(( YY_BUFFER_STATE b ));
-#define YY_FLUSH_BUFFER yy_flush_buffer( yy_current_buffer )
-
-YY_BUFFER_STATE yy_scan_buffer YY_PROTO(( char *base, yy_size_t size ));
-YY_BUFFER_STATE yy_scan_string YY_PROTO(( yyconst char *yy_str ));
-YY_BUFFER_STATE yy_scan_bytes YY_PROTO(( yyconst char *bytes, int len ));
-
-static void *yy_flex_alloc YY_PROTO(( yy_size_t ));
-static void *yy_flex_realloc YY_PROTO(( void *, yy_size_t ));
-static void yy_flex_free YY_PROTO(( void * ));
+void yyrestart ( FILE *input_file  );
+void yy_switch_to_buffer ( YY_BUFFER_STATE new_buffer  );
+YY_BUFFER_STATE yy_create_buffer ( FILE *file, int size  );
+void yy_delete_buffer ( YY_BUFFER_STATE b  );
+void yy_flush_buffer ( YY_BUFFER_STATE b  );
+void yypush_buffer_state ( YY_BUFFER_STATE new_buffer  );
+void yypop_buffer_state ( void );
+
+static void yyensure_buffer_stack ( void );
+static void yy_load_buffer_state ( void );
+static void yy_init_buffer ( YY_BUFFER_STATE b, FILE *file  );
+#define YY_FLUSH_BUFFER yy_flush_buffer( YY_CURRENT_BUFFER )
+
+YY_BUFFER_STATE yy_scan_buffer ( char *base, yy_size_t size  );
+YY_BUFFER_STATE yy_scan_string ( const char *yy_str  );
+YY_BUFFER_STATE yy_scan_bytes ( const char *bytes, int len  );
+
+void *yyalloc ( yy_size_t  );
+void *yyrealloc ( void *, yy_size_t  );
+void yyfree ( void *  );
 
 #define yy_new_buffer yy_create_buffer
-
 #define yy_set_interactive(is_interactive) \
 	{ \
-	if ( ! yy_current_buffer ) \
-		yy_current_buffer = yy_create_buffer( yyin, YY_BUF_SIZE ); \
-	yy_current_buffer->yy_is_interactive = is_interactive; \
+	if ( ! YY_CURRENT_BUFFER ){ \
+        yyensure_buffer_stack (); \
+		YY_CURRENT_BUFFER_LVALUE =    \
+            yy_create_buffer( yyin, YY_BUF_SIZE ); \
+	} \
+	YY_CURRENT_BUFFER_LVALUE->yy_is_interactive = is_interactive; \
 	}
-
 #define yy_set_bol(at_bol) \
 	{ \
-	if ( ! yy_current_buffer ) \
-		yy_current_buffer = yy_create_buffer( yyin, YY_BUF_SIZE ); \
-	yy_current_buffer->yy_at_bol = at_bol; \
-	}
-
-#define YY_AT_BOL() (yy_current_buffer->yy_at_bol)
+	if ( ! YY_CURRENT_BUFFER ){\
+        yyensure_buffer_stack (); \
+		YY_CURRENT_BUFFER_LVALUE =    \
+            yy_create_buffer( yyin, YY_BUF_SIZE ); \
+	} \
+	YY_CURRENT_BUFFER_LVALUE->yy_at_bol = at_bol; \
+	}
+#define YY_AT_BOL() (YY_CURRENT_BUFFER_LVALUE->yy_at_bol)
+
+/* Begin user sect3 */
+typedef flex_uint8_t YY_CHAR;
+
+FILE *yyin = NULL, *yyout = NULL;
 
-typedef unsigned char YY_CHAR;
-FILE *yyin = (FILE *) 0, *yyout = (FILE *) 0;
 typedef int yy_state_type;
+
+extern int yylineno;
+int yylineno = 1;
+
 extern char *yytext;
+#ifdef yytext_ptr
+#undef yytext_ptr
+#endif
 #define yytext_ptr yytext
 
-static yy_state_type yy_get_previous_state YY_PROTO(( void ));
-static yy_state_type yy_try_NUL_trans YY_PROTO(( yy_state_type current_state ));
-static int yy_get_next_buffer YY_PROTO(( void ));
-static void yy_fatal_error YY_PROTO(( yyconst char msg[] ));
+static yy_state_type yy_get_previous_state ( void );
+static yy_state_type yy_try_NUL_trans ( yy_state_type current_state  );
+static int yy_get_next_buffer ( void );
+static void yynoreturn yy_fatal_error ( const char* msg  );
 
 /* Done after the current pattern has been matched and before the
  * corresponding action - sets up yytext.
  */
 #define YY_DO_BEFORE_ACTION \
-	yytext_ptr = yy_bp; \
+	(yytext_ptr) = yy_bp; \
 	yyleng = (int) (yy_cp - yy_bp); \
-	yy_hold_char = *yy_cp; \
+	(yy_hold_char) = *yy_cp; \
 	*yy_cp = '\0'; \
-	yy_c_buf_p = yy_cp;
-
+	(yy_c_buf_p) = yy_cp;
 #define YY_NUM_RULES 7
 #define YY_END_OF_BUFFER 8
-static yyconst short int yy_accept[34] =
+/* This struct is not used in this scanner,
+   but its presence is necessary. */
+struct yy_trans_info
+	{
+	flex_int32_t yy_verify;
+	flex_int32_t yy_nxt;
+	};
+static const flex_int16_t yy_accept[34] =
     {   0,
         4,    4,    5,    5,    8,    4,    4,    3,    4,    3,
         6,    5,    7,    4,    4,    3,    0,    3,    6,    5,
@@ -296,7 +368,7 @@
         1,    2,    0
     } ;
 
-static yyconst int yy_ec[256] =
+static const YY_CHAR yy_ec[256] =
     {   0,
         1,    1,    1,    1,    1,    1,    1,    1,    2,    3,
         1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
@@ -328,13 +400,13 @@
         1,    1,    1,    1,    1
     } ;
 
-static yyconst int yy_meta[14] =
+static const YY_CHAR yy_meta[14] =
     {   0,
         1,    2,    3,    2,    1,    4,    4,    4,    4,    4,
         4,    4,    4
     } ;
 
-static yyconst short int yy_base[40] =
+static const flex_int16_t yy_base[40] =
     {   0,
         0,    5,   14,   17,   50,   46,   51,    0,   19,   36,
         0,    0,   51,   44,   51,    0,   34,   38,    0,    0,
@@ -342,7 +414,7 @@
        51,   51,   51,   29,   33,   37,    8,   40,    9
     } ;
 
-static yyconst short int yy_def[40] =
+static const flex_int16_t yy_def[40] =
     {   0,
        34,   34,   35,   35,   33,   36,   33,   37,   36,   37,
        38,   39,   33,   36,   33,   37,   33,   37,   38,   39,
@@ -350,7 +422,7 @@
        33,   33,    0,   33,   33,   33,   33,   33,   33
     } ;
 
-static yyconst short int yy_nxt[65] =
+static const flex_int16_t yy_nxt[65] =
     {   0,
         6,    6,    7,    6,    6,    6,    6,    7,    6,    9,
        20,   16,   32,   31,   10,   12,   13,   12,   12,   13,
@@ -361,7 +433,7 @@
        33,   33,   33,   33
     } ;
 
-static yyconst short int yy_chk[65] =
+static const flex_int16_t yy_chk[65] =
     {   0,
         1,    1,    1,    1,    1,    2,    2,    2,    2,    2,
        39,   37,   30,   29,    2,    3,    3,    3,    4,    4,
@@ -375,6 +447,9 @@
 static yy_state_type yy_last_accepting_state;
 static char *yy_last_accepting_cpos;
 
+extern int yy_flex_debug;
+int yy_flex_debug = 0;
+
 /* The intent behind this definition is that it'll catch
  * any uses of REJECT which flex missed.
  */
@@ -384,7 +459,6 @@
 #define YY_RESTORE_YY_MORE_OFFSET
 char *yytext;
 #line 1 "spp.ll"
-#define INITIAL 0
 /**************************************************************************
  *
  *  Copyright 2022, Yuri Prokushev
@@ -417,13 +491,14 @@
 /* the "incl" state is used for picking up the name
  * of an include file
  */
-#define incl 1
 
 #line 38 "spp.ll"
 #include <stdlib.h>
 #include <string.h>
-#include <direct.h>
+#ifndef __LINUX__
 #include <io.h>
+#include <direct.h>
+#endif
 
 #include <emitlib.h>
 
@@ -436,7 +511,54 @@
   int lineno;
 } include_stack[MAX_INCLUDE_DEPTH];
 int include_stack_ptr = 0;
-#line 440 "spp.c"
+#line 515 "lex.yy.c"
+#line 516 "lex.yy.c"
+
+#define INITIAL 0
+#define incl 1
+
+#ifndef YY_NO_UNISTD_H
+/* Special case for "unistd.h", since it is non-ANSI. We include it way
+ * down here because we want the user's section 1 to have been scanned first.
+ * The user has a chance to override it with an option.
+ */
+#include <unistd.h>
+#endif
+
+#ifndef YY_EXTRA_TYPE
+#define YY_EXTRA_TYPE void *
+#endif
+
+static int yy_init_globals ( void );
+
+/* Accessor methods to globals.
+   These are made visible to non-reentrant scanners for convenience. */
+
+int yylex_destroy ( void );
+
+int yyget_debug ( void );
+
+void yyset_debug ( int debug_flag  );
+
+YY_EXTRA_TYPE yyget_extra ( void );
+
+void yyset_extra ( YY_EXTRA_TYPE user_defined  );
+
+FILE *yyget_in ( void );
+
+void yyset_in  ( FILE * _in_str  );
+
+FILE *yyget_out ( void );
+
+void yyset_out  ( FILE * _out_str  );
+
+			int yyget_leng ( void );
+
+char *yyget_text ( void );
+
+int yyget_lineno ( void );
+
+void yyset_lineno ( int _line_number  );
 
 /* Macros after this point can all be overridden by user definitions in
  * section 1.
@@ -444,79 +566,51 @@
 
 #ifndef YY_SKIP_YYWRAP
 #ifdef __cplusplus
-extern "C" int yywrap YY_PROTO(( void ));
+extern "C" int yywrap ( void );
 #else
-extern int yywrap YY_PROTO(( void ));
+extern int yywrap ( void );
 #endif
 #endif
 
 #ifndef YY_NO_UNPUT
-static void yyunput YY_PROTO(( int c, char *buf_ptr ));
+    
+    static void yyunput ( int c, char *buf_ptr  );
+    
 #endif
 
 #ifndef yytext_ptr
-static void yy_flex_strncpy YY_PROTO(( char *, yyconst char *, int ));
+static void yy_flex_strncpy ( char *, const char *, int );
 #endif
 
 #ifdef YY_NEED_STRLEN
-static int yy_flex_strlen YY_PROTO(( yyconst char * ));
+static int yy_flex_strlen ( const char * );
 #endif
 
 #ifndef YY_NO_INPUT
 #ifdef __cplusplus
-static int yyinput YY_PROTO(( void ));
+static int yyinput ( void );
 #else
-static int input YY_PROTO(( void ));
-#endif
-#endif
-
-#if YY_STACK_USED
-static int yy_start_stack_ptr = 0;
-static int yy_start_stack_depth = 0;
-static int *yy_start_stack = 0;
-#ifndef YY_NO_PUSH_STATE
-static void yy_push_state YY_PROTO(( int new_state ));
-#endif
-#ifndef YY_NO_POP_STATE
-static void yy_pop_state YY_PROTO(( void ));
-#endif
-#ifndef YY_NO_TOP_STATE
-static int yy_top_state YY_PROTO(( void ));
+static int input ( void );
 #endif
 
-#else
-#define YY_NO_PUSH_STATE 1
-#define YY_NO_POP_STATE 1
-#define YY_NO_TOP_STATE 1
-#endif
-
-#ifdef YY_MALLOC_DECL
-YY_MALLOC_DECL
-#else
-#if __STDC__
-#ifndef __cplusplus
-#include <stdlib.h>
-#endif
-#else
-/* Just try to get by without declaring the routines.  This will fail
- * miserably on non-ANSI systems for which sizeof(size_t) != sizeof(int)
- * or sizeof(void*) != sizeof(int).
- */
-#endif
 #endif
 
 /* Amount of stuff to slurp up with each read. */
 #ifndef YY_READ_BUF_SIZE
+#ifdef __ia64__
+/* On IA-64, the buffer size is 16k, not 8k */
+#define YY_READ_BUF_SIZE 16384
+#else
 #define YY_READ_BUF_SIZE 8192
+#endif /* __ia64__ */
 #endif
 
 /* Copy whatever the last rule matched to the standard output. */
-
 #ifndef ECHO
 /* This used to be an fputs(), but since the string might contain NUL's,
  * we now use fwrite().
  */
-#define ECHO (void) fwrite( yytext, yyleng, 1, yyout )
+#define ECHO do { if (fwrite( yytext, (size_t) yyleng, 1, yyout )) {} } while (0)
 #endif
 
 /* Gets input and stuffs it into "buf".  number of characters read, or YY_NULL,
@@ -524,9 +618,10 @@
  */
 #ifndef YY_INPUT
 #define YY_INPUT(buf,result,max_size) \
-	if ( yy_current_buffer->yy_is_interactive ) \
+	if ( YY_CURRENT_BUFFER_LVALUE->yy_is_interactive ) \
 		{ \
-		int c = '*', n; \
+		int c = '*'; \
+		int n; \
 		for ( n = 0; n < max_size && \
 			     (c = getc( yyin )) != EOF && c != '\n'; ++n ) \
 			buf[n] = (char) c; \
@@ -536,9 +631,22 @@
 			YY_FATAL_ERROR( "input in flex scanner failed" ); \
 		result = n; \
 		} \
-	else if ( ((result = fread( buf, 1, max_size, yyin )) == 0) \
-		  && ferror( yyin ) ) \
-		YY_FATAL_ERROR( "input in flex scanner failed" );
+	else \
+		{ \
+		errno=0; \
+		while ( (result = (int) fread(buf, 1, (yy_size_t) max_size, yyin)) == 0 && ferror(yyin)) \
+			{ \
+			if( errno != EINTR) \
+				{ \
+				YY_FATAL_ERROR( "input in flex scanner failed" ); \
+				break; \
+				} \
+			errno=0; \
+			clearerr(yyin); \
+			} \
+		}\
+\
+
 #endif
 
 /* No semi-colon after return; correct usage is to write "yyterminate();" -
@@ -559,12 +667,18 @@
 #define YY_FATAL_ERROR(msg) yy_fatal_error( msg )
 #endif
 
+/* end tables serialization structures and prototypes */
+
 /* Default declaration of generated scanner - a define so the user can
  * easily add parameters.
  */
 #ifndef YY_DECL
-#define YY_DECL int yylex YY_PROTO(( void ))
-#endif
+#define YY_DECL_IS_OURS 1
+
+extern int yylex (void);
+
+#define YY_DECL int yylex (void)
+#endif /* !YY_DECL */
 
 /* Code executed at the beginning of each rule, after yytext and yyleng
  * have been set up.
@@ -575,35 +689,33 @@
 
 /* Code executed at the end of each rule. */
 #ifndef YY_BREAK
-#define YY_BREAK break;
+#define YY_BREAK /*LINTED*/break;
 #endif
 
 #define YY_RULE_SETUP \
 	if ( yyleng > 0 ) \
-		yy_current_buffer->yy_at_bol = \
+		YY_CURRENT_BUFFER_LVALUE->yy_at_bol = \
 				(yytext[yyleng - 1] == '\n'); \
 	YY_USER_ACTION
 
+/** The main scanner function which does all the work.
+ */
 YY_DECL
 	{
-	register yy_state_type yy_current_state;
-	register char *yy_cp, *yy_bp;
-	register int yy_act;
-
-#line 56 "spp.ll"
+	yy_state_type yy_current_state;
+	char *yy_cp, *yy_bp;
+	int yy_act;
 
-#line 596 "spp.c"
-
-	if ( yy_init )
+	if ( !(yy_init) )
 		{
-		yy_init = 0;
+		(yy_init) = 1;
 
 #ifdef YY_USER_INIT
 		YY_USER_INIT;
 #endif
 
-		if ( ! yy_start )
-			yy_start = 1;	/* first start state */
+		if ( ! (yy_start) )
+			(yy_start) = 1;	/* first start state */
 
 		if ( ! yyin )
 			yyin = stdin;
@@ -611,43 +723,50 @@
 		if ( ! yyout )
 			yyout = stdout;
 
-		if ( ! yy_current_buffer )
-			yy_current_buffer =
+		if ( ! YY_CURRENT_BUFFER ) {
+			yyensure_buffer_stack ();
+			YY_CURRENT_BUFFER_LVALUE =
 				yy_create_buffer( yyin, YY_BUF_SIZE );
+		}
 
 		yy_load_buffer_state();
 		}
 
-	while ( 1 )		/* loops until end-of-file is reached */
 		{
-		yy_cp = yy_c_buf_p;
+#line 58 "spp.ll"
+
+#line 739 "lex.yy.c"
+
+	while ( /*CONSTCOND*/1 )		/* loops until end-of-file is reached */
+		{
+		yy_cp = (yy_c_buf_p);
 
 		/* Support of yytext. */
-		*yy_cp = yy_hold_char;
+		*yy_cp = (yy_hold_char);
 
 		/* yy_bp points to the position in yy_ch_buf of the start of
 		 * the current run.
 		 */
 		yy_bp = yy_cp;
 
-		yy_current_state = yy_start;
+		yy_current_state = (yy_start);
 		yy_current_state += YY_AT_BOL();
 yy_match:
 		do
 			{
-			register YY_CHAR yy_c = yy_ec[YY_SC_TO_UI(*yy_cp)];
+			YY_CHAR yy_c = yy_ec[YY_SC_TO_UI(*yy_cp)] ;
 			if ( yy_accept[yy_current_state] )
 				{
-				yy_last_accepting_state = yy_current_state;
-				yy_last_accepting_cpos = yy_cp;
+				(yy_last_accepting_state) = yy_current_state;
+				(yy_last_accepting_cpos) = yy_cp;
 				}
 			while ( yy_chk[yy_base[yy_current_state] + yy_c] != yy_current_state )
 				{
 				yy_current_state = (int) yy_def[yy_current_state];
 				if ( yy_current_state >= 34 )
-					yy_c = yy_meta[(unsigned int) yy_c];
+					yy_c = yy_meta[yy_c];
 				}
-			yy_current_state = yy_nxt[yy_base[yy_current_state] + (unsigned int) yy_c];
+			yy_current_state = yy_nxt[yy_base[yy_current_state] + yy_c];
 			++yy_cp;
 			}
 		while ( yy_base[yy_current_state] != 51 );
@@ -656,54 +775,53 @@
 		yy_act = yy_accept[yy_current_state];
 		if ( yy_act == 0 )
 			{ /* have to back up */
-			yy_cp = yy_last_accepting_cpos;
-			yy_current_state = yy_last_accepting_state;
+			yy_cp = (yy_last_accepting_cpos);
+			yy_current_state = (yy_last_accepting_state);
 			yy_act = yy_accept[yy_current_state];
 			}
 
 		YY_DO_BEFORE_ACTION;
 
-
 do_action:	/* This label is used only to access EOF actions. */
 
-
 		switch ( yy_act )
 	{ /* beginning of action switch */
 			case 0: /* must back up */
 			/* undo the effects of YY_DO_BEFORE_ACTION */
-			*yy_cp = yy_hold_char;
-			yy_cp = yy_last_accepting_cpos;
-			yy_current_state = yy_last_accepting_state;
+			*yy_cp = (yy_hold_char);
+			yy_cp = (yy_last_accepting_cpos);
+			yy_current_state = (yy_last_accepting_state);
 			goto yy_find_action;
 
 case 1:
 YY_RULE_SETUP
-#line 57 "spp.ll"
+#line 59 "spp.ll"
 { BEGIN(incl); }
 	YY_BREAK
 case 2:
 YY_RULE_SETUP
-#line 58 "spp.ll"
+#line 60 "spp.ll"
 { BEGIN(incl); }
 	YY_BREAK
 case 3:
 YY_RULE_SETUP
-#line 60 "spp.ll"
+#line 62 "spp.ll"
 { ECHO; }
 	YY_BREAK
 case 4:
+/* rule 4 can match eol */
 YY_RULE_SETUP
-#line 61 "spp.ll"
+#line 63 "spp.ll"
 { ECHO; include_stack[include_stack_ptr].lineno++; }
 	YY_BREAK
 case 5:
 YY_RULE_SETUP
-#line 63 "spp.ll"
+#line 65 "spp.ll"
 { /* eat the whitespace */ }
 	YY_BREAK
 case 6:
 YY_RULE_SETUP
-#line 64 "spp.ll"
+#line 66 "spp.ll"
 { /* got the include file name */
 		if (include_stack_ptr >= MAX_INCLUDE_DEPTH)
 		{
@@ -741,7 +859,7 @@
 	YY_BREAK
 case YY_STATE_EOF(INITIAL):
 case YY_STATE_EOF(incl):
-#line 99 "spp.ll"
+#line 101 "spp.ll"
 {
 	   if (	--include_stack_ptr < 0	)
 	       {
@@ -759,34 +877,34 @@
 	YY_BREAK
 case 7:
 YY_RULE_SETUP
-#line 114 "spp.ll"
+#line 116 "spp.ll"
 ECHO;
 	YY_BREAK
-#line 766 "spp.c"
+#line 884 "lex.yy.c"
 
 	case YY_END_OF_BUFFER:
 		{
 		/* Amount of text matched not including the EOB char. */
-		int yy_amount_of_matched_text = (int) (yy_cp - yytext_ptr) - 1;
+		int yy_amount_of_matched_text = (int) (yy_cp - (yytext_ptr)) - 1;
 
 		/* Undo the effects of YY_DO_BEFORE_ACTION. */
-		*yy_cp = yy_hold_char;
+		*yy_cp = (yy_hold_char);
 		YY_RESTORE_YY_MORE_OFFSET
 
-		if ( yy_current_buffer->yy_buffer_status == YY_BUFFER_NEW )
+		if ( YY_CURRENT_BUFFER_LVALUE->yy_buffer_status == YY_BUFFER_NEW )
 			{
 			/* We're scanning a new file or input source.  It's
 			 * possible that this happened because the user
 			 * just pointed yyin at a new source and called
 			 * yylex().  If so, then we have to assure
-			 * consistency between yy_current_buffer and our
+			 * consistency between YY_CURRENT_BUFFER and our
 			 * globals.  Here is the right place to do so, because
 			 * this is the first action (other than possibly a
 			 * back-up) that will match for the new input source.
 			 */
-			yy_n_chars = yy_current_buffer->yy_n_chars;
-			yy_current_buffer->yy_input_file = yyin;
-			yy_current_buffer->yy_buffer_status = YY_BUFFER_NORMAL;
+			(yy_n_chars) = YY_CURRENT_BUFFER_LVALUE->yy_n_chars;
+			YY_CURRENT_BUFFER_LVALUE->yy_input_file = yyin;
+			YY_CURRENT_BUFFER_LVALUE->yy_buffer_status = YY_BUFFER_NORMAL;
 			}
 
 		/* Note that here we test for yy_c_buf_p "<=" to the position
@@ -796,11 +914,11 @@
 		 * end-of-buffer state).  Contrast this with the test
 		 * in input().
 		 */
-		if ( yy_c_buf_p <= &yy_current_buffer->yy_ch_buf[yy_n_chars] )
+		if ( (yy_c_buf_p) <= &YY_CURRENT_BUFFER_LVALUE->yy_ch_buf[(yy_n_chars)] )
 			{ /* This was really a NUL. */
 			yy_state_type yy_next_state;
 
-			yy_c_buf_p = yytext_ptr + yy_amount_of_matched_text;
+			(yy_c_buf_p) = (yytext_ptr) + yy_amount_of_matched_text;
 
 			yy_current_state = yy_get_previous_state();
 
@@ -815,19 +933,19 @@
 
 			yy_next_state = yy_try_NUL_trans( yy_current_state );
 
-			yy_bp = yytext_ptr + YY_MORE_ADJ;
+			yy_bp = (yytext_ptr) + YY_MORE_ADJ;
 
 			if ( yy_next_state )
 				{
 				/* Consume the NUL. */
-				yy_cp = ++yy_c_buf_p;
+				yy_cp = ++(yy_c_buf_p);
 				yy_current_state = yy_next_state;
 				goto yy_match;
 				}
 
 			else
 				{
-				yy_cp = yy_c_buf_p;
+				yy_cp = (yy_c_buf_p);
 				goto yy_find_action;
 				}
 			}
@@ -836,7 +954,7 @@
 			{
 			case EOB_ACT_END_OF_FILE:
 				{
-				yy_did_buffer_switch_on_eof = 0;
+				(yy_did_buffer_switch_on_eof) = 0;
 
 				if ( yywrap() )
 					{
@@ -849,7 +967,7 @@
 					 * YY_NULL, it'll still work - another
 					 * YY_NULL will get returned.
 					 */
-					yy_c_buf_p = yytext_ptr + YY_MORE_ADJ;
+					(yy_c_buf_p) = (yytext_ptr) + YY_MORE_ADJ;
 
 					yy_act = YY_STATE_EOF(YY_START);
 					goto do_action;
@@ -857,30 +975,30 @@
 
 				else
 					{
-					if ( ! yy_did_buffer_switch_on_eof )
+					if ( ! (yy_did_buffer_switch_on_eof) )
 						YY_NEW_FILE;
 					}
 				break;
 				}
 
 			case EOB_ACT_CONTINUE_SCAN:
-				yy_c_buf_p =
-					yytext_ptr + yy_amount_of_matched_text;
+				(yy_c_buf_p) =
+					(yytext_ptr) + yy_amount_of_matched_text;
 
 				yy_current_state = yy_get_previous_state();
 
-				yy_cp = yy_c_buf_p;
-				yy_bp = yytext_ptr + YY_MORE_ADJ;
+				yy_cp = (yy_c_buf_p);
+				yy_bp = (yytext_ptr) + YY_MORE_ADJ;
 				goto yy_match;
 
 			case EOB_ACT_LAST_MATCH:
-				yy_c_buf_p =
-				&yy_current_buffer->yy_ch_buf[yy_n_chars];
+				(yy_c_buf_p) =
+				&YY_CURRENT_BUFFER_LVALUE->yy_ch_buf[(yy_n_chars)];
 
 				yy_current_state = yy_get_previous_state();
 
-				yy_cp = yy_c_buf_p;
-				yy_bp = yytext_ptr + YY_MORE_ADJ;
+				yy_cp = (yy_c_buf_p);
+				yy_bp = (yytext_ptr) + YY_MORE_ADJ;
 				goto yy_find_action;
 			}
 		break;
@@ -891,9 +1009,9 @@
 			"fatal flex scanner internal error--no action found" );
 	} /* end of action switch */
 		} /* end of scanning one token */
+	} /* end of user's declarations */
 	} /* end of yylex */
 
-
 /* yy_get_next_buffer - try to read in a new buffer
  *
  * Returns a code representing an action:
@@ -901,21 +1019,20 @@
  *	EOB_ACT_CONTINUE_SCAN - continue scanning from current position
  *	EOB_ACT_END_OF_FILE - end of file
  */
-
-static int yy_get_next_buffer()
+static int yy_get_next_buffer (void)
 	{
-	register char *dest = yy_current_buffer->yy_ch_buf;
-	register char *source = yytext_ptr;
-	register int number_to_move, i;
+    	char *dest = YY_CURRENT_BUFFER_LVALUE->yy_ch_buf;
+	char *source = (yytext_ptr);
+	int number_to_move, i;
 	int ret_val;
 
-	if ( yy_c_buf_p > &yy_current_buffer->yy_ch_buf[yy_n_chars + 1] )
+	if ( (yy_c_buf_p) > &YY_CURRENT_BUFFER_LVALUE->yy_ch_buf[(yy_n_chars) + 1] )
 		YY_FATAL_ERROR(
 		"fatal flex scanner internal error--end of buffer missed" );
 
-	if ( yy_current_buffer->yy_fill_buffer == 0 )
+	if ( YY_CURRENT_BUFFER_LVALUE->yy_fill_buffer == 0 )
 		{ /* Don't try to fill the buffer, so this is an EOF. */
-		if ( yy_c_buf_p - yytext_ptr - YY_MORE_ADJ == 1 )
+		if ( (yy_c_buf_p) - (yytext_ptr) - YY_MORE_ADJ == 1 )
 			{
 			/* We matched a single character, the EOB, so
 			 * treat this as a final EOF.
@@ -935,34 +1052,30 @@
 	/* Try to read more data. */
 
 	/* First move last chars to start of buffer. */
-	number_to_move = (int) (yy_c_buf_p - yytext_ptr) - 1;
+	number_to_move = (int) ((yy_c_buf_p) - (yytext_ptr) - 1);
 
 	for ( i = 0; i < number_to_move; ++i )
 		*(dest++) = *(source++);
 
-	if ( yy_current_buffer->yy_buffer_status == YY_BUFFER_EOF_PENDING )
+	if ( YY_CURRENT_BUFFER_LVALUE->yy_buffer_status == YY_BUFFER_EOF_PENDING )
 		/* don't do the read, it's not guaranteed to return an EOF,
 		 * just force an EOF
 		 */
-		yy_current_buffer->yy_n_chars = yy_n_chars = 0;
+		YY_CURRENT_BUFFER_LVALUE->yy_n_chars = (yy_n_chars) = 0;
 
 	else
 		{
 		int num_to_read =
-			yy_current_buffer->yy_buf_size - number_to_move - 1;
+			YY_CURRENT_BUFFER_LVALUE->yy_buf_size - number_to_move - 1;
 
 		while ( num_to_read <= 0 )
 			{ /* Not enough room in the buffer - grow it. */
-#ifdef YY_USES_REJECT
-			YY_FATAL_ERROR(
-"input buffer overflow, can't enlarge buffer because scanner uses REJECT" );
-#else
 
 			/* just a shorter name for the current buffer */
-			YY_BUFFER_STATE b = yy_current_buffer;
+			YY_BUFFER_STATE b = YY_CURRENT_BUFFER_LVALUE;
 
 			int yy_c_buf_p_offset =
-				(int) (yy_c_buf_p - b->yy_ch_buf);
+				(int) ((yy_c_buf_p) - b->yy_ch_buf);
 
 			if ( b->yy_is_our_buffer )
 				{
@@ -975,35 +1088,35 @@
 
 				b->yy_ch_buf = (char *)
 					/* Include room in for 2 EOB chars. */
-					yy_flex_realloc( (void *) b->yy_ch_buf,
-							 b->yy_buf_size + 2 );
+					yyrealloc( (void *) b->yy_ch_buf,
+							 (yy_size_t) (b->yy_buf_size + 2)  );
 				}
 			else
 				/* Can't grow it, we don't own it. */
-				b->yy_ch_buf = 0;
+				b->yy_ch_buf = NULL;
 
 			if ( ! b->yy_ch_buf )
 				YY_FATAL_ERROR(
 				"fatal error - scanner input buffer overflow" );
 
-			yy_c_buf_p = &b->yy_ch_buf[yy_c_buf_p_offset];
+			(yy_c_buf_p) = &b->yy_ch_buf[yy_c_buf_p_offset];
 
-			num_to_read = yy_current_buffer->yy_buf_size -
+			num_to_read = YY_CURRENT_BUFFER_LVALUE->yy_buf_size -
 						number_to_move - 1;
-#endif
+
 			}
 
 		if ( num_to_read > YY_READ_BUF_SIZE )
 			num_to_read = YY_READ_BUF_SIZE;
 
 		/* Read in more data. */
-		YY_INPUT( (&yy_current_buffer->yy_ch_buf[number_to_move]),
-			yy_n_chars, num_to_read );
+		YY_INPUT( (&YY_CURRENT_BUFFER_LVALUE->yy_ch_buf[number_to_move]),
+			(yy_n_chars), num_to_read );
 
-		yy_current_buffer->yy_n_chars = yy_n_chars;
+		YY_CURRENT_BUFFER_LVALUE->yy_n_chars = (yy_n_chars);
 		}
 
-	if ( yy_n_chars == 0 )
+	if ( (yy_n_chars) == 0 )
 		{
 		if ( number_to_move == YY_MORE_ADJ )
 			{
@@ -1014,7 +1127,7 @@
 		else
 			{
 			ret_val = EOB_ACT_LAST_MATCH;
-			yy_current_buffer->yy_buffer_status =
+			YY_CURRENT_BUFFER_LVALUE->yy_buffer_status =
 				YY_BUFFER_EOF_PENDING;
 			}
 		}
@@ -1022,151 +1135,151 @@
 	else
 		ret_val = EOB_ACT_CONTINUE_SCAN;
 
-	yy_n_chars += number_to_move;
-	yy_current_buffer->yy_ch_buf[yy_n_chars] = YY_END_OF_BUFFER_CHAR;
-	yy_current_buffer->yy_ch_buf[yy_n_chars + 1] = YY_END_OF_BUFFER_CHAR;
+	if (((yy_n_chars) + number_to_move) > YY_CURRENT_BUFFER_LVALUE->yy_buf_size) {
+		/* Extend the array by 50%, plus the number we really need. */
+		int new_size = (yy_n_chars) + number_to_move + ((yy_n_chars) >> 1);
+		YY_CURRENT_BUFFER_LVALUE->yy_ch_buf = (char *) yyrealloc(
+			(void *) YY_CURRENT_BUFFER_LVALUE->yy_ch_buf, (yy_size_t) new_size  );
+		if ( ! YY_CURRENT_BUFFER_LVALUE->yy_ch_buf )
+			YY_FATAL_ERROR( "out of dynamic memory in yy_get_next_buffer()" );
+		/* "- 2" to take care of EOB's */
+		YY_CURRENT_BUFFER_LVALUE->yy_buf_size = (int) (new_size - 2);
+	}
+
+	(yy_n_chars) += number_to_move;
+	YY_CURRENT_BUFFER_LVALUE->yy_ch_buf[(yy_n_chars)] = YY_END_OF_BUFFER_CHAR;
+	YY_CURRENT_BUFFER_LVALUE->yy_ch_buf[(yy_n_chars) + 1] = YY_END_OF_BUFFER_CHAR;
 
-	yytext_ptr = &yy_current_buffer->yy_ch_buf[0];
+	(yytext_ptr) = &YY_CURRENT_BUFFER_LVALUE->yy_ch_buf[0];
 
 	return ret_val;
 	}
 
-
 /* yy_get_previous_state - get the state just before the EOB char was reached */
 
-static yy_state_type yy_get_previous_state()
+    static yy_state_type yy_get_previous_state (void)
 	{
-	register yy_state_type yy_current_state;
-	register char *yy_cp;
+	yy_state_type yy_current_state;
+	char *yy_cp;
 
-	yy_current_state = yy_start;
+	yy_current_state = (yy_start);
 	yy_current_state += YY_AT_BOL();
 
-	for ( yy_cp = yytext_ptr + YY_MORE_ADJ; yy_cp < yy_c_buf_p; ++yy_cp )
+	for ( yy_cp = (yytext_ptr) + YY_MORE_ADJ; yy_cp < (yy_c_buf_p); ++yy_cp )
 		{
-		register YY_CHAR yy_c = (*yy_cp ? yy_ec[YY_SC_TO_UI(*yy_cp)] : 1);
+		YY_CHAR yy_c = (*yy_cp ? yy_ec[YY_SC_TO_UI(*yy_cp)] : 1);
 		if ( yy_accept[yy_current_state] )
 			{
-			yy_last_accepting_state = yy_current_state;
-			yy_last_accepting_cpos = yy_cp;
+			(yy_last_accepting_state) = yy_current_state;
+			(yy_last_accepting_cpos) = yy_cp;
 			}
 		while ( yy_chk[yy_base[yy_current_state] + yy_c] != yy_current_state )
 			{
 			yy_current_state = (int) yy_def[yy_current_state];
 			if ( yy_current_state >= 34 )
-				yy_c = yy_meta[(unsigned int) yy_c];
+				yy_c = yy_meta[yy_c];
 			}
-		yy_current_state = yy_nxt[yy_base[yy_current_state] + (unsigned int) yy_c];
+		yy_current_state = yy_nxt[yy_base[yy_current_state] + yy_c];
 		}
 
 	return yy_current_state;
 	}
 
-
 /* yy_try_NUL_trans - try to make a transition on the NUL character
  *
  * synopsis
  *	next_state = yy_try_NUL_trans( current_state );
  */
-
-#ifdef YY_USE_PROTOS
 static yy_state_type yy_try_NUL_trans( yy_state_type yy_current_state )
-#else
-static yy_state_type yy_try_NUL_trans( yy_current_state )
-yy_state_type yy_current_state;
-#endif
 	{
-	register int yy_is_jam;
-	register char *yy_cp = yy_c_buf_p;
+	int yy_is_jam;
+    	char *yy_cp = (yy_c_buf_p);
 
-	register YY_CHAR yy_c = 1;
+	YY_CHAR yy_c = 1;
 	if ( yy_accept[yy_current_state] )
 		{
-		yy_last_accepting_state = yy_current_state;
-		yy_last_accepting_cpos = yy_cp;
+		(yy_last_accepting_state) = yy_current_state;
+		(yy_last_accepting_cpos) = yy_cp;
 		}
 	while ( yy_chk[yy_base[yy_current_state] + yy_c] != yy_current_state )
 		{
 		yy_current_state = (int) yy_def[yy_current_state];
 		if ( yy_current_state >= 34 )
-			yy_c = yy_meta[(unsigned int) yy_c];
+			yy_c = yy_meta[yy_c];
 		}
-	yy_current_state = yy_nxt[yy_base[yy_current_state] + (unsigned int) yy_c];
+	yy_current_state = yy_nxt[yy_base[yy_current_state] + yy_c];
 	yy_is_jam = (yy_current_state == 33);
 
 	return yy_is_jam ? 0 : yy_current_state;
 	}
 
-
 #ifndef YY_NO_UNPUT
-#ifdef YY_USE_PROTOS
-static void yyunput( int c, register char *yy_bp )
-#else
-static void yyunput( c, yy_bp )
-int c;
-register char *yy_bp;
-#endif
+
+    static void yyunput (int c, char * yy_bp )
 	{
-	register char *yy_cp = yy_c_buf_p;
+	char *yy_cp;
+    
+    yy_cp = (yy_c_buf_p);
 
 	/* undo effects of setting up yytext */
-	*yy_cp = yy_hold_char;
+	*yy_cp = (yy_hold_char);
 
-	if ( yy_cp < yy_current_buffer->yy_ch_buf + 2 )
+	if ( yy_cp < YY_CURRENT_BUFFER_LVALUE->yy_ch_buf + 2 )
 		{ /* need to shift things up to make room */
 		/* +2 for EOB chars. */
-		register int number_to_move = yy_n_chars + 2;
-		register char *dest = &yy_current_buffer->yy_ch_buf[
-					yy_current_buffer->yy_buf_size + 2];
-		register char *source =
-				&yy_current_buffer->yy_ch_buf[number_to_move];
+		int number_to_move = (yy_n_chars) + 2;
+		char *dest = &YY_CURRENT_BUFFER_LVALUE->yy_ch_buf[
+					YY_CURRENT_BUFFER_LVALUE->yy_buf_size + 2];
+		char *source =
+				&YY_CURRENT_BUFFER_LVALUE->yy_ch_buf[number_to_move];
 
-		while ( source > yy_current_buffer->yy_ch_buf )
+		while ( source > YY_CURRENT_BUFFER_LVALUE->yy_ch_buf )
 			*--dest = *--source;
 
 		yy_cp += (int) (dest - source);
 		yy_bp += (int) (dest - source);
-		yy_current_buffer->yy_n_chars =
-			yy_n_chars = yy_current_buffer->yy_buf_size;
+		YY_CURRENT_BUFFER_LVALUE->yy_n_chars =
+			(yy_n_chars) = (int) YY_CURRENT_BUFFER_LVALUE->yy_buf_size;
 
-		if ( yy_cp < yy_current_buffer->yy_ch_buf + 2 )
+		if ( yy_cp < YY_CURRENT_BUFFER_LVALUE->yy_ch_buf + 2 )
 			YY_FATAL_ERROR( "flex scanner push-back overflow" );
 		}
 
 	*--yy_cp = (char) c;
 
-
-	yytext_ptr = yy_bp;
-	yy_hold_char = *yy_cp;
-	yy_c_buf_p = yy_cp;
+	(yytext_ptr) = yy_bp;
+	(yy_hold_char) = *yy_cp;
+	(yy_c_buf_p) = yy_cp;
 	}
-#endif	/* ifndef YY_NO_UNPUT */
 
+#endif
 
+#ifndef YY_NO_INPUT
 #ifdef __cplusplus
-static int yyinput()
+    static int yyinput (void)
 #else
-static int input()
+    static int input  (void)
 #endif
+
 	{
 	int c;
 
-	*yy_c_buf_p = yy_hold_char;
+	*(yy_c_buf_p) = (yy_hold_char);
 
-	if ( *yy_c_buf_p == YY_END_OF_BUFFER_CHAR )
+	if ( *(yy_c_buf_p) == YY_END_OF_BUFFER_CHAR )
 		{
 		/* yy_c_buf_p now points to the character we want to return.
 		 * If this occurs *before* the EOB characters, then it's a
 		 * valid NUL; if not, then we've hit the end of the buffer.
 		 */
-		if ( yy_c_buf_p < &yy_current_buffer->yy_ch_buf[yy_n_chars] )
+		if ( (yy_c_buf_p) < &YY_CURRENT_BUFFER_LVALUE->yy_ch_buf[(yy_n_chars)] )
 			/* This was really a NUL. */
-			*yy_c_buf_p = '\0';
+			*(yy_c_buf_p) = '\0';
 
 		else
 			{ /* need more input */
-			int offset = yy_c_buf_p - yytext_ptr;
-			++yy_c_buf_p;
+			int offset = (int) ((yy_c_buf_p) - (yytext_ptr));
+			++(yy_c_buf_p);
 
 			switch ( yy_get_next_buffer() )
 				{
@@ -1184,14 +1297,14 @@
 					/* Reset buffer status. */
 					yyrestart( yyin );
 
-					/* fall through */
+					/*FALLTHROUGH*/
 
 				case EOB_ACT_END_OF_FILE:
 					{
 					if ( yywrap() )
-						return EOF;
+						return 0;
 
-					if ( ! yy_did_buffer_switch_on_eof )
+					if ( ! (yy_did_buffer_switch_on_eof) )
 						YY_NEW_FILE;
 #ifdef __cplusplus
 					return yyinput();
@@ -1201,56 +1314,65 @@
 					}
 
 				case EOB_ACT_CONTINUE_SCAN:
-					yy_c_buf_p = yytext_ptr + offset;
+					(yy_c_buf_p) = (yytext_ptr) + offset;
 					break;
 				}
 			}
 		}
 
-	c = *(unsigned char *) yy_c_buf_p;	/* cast for 8-bit char's */
-	*yy_c_buf_p = '\0';	/* preserve yytext */
-	yy_hold_char = *++yy_c_buf_p;
+	c = *(unsigned char *) (yy_c_buf_p);	/* cast for 8-bit char's */
+	*(yy_c_buf_p) = '\0';	/* preserve yytext */
+	(yy_hold_char) = *++(yy_c_buf_p);
 
-	yy_current_buffer->yy_at_bol = (c == '\n');
+	YY_CURRENT_BUFFER_LVALUE->yy_at_bol = (c == '\n');
 
 	return c;
 	}
+#endif	/* ifndef YY_NO_INPUT */
 
-
-#ifdef YY_USE_PROTOS
+/** Immediately switch to a different input stream.
+ * @param input_file A readable stream.
+ * 
+ * @note This function does not reset the start condition to @c INITIAL .
+ */
 void yyrestart( FILE *input_file )
-#else
-void yyrestart( input_file )
-FILE *input_file;
-#endif
 	{
-	if ( ! yy_current_buffer )
-		yy_current_buffer = yy_create_buffer( yyin, YY_BUF_SIZE );
 
-	yy_init_buffer( yy_current_buffer, input_file );
-	yy_load_buffer_state();
+	if ( ! YY_CURRENT_BUFFER ){
+        yyensure_buffer_stack ();
+		YY_CURRENT_BUFFER_LVALUE =
+            yy_create_buffer( yyin, YY_BUF_SIZE );
 	}
 
-
-#ifdef YY_USE_PROTOS
+	yy_init_buffer( YY_CURRENT_BUFFER, input_file );
+	yy_load_buffer_state(  );
+}
+
+/** Switch to a different input buffer.
+ * @param new_buffer The new input buffer.
+ * 
+ */
 void yy_switch_to_buffer( YY_BUFFER_STATE new_buffer )
-#else
-void yy_switch_to_buffer( new_buffer )
-YY_BUFFER_STATE new_buffer;
-#endif
 	{
-	if ( yy_current_buffer == new_buffer )
+    
+	/* TODO. We should be able to replace this entire function body
+	 * with
+	 *		yypop_buffer_state();
+	 *		yypush_buffer_state(new_buffer);
+     */
+	yyensure_buffer_stack ();
+	if ( YY_CURRENT_BUFFER == new_buffer )
 		return;
 
-	if ( yy_current_buffer )
+	if ( YY_CURRENT_BUFFER )
 		{
 		/* Flush out information for old buffer. */
-		*yy_c_buf_p = yy_hold_char;
-		yy_current_buffer->yy_buf_pos = yy_c_buf_p;
-		yy_current_buffer->yy_n_chars = yy_n_chars;
+		*(yy_c_buf_p) = (yy_hold_char);
+		YY_CURRENT_BUFFER_LVALUE->yy_buf_pos = (yy_c_buf_p);
+		YY_CURRENT_BUFFER_LVALUE->yy_n_chars = (yy_n_chars);
 		}
 
-	yy_current_buffer = new_buffer;
+	YY_CURRENT_BUFFER_LVALUE = new_buffer;
 	yy_load_buffer_state();
 
 	/* We don't actually know whether we did this switch during
@@ -1258,34 +1380,28 @@
 	 * is looked at is after yywrap() is called, so it's safe
 	 * to go ahead and always set it.
 	 */
-	yy_did_buffer_switch_on_eof = 1;
+	(yy_did_buffer_switch_on_eof) = 1;
 	}
 
-
-#ifdef YY_USE_PROTOS
-void yy_load_buffer_state( void )
-#else
-void yy_load_buffer_state()
-#endif
+static void yy_load_buffer_state  (void)
 	{
-	yy_n_chars = yy_current_buffer->yy_n_chars;
-	yytext_ptr = yy_c_buf_p = yy_current_buffer->yy_buf_pos;
-	yyin = yy_current_buffer->yy_input_file;
-	yy_hold_char = *yy_c_buf_p;
+    	(yy_n_chars) = YY_CURRENT_BUFFER_LVALUE->yy_n_chars;
+	(yytext_ptr) = (yy_c_buf_p) = YY_CURRENT_BUFFER_LVALUE->yy_buf_pos;
+	yyin = YY_CURRENT_BUFFER_LVALUE->yy_input_file;
+	(yy_hold_char) = *(yy_c_buf_p);
 	}
 
-
-#ifdef YY_USE_PROTOS
+/** Allocate and initialize an input buffer state.
+ * @param file A readable stream.
+ * @param size The character buffer size in bytes. When in doubt, use @c YY_BUF_SIZE.
+ * 
+ * @return the allocated buffer state.
+ */
 YY_BUFFER_STATE yy_create_buffer( FILE *file, int size )
-#else
-YY_BUFFER_STATE yy_create_buffer( file, size )
-FILE *file;
-int size;
-#endif
 	{
 	YY_BUFFER_STATE b;
 
-	b = (YY_BUFFER_STATE) yy_flex_alloc( sizeof( struct yy_buffer_state ) );
+	b = (YY_BUFFER_STATE) yyalloc( sizeof( struct yy_buffer_state )  );
 	if ( ! b )
 		YY_FATAL_ERROR( "out of dynamic memory in yy_create_buffer()" );
 
@@ -1294,7 +1410,7 @@
 	/* yy_ch_buf has to be 2 characters longer than the size given because
 	 * we need to put in 2 end-of-buffer characters.
 	 */
-	b->yy_ch_buf = (char *) yy_flex_alloc( b->yy_buf_size + 2 );
+	b->yy_ch_buf = (char *) yyalloc( (yy_size_t) (b->yy_buf_size + 2)  );
 	if ( ! b->yy_ch_buf )
 		YY_FATAL_ERROR( "out of dynamic memory in yy_create_buffer()" );
 
@@ -1305,67 +1421,58 @@
 	return b;
 	}
 
-
-#ifdef YY_USE_PROTOS
+/** Destroy the buffer.
+ * @param b a buffer created with yy_create_buffer()
+ * 
+ */
 void yy_delete_buffer( YY_BUFFER_STATE b )
-#else
-void yy_delete_buffer( b )
-YY_BUFFER_STATE b;
-#endif
 	{
+    
 	if ( ! b )
 		return;
 
-	if ( b == yy_current_buffer )
-		yy_current_buffer = (YY_BUFFER_STATE) 0;
+	if ( b == YY_CURRENT_BUFFER ) /* Not sure if we should pop here. */
+		YY_CURRENT_BUFFER_LVALUE = (YY_BUFFER_STATE) 0;
 
 	if ( b->yy_is_our_buffer )
-		yy_flex_free( (void *) b->yy_ch_buf );
+		yyfree( (void *) b->yy_ch_buf  );
 
-	yy_flex_free( (void *) b );
+	yyfree( (void *) b  );
 	}
 
-
-#ifndef YY_ALWAYS_INTERACTIVE
-#ifndef YY_NEVER_INTERACTIVE
-extern int isatty YY_PROTO(( int ));
-#endif
-#endif
-
-#ifdef YY_USE_PROTOS
-void yy_init_buffer( YY_BUFFER_STATE b, FILE *file )
-#else
-void yy_init_buffer( b, file )
-YY_BUFFER_STATE b;
-FILE *file;
-#endif
-
+/* Initializes or reinitializes a buffer.
+ * This function is sometimes called more than once on the same buffer,
+ * such as during a yyrestart() or at EOF.
+ */
+    static void yy_init_buffer  (YY_BUFFER_STATE  b, FILE * file )
 
 	{
+	int oerrno = errno;
+    
 	yy_flush_buffer( b );
 
 	b->yy_input_file = file;
 	b->yy_fill_buffer = 1;
 
-#if YY_ALWAYS_INTERACTIVE
-	b->yy_is_interactive = 1;
-#else
-#if YY_NEVER_INTERACTIVE
-	b->yy_is_interactive = 0;
-#else
-	b->yy_is_interactive = file ? (isatty( fileno(file) ) > 0) : 0;
-#endif
-#endif
-	}
-
-
-#ifdef YY_USE_PROTOS
-void yy_flush_buffer( YY_BUFFER_STATE b )
-#else
-void yy_flush_buffer( b )
-YY_BUFFER_STATE b;
-#endif
-
+    /* If b is the current buffer, then yy_init_buffer was _probably_
+     * called from yyrestart() or through yy_get_next_buffer.
+     * In that case, we don't want to reset the lineno or column.
+     */
+    if (b != YY_CURRENT_BUFFER){
+        b->yy_bs_lineno = 1;
+        b->yy_bs_column = 0;
+	}
+
+        b->yy_is_interactive = file ? (isatty( fileno(file) ) > 0) : 0;
+
+	errno = oerrno;
+}
+
+/** Discard all buffered characters. On the next scan, YY_INPUT will be called.
+ * @param b the buffer state to be flushed, usually @c YY_CURRENT_BUFFER.
+ * 
+ */
+    void yy_flush_buffer (YY_BUFFER_STATE  b )
 	{
 	if ( ! b )
 		return;
@@ -1384,19 +1491,115 @@
 	b->yy_at_bol = 1;
 	b->yy_buffer_status = YY_BUFFER_NEW;
 
-	if ( b == yy_current_buffer )
+	if ( b == YY_CURRENT_BUFFER )
+		yy_load_buffer_state(  );
+}
+
+/** Pushes the new state onto the stack. The new state becomes
+ *  the current state. This function will allocate the stack
+ *  if necessary.
+ *  @param new_buffer The new state.
+ *  
+ */
+void yypush_buffer_state (YY_BUFFER_STATE new_buffer )
+{
+    	if (new_buffer == NULL)
+		return;
+
+	yyensure_buffer_stack();
+
+	/* This block is copied from yy_switch_to_buffer. */
+	if ( YY_CURRENT_BUFFER )
+		{
+		/* Flush out information for old buffer. */
+		*(yy_c_buf_p) = (yy_hold_char);
+		YY_CURRENT_BUFFER_LVALUE->yy_buf_pos = (yy_c_buf_p);
+		YY_CURRENT_BUFFER_LVALUE->yy_n_chars = (yy_n_chars);
+		}
+
+	/* Only push if top exists. Otherwise, replace top. */
+	if (YY_CURRENT_BUFFER)
+		(yy_buffer_stack_top)++;
+	YY_CURRENT_BUFFER_LVALUE = new_buffer;
+
+	/* copied from yy_switch_to_buffer. */
+	yy_load_buffer_state(  );
+	(yy_did_buffer_switch_on_eof) = 1;
+}
+
+/** Removes and deletes the top of the stack, if present.
+ *  The next element becomes the new top.
+ *  
+ */
+void yypop_buffer_state (void)
+{
+    	if (!YY_CURRENT_BUFFER)
+		return;
+
+	yy_delete_buffer(YY_CURRENT_BUFFER );
+	YY_CURRENT_BUFFER_LVALUE = NULL;
+	if ((yy_buffer_stack_top) > 0)
+		--(yy_buffer_stack_top);
+
+	if (YY_CURRENT_BUFFER) {
 		yy_load_buffer_state();
+		(yy_did_buffer_switch_on_eof) = 1;
+	}
 	}
 
-
-#ifndef YY_NO_SCAN_BUFFER
-#ifdef YY_USE_PROTOS
+/* Allocates the stack if it does not exist.
+ *  Guarantees space for at least one push.
+ */
+static void yyensure_buffer_stack (void)
+{
+	yy_size_t num_to_alloc;
+    
+	if (!(yy_buffer_stack)) {
+
+		/* First allocation is just for 2 elements, since we don't know if this
+		 * scanner will even need a stack. We use 2 instead of 1 to avoid an
+		 * immediate realloc on the next call.
+         */
+      num_to_alloc = 1; /* After all that talk, this was set to 1 anyways... */
+		(yy_buffer_stack) = (struct yy_buffer_state**)yyalloc
+								(num_to_alloc * sizeof(struct yy_buffer_state*)
+								);
+		if ( ! (yy_buffer_stack) )
+			YY_FATAL_ERROR( "out of dynamic memory in yyensure_buffer_stack()" );
+
+		memset((yy_buffer_stack), 0, num_to_alloc * sizeof(struct yy_buffer_state*));
+
+		(yy_buffer_stack_max) = num_to_alloc;
+		(yy_buffer_stack_top) = 0;
+		return;
+	}
+
+	if ((yy_buffer_stack_top) >= ((yy_buffer_stack_max)) - 1){
+
+		/* Increase the buffer to prepare for a possible push. */
+		yy_size_t grow_size = 8 /* arbitrary grow size */;
+
+		num_to_alloc = (yy_buffer_stack_max) + grow_size;
+		(yy_buffer_stack) = (struct yy_buffer_state**)yyrealloc
+								((yy_buffer_stack),
+								num_to_alloc * sizeof(struct yy_buffer_state*)
+								);
+		if ( ! (yy_buffer_stack) )
+			YY_FATAL_ERROR( "out of dynamic memory in yyensure_buffer_stack()" );
+
+		/* zero only the new slots.*/
+		memset((yy_buffer_stack) + (yy_buffer_stack_max), 0, grow_size * sizeof(struct yy_buffer_state*));
+		(yy_buffer_stack_max) = num_to_alloc;
+	}
+}
+
+/** Setup the input buffer state to scan directly from a user-specified character buffer.
+ * @param base the character buffer
+ * @param size the size in bytes of the character buffer
+ * 
+ * @return the newly allocated buffer state object.
+ */
 YY_BUFFER_STATE yy_scan_buffer( char *base, yy_size_t size )
-#else
-YY_BUFFER_STATE yy_scan_buffer( base, size )
-char *base;
-yy_size_t size;
-#endif
 	{
 	YY_BUFFER_STATE b;
 
@@ -1404,16 +1607,16 @@
 	     base[size-2] != YY_END_OF_BUFFER_CHAR ||
 	     base[size-1] != YY_END_OF_BUFFER_CHAR )
 		/* They forgot to leave room for the EOB's. */
-		return 0;
+		return NULL;
 
-	b = (YY_BUFFER_STATE) yy_flex_alloc( sizeof( struct yy_buffer_state ) );
+	b = (YY_BUFFER_STATE) yyalloc( sizeof( struct yy_buffer_state )  );
 	if ( ! b )
 		YY_FATAL_ERROR( "out of dynamic memory in yy_scan_buffer()" );
 
-	b->yy_buf_size = size - 2;	/* "- 2" to take care of EOB's */
+	b->yy_buf_size = (int) (size - 2);	/* "- 2" to take care of EOB's */
 	b->yy_buf_pos = b->yy_ch_buf = base;
 	b->yy_is_our_buffer = 0;
-	b->yy_input_file = 0;
+	b->yy_input_file = NULL;
 	b->yy_n_chars = b->yy_buf_size;
 	b->yy_is_interactive = 0;
 	b->yy_at_bol = 1;
@@ -1424,34 +1627,29 @@
 
 	return b;
 	}
-#endif
 
-
-#ifndef YY_NO_SCAN_STRING
-#ifdef YY_USE_PROTOS
-YY_BUFFER_STATE yy_scan_string( yyconst char *yy_str )
-#else
-YY_BUFFER_STATE yy_scan_string( yy_str )
-yyconst char *yy_str;
-#endif
-	{
-	int len;
-	for ( len = 0; yy_str[len]; ++len )
-		;
-
-	return yy_scan_bytes( yy_str, len );
-	}
-#endif
-
-
-#ifndef YY_NO_SCAN_BYTES
-#ifdef YY_USE_PROTOS
-YY_BUFFER_STATE yy_scan_bytes( yyconst char *bytes, int len )
-#else
-YY_BUFFER_STATE yy_scan_bytes( bytes, len )
-yyconst char *bytes;
-int len;
-#endif
+/** Setup the input buffer state to scan a string. The next call to yylex() will
+ * scan from a @e copy of @a str.
+ * @param yystr a NUL-terminated string to scan
+ * 
+ * @return the newly allocated buffer state object.
+ * @note If you want to scan bytes that may contain NUL values, then use
+ *       yy_scan_bytes() instead.
+ */
+YY_BUFFER_STATE yy_scan_string (const char * yystr )
+	{
+
+	return yy_scan_bytes( yystr, (int) strlen(yystr) );
+	}
+
+/** Setup the input buffer state to scan the given bytes. The next call to yylex() will
+ * scan from a @e copy of @a bytes.
+ * @param yybytes the byte buffer to scan
+ * @param _yybytes_len the number of bytes in the buffer pointed to by @a bytes.
+ * 
+ * @return the newly allocated buffer state object.
+ */
+YY_BUFFER_STATE yy_scan_bytes  (const char * yybytes, int  _yybytes_len )
 	{
 	YY_BUFFER_STATE b;
 	char *buf;
@@ -1459,15 +1657,15 @@
 	int i;
 
 	/* Get memory for full buffer, including space for trailing EOB's. */
-	n = len + 2;
-	buf = (char *) yy_flex_alloc( n );
+	n = (yy_size_t) (_yybytes_len + 2);
+	buf = (char *) yyalloc( n  );
 	if ( ! buf )
 		YY_FATAL_ERROR( "out of dynamic memory in yy_scan_bytes()" );
 
-	for ( i = 0; i < len; ++i )
-		buf[i] = bytes[i];
+	for ( i = 0; i < _yybytes_len; ++i )
+		buf[i] = yybytes[i];
 
-	buf[len] = buf[len+1] = YY_END_OF_BUFFER_CHAR;
+	buf[_yybytes_len] = buf[_yybytes_len+1] = YY_END_OF_BUFFER_CHAR;
 
 	b = yy_scan_buffer( buf, n );
 	if ( ! b )
@@ -1480,121 +1678,182 @@
 
 	return b;
 	}
-#endif
-
 
-#ifndef YY_NO_PUSH_STATE
-#ifdef YY_USE_PROTOS
-static void yy_push_state( int new_state )
-#else
-static void yy_push_state( new_state )
-int new_state;
+#ifndef YY_EXIT_FAILURE
+#define YY_EXIT_FAILURE 2
 #endif
+
+static void yynoreturn yy_fatal_error (const char* msg )
 	{
-	if ( yy_start_stack_ptr >= yy_start_stack_depth )
+			fprintf( stderr, "%s\n", msg );
+	exit( YY_EXIT_FAILURE );
+}
+
+/* Redefine yyless() so it works in section 3 code. */
+
+#undef yyless
+#define yyless(n) \
+	do \
+		{ \
+		/* Undo effects of setting up yytext. */ \
+        int yyless_macro_arg = (n); \
+        YY_LESS_LINENO(yyless_macro_arg);\
+		yytext[yyleng] = (yy_hold_char); \
+		(yy_c_buf_p) = yytext + yyless_macro_arg; \
+		(yy_hold_char) = *(yy_c_buf_p); \
+		*(yy_c_buf_p) = '\0'; \
+		yyleng = yyless_macro_arg; \
+		} \
+	while ( 0 )
+
+/* Accessor  methods (get/set functions) to struct members. */
+
+/** Get the current line number.
+ * 
+ */
+int yyget_lineno  (void)
 		{
-		yy_size_t new_size;
 
-		yy_start_stack_depth += YY_START_STACK_INCR;
-		new_size = yy_start_stack_depth * sizeof( int );
+    return yylineno;
+}
 
-		if ( ! yy_start_stack )
-			yy_start_stack = (int *) yy_flex_alloc( new_size );
-
-		else
-			yy_start_stack = (int *) yy_flex_realloc(
-					(void *) yy_start_stack, new_size );
-
-		if ( ! yy_start_stack )
-			YY_FATAL_ERROR(
-			"out of memory expanding start-condition stack" );
+/** Get the input stream.
+ * 
+ */
+FILE *yyget_in  (void)
+{
+        return yyin;
+}
+
+/** Get the output stream.
+ * 
+ */
+FILE *yyget_out  (void)
+{
+        return yyout;
+}
+
+/** Get the length of the current token.
+ * 
+ */
+int yyget_leng  (void)
+{
+        return yyleng;
 		}
 
-	yy_start_stack[yy_start_stack_ptr++] = YY_START;
-
-	BEGIN(new_state);
-	}
-#endif
-
-
-#ifndef YY_NO_POP_STATE
-static void yy_pop_state()
-	{
-	if ( --yy_start_stack_ptr < 0 )
-		YY_FATAL_ERROR( "start-condition stack underflow" );
-
-	BEGIN(yy_start_stack[yy_start_stack_ptr]);
-	}
-#endif
-
-
-#ifndef YY_NO_TOP_STATE
-static int yy_top_state()
-	{
-	return yy_start_stack[yy_start_stack_ptr - 1];
-	}
-#endif
-
-#ifndef YY_EXIT_FAILURE
-#define YY_EXIT_FAILURE 2
-#endif
-
-#ifdef YY_USE_PROTOS
-static void yy_fatal_error( yyconst char msg[] )
-#else
-static void yy_fatal_error( msg )
-char msg[];
-#endif
-	{
-	(void) fprintf( stderr, "%s\n", msg );
-	exit( YY_EXIT_FAILURE );
-	}
-
-
-
-/* Redefine yyless() so it works in section 3 code. */
-
-#undef yyless
-#define yyless(n) \
-	do \
-		{ \
-		/* Undo effects of setting up yytext. */ \
-		yytext[yyleng] = yy_hold_char; \
-		yy_c_buf_p = yytext + n; \
-		yy_hold_char = *yy_c_buf_p; \
-		*yy_c_buf_p = '\0'; \
-		yyleng = n; \
-		} \
-	while ( 0 )
-
-
-/* Internal utility routines. */
+/** Get the current token.
+ * 
+ */
+
+char *yyget_text  (void)
+{
+        return yytext;
+	}
+
+/** Set the current line number.
+ * @param _line_number line number
+ * 
+ */
+void yyset_lineno (int  _line_number )
+{
+    
+    yylineno = _line_number;
+}
+
+/** Set the input stream. This does not discard the current
+ * input buffer.
+ * @param _in_str A readable stream.
+ * 
+ * @see yy_switch_to_buffer
+ */
+void yyset_in (FILE *  _in_str )
+	{
+        yyin = _in_str ;
+}
+
+void yyset_out (FILE *  _out_str )
+{
+        yyout = _out_str ;
+	}
+
+int yyget_debug  (void)
+{
+        return yy_flex_debug;
+}
+
+void yyset_debug (int  _bdebug )
+	{
+        yy_flex_debug = _bdebug ;
+	}
+
+static int yy_init_globals (void)
+{
+        /* Initialization is the same as for the non-reentrant scanner.
+     * This function is called from yylex_destroy(), so don't allocate here.
+     */
+
+    (yy_buffer_stack) = NULL;
+    (yy_buffer_stack_top) = 0;
+    (yy_buffer_stack_max) = 0;
+    (yy_c_buf_p) = NULL;
+    (yy_init) = 0;
+    (yy_start) = 0;
+
+/* Defined in main.c */
+#ifdef YY_STDINIT
+    yyin = stdin;
+    yyout = stdout;
+#else
+    yyin = NULL;
+    yyout = NULL;
+#endif
+
+    /* For future reference: Set errno on error, since we are called by
+     * yylex_init()
+     */
+    return 0;
+	}
+
+/* yylex_destroy is for both reentrant and non-reentrant scanners. */
+int yylex_destroy  (void)
+{
+
+    /* Pop the buffer stack, destroying each element. */
+	while(YY_CURRENT_BUFFER){
+		yy_delete_buffer( YY_CURRENT_BUFFER  );
+		YY_CURRENT_BUFFER_LVALUE = NULL;
+		yypop_buffer_state();
+	}
+
+	/* Destroy the stack itself. */
+	yyfree((yy_buffer_stack) );
+	(yy_buffer_stack) = NULL;
+
+    /* Reset the globals. This is important in a non-reentrant scanner so the next time
+     * yylex() is called, initialization will occur. */
+    yy_init_globals( );
+
+    return 0;
+}
+
+/*
+ * Internal utility routines.
+ */
 
 #ifndef yytext_ptr
-#ifdef YY_USE_PROTOS
-static void yy_flex_strncpy( char *s1, yyconst char *s2, int n )
-#else
-static void yy_flex_strncpy( s1, s2, n )
-char *s1;
-yyconst char *s2;
-int n;
-#endif
+static void yy_flex_strncpy (char* s1, const char * s2, int n )
 	{
-	register int i;
+		
+	int i;
 	for ( i = 0; i < n; ++i )
 		s1[i] = s2[i];
 	}
 #endif
 
 #ifdef YY_NEED_STRLEN
-#ifdef YY_USE_PROTOS
-static int yy_flex_strlen( yyconst char *s )
-#else
-static int yy_flex_strlen( s )
-yyconst char *s;
-#endif
+static int yy_flex_strlen (const char * s )
 	{
-	register int n;
+	int n;
 	for ( n = 0; s[n]; ++n )
 		;
 
@@ -1602,25 +1861,14 @@
 	}
 #endif
 
-
-#ifdef YY_USE_PROTOS
-static void *yy_flex_alloc( yy_size_t size )
-#else
-static void *yy_flex_alloc( size )
-yy_size_t size;
-#endif
+void *yyalloc (yy_size_t  size )
 	{
-	return (void *) malloc( size );
+			return malloc(size);
 	}
 
-#ifdef YY_USE_PROTOS
-static void *yy_flex_realloc( void *ptr, yy_size_t size )
-#else
-static void *yy_flex_realloc( ptr, size )
-void *ptr;
-yy_size_t size;
-#endif
+void *yyrealloc  (void * ptr, yy_size_t  size )
 	{
+		
 	/* The cast to (char *) in the following accommodates both
 	 * implementations that use char* generic pointers, and those
 	 * that use void* generic pointers.  It works with the latter
@@ -1628,27 +1876,17 @@
 	 * any pointer type to void*, and deal with argument conversions
 	 * as though doing an assignment.
 	 */
-	return (void *) realloc( (char *) ptr, size );
+	return realloc(ptr, size);
 	}
 
-#ifdef YY_USE_PROTOS
-static void yy_flex_free( void *ptr )
-#else
-static void yy_flex_free( ptr )
-void *ptr;
-#endif
+void yyfree (void * ptr )
 	{
-	free( ptr );
+			free( (char *) ptr );	/* see yyrealloc() for (char *) cast */
 	}
 
-#if YY_MAIN
-int main()
-	{
-	yylex();
-	return 0;
-	}
-#endif
-#line 114 "spp.ll"
+#define YYTABLES_NAME "yytables"
+
+#line 116 "spp.ll"
 
 
 
@@ -1688,3 +1926,4 @@
 
   return 0;
 }
+
diff -urN somfree-old/spp/src/spp.ll somfree/spp/src/spp.ll
--- somfree-old/spp/src/spp.ll	2024-09-13 06:03:41.198811111 +0300
+++ somfree/spp/src/spp.ll	2024-09-13 05:56:58.362026992 +0300
@@ -37,8 +37,10 @@
 %{
 #include <stdlib.h>
 #include <string.h>
-#include <direct.h>
+#ifndef __LINUX__
 #include <io.h>
+#include <direct.h>
+#endif
 
 #include <emitlib.h>
 
Binary files somfree-old/.svn/wc.db and somfree/.svn/wc.db differ
