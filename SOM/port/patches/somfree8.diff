diff -urN somfree-old/sc/src/sc.c somfree/sc/src/sc.c
--- somfree-old/sc/src/sc.c	2024-09-13 06:03:41.214811143 +0300
+++ somfree/sc/src/sc.c	2024-09-13 05:56:58.362026992 +0300
@@ -581,9 +581,9 @@
 				{
 					if (
 #if defined(_WIN32) || defined(__OS2__) || defined(__DOS__)
-						(buf[len]=='/')||
+						(buf[len]=='\\')||
 #endif
-						(buf[len]=='\\'))
+						(buf[len]=='/'))
 					{
 						len++;
 						break;
@@ -597,6 +597,9 @@
 					add_str(&somcpp,"\"");
 				}
 
+
+				if (len < 0) len=0;
+
                                 strncpy(buf+len,"somipc2.exe",sizeof(buf)-len);
                                 add_str(&somipc2,buf);
 
diff -urN somfree-old/somc/include/emitlib.h somfree/somc/include/emitlib.h
--- somfree-old/somc/include/emitlib.h	2024-09-13 06:03:41.198811111 +0300
+++ somfree/somc/include/emitlib.h	2024-09-13 05:56:58.362026992 +0300
@@ -24,7 +24,9 @@
 #ifdef _WIN32
 #include <windows.h>
 #endif
+#ifndef __LINUX__
 #include <io.h>	
+#endif
 #include <stdio.h>
 #include <stdlib.h>
 
diff -urN somfree-old/somc/src/somc.c somfree/somc/src/somc.c
--- somfree-old/somc/src/somc.c	2024-09-13 06:03:41.202811119 +0300
+++ somfree/somc/src/somc.c	2024-09-13 05:56:58.362026992 +0300
@@ -22,7 +22,9 @@
 #define global
 #include <emitlib.h>
 
+#ifndef __LINUX__
 #include <direct.h> // _getcwd
+#endif
 #include <ctype.h> // tolower, toupper
 
 // Use IBM SOM 3.0 ABI for non SOMLINK functions (1) or IBM SOM 2.1 ABI (0)
diff -urN somfree-old/somopc/src/oidl.l somfree/somopc/src/oidl.l
--- somfree-old/somopc/src/oidl.l	2024-09-13 06:03:41.210811136 +0300
+++ somfree/somopc/src/oidl.l	2024-09-13 06:04:33.030915742 +0300
@@ -1,90 +1,90 @@
-%{
-
-#include <stdio.h>  // fopen
-#include <stdlib.h> // malloc, free, realloc
-#include <string.h> // strcat
-
-#include <emitlib.h>
-
-#include "oidl.h"
-
-int trace=1;
-int lineno=1, column=0;
-char comment[16384]; // handle with -C
-char passthru[32768]; // handle with -S
-
-%}
-
-
-%x IN_CPP_COMMENT
-%x IN_PASSTHRU
-
-%%
-
-<INITIAL>{
-  "/*"             {BEGIN(IN_CPP_COMMENT); comment[0]=0x0; }
-  "passthru:"       {BEGIN(IN_PASSTHRU); passthru[0]=0x0;}
-}
-
-<IN_CPP_COMMENT>{
-  "*/"      { BEGIN(INITIAL); yylval.stval=strdup(comment); return T_COMMENT; }
-  [^*\n]+   { strcat(comment, yytext); }
-  "*"       // eat the lone star
-  \n        { strcat(comment, "\n"); lineno++; }
-}
-
-<IN_PASSTHRU>{
-  "endpassthru;"  {BEGIN(INITIAL);}
-  [^\n]+    { strcat(passthru, yytext);}
-  \n        { strcat(passthru, "\n"); lineno++; }
-}
-
-[0-9]+	 	  {if (trace) ECHO; column+=yyleng; yylval.ival=atoi(yytext); return T_CONSTANT;}
-:                 {if (trace) ECHO; column+=yyleng; return T_COLON;            }
-;                 {if (trace) ECHO; column+=yyleng; return T_SEMICOLON;        }
-,                 {if (trace) ECHO; column+=yyleng; return T_COMMA;            }
-=                 {if (trace) ECHO; column+=yyleng; return T_EQUAL;            }
---                {if (trace) ECHO; column+=yyleng; return T_DASHES;           }
-"..."             {if (trace) ECHO; column+=yyleng; return T_ELLIPSIS;         }
-"*"               {if (trace) ECHO; column+=yyleng; yylval.stval=strdup(yytext); return T_STAR; }
-"("               {if (trace) ECHO; column+=yyleng; return T_LEFTPARENTHESIS;  }
-")"               {if (trace) ECHO; column+=yyleng; return T_RIGHTPARENTHESIS; }
-"["               {if (trace) ECHO; column+=yyleng; return T_LEFTSQUAREBRACKET;  }
-"]"               {if (trace) ECHO; column+=yyleng; return T_RIGHTSQUAREBRACKET; }
-^#line            {if (trace) ECHO; column+=yyleng; return T_LINE;             }
-class             {if (trace) ECHO; column+=yyleng; return T_CLASS;            }
-file              {if (trace) ECHO; column+=yyleng; return T_FILE;             }
-stem              {if (trace) ECHO; column+=yyleng; return T_STEM;             }
-function          {if (trace) ECHO; column+=yyleng; return T_FUNCTION;         }
-prefix            {if (trace) ECHO; column+=yyleng; return T_PREFIX;           }
-classprefix       {if (trace) ECHO; column+=yyleng; return T_CLASSPREFIX;      }
-major             {if (trace) ECHO; column+=yyleng; return T_MAJOR;            }
-minor             {if (trace) ECHO; column+=yyleng; return T_MINOR;            }
-version           {if (trace) ECHO; column+=yyleng; return T_VERSION;          }
-global            {if (trace) ECHO; column+=yyleng; return T_GLOBAL;           }
-local             {if (trace) ECHO; column+=yyleng; return T_LOCAL;            }
-classInit         {if (trace) ECHO; column+=yyleng; return T_CLASSINIT;        }
-release           {if (trace) ECHO; column+=yyleng; return T_RELEASE;          }
-order             {if (trace) ECHO; column+=yyleng; return T_ORDER;            }
-metaclass         {if (trace) ECHO; column+=yyleng; return T_METACLASS;        }
-parent            {if (trace) ECHO; column+=yyleng; return T_PARENT;           }
-data              {if (trace) ECHO; column+=yyleng; return T_DATA;             }
-private           {if (trace) ECHO; column+=yyleng; return T_PRIVATE;          }
-public            {if (trace) ECHO; column+=yyleng; return T_PUBLIC;           }
-internal          {if (trace) ECHO; column+=yyleng; return T_INTERNAL;         }
-methods           {if (trace) ECHO; column+=yyleng; return T_METHODS;          }
-group             {if (trace) ECHO; column+=yyleng; return T_GROUP;            }
-method            {if (trace) ECHO; column+=yyleng; return T_METHOD;           }
-procedure         {if (trace) ECHO; column+=yyleng; return T_PROCEDURE;        }
-offset            {if (trace) ECHO; column+=yyleng; return T_OFFSET;           }
-name              {if (trace) ECHO; column+=yyleng; return T_NAME;             }
-lookup            {if (trace) ECHO; column+=yyleng; return T_LOOKUP;           }
-external          {if (trace) ECHO; column+=yyleng; return T_EXTERNAL;         }
-override          {if (trace) ECHO; column+=yyleng; return T_OVERRIDE;         }
-[A-Za-z][_0-9A-Za-z]* {if (trace) ECHO; column+=yyleng; yylval.stval=strdup(yytext); return T_IDENTIFIER;   }
-[ \t]+            { column++;                                                  }
-\n                { lineno++;                                                  }
-.                 { printf("ERROR"); };
-
-%%
-/* "use"             {if (trace) ECHO; column+=yyleng; return T_USE;              } */
+%{
+
+#include <stdio.h>  // fopen
+#include <stdlib.h> // malloc, free, realloc
+#include <string.h> // strcat
+
+#include <emitlib.h>
+
+#include "oidl.h"
+
+int trace=1;
+int lineno=1, column=0;
+char comment[16384]; // handle with -C
+char passthru[32768]; // handle with -S
+
+%}
+
+
+%x IN_CPP_COMMENT
+%x IN_PASSTHRU
+
+%%
+
+<INITIAL>{
+  "/*"             {BEGIN(IN_CPP_COMMENT); comment[0]=0x0; }
+  "passthru:"       {BEGIN(IN_PASSTHRU); passthru[0]=0x0;}
+}
+
+<IN_CPP_COMMENT>{
+  "*/"      { BEGIN(INITIAL); yylval.stval=strdup(comment); return T_COMMENT; }
+  [^*\n]+   { strcat(comment, yytext); }
+  "*"       // eat the lone star
+  \n        { strcat(comment, "\n"); lineno++; }
+}
+
+<IN_PASSTHRU>{
+  "endpassthru;"  {BEGIN(INITIAL);}
+  [^\n]+    { strcat(passthru, yytext);}
+  \n        { strcat(passthru, "\n"); lineno++; }
+}
+
+[0-9]+	 	  {if (trace) ECHO; column+=yyleng; yylval.ival=atoi(yytext); return T_CONSTANT;}
+:                 {if (trace) ECHO; column+=yyleng; return T_COLON;            }
+;                 {if (trace) ECHO; column+=yyleng; return T_SEMICOLON;        }
+,                 {if (trace) ECHO; column+=yyleng; return T_COMMA;            }
+=                 {if (trace) ECHO; column+=yyleng; return T_EQUAL;            }
+--                {if (trace) ECHO; column+=yyleng; return T_DASHES;           }
+"..."             {if (trace) ECHO; column+=yyleng; return T_ELLIPSIS;         }
+"*"               {if (trace) ECHO; column+=yyleng; yylval.stval=strdup(yytext); return T_STAR; }
+"("               {if (trace) ECHO; column+=yyleng; return T_LEFTPARENTHESIS;  }
+")"               {if (trace) ECHO; column+=yyleng; return T_RIGHTPARENTHESIS; }
+"["               {if (trace) ECHO; column+=yyleng; return T_LEFTSQUAREBRACKET;  }
+"]"               {if (trace) ECHO; column+=yyleng; return T_RIGHTSQUAREBRACKET; }
+^#line            {if (trace) ECHO; column+=yyleng; return T_LINE;             }
+class             {if (trace) ECHO; column+=yyleng; return T_CLASS;            }
+file              {if (trace) ECHO; column+=yyleng; return T_FILE;             }
+stem              {if (trace) ECHO; column+=yyleng; return T_STEM;             }
+function          {if (trace) ECHO; column+=yyleng; return T_FUNCTION;         }
+prefix            {if (trace) ECHO; column+=yyleng; return T_PREFIX;           }
+classprefix       {if (trace) ECHO; column+=yyleng; return T_CLASSPREFIX;      }
+major             {if (trace) ECHO; column+=yyleng; return T_MAJOR;            }
+minor             {if (trace) ECHO; column+=yyleng; return T_MINOR;            }
+version           {if (trace) ECHO; column+=yyleng; return T_VERSION;          }
+global            {if (trace) ECHO; column+=yyleng; return T_GLOBAL;           }
+local             {if (trace) ECHO; column+=yyleng; return T_LOCAL;            }
+classInit         {if (trace) ECHO; column+=yyleng; return T_CLASSINIT;        }
+release           {if (trace) ECHO; column+=yyleng; return T_RELEASE;          }
+order             {if (trace) ECHO; column+=yyleng; return T_ORDER;            }
+metaclass         {if (trace) ECHO; column+=yyleng; return T_METACLASS;        }
+parent            {if (trace) ECHO; column+=yyleng; return T_PARENT;           }
+data              {if (trace) ECHO; column+=yyleng; return T_DATA;             }
+private           {if (trace) ECHO; column+=yyleng; return T_PRIVATE;          }
+public            {if (trace) ECHO; column+=yyleng; return T_PUBLIC;           }
+internal          {if (trace) ECHO; column+=yyleng; return T_INTERNAL;         }
+methods           {if (trace) ECHO; column+=yyleng; return T_METHODS;          }
+group             {if (trace) ECHO; column+=yyleng; return T_GROUP;            }
+method            {if (trace) ECHO; column+=yyleng; return T_METHOD;           }
+procedure         {if (trace) ECHO; column+=yyleng; return T_PROCEDURE;        }
+offset            {if (trace) ECHO; column+=yyleng; return T_OFFSET;           }
+name              {if (trace) ECHO; column+=yyleng; return T_NAME;             }
+lookup            {if (trace) ECHO; column+=yyleng; return T_LOOKUP;           }
+external          {if (trace) ECHO; column+=yyleng; return T_EXTERNAL;         }
+override          {if (trace) ECHO; column+=yyleng; return T_OVERRIDE;         }
+[A-Za-z][_0-9A-Za-z]* {if (trace) ECHO; column+=yyleng; yylval.stval=strdup(yytext); return T_IDENTIFIER;   }
+[ \t]+            { column++;                                                  }
+\n                { lineno++;                                                  }
+.                 { printf("ERROR"); };
+
+%%
+/* "use"             {if (trace) ECHO; column+=yyleng; return T_USE;              } */
diff -urN somfree-old/somopc/src/oidl.y somfree/somopc/src/oidl.y
--- somfree-old/somopc/src/oidl.y	2024-09-13 06:03:41.210811136 +0300
+++ somfree/somopc/src/oidl.y	2024-09-13 06:04:30.758911143 +0300
@@ -1,1128 +1,1128 @@
-%{
-#include <stdio.h> // fopen, fprintf
-#include <string.h>
-
-#include <emitlib.h>
-
-#define YYERROR_VERBOSE
-
-extern int lineno, column;
-
-Entry e;
-
-Entry *cls;	// Current Class Entry
-Entry *pcls;	// Parent Class Entry
-Entry *mcls;	// Meta Class Entry
-
-void yyerror(const char *str)
-{
-        fprintf(stderr,"\nerror: %s\n", str);
-}
- 
-int yywrap()
-{
-        return 1;
-} 
-  
-%}
-
-
-
-%start oidl
-
-%union{
- char *stval;
- int ival;
-}
-
-
-%type <stval> overridemethod_name
-
-%type <ival> T_CONSTANT
-
-%token T_COLON T_SEMICOLON T_COMMA T_STAR T_COMMENT T_IDENTIFIER
-%token T_EQUAL T_DASHES T_CONSTANT T_PERIOD  T_STRING
-%token T_ELLIPSIS T_LEFTPARENTHESIS T_RIGHTPARENTHESIS
-%token T_LEFTSQUAREBRACKET T_RIGHTSQUAREBRACKET
-
-%token T_VERSION T_GLOBAL T_LOCAL T_CLASSINIT T_RELEASE T_ORDER T_METACLASS T_PARENT
-%token T_CLASS T_LINE
-%token T_FILE T_STEM T_FUNCTION T_PREFIX T_CLASSPREFIX T_MAJOR T_MINOR
-%token T_PASSTHRU T_BEFORE T_AFTER T_ENDPASSTHRU T_DATA T_PRIVATE T_PUBLIC T_INTERNAL
-%token T_METHODS T_GROUP T_METHOD T_PROCEDURE T_OFFSET T_NAME T_LOOKUP T_EXTERNAL
-%token T_USE T_OVERRIDE
-
-%%
-
-oidl
-	:
-		{
-			if (somtg_f.verbose) printf("Parsing of \"%s\" started.\n", somtfilePath);
-			somtg_f._ERROR=0;   /* @todo subject to move to parse() */
-			somtg_f.WARN=0;   /* @todo subject to move to parse() */
-			somtg_f.FATAL=0;   /* @todo subject to move to parse() */
-			somtg_f.INTERNAL=0;   /* @todo subject to move to parse() */
-			somtg_buf=somtsmallocSL(somtg_f.commentsize, TRUE);   /* @todo subject to move to parse() */
-		}
-	  class_list
-		{
-			somtfree(somtg_buf);   /* @todo subject to move to parse() */
-			if (somtg_f.verbose) printf("Parsing of \"%s\" finished.\n", somtfilePath);
-		}
-	| line
-        ;
-
-line	: T_LINE T_CONSTANT T_STRING
-	;
-
-class_list
-	: class_definition
-	| class_list class_definition
-	;
-
-class_definition
-	:
-		{
-			cls=(Entry *)somtsmallocSL(sizeof(Entry), TRUE);
-			cls->atts=somtaddModifierSL(cls->atts, "callstyle", "oidl");
-			cls->type=SOMTClassE;
-			somtclassIdlCall=FALSE;
-			cls->u.c.file=strdup(somtfilePath);
-		}
-	  class_section section_list
-		{
-			somtaddEntrySL(somtstab, cls->name, cls);
-			somtfree(cls);
-		}
-	;
-
-section_list
-	: section
-        | section_list section
-        ;
-
-section
-	: releaseorder_section
-        | metaclass_section
-        |
-		{
-			pcls=(Entry *)somtsmallocSL(sizeof(Entry), TRUE);
-			pcls->atts=somtaddModifierSL(pcls->atts, "callstyle", "oidl");
-			pcls->type=SOMTBaseE;
-			somtclassIdlCall=FALSE;
-//			pcls->u.c.file=strdup(somtfilePath);
-		}
-	  parent_section
-		{
-			cls->u.c.parent=somtaddEntrySL(somtstab, pcls->name, pcls);
-			somtfree(pcls);
-		}
-        | passthru_section
-        | data_section
-	| methods_section
-	;
-
-class_section
-	: classdef 
-        | classdef description
-		{
-			cls->comment=$<stval>2;
-		}
-	;
-
-classdef
-	: class_header class_name T_SEMICOLON 
-	| class_header class_name class_attributes T_SEMICOLON
-        ;
-
-class_header
-	: T_CLASS T_COLON 
-	;
-
-class_name
-	: T_IDENTIFIER 
-		{
-			somtclassName=$<stval>1;
-			cls->lineno=lineno;                 
-			cls->name=$<stval>1;
-		}
-        ;
-
-class_attributes
-	: T_COMMA class_attribute
-	| class_attributes T_COMMA class_attribute
-        ;
-
-class_attribute
-	: T_FILE T_STEM T_EQUAL T_IDENTIFIER
-		{
-			cls->atts=somtaddModifierSL(cls->atts, "filestem", $<stval>4);
-		}
-        | T_EXTERNAL T_STEM T_EQUAL T_IDENTIFIER
-		{
-			cls->atts=somtaddModifierSL(cls->atts, "externalstem", $<stval>4);
-		}
-        | T_FUNCTION T_PREFIX T_EQUAL T_IDENTIFIER
-		{
-			cls->atts=somtaddModifierSL(cls->atts, "functionprefix", $<stval>4);
-		}
-        | T_EXTERNAL T_PREFIX T_EQUAL T_IDENTIFIER
-		{
-			cls->atts=somtaddModifierSL(cls->atts, "externalprefix", $<stval>4);
-		}
-        | T_CLASSPREFIX T_EQUAL T_IDENTIFIER
-		{
-			cls->atts=somtaddModifierSL(cls->atts, "classprefix", $<stval>3);
-		}
-        | T_MAJOR T_VERSION T_EQUAL T_CONSTANT
-		{
-			char *st=itoa($4, somtsmallocSL(sizeof(int)*8+1/*_MAX_ITOSTR_BASE10_COUNT*/, TRUE), 10);
-			cls->atts=somtaddModifierSL(cls->atts, "majorversion", st);
-			somtmajorVersion=strdup(st);
-			somtfree(st);
-		}
-        | T_MINOR T_VERSION T_EQUAL T_CONSTANT
-		{
-			char *st=itoa($4, somtsmallocSL(sizeof(int)*+1/*_MAX_ITOSTR_BASE10_COUNT*/, TRUE), 10);
-			cls->atts=somtaddModifierSL(cls->atts, "minorversion", st);
-			somtminorVersion=strdup(st);
-			somtfree(st);
-		}
-        | T_CLASSINIT T_EQUAL T_IDENTIFIER
-		{
-			cls->atts=somtaddModifierSL(cls->atts, "classInit", $<stval>3);
-		}
-	| visibility
-        ;
-
-visibility
-	: T_GLOBAL
-        | T_LOCAL
-	;
-
-releaseorder_section
-	: releaseorder_header release_list T_SEMICOLON
-		{
-			cls->atts=somtaddModifierSL(cls->atts, "releaseorder", $<stval>2);
-		}
-	;
-
-releaseorder_header
-	: T_RELEASE T_ORDER T_COLON
-	;
-
-release_list
-	: release
-		{ 
-			$<stval>$=strdup($<stval>1);
-		}
-	| release_list T_COMMA release
-		{
-			char *r=somtsmallocSL(strlen($<stval>1)+strlen($<stval>3)+2, TRUE);
-			strcat(strcat(strcat(r, $<stval>1), ","), $<stval>3);
-			$<stval>$=strdup(r);
-			somtfree(r);
-		}
-	;
-
-release
-	: T_IDENTIFIER
-		{
-			cls->u.c.release=somtaddModifierSL(cls->u.c.release, $<stval>1, NULL);
-			$<stval>$=$<stval>1;
-		}
-	;
-
-metaclass_section
-	: metaclassdef
-        | metaclassdef description
-		{
-			mcls->comment=$<stval>2;
-		}
-	;
-
-metaclassdef
-	: metaclass_header metaclass_name T_SEMICOLON
-        | metaclass_header metaclass_name metaclass_attributes T_SEMICOLON
-        ;
-
-metaclass_header
-	: T_METACLASS T_COLON
-        ;
-
-metaclass_name
-	: T_IDENTIFIER
-	;
-
-metaclass_attributes
-	: T_COMMA metaclass_attribute
-	| metaclass_attributes T_COMMA metaclass_attribute 
-	;
-
-metaclass_attribute
-	: T_FILE T_STEM T_EQUAL T_IDENTIFIER
-        | T_MAJOR T_VERSION T_EQUAL T_CONSTANT
-        | T_MINOR T_VERSION T_EQUAL T_CONSTANT
-        | visibility
-        ;
-
-parent_section
-	: parentdef
-        | parentdef description
-		{
-			pcls->comment=$<stval>2;
-		}
-	;
-
-
-parentdef
-	: parent_header parent_name T_SEMICOLON
-        | parent_header parent_name parent_attributes T_SEMICOLON
-        ;
-
-parent_header
-	: T_PARENT T_CLASS T_COLON
-        | T_PARENT T_COLON 
-        ;
-
-parent_name
-	: T_IDENTIFIER
-		{
-			pcls->lineno=lineno;  // @todo line of class definition?
-			pcls->name=$<stval>1;
-		}
-	;
-
-parent_attributes
-	: T_COMMA parent_attribute
-	| parent_attributes T_COMMA parent_attribute
-	;
-
-parent_attribute
-	: T_FILE T_STEM T_EQUAL T_IDENTIFIER
-        | T_MAJOR T_VERSION T_EQUAL T_CONSTANT
-        | T_MINOR T_VERSION T_EQUAL T_CONSTANT
-        | visibility
-        ;
-
-passthru_section
-	: T_PASSTHRU
-        ;
-
-data_section
-	: data_header variables
-	;
-
-data_header
-	: T_DATA T_COLON
-	;
-
-variables
-	: declaration
-        | declaration variables
-        ;
-
-declaration
-	: declarationdef T_SEMICOLON
-	| declarationdef T_SEMICOLON description
-		{
-//			cls->comment=$<stval>2;
-		}
-	;
-
-declarationdef
-	: declaration_specifiers
-	| declaration_specifiers data_attributes
-	;
-
-data_attributes
-	: T_COMMA data_attribute
-	| data_attributes T_COMMA data_attribute
-	;
-
-data_attribute
-	: T_PRIVATE
-	| T_PUBLIC
-	| T_INTERNAL
-	| T_CLASS
-	;
-
-declaration_specifiers
-	: type_specifier declarator
-	| type_specifier declarator declaration_specifiers
-	;
-
-type_specifier
-	: T_IDENTIFIER 
-		{
-			$<stval>$=$<stval>1;
-		}
-	;
-
-declarator
-	: pointer direct_declarator
-	| direct_declarator
-	;
-
-direct_declarator
-	: T_IDENTIFIER {printf("$<stval>1");}
-	| T_LEFTPARENTHESIS declarator T_RIGHTPARENTHESIS
-	| direct_declarator T_LEFTSQUAREBRACKET T_CONSTANT T_RIGHTSQUAREBRACKET
-	| direct_declarator T_LEFTSQUAREBRACKET T_RIGHTSQUAREBRACKET
-	| direct_declarator T_LEFTPARENTHESIS declaration_specifiers T_RIGHTPARENTHESIS
-	| direct_declarator T_LEFTPARENTHESIS T_RIGHTPARENTHESIS
-	;
-
-pointer
-	: T_STAR
-		{
-			$<stval>$=$<stval>1;
-		}
-	| pointer T_STAR
-		{
-			char *r=somtsmallocSL(strlen($<stval>1)+strlen($<stval>2)+1, TRUE);
-			strcat(r, $<stval>1);
-			strcat(r, $<stval>2);
-			free($<stval>1);
-			$<stval>$=strdup(r);
-			somtfree(r);
-		}
-	;
-
-
-methods_section
-	: method_header method_list
-	| method_header description method_list
-		{
-			e.comment=$<stval>2;
-		}
-	;
-
-method_header
-	: T_METHODS T_COLON
-	;
-
-method_list
-	: method 
-		{
-			cls->u.c.methodcnt++;
-			somtaddEntrySL(somtstab, e.name, &e);
-			memset(&e, 0, sizeof(Entry));
-		}
-	| method_list method 
-		{
-			cls->u.c.methodcnt++;
-			somtaddEntrySL(somtstab, e.name, &e);
-			memset(&e, 0, sizeof(Entry));
-		}
-        ;
-
-method
-	: methoddef T_SEMICOLON 
-	| methoddef T_SEMICOLON description 
-	;
-
-methoddef
-	: method_specifier
-	| method_specifier method_attributes
-	| overridemethod_specifier
-	;
-
-method_specifier
-	: method_type method_name T_LEFTPARENTHESIS parameter_list T_RIGHTPARENTHESIS 
-		{
-			e.u.m.type=strdup($<stval>1);
-		}
-	;                                             
-
-method_name
-	: T_IDENTIFIER 
-		{
-			char * desc=somtsmallocSL(MAX_DESCRIPTOR_LENGTH, TRUE);
-			e.type=SOMTNewMethodE;
-			e.lineno=lineno;
-			e.name=$<stval>1;
-			e.sname=&somtclassName;
-			strcat(desc, "::");
-			strcat(desc, $<stval>1);
-			strcat(desc, "::");
-			strcat(desc, somtclassName);
-			e.atts=somtaddModifierSL(e.atts, "descriptor", desc);
-			somtfree(desc);
-		}
-	;
-
-method_type
-	: type_specifier
-		{
-			$<stval>$=$<stval>1;
-		}
-	| type_specifier pointer
-		{
-			char *r=somtsmallocSL(strlen($<stval>1)+strlen($<stval>2)+1, TRUE);
-			strcat(r, $<stval>1);
-			strcat(r, $<stval>2);
-			free($<stval>1);
-			$<stval>$=strdup(r);
-			somtfree(r);
-		}
-	;
-
-overridemethod_specifier
-	: overridemethod_header overridemethod_name
-	| overridemethod_header overridemethod_name overridemethod_attributes
-	;                                             
-
-overridemethod_header
-	: T_OVERRIDE
-	| T_OVERRIDE T_COLON
-	;
-
-overridemethod_name
-	: T_IDENTIFIER 
-		{
-			char * desc=somtsmallocSL(MAX_DESCRIPTOR_LENGTH, TRUE);
-			e.type=SOMTOverrideMethodE;
-			e.lineno=lineno;
-			e.name=$<stval>1;
-			e.sname=&somtclassName;
-			strcat(strcat(strcat(strcat(desc ,"::"), $<stval>1), "::"), somtclassName);
-			e.atts=somtaddModifierSL(e.atts, "descriptor", desc);
-			somtfree(desc);
-		}
-	;
-
-parameter_list
-	: parameter
-	| parameter_list T_COMMA parameter
-	;
-
-parameter
-	: T_ELLIPSIS
-	| type_specifier declarator
-	;
-
-method_attributes
-	: T_COMMA method_attribute
-	| method_attributes T_COMMA method_attribute
-	;
-
-method_attribute
-	: T_PRIVATE
-	| T_PUBLIC
-	| T_METHOD
-	| T_PROCEDURE
-	| T_CLASS
-	| T_OFFSET
-	| T_NAME T_LOOKUP
-	| T_LOCAL
-	| T_EXTERNAL
-	| T_USE T_EQUAL T_IDENTIFIER
-	;
-
-/* descriptor */
-/* noset */
-/* original */
-
-overridemethod_attributes
-	: T_COMMA overridemethod_attribute
-	| overridemethod_attributes T_COMMA overridemethod_attribute
-	;
-
-overridemethod_attribute
-	: T_PRIVATE
-	| T_PUBLIC
-	| T_CLASS
-	| T_LOCAL
-	| T_EXTERNAL
-	| T_USE T_EQUAL T_IDENTIFIER
-	;
-
-description
-	: T_COMMENT 
-		{
-			$<stval>$=$<stval>1;
-		}
-        ;
-
-%%
-
-FILE *yyin;
-
-// Experimental replacement of somttype
-char * mysomttype(SOMTTypes ttype)
-{
-  char * result=NULL;
-  switch ( ttype )
-  {
-    case SOMTAnyBE:
-      result="SOMTAnyBE";
-      break;
-    case     SOMTArgumentE:
-      result="SOMTArgumentE";
-      break;
-    case     SOMTAttE:
-      result="SOMTAttE";
-      break;
-    case     SOMTBadEntryE:
-      result="SOMTBadEntryE";
-      break;
-    case     SOMTBaseE:
-      result="SOMTBaseE";
-      break;
-    case     SOMTBooleanBE:
-      result="SOMTBooleanBE";
-      break;
-    case     SOMTCaseEntryE:
-      result="SOMTCaseEntryE";
-      break;
-    case     SOMTCaseListE:
-      result="SOMTCaseListE";
-      break;
-    case     SOMTCaseSTME:
-      result="SOMTCaseSTME";
-      break;
-    case     SOMTCharBE:
-      result="SOMTCharBE";
-      break;
-    case     SOMTClassE:
-      result="SOMTClassE";
-      break;
-    case     SOMTConstE:
-      result="SOMTConstE";
-      break;
-    case     SOMTCopyrightE:
-      result="SOMTCopyrightE";
-      break;
-    case     SOMTDataE:
-      result="SOMTDataE";
-      break;
-    case     SOMTDclListE:
-      result="SOMTDclListE";
-      break;
-    case     SOMTDefaultE:
-      result="SOMTDefaultE";
-      break;
-    case     SOMTDoubleBE:
-      result="SOMTDoubleBE";
-      break;
-    case     SOMTEBaseE:
-      result="SOMTEBaseE";
-      break;
-    case     SOMTEEnumE:
-      result="SOMTEEnumE";
-      break;
-    case     SOMTEnumBE:
-      result="SOMTEnumBE";
-      break;
-    case     SOMTEnumE:
-      result="SOMTEnumE";
-      break;
-    case     SOMTEnumPE:
-      result="SOMTEnumPE";
-      break;
-    case     SOMTFloatBE:
-      result="SOMTFloatBE";
-      break;
-    case     SOMTGroupE:
-      result="SOMTGroupE";
-      break;
-    case     SOMTLongBE:
-      result="SOMTLongBE";
-      break;
-    case     SOMTMetaE:
-      result="SOMTMetaE";
-      break;
-    case     SOMTModuleE:
-      result="SOMTModuleE";
-      break;
-    case     SOMTNegativeBE:
-      result="SOMTNegativeBE";
-      break;
-    case     SOMTNewMethodE:
-      result="SOMTNewMethodE";
-      break;
-    case     SOMTOctetBE:
-      result="SOMTOctetBE";
-      break;
-    case     SOMTOverriddenMethodE:
-      result="SOMTOverriddenMethodE";
-      break;
-    case     SOMTOverrideMethodE:
-      result="SOMTOverrideMethodE";
-      break;
-    case     SOMTPassthruE:
-      result="SOMTPassthruE";
-      break;
-    case     SOMTSequenceE:
-      result="SOMTSequenceE";
-      break;
-    case     SOMTSequenceTDE:
-      result="SOMTSequenceTDE";
-      break;
-    case     SOMTShortBE:
-      result="SOMTShortBE";
-      break;
-    case     SOMTStringBE:
-      result="SOMTStringBE";
-      break;
-    case     SOMTStringE:
-      result="SOMTStringE";
-      break;
-    case     SOMTStructE:
-      result="SOMTStructE";
-      break;
-    case     SOMTStructPE:
-      result="SOMTStructPE";
-      break;
-    case     SOMTStructSE:
-      result="SOMTStructSE";
-      break;
-    case     SOMTTyDclE:
-      result="SOMTTyDclE";
-      break;
-    case     SOMTTypeCodeBE:
-      result="SOMTTypeCodeBE";
-      break;
-    case     SOMTTypedefBE:
-      result="SOMTTypedefBE";
-      break;
-    case     SOMTTypedefE:
-      result="SOMTTypedefE";
-      break;
-    case     SOMTUnionE:
-      result="SOMTUnionE";
-      break;
-    case     SOMTUnionPE:
-      result="SOMTUnionPE";
-      break;
-    case     SOMTUnionSE:
-      result="SOMTUnionSE";
-      break;
-    case     SOMTUnsignedLongBE:
-      result="SOMTUnsignedLongBE";
-      break;
-    case     SOMTUnsignedShortBE:
-      result="SOMTUnsignedShortBE";
-      break;
-    case     SOMTVoidBE:
-      result="SOMTVoidBE";
-      break;
-    case     SOMTVoidPtrBE:
-      result="SOMTVoidPtrBE";
-      break;
-// This is special case SOMTTypes used on call of emitter start and emitter end
-/*    case     SOMTEmitterBeginE:
-      result="SOMTEmitterBeginE";
-      break;
-    case     SOMTEmitterEndE:
-      result="SOMTEmitterEndE";
-      break; */
-    default:
-      printf("Unknown entry type: %d.\n", ttype);
-  }
-  return result;
-}
-
-void dumpReleaseOrder(char * name, AttList *ap)
-{
-  AttList *cur=ap;
-
-  for(; cur; cur = cur->next) 
-  {
-    printf("\t%s %s\n", name, cur->name);
-//    dumpAttrs("static", cur->staticlist);
-//    dumpAttrs("protectted", cur->protectedlist);
-//    dumpAttrs("public", cur->publiclist);
-//    dumpAttrs("private", cur->privatelist);
-  }
-}
-
-void dumpMethodOrData(Entry * ep)
-{
-  printf("\teptype = %08p\n", ep->u.m.eptype);
-  printf("\tptrs = %08p\n", ep->u.m.ptrs);
-  printf("\tarray = %08p\n", ep->u.m.array);
-  printf("\tarrays = %s\n", ep->u.m.arrays);
-  printf("\tdefn = %s\n", ep->u.m.defn);
-  printf("\ttype = %s\n", ep->u.m.type);
-  printf("\tvarargs = %s\n", ep->u.m.varargs ? "true" : "false");
-  printf("\tprivate = %s\n", ep->u.m.isprivate ? "true" : "false");
-  printf("\tinout = %d\n", ep->u.m.inoutmode);
-  printf("\tselfref = %s\n", ep->u.m.isselfref ? "true" : "false");
-  printf("\toneway = %s\n", ep->u.m.isoneway ? "true" : "false");
-  printf("\targcnt = %d\n", ep->u.m.argcnt);
-  printf("\targs = %08p\n", ep->u.m.args);
-  printf("\tomethod = %08p\n", ep->u.m.omethod);
-  printf("\toparent = %08p\n", ep->u.m.oparent);
-  printf("\tgroup = %08p\n", ep->u.m.group);
-  printf("\tnext = %08p\n", ep->u.m.next);
-  printf("\tctxsa = %08p\n", ep->u.m.ctxsa);
-  printf("\traiseslist = %08p\n", ep->u.m.raiseslist);
-}
-
-void mysomtShowEntry(Entry * ep)
-{
-  if (ep)
-  {
-    printf("      somtShowEntry: Entry at %08p, name = %s, type = %d\n", ep, ep->name, ep->type);
-    printf("\tlineno = %d\n", ep->lineno);
-    switch ( ep->type )
-    {
-      case SOMTAnyBE:
-        printf("\t SOMTAnyBE\n");
-        break;
-      case     SOMTArgumentE:
-        printf("\t SOMTArgumentE\n");
-        dumpMethodOrData(ep);
-        break;
-      case     SOMTAttE:
-        printf("\t SOMTAttE\n");
-        break;
-      case     SOMTBadEntryE:
-        printf("\t SOMTBadEntryE\n");
-        break;
-      case     SOMTBaseE:
-        printf("\t SOMTBaseE\n");
-        printf("\tparentdef = %08p\n", ep->u.p.parentdef);
-        break;
-      case     SOMTBooleanBE:
-        printf("\t SOMTBooleanBE\n");
-        break;
-      case     SOMTCaseEntryE:
-        printf("\t SOMTCaseEntryE\n");
-        break;
-      case     SOMTCaseListE:
-        printf("\t SOMTCaseListE\n");
-        break;
-      case     SOMTCaseSTME:
-        printf("\t SOMTCaseSTME\n");
-        break;
-      case     SOMTCharBE:
-        printf("\t SOMTCharBE\n");
-        break;
-      case     SOMTClassE:
-        printf("\tClass Definition Entry:\n");
-        printf("\tfile = %s\n", ep->u.c.file);
-        printf("\tmeta = %08p\n", ep->u.c.meta);
-        printf("\tparent = %08p\n", ep->u.c.parent);
-        printf("\tparents = %08p\n", ep->u.c.parents);
-        printf("\trelease = %08p\n", ep->u.c.release);
-	dumpReleaseOrder("\t", ep->u.c.release);
-        printf("\tpassthru = %08p\n", ep->u.c.passthrus);
-        printf("\tdata = %08p\n", ep->u.c.data);
-        printf("\ttc = %08p\n", ep->tc);
-        printf("\tmethodcnt = %08d\n", ep->u.c.methodcnt);
-        printf("\tmethods = %08p\n", ep->u.c.methods);
-        printf("\tinherited = %08p\n", ep->u.c.inherited);
-        printf("\tpubdefs = %08p\n", ep->u.c.pubdefs);
-        printf("\tmod = %08p\n", ep->u.c.mod);
-        printf("\tcls = %08p\n", ep->u.c.cls);
-        printf("\tforward = %s\n", ep->u.c.isforward ? "true" : "false");
-        break;
-      case     SOMTConstE:
-        printf("\t SOMTConstE\n");
-        break;
-      case     SOMTCopyrightE:
-        printf("\t SOMTCopyrightE\n");
-        break;
-      case     SOMTDataE:
-        printf("\t SOMTDataE\n");
-        dumpMethodOrData(ep);
-        break;
-      case     SOMTDclListE:
-        printf("\t SOMTDclListE\n");
-        break;
-      case     SOMTDefaultE:
-        printf("\t SOMTDefaultE\n");
-        break;
-      case     SOMTDoubleBE:
-        printf("\t SOMTDoubleBE\n");
-        break;
-      case     SOMTEBaseE:
-        printf("\t SOMTEBaseE\n");
-        break;
-      case     SOMTEEnumE:
-        printf("\t SOMTEEnumE\n");
-        break;
-      case     SOMTEnumBE:
-        printf("\t SOMTEnumBE\n");
-        break;
-      case     SOMTEnumE:
-        printf("\t SOMTEnumE\n");
-        break;
-      case     SOMTEnumPE:
-        printf("\t SOMTEnumPE\n");
-        break;
-      case     SOMTFloatBE:
-        printf("\t SOMTFloatBE\n");
-        break;
-      case     SOMTGroupE:
-        printf("\t SOMTGroupE\n");
-        break;
-      case     SOMTLongBE:
-        printf("\t SOMTLongBE\n");
-        break;
-      case     SOMTMetaE:
-        printf("\t SOMTMetaE\n");
-        break;
-      case     SOMTModuleE:
-        printf("\t SOMTModuleE\n");
-        break;
-      case     SOMTNegativeBE:
-        printf("\t SOMTNegativeBE\n");
-        break;
-      case     SOMTNewMethodE:
-        printf("\t SOMTNewMethodE\n");
-        dumpMethodOrData(ep);
-        break;
-      case     SOMTOctetBE:
-        printf("\t SOMTOctetBE\n");
-        break;
-      case     SOMTOverriddenMethodE:
-        printf("\t SOMTOverriddenMethodE\n");
-        dumpMethodOrData(ep);
-        break;
-      case     SOMTOverrideMethodE:
-        printf("\t SOMTOverrideMethodE\n");
-        dumpMethodOrData(ep);
-        break;
-      case     SOMTPassthruE:
-        printf("\t SOMTPassthruE\n");
-        break;
-      case     SOMTSequenceE:
-        printf("\t SOMTSequenceE\n");
-        break;
-      case     SOMTSequenceTDE:
-        printf("\t SOMTSequenceTDE\n");
-        break;
-      case     SOMTShortBE:
-        printf("\t SOMTShortBE\n");
-        break;
-      case     SOMTStringBE:
-        printf("\t SOMTStringBE\n");
-        break;
-      case     SOMTStringE:
-        printf("\t SOMTStringE\n");
-        break;
-      case     SOMTStructE:
-        printf("\t SOMTStructE\n");
-        break;
-      case     SOMTStructPE:
-        printf("\t SOMTStructPE\n");
-        break;
-      case     SOMTStructSE:
-        printf("\t SOMTStructSE\n");
-        printf("\tdcllist = %08p\n", ep->u.struc.dcllist);
-        printf("\tcls = %08p\n", ep->u.struc.cls);
-        printf("\texception = %s\n", ep->u.struc.isexcept ? "true" : "false");
-        printf("\tmutref = %s\n", ep->u.struc.ismutref ? "true" : "false");
-        break;
-      case     SOMTTyDclE:
-        printf("\t SOMTTyDclE\n");
-        break;
-      case     SOMTTypeCodeBE:
-        printf("\t SOMTTypeCodeBE\n");
-        break;
-      case     SOMTTypedefBE:
-        printf("\t SOMTTypedefBE\n");
-        dumpMethodOrData(ep);
-        break;
-      case     SOMTTypedefE:
-        printf("\t SOMTTypedefE\n");
-        break;
-      case     SOMTUnionE:
-        printf("\t SOMTUnionE\n");
-        break;
-      case     SOMTUnionPE:
-        printf("\t SOMTUnionPE\n");
-        break;
-      case     SOMTUnionSE:
-        printf("\t SOMTUnionSE\n");
-        break;
-      case     SOMTUnsignedLongBE:
-        printf("\t SOMTUnsignedLongBE\n");
-        break;
-      case     SOMTUnsignedShortBE:
-        printf("\t SOMTUnsignedShortBE\n");
-        break;
-      case     SOMTVoidBE:
-        printf("\t SOMTVoidBE\n");
-        break;
-      case     SOMTVoidPtrBE:
-        printf("\t SOMTVoidPtrBE\n");
-        dumpMethodOrData(ep);
-        break;
-  // This is special case SOMTTypes used on call of emitter start and emitter end
-  /*    case     SOMTEmitterBeginE:
-        result="SOMTEmitterBeginE";
-        break;
-      case     SOMTEmitterEndE:
-        result="SOMTEmitterEndE";
-        break; */
-      default:
-        printf("Error: somtShowEntry, bad entry type of %d", ep->type);
-//        SOM_Error(SOM_Fatal, __FILE__, __LINE__);
-//        SOMError(9, __FILE__, __LINE__);
-    }
-  }
-  else 
-  {
-    printf("somtShowEntry: NULL entry\n");
-  }
-}
-
-void dumpAttrs(AttList *ap)
-{
-  struct AttList *cur = ap;
-
-  for(cur = ap; cur; cur = cur->next) 
-  {
-    printf("\tModifier %s=%s\n", cur->name, cur->value);
-  }
-}
-
-
-void mydumpEntry(Entry * ep)
-{
-  printf("Entry at address %p\n", ep);
-  printf("--------------------------\n");
-  printf("Entry type: %s (%d)\n", mysomttype(ep->type), ep->type);
-//  printf("Entry type: %s (%d)\n", somtEntryTypeName(ep->type), ep->type);
-  if (ep->sname) printf("Scoped name: %s\n", *ep->sname);
-  if (ep->comment) printf("Comment associated with entry: %s\n", ep->comment);
-  printf("Modifiers: %p\n", ep->atts);
-  if (ep->atts) dumpAttrs(ep->atts);
-  printf("TypeCode: %p\n", ep->tc);
-  printf("Points to the object: %p\n", ep->objref);
-  printf("Reference to real type: %s\n", ep->isref ? "true" : "false");
-  printf("Entry union: %p\n", &ep->u);
-#ifdef __PRIVATE__
-//    RHBelement *data;
-//    char *filestem;
-#endif    
-  mysomtShowEntry(ep);
-//  somtShowEntry(ep);
-};
-
-void dumpSep(Sep * sep)
-{
-    printf("Linked list item at address %p\n", sep);
-    printf("---------------------------------------\n");
-    printf("Position number: %d\n", sep->posn);
-    printf("Address of Entry: %p\n", sep->ep);
-    printf("Next linked list item address: %p\n", sep->next);
-    if (sep->ep) 
-    {
-      mydumpEntry((Entry *)sep->ep);
-      dumpSep(sep->next);
-    }
-}
-
-void dumpStab(Stab * stab)
-{
-  unsigned int i;
-  printf("Basic Symbol Table/Hash table (STab) structure\n");
-  printf("----------------------------------------------\n");
-  printf("Size of buscet: %d\n", stab->size);
-  printf("Size of entry structure: %d\n", stab->entrysize);
-  printf("Number of elements: %d\n", stab->nelms);
-  printf("Address of base slot: %p\n", stab->base);
-  printf("Max address of slot: %p\n", stab->limit);
-  printf("Start address of slot buffer: %p\n", stab->buf);
-  printf("Address of MemBuf: %p\n", stab->membuf);
-  printf("Ignore case flag: %s\n", stab->ignorecase ? "true" : "false");
-  for(i=0; i<stab->size;i++)
-  {
-    printf("Linked list at slot %d at offset %08x at address %p\n", i, sizeof(Sep)*i, stab->buf+i);
-    printf("----------------------\n");
-    dumpSep(stab->buf+i);
-  }
-}
-
-
-void usage(void)
-{
-  printf("\nSC [-options] file[.CSC]\n");
-  printf("\n-C n\n\tset the size of the comment buffer (default: 16384)\n");
-  printf("\n-s n\n\tset the total amount of string space for names and passthru lines (default: 32768)\n");
-  printf("\n-V\n\tdisplay version information\n");
-  printf("\n-a name[=value]\n\tadd a global attribute. The currently supported attributes are defined below (at the end of this section)\n");
-  printf("\n-d directory\n\tspecify a directory where all files emitted during the execution of this command should be placed. If the -d option is not used, all emitted output files are placed in the same directory as the input .csc file\n");
-  printf("\n-h or ?\n\tprovide usage information for reference\n");
-  printf("\n-i filename\n\tspecify the name of the OIDL class definition file. Use this option to override the built-in assumption that the input file will have a .csc extension. Any filename you supply with the -i option is used exactly as you provide it\n");
-  printf("\n-r\n\tcheck that all release-order entries actually exist (default: FALSE)\n");
-  printf("\n-s string\n\tsubstitute string in place of the contents of the SMEMIT environment variable for the duration of the current SC command. If you supply a list of values, you\n");
-  printf("must enclose the list with double quotation marks (\" \"). You can use the -s option as a convenient way to override the SMEMIT environment variable. For example:\n\n");
-  printf("SC -s \"h;sc\" EXAMPLE\n\n");
-  printf("is equivalent to the following sequence of commands:\n\n");
-  printf("SET OLDSMEMIT = %%SMEMIT%%\n");
-  printf("SET SMEMIT = h;sc\n");
-  printf("SC EXAMPLE\n");
-  printf("SET SMEMIT = %%OLDSMEMIT%%\n");
-  printf("\n-w\n\tsuppress warning messages (default: FALSE)\n\n");
-  printf("The only global attributes currently supported by SC.EXE are:\n");
-  printf("\ncomment = comment string\n\twhere comment string can be one of the following: \"/*\", \"--\", or \"//\". This\n");
-  printf("indicates that comments marked in the indicated way are to be completely\n");
-  printf("ignored by SC.EXE and not retained for subsequent processing by one of the\n");
-  printf("emitters.\n");
-  printf("Note: Comments indicated by lines whose first non-white-space character is\n");
-  printf("a # are always ignored by SC.EXE. Also note that comments of any\n");
-  printf("form in passthru lines are passed through.\n");
-  printf("\ncstyle = comment style\n\tcontrols the form of emitted comments. Comment style must be one of s, c, or\n");
-  printf("+ to cause emitted comments to be in \"--\", \"/* */\", or \"//\" form , respectively\n");
-  printf("The default form is s\n");
-  printf("\nibmc\n\tcauses EMITC, EMITH, EMITIH, EMITPH, and EMITDEF to generate code with\n");
-  printf("pragmas specifically intended for the IBM C Set/2 Compiler. This attribute is\n");
-  printf("specified by default\n");
-  printf("\ncl386\n\tcauses EMITC, EMITH, EMITIH, EMITPH, and EMITDEF not to generate code\n");
-  printf("with pragmas specifically intended for the IBM C Set/2 Compiler\n");
-}
-
-void parse_file(char * file)
-{
-  // parser input stream
-  yyin=fopen(file,"r");
-
-  strcpy(somtfilePath, file);
-
-  // Initialize symbol table
-  somtstab=(Stab *)somtsmallocSL(sizeof(Stab), 0);
-  somtcreateStabSL(somtstab, HASH_SIZE, sizeof(Entry));
-
-  yyparse();
-
-  dumpStab(somtstab);
-}
-
-void emit_file(char * file)
-{
-   EmitFn proc;
-   FILE * fp;
-   HMODULE hmod;
-   Entry * root;
-   Stab * stab;
-
-   proc=somtloadSL("emitpsc.dll", "emitSL", (void**)&hmod);
-
-   fp=proc(file, root, stab);
-
-   if (fp) somtfcloseSL(fp);
-}
-
-void main(int argc, char *argv[])
-{
-#if YYDEBUG != 0
-   yydebug =1 ;
-#endif
-
-//   parse_args(argc, argv);
-
-   usage();
-
-   parse_file(argv[1]);
-
-//   dump();
-
-//   emit_file(argv[1]);
-}
+%{
+#include <stdio.h> // fopen, fprintf
+#include <string.h>
+
+#include <emitlib.h>
+
+#define YYERROR_VERBOSE
+
+extern int lineno, column;
+
+Entry e;
+
+Entry *cls;	// Current Class Entry
+Entry *pcls;	// Parent Class Entry
+Entry *mcls;	// Meta Class Entry
+
+void yyerror(const char *str)
+{
+        fprintf(stderr,"\nerror: %s\n", str);
+}
+ 
+int yywrap()
+{
+        return 1;
+} 
+  
+%}
+
+
+
+%start oidl
+
+%union{
+ char *stval;
+ int ival;
+}
+
+
+%type <stval> overridemethod_name
+
+%type <ival> T_CONSTANT
+
+%token T_COLON T_SEMICOLON T_COMMA T_STAR T_COMMENT T_IDENTIFIER
+%token T_EQUAL T_DASHES T_CONSTANT T_PERIOD  T_STRING
+%token T_ELLIPSIS T_LEFTPARENTHESIS T_RIGHTPARENTHESIS
+%token T_LEFTSQUAREBRACKET T_RIGHTSQUAREBRACKET
+
+%token T_VERSION T_GLOBAL T_LOCAL T_CLASSINIT T_RELEASE T_ORDER T_METACLASS T_PARENT
+%token T_CLASS T_LINE
+%token T_FILE T_STEM T_FUNCTION T_PREFIX T_CLASSPREFIX T_MAJOR T_MINOR
+%token T_PASSTHRU T_BEFORE T_AFTER T_ENDPASSTHRU T_DATA T_PRIVATE T_PUBLIC T_INTERNAL
+%token T_METHODS T_GROUP T_METHOD T_PROCEDURE T_OFFSET T_NAME T_LOOKUP T_EXTERNAL
+%token T_USE T_OVERRIDE
+
+%%
+
+oidl
+	:
+		{
+			if (somtg_f.verbose) printf("Parsing of \"%s\" started.\n", somtfilePath);
+			somtg_f._ERROR=0;   /* @todo subject to move to parse() */
+			somtg_f.WARN=0;   /* @todo subject to move to parse() */
+			somtg_f.FATAL=0;   /* @todo subject to move to parse() */
+			somtg_f.INTERNAL=0;   /* @todo subject to move to parse() */
+			somtg_buf=somtsmallocSL(somtg_f.commentsize, TRUE);   /* @todo subject to move to parse() */
+		}
+	  class_list
+		{
+			somtfree(somtg_buf);   /* @todo subject to move to parse() */
+			if (somtg_f.verbose) printf("Parsing of \"%s\" finished.\n", somtfilePath);
+		}
+	| line
+        ;
+
+line	: T_LINE T_CONSTANT T_STRING
+	;
+
+class_list
+	: class_definition
+	| class_list class_definition
+	;
+
+class_definition
+	:
+		{
+			cls=(Entry *)somtsmallocSL(sizeof(Entry), TRUE);
+			cls->atts=somtaddModifierSL(cls->atts, "callstyle", "oidl");
+			cls->type=SOMTClassE;
+			somtclassIdlCall=FALSE;
+			cls->u.c.file=strdup(somtfilePath);
+		}
+	  class_section section_list
+		{
+			somtaddEntrySL(somtstab, cls->name, cls);
+			somtfree(cls);
+		}
+	;
+
+section_list
+	: section
+        | section_list section
+        ;
+
+section
+	: releaseorder_section
+        | metaclass_section
+        |
+		{
+			pcls=(Entry *)somtsmallocSL(sizeof(Entry), TRUE);
+			pcls->atts=somtaddModifierSL(pcls->atts, "callstyle", "oidl");
+			pcls->type=SOMTBaseE;
+			somtclassIdlCall=FALSE;
+//			pcls->u.c.file=strdup(somtfilePath);
+		}
+	  parent_section
+		{
+			cls->u.c.parent=somtaddEntrySL(somtstab, pcls->name, pcls);
+			somtfree(pcls);
+		}
+        | passthru_section
+        | data_section
+	| methods_section
+	;
+
+class_section
+	: classdef 
+        | classdef description
+		{
+			cls->comment=$<stval>2;
+		}
+	;
+
+classdef
+	: class_header class_name T_SEMICOLON 
+	| class_header class_name class_attributes T_SEMICOLON
+        ;
+
+class_header
+	: T_CLASS T_COLON 
+	;
+
+class_name
+	: T_IDENTIFIER 
+		{
+			somtclassName=$<stval>1;
+			cls->lineno=lineno;                 
+			cls->name=$<stval>1;
+		}
+        ;
+
+class_attributes
+	: T_COMMA class_attribute
+	| class_attributes T_COMMA class_attribute
+        ;
+
+class_attribute
+	: T_FILE T_STEM T_EQUAL T_IDENTIFIER
+		{
+			cls->atts=somtaddModifierSL(cls->atts, "filestem", $<stval>4);
+		}
+        | T_EXTERNAL T_STEM T_EQUAL T_IDENTIFIER
+		{
+			cls->atts=somtaddModifierSL(cls->atts, "externalstem", $<stval>4);
+		}
+        | T_FUNCTION T_PREFIX T_EQUAL T_IDENTIFIER
+		{
+			cls->atts=somtaddModifierSL(cls->atts, "functionprefix", $<stval>4);
+		}
+        | T_EXTERNAL T_PREFIX T_EQUAL T_IDENTIFIER
+		{
+			cls->atts=somtaddModifierSL(cls->atts, "externalprefix", $<stval>4);
+		}
+        | T_CLASSPREFIX T_EQUAL T_IDENTIFIER
+		{
+			cls->atts=somtaddModifierSL(cls->atts, "classprefix", $<stval>3);
+		}
+        | T_MAJOR T_VERSION T_EQUAL T_CONSTANT
+		{
+			char *st=itoa($4, somtsmallocSL(sizeof(int)*8+1/*_MAX_ITOSTR_BASE10_COUNT*/, TRUE), 10);
+			cls->atts=somtaddModifierSL(cls->atts, "majorversion", st);
+			somtmajorVersion=strdup(st);
+			somtfree(st);
+		}
+        | T_MINOR T_VERSION T_EQUAL T_CONSTANT
+		{
+			char *st=itoa($4, somtsmallocSL(sizeof(int)*+1/*_MAX_ITOSTR_BASE10_COUNT*/, TRUE), 10);
+			cls->atts=somtaddModifierSL(cls->atts, "minorversion", st);
+			somtminorVersion=strdup(st);
+			somtfree(st);
+		}
+        | T_CLASSINIT T_EQUAL T_IDENTIFIER
+		{
+			cls->atts=somtaddModifierSL(cls->atts, "classInit", $<stval>3);
+		}
+	| visibility
+        ;
+
+visibility
+	: T_GLOBAL
+        | T_LOCAL
+	;
+
+releaseorder_section
+	: releaseorder_header release_list T_SEMICOLON
+		{
+			cls->atts=somtaddModifierSL(cls->atts, "releaseorder", $<stval>2);
+		}
+	;
+
+releaseorder_header
+	: T_RELEASE T_ORDER T_COLON
+	;
+
+release_list
+	: release
+		{ 
+			$<stval>$=strdup($<stval>1);
+		}
+	| release_list T_COMMA release
+		{
+			char *r=somtsmallocSL(strlen($<stval>1)+strlen($<stval>3)+2, TRUE);
+			strcat(strcat(strcat(r, $<stval>1), ","), $<stval>3);
+			$<stval>$=strdup(r);
+			somtfree(r);
+		}
+	;
+
+release
+	: T_IDENTIFIER
+		{
+			cls->u.c.release=somtaddModifierSL(cls->u.c.release, $<stval>1, NULL);
+			$<stval>$=$<stval>1;
+		}
+	;
+
+metaclass_section
+	: metaclassdef
+        | metaclassdef description
+		{
+			mcls->comment=$<stval>2;
+		}
+	;
+
+metaclassdef
+	: metaclass_header metaclass_name T_SEMICOLON
+        | metaclass_header metaclass_name metaclass_attributes T_SEMICOLON
+        ;
+
+metaclass_header
+	: T_METACLASS T_COLON
+        ;
+
+metaclass_name
+	: T_IDENTIFIER
+	;
+
+metaclass_attributes
+	: T_COMMA metaclass_attribute
+	| metaclass_attributes T_COMMA metaclass_attribute 
+	;
+
+metaclass_attribute
+	: T_FILE T_STEM T_EQUAL T_IDENTIFIER
+        | T_MAJOR T_VERSION T_EQUAL T_CONSTANT
+        | T_MINOR T_VERSION T_EQUAL T_CONSTANT
+        | visibility
+        ;
+
+parent_section
+	: parentdef
+        | parentdef description
+		{
+			pcls->comment=$<stval>2;
+		}
+	;
+
+
+parentdef
+	: parent_header parent_name T_SEMICOLON
+        | parent_header parent_name parent_attributes T_SEMICOLON
+        ;
+
+parent_header
+	: T_PARENT T_CLASS T_COLON
+        | T_PARENT T_COLON 
+        ;
+
+parent_name
+	: T_IDENTIFIER
+		{
+			pcls->lineno=lineno;  // @todo line of class definition?
+			pcls->name=$<stval>1;
+		}
+	;
+
+parent_attributes
+	: T_COMMA parent_attribute
+	| parent_attributes T_COMMA parent_attribute
+	;
+
+parent_attribute
+	: T_FILE T_STEM T_EQUAL T_IDENTIFIER
+        | T_MAJOR T_VERSION T_EQUAL T_CONSTANT
+        | T_MINOR T_VERSION T_EQUAL T_CONSTANT
+        | visibility
+        ;
+
+passthru_section
+	: T_PASSTHRU
+        ;
+
+data_section
+	: data_header variables
+	;
+
+data_header
+	: T_DATA T_COLON
+	;
+
+variables
+	: declaration
+        | declaration variables
+        ;
+
+declaration
+	: declarationdef T_SEMICOLON
+	| declarationdef T_SEMICOLON description
+		{
+//			cls->comment=$<stval>2;
+		}
+	;
+
+declarationdef
+	: declaration_specifiers
+	| declaration_specifiers data_attributes
+	;
+
+data_attributes
+	: T_COMMA data_attribute
+	| data_attributes T_COMMA data_attribute
+	;
+
+data_attribute
+	: T_PRIVATE
+	| T_PUBLIC
+	| T_INTERNAL
+	| T_CLASS
+	;
+
+declaration_specifiers
+	: type_specifier declarator
+	| type_specifier declarator declaration_specifiers
+	;
+
+type_specifier
+	: T_IDENTIFIER 
+		{
+			$<stval>$=$<stval>1;
+		}
+	;
+
+declarator
+	: pointer direct_declarator
+	| direct_declarator
+	;
+
+direct_declarator
+	: T_IDENTIFIER {printf("$<stval>1");}
+	| T_LEFTPARENTHESIS declarator T_RIGHTPARENTHESIS
+	| direct_declarator T_LEFTSQUAREBRACKET T_CONSTANT T_RIGHTSQUAREBRACKET
+	| direct_declarator T_LEFTSQUAREBRACKET T_RIGHTSQUAREBRACKET
+	| direct_declarator T_LEFTPARENTHESIS declaration_specifiers T_RIGHTPARENTHESIS
+	| direct_declarator T_LEFTPARENTHESIS T_RIGHTPARENTHESIS
+	;
+
+pointer
+	: T_STAR
+		{
+			$<stval>$=$<stval>1;
+		}
+	| pointer T_STAR
+		{
+			char *r=somtsmallocSL(strlen($<stval>1)+strlen($<stval>2)+1, TRUE);
+			strcat(r, $<stval>1);
+			strcat(r, $<stval>2);
+			free($<stval>1);
+			$<stval>$=strdup(r);
+			somtfree(r);
+		}
+	;
+
+
+methods_section
+	: method_header method_list
+	| method_header description method_list
+		{
+			e.comment=$<stval>2;
+		}
+	;
+
+method_header
+	: T_METHODS T_COLON
+	;
+
+method_list
+	: method 
+		{
+			cls->u.c.methodcnt++;
+			somtaddEntrySL(somtstab, e.name, &e);
+			memset(&e, 0, sizeof(Entry));
+		}
+	| method_list method 
+		{
+			cls->u.c.methodcnt++;
+			somtaddEntrySL(somtstab, e.name, &e);
+			memset(&e, 0, sizeof(Entry));
+		}
+        ;
+
+method
+	: methoddef T_SEMICOLON 
+	| methoddef T_SEMICOLON description 
+	;
+
+methoddef
+	: method_specifier
+	| method_specifier method_attributes
+	| overridemethod_specifier
+	;
+
+method_specifier
+	: method_type method_name T_LEFTPARENTHESIS parameter_list T_RIGHTPARENTHESIS 
+		{
+			e.u.m.type=strdup($<stval>1);
+		}
+	;                                             
+
+method_name
+	: T_IDENTIFIER 
+		{
+			char * desc=somtsmallocSL(MAX_DESCRIPTOR_LENGTH, TRUE);
+			e.type=SOMTNewMethodE;
+			e.lineno=lineno;
+			e.name=$<stval>1;
+			e.sname=&somtclassName;
+			strcat(desc, "::");
+			strcat(desc, $<stval>1);
+			strcat(desc, "::");
+			strcat(desc, somtclassName);
+			e.atts=somtaddModifierSL(e.atts, "descriptor", desc);
+			somtfree(desc);
+		}
+	;
+
+method_type
+	: type_specifier
+		{
+			$<stval>$=$<stval>1;
+		}
+	| type_specifier pointer
+		{
+			char *r=somtsmallocSL(strlen($<stval>1)+strlen($<stval>2)+1, TRUE);
+			strcat(r, $<stval>1);
+			strcat(r, $<stval>2);
+			free($<stval>1);
+			$<stval>$=strdup(r);
+			somtfree(r);
+		}
+	;
+
+overridemethod_specifier
+	: overridemethod_header overridemethod_name
+	| overridemethod_header overridemethod_name overridemethod_attributes
+	;                                             
+
+overridemethod_header
+	: T_OVERRIDE
+	| T_OVERRIDE T_COLON
+	;
+
+overridemethod_name
+	: T_IDENTIFIER 
+		{
+			char * desc=somtsmallocSL(MAX_DESCRIPTOR_LENGTH, TRUE);
+			e.type=SOMTOverrideMethodE;
+			e.lineno=lineno;
+			e.name=$<stval>1;
+			e.sname=&somtclassName;
+			strcat(strcat(strcat(strcat(desc ,"::"), $<stval>1), "::"), somtclassName);
+			e.atts=somtaddModifierSL(e.atts, "descriptor", desc);
+			somtfree(desc);
+		}
+	;
+
+parameter_list
+	: parameter
+	| parameter_list T_COMMA parameter
+	;
+
+parameter
+	: T_ELLIPSIS
+	| type_specifier declarator
+	;
+
+method_attributes
+	: T_COMMA method_attribute
+	| method_attributes T_COMMA method_attribute
+	;
+
+method_attribute
+	: T_PRIVATE
+	| T_PUBLIC
+	| T_METHOD
+	| T_PROCEDURE
+	| T_CLASS
+	| T_OFFSET
+	| T_NAME T_LOOKUP
+	| T_LOCAL
+	| T_EXTERNAL
+	| T_USE T_EQUAL T_IDENTIFIER
+	;
+
+/* descriptor */
+/* noset */
+/* original */
+
+overridemethod_attributes
+	: T_COMMA overridemethod_attribute
+	| overridemethod_attributes T_COMMA overridemethod_attribute
+	;
+
+overridemethod_attribute
+	: T_PRIVATE
+	| T_PUBLIC
+	| T_CLASS
+	| T_LOCAL
+	| T_EXTERNAL
+	| T_USE T_EQUAL T_IDENTIFIER
+	;
+
+description
+	: T_COMMENT 
+		{
+			$<stval>$=$<stval>1;
+		}
+        ;
+
+%%
+
+FILE *yyin;
+
+// Experimental replacement of somttype
+char * mysomttype(SOMTTypes ttype)
+{
+  char * result=NULL;
+  switch ( ttype )
+  {
+    case SOMTAnyBE:
+      result="SOMTAnyBE";
+      break;
+    case     SOMTArgumentE:
+      result="SOMTArgumentE";
+      break;
+    case     SOMTAttE:
+      result="SOMTAttE";
+      break;
+    case     SOMTBadEntryE:
+      result="SOMTBadEntryE";
+      break;
+    case     SOMTBaseE:
+      result="SOMTBaseE";
+      break;
+    case     SOMTBooleanBE:
+      result="SOMTBooleanBE";
+      break;
+    case     SOMTCaseEntryE:
+      result="SOMTCaseEntryE";
+      break;
+    case     SOMTCaseListE:
+      result="SOMTCaseListE";
+      break;
+    case     SOMTCaseSTME:
+      result="SOMTCaseSTME";
+      break;
+    case     SOMTCharBE:
+      result="SOMTCharBE";
+      break;
+    case     SOMTClassE:
+      result="SOMTClassE";
+      break;
+    case     SOMTConstE:
+      result="SOMTConstE";
+      break;
+    case     SOMTCopyrightE:
+      result="SOMTCopyrightE";
+      break;
+    case     SOMTDataE:
+      result="SOMTDataE";
+      break;
+    case     SOMTDclListE:
+      result="SOMTDclListE";
+      break;
+    case     SOMTDefaultE:
+      result="SOMTDefaultE";
+      break;
+    case     SOMTDoubleBE:
+      result="SOMTDoubleBE";
+      break;
+    case     SOMTEBaseE:
+      result="SOMTEBaseE";
+      break;
+    case     SOMTEEnumE:
+      result="SOMTEEnumE";
+      break;
+    case     SOMTEnumBE:
+      result="SOMTEnumBE";
+      break;
+    case     SOMTEnumE:
+      result="SOMTEnumE";
+      break;
+    case     SOMTEnumPE:
+      result="SOMTEnumPE";
+      break;
+    case     SOMTFloatBE:
+      result="SOMTFloatBE";
+      break;
+    case     SOMTGroupE:
+      result="SOMTGroupE";
+      break;
+    case     SOMTLongBE:
+      result="SOMTLongBE";
+      break;
+    case     SOMTMetaE:
+      result="SOMTMetaE";
+      break;
+    case     SOMTModuleE:
+      result="SOMTModuleE";
+      break;
+    case     SOMTNegativeBE:
+      result="SOMTNegativeBE";
+      break;
+    case     SOMTNewMethodE:
+      result="SOMTNewMethodE";
+      break;
+    case     SOMTOctetBE:
+      result="SOMTOctetBE";
+      break;
+    case     SOMTOverriddenMethodE:
+      result="SOMTOverriddenMethodE";
+      break;
+    case     SOMTOverrideMethodE:
+      result="SOMTOverrideMethodE";
+      break;
+    case     SOMTPassthruE:
+      result="SOMTPassthruE";
+      break;
+    case     SOMTSequenceE:
+      result="SOMTSequenceE";
+      break;
+    case     SOMTSequenceTDE:
+      result="SOMTSequenceTDE";
+      break;
+    case     SOMTShortBE:
+      result="SOMTShortBE";
+      break;
+    case     SOMTStringBE:
+      result="SOMTStringBE";
+      break;
+    case     SOMTStringE:
+      result="SOMTStringE";
+      break;
+    case     SOMTStructE:
+      result="SOMTStructE";
+      break;
+    case     SOMTStructPE:
+      result="SOMTStructPE";
+      break;
+    case     SOMTStructSE:
+      result="SOMTStructSE";
+      break;
+    case     SOMTTyDclE:
+      result="SOMTTyDclE";
+      break;
+    case     SOMTTypeCodeBE:
+      result="SOMTTypeCodeBE";
+      break;
+    case     SOMTTypedefBE:
+      result="SOMTTypedefBE";
+      break;
+    case     SOMTTypedefE:
+      result="SOMTTypedefE";
+      break;
+    case     SOMTUnionE:
+      result="SOMTUnionE";
+      break;
+    case     SOMTUnionPE:
+      result="SOMTUnionPE";
+      break;
+    case     SOMTUnionSE:
+      result="SOMTUnionSE";
+      break;
+    case     SOMTUnsignedLongBE:
+      result="SOMTUnsignedLongBE";
+      break;
+    case     SOMTUnsignedShortBE:
+      result="SOMTUnsignedShortBE";
+      break;
+    case     SOMTVoidBE:
+      result="SOMTVoidBE";
+      break;
+    case     SOMTVoidPtrBE:
+      result="SOMTVoidPtrBE";
+      break;
+// This is special case SOMTTypes used on call of emitter start and emitter end
+/*    case     SOMTEmitterBeginE:
+      result="SOMTEmitterBeginE";
+      break;
+    case     SOMTEmitterEndE:
+      result="SOMTEmitterEndE";
+      break; */
+    default:
+      printf("Unknown entry type: %d.\n", ttype);
+  }
+  return result;
+}
+
+void dumpReleaseOrder(char * name, AttList *ap)
+{
+  AttList *cur=ap;
+
+  for(; cur; cur = cur->next) 
+  {
+    printf("\t%s %s\n", name, cur->name);
+//    dumpAttrs("static", cur->staticlist);
+//    dumpAttrs("protectted", cur->protectedlist);
+//    dumpAttrs("public", cur->publiclist);
+//    dumpAttrs("private", cur->privatelist);
+  }
+}
+
+void dumpMethodOrData(Entry * ep)
+{
+  printf("\teptype = %08p\n", ep->u.m.eptype);
+  printf("\tptrs = %08p\n", ep->u.m.ptrs);
+  printf("\tarray = %08p\n", ep->u.m.array);
+  printf("\tarrays = %s\n", ep->u.m.arrays);
+  printf("\tdefn = %s\n", ep->u.m.defn);
+  printf("\ttype = %s\n", ep->u.m.type);
+  printf("\tvarargs = %s\n", ep->u.m.varargs ? "true" : "false");
+  printf("\tprivate = %s\n", ep->u.m.isprivate ? "true" : "false");
+  printf("\tinout = %d\n", ep->u.m.inoutmode);
+  printf("\tselfref = %s\n", ep->u.m.isselfref ? "true" : "false");
+  printf("\toneway = %s\n", ep->u.m.isoneway ? "true" : "false");
+  printf("\targcnt = %d\n", ep->u.m.argcnt);
+  printf("\targs = %08p\n", ep->u.m.args);
+  printf("\tomethod = %08p\n", ep->u.m.omethod);
+  printf("\toparent = %08p\n", ep->u.m.oparent);
+  printf("\tgroup = %08p\n", ep->u.m.group);
+  printf("\tnext = %08p\n", ep->u.m.next);
+  printf("\tctxsa = %08p\n", ep->u.m.ctxsa);
+  printf("\traiseslist = %08p\n", ep->u.m.raiseslist);
+}
+
+void mysomtShowEntry(Entry * ep)
+{
+  if (ep)
+  {
+    printf("      somtShowEntry: Entry at %08p, name = %s, type = %d\n", ep, ep->name, ep->type);
+    printf("\tlineno = %d\n", ep->lineno);
+    switch ( ep->type )
+    {
+      case SOMTAnyBE:
+        printf("\t SOMTAnyBE\n");
+        break;
+      case     SOMTArgumentE:
+        printf("\t SOMTArgumentE\n");
+        dumpMethodOrData(ep);
+        break;
+      case     SOMTAttE:
+        printf("\t SOMTAttE\n");
+        break;
+      case     SOMTBadEntryE:
+        printf("\t SOMTBadEntryE\n");
+        break;
+      case     SOMTBaseE:
+        printf("\t SOMTBaseE\n");
+        printf("\tparentdef = %08p\n", ep->u.p.parentdef);
+        break;
+      case     SOMTBooleanBE:
+        printf("\t SOMTBooleanBE\n");
+        break;
+      case     SOMTCaseEntryE:
+        printf("\t SOMTCaseEntryE\n");
+        break;
+      case     SOMTCaseListE:
+        printf("\t SOMTCaseListE\n");
+        break;
+      case     SOMTCaseSTME:
+        printf("\t SOMTCaseSTME\n");
+        break;
+      case     SOMTCharBE:
+        printf("\t SOMTCharBE\n");
+        break;
+      case     SOMTClassE:
+        printf("\tClass Definition Entry:\n");
+        printf("\tfile = %s\n", ep->u.c.file);
+        printf("\tmeta = %08p\n", ep->u.c.meta);
+        printf("\tparent = %08p\n", ep->u.c.parent);
+        printf("\tparents = %08p\n", ep->u.c.parents);
+        printf("\trelease = %08p\n", ep->u.c.release);
+	dumpReleaseOrder("\t", ep->u.c.release);
+        printf("\tpassthru = %08p\n", ep->u.c.passthrus);
+        printf("\tdata = %08p\n", ep->u.c.data);
+        printf("\ttc = %08p\n", ep->tc);
+        printf("\tmethodcnt = %08d\n", ep->u.c.methodcnt);
+        printf("\tmethods = %08p\n", ep->u.c.methods);
+        printf("\tinherited = %08p\n", ep->u.c.inherited);
+        printf("\tpubdefs = %08p\n", ep->u.c.pubdefs);
+        printf("\tmod = %08p\n", ep->u.c.mod);
+        printf("\tcls = %08p\n", ep->u.c.cls);
+        printf("\tforward = %s\n", ep->u.c.isforward ? "true" : "false");
+        break;
+      case     SOMTConstE:
+        printf("\t SOMTConstE\n");
+        break;
+      case     SOMTCopyrightE:
+        printf("\t SOMTCopyrightE\n");
+        break;
+      case     SOMTDataE:
+        printf("\t SOMTDataE\n");
+        dumpMethodOrData(ep);
+        break;
+      case     SOMTDclListE:
+        printf("\t SOMTDclListE\n");
+        break;
+      case     SOMTDefaultE:
+        printf("\t SOMTDefaultE\n");
+        break;
+      case     SOMTDoubleBE:
+        printf("\t SOMTDoubleBE\n");
+        break;
+      case     SOMTEBaseE:
+        printf("\t SOMTEBaseE\n");
+        break;
+      case     SOMTEEnumE:
+        printf("\t SOMTEEnumE\n");
+        break;
+      case     SOMTEnumBE:
+        printf("\t SOMTEnumBE\n");
+        break;
+      case     SOMTEnumE:
+        printf("\t SOMTEnumE\n");
+        break;
+      case     SOMTEnumPE:
+        printf("\t SOMTEnumPE\n");
+        break;
+      case     SOMTFloatBE:
+        printf("\t SOMTFloatBE\n");
+        break;
+      case     SOMTGroupE:
+        printf("\t SOMTGroupE\n");
+        break;
+      case     SOMTLongBE:
+        printf("\t SOMTLongBE\n");
+        break;
+      case     SOMTMetaE:
+        printf("\t SOMTMetaE\n");
+        break;
+      case     SOMTModuleE:
+        printf("\t SOMTModuleE\n");
+        break;
+      case     SOMTNegativeBE:
+        printf("\t SOMTNegativeBE\n");
+        break;
+      case     SOMTNewMethodE:
+        printf("\t SOMTNewMethodE\n");
+        dumpMethodOrData(ep);
+        break;
+      case     SOMTOctetBE:
+        printf("\t SOMTOctetBE\n");
+        break;
+      case     SOMTOverriddenMethodE:
+        printf("\t SOMTOverriddenMethodE\n");
+        dumpMethodOrData(ep);
+        break;
+      case     SOMTOverrideMethodE:
+        printf("\t SOMTOverrideMethodE\n");
+        dumpMethodOrData(ep);
+        break;
+      case     SOMTPassthruE:
+        printf("\t SOMTPassthruE\n");
+        break;
+      case     SOMTSequenceE:
+        printf("\t SOMTSequenceE\n");
+        break;
+      case     SOMTSequenceTDE:
+        printf("\t SOMTSequenceTDE\n");
+        break;
+      case     SOMTShortBE:
+        printf("\t SOMTShortBE\n");
+        break;
+      case     SOMTStringBE:
+        printf("\t SOMTStringBE\n");
+        break;
+      case     SOMTStringE:
+        printf("\t SOMTStringE\n");
+        break;
+      case     SOMTStructE:
+        printf("\t SOMTStructE\n");
+        break;
+      case     SOMTStructPE:
+        printf("\t SOMTStructPE\n");
+        break;
+      case     SOMTStructSE:
+        printf("\t SOMTStructSE\n");
+        printf("\tdcllist = %08p\n", ep->u.struc.dcllist);
+        printf("\tcls = %08p\n", ep->u.struc.cls);
+        printf("\texception = %s\n", ep->u.struc.isexcept ? "true" : "false");
+        printf("\tmutref = %s\n", ep->u.struc.ismutref ? "true" : "false");
+        break;
+      case     SOMTTyDclE:
+        printf("\t SOMTTyDclE\n");
+        break;
+      case     SOMTTypeCodeBE:
+        printf("\t SOMTTypeCodeBE\n");
+        break;
+      case     SOMTTypedefBE:
+        printf("\t SOMTTypedefBE\n");
+        dumpMethodOrData(ep);
+        break;
+      case     SOMTTypedefE:
+        printf("\t SOMTTypedefE\n");
+        break;
+      case     SOMTUnionE:
+        printf("\t SOMTUnionE\n");
+        break;
+      case     SOMTUnionPE:
+        printf("\t SOMTUnionPE\n");
+        break;
+      case     SOMTUnionSE:
+        printf("\t SOMTUnionSE\n");
+        break;
+      case     SOMTUnsignedLongBE:
+        printf("\t SOMTUnsignedLongBE\n");
+        break;
+      case     SOMTUnsignedShortBE:
+        printf("\t SOMTUnsignedShortBE\n");
+        break;
+      case     SOMTVoidBE:
+        printf("\t SOMTVoidBE\n");
+        break;
+      case     SOMTVoidPtrBE:
+        printf("\t SOMTVoidPtrBE\n");
+        dumpMethodOrData(ep);
+        break;
+  // This is special case SOMTTypes used on call of emitter start and emitter end
+  /*    case     SOMTEmitterBeginE:
+        result="SOMTEmitterBeginE";
+        break;
+      case     SOMTEmitterEndE:
+        result="SOMTEmitterEndE";
+        break; */
+      default:
+        printf("Error: somtShowEntry, bad entry type of %d", ep->type);
+//        SOM_Error(SOM_Fatal, __FILE__, __LINE__);
+//        SOMError(9, __FILE__, __LINE__);
+    }
+  }
+  else 
+  {
+    printf("somtShowEntry: NULL entry\n");
+  }
+}
+
+void dumpAttrs(AttList *ap)
+{
+  struct AttList *cur = ap;
+
+  for(cur = ap; cur; cur = cur->next) 
+  {
+    printf("\tModifier %s=%s\n", cur->name, cur->value);
+  }
+}
+
+
+void mydumpEntry(Entry * ep)
+{
+  printf("Entry at address %p\n", ep);
+  printf("--------------------------\n");
+  printf("Entry type: %s (%d)\n", mysomttype(ep->type), ep->type);
+//  printf("Entry type: %s (%d)\n", somtEntryTypeName(ep->type), ep->type);
+  if (ep->sname) printf("Scoped name: %s\n", *ep->sname);
+  if (ep->comment) printf("Comment associated with entry: %s\n", ep->comment);
+  printf("Modifiers: %p\n", ep->atts);
+  if (ep->atts) dumpAttrs(ep->atts);
+  printf("TypeCode: %p\n", ep->tc);
+  printf("Points to the object: %p\n", ep->objref);
+  printf("Reference to real type: %s\n", ep->isref ? "true" : "false");
+  printf("Entry union: %p\n", &ep->u);
+#ifdef __PRIVATE__
+//    RHBelement *data;
+//    char *filestem;
+#endif    
+  mysomtShowEntry(ep);
+//  somtShowEntry(ep);
+};
+
+void dumpSep(Sep * sep)
+{
+    printf("Linked list item at address %p\n", sep);
+    printf("---------------------------------------\n");
+    printf("Position number: %d\n", sep->posn);
+    printf("Address of Entry: %p\n", sep->ep);
+    printf("Next linked list item address: %p\n", sep->next);
+    if (sep->ep) 
+    {
+      mydumpEntry((Entry *)sep->ep);
+      dumpSep(sep->next);
+    }
+}
+
+void dumpStab(Stab * stab)
+{
+  unsigned int i;
+  printf("Basic Symbol Table/Hash table (STab) structure\n");
+  printf("----------------------------------------------\n");
+  printf("Size of buscet: %d\n", stab->size);
+  printf("Size of entry structure: %d\n", stab->entrysize);
+  printf("Number of elements: %d\n", stab->nelms);
+  printf("Address of base slot: %p\n", stab->base);
+  printf("Max address of slot: %p\n", stab->limit);
+  printf("Start address of slot buffer: %p\n", stab->buf);
+  printf("Address of MemBuf: %p\n", stab->membuf);
+  printf("Ignore case flag: %s\n", stab->ignorecase ? "true" : "false");
+  for(i=0; i<stab->size;i++)
+  {
+    printf("Linked list at slot %d at offset %08x at address %p\n", i, sizeof(Sep)*i, stab->buf+i);
+    printf("----------------------\n");
+    dumpSep(stab->buf+i);
+  }
+}
+
+
+void usage(void)
+{
+  printf("\nSC [-options] file[.CSC]\n");
+  printf("\n-C n\n\tset the size of the comment buffer (default: 16384)\n");
+  printf("\n-s n\n\tset the total amount of string space for names and passthru lines (default: 32768)\n");
+  printf("\n-V\n\tdisplay version information\n");
+  printf("\n-a name[=value]\n\tadd a global attribute. The currently supported attributes are defined below (at the end of this section)\n");
+  printf("\n-d directory\n\tspecify a directory where all files emitted during the execution of this command should be placed. If the -d option is not used, all emitted output files are placed in the same directory as the input .csc file\n");
+  printf("\n-h or ?\n\tprovide usage information for reference\n");
+  printf("\n-i filename\n\tspecify the name of the OIDL class definition file. Use this option to override the built-in assumption that the input file will have a .csc extension. Any filename you supply with the -i option is used exactly as you provide it\n");
+  printf("\n-r\n\tcheck that all release-order entries actually exist (default: FALSE)\n");
+  printf("\n-s string\n\tsubstitute string in place of the contents of the SMEMIT environment variable for the duration of the current SC command. If you supply a list of values, you\n");
+  printf("must enclose the list with double quotation marks (\" \"). You can use the -s option as a convenient way to override the SMEMIT environment variable. For example:\n\n");
+  printf("SC -s \"h;sc\" EXAMPLE\n\n");
+  printf("is equivalent to the following sequence of commands:\n\n");
+  printf("SET OLDSMEMIT = %%SMEMIT%%\n");
+  printf("SET SMEMIT = h;sc\n");
+  printf("SC EXAMPLE\n");
+  printf("SET SMEMIT = %%OLDSMEMIT%%\n");
+  printf("\n-w\n\tsuppress warning messages (default: FALSE)\n\n");
+  printf("The only global attributes currently supported by SC.EXE are:\n");
+  printf("\ncomment = comment string\n\twhere comment string can be one of the following: \"/*\", \"--\", or \"//\". This\n");
+  printf("indicates that comments marked in the indicated way are to be completely\n");
+  printf("ignored by SC.EXE and not retained for subsequent processing by one of the\n");
+  printf("emitters.\n");
+  printf("Note: Comments indicated by lines whose first non-white-space character is\n");
+  printf("a # are always ignored by SC.EXE. Also note that comments of any\n");
+  printf("form in passthru lines are passed through.\n");
+  printf("\ncstyle = comment style\n\tcontrols the form of emitted comments. Comment style must be one of s, c, or\n");
+  printf("+ to cause emitted comments to be in \"--\", \"/* */\", or \"//\" form , respectively\n");
+  printf("The default form is s\n");
+  printf("\nibmc\n\tcauses EMITC, EMITH, EMITIH, EMITPH, and EMITDEF to generate code with\n");
+  printf("pragmas specifically intended for the IBM C Set/2 Compiler. This attribute is\n");
+  printf("specified by default\n");
+  printf("\ncl386\n\tcauses EMITC, EMITH, EMITIH, EMITPH, and EMITDEF not to generate code\n");
+  printf("with pragmas specifically intended for the IBM C Set/2 Compiler\n");
+}
+
+void parse_file(char * file)
+{
+  // parser input stream
+  yyin=fopen(file,"r");
+
+  strcpy(somtfilePath, file);
+
+  // Initialize symbol table
+  somtstab=(Stab *)somtsmallocSL(sizeof(Stab), 0);
+  somtcreateStabSL(somtstab, HASH_SIZE, sizeof(Entry));
+
+  yyparse();
+
+  dumpStab(somtstab);
+}
+
+void emit_file(char * file)
+{
+   EmitFn proc;
+   FILE * fp;
+   HMODULE hmod;
+   Entry * root;
+   Stab * stab;
+
+   proc=somtloadSL("emitpsc.dll", "emitSL", (void**)&hmod);
+
+   fp=proc(file, root, stab);
+
+   if (fp) somtfcloseSL(fp);
+}
+
+void main(int argc, char *argv[])
+{
+#if YYDEBUG != 0
+   yydebug =1 ;
+#endif
+
+//   parse_args(argc, argv);
+
+   usage();
+
+   parse_file(argv[1]);
+
+//   dump();
+
+//   emit_file(argv[1]);
+}
