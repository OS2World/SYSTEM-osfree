diff -urN somfree/somopc/src/_gramma.yy.output newsomfree/somopc/src/_gramma.yy.output
--- somfree/somopc/src/_gramma.yy.output	Sat Jun 29 21:47:30 2024
+++ newsomfree/somopc/src/_gramma.yy.output	Thu Jan 01 07:00:00 1970
@@ -1,840 +0,0 @@
-
-
-Terminals which are not used:
-
-   T_RELEASE
-   T_ORDER
-   T_METACLASS
-   T_PASSTHRU
-   T_BEFORE
-   T_AFTER
-   T_ENDPASSTHRU
-   T_DATA
-   T_PRIVATE
-   T_PUBLIC
-   T_INTERNAL
-   T_METHODS
-   T_GROUP
-   T_METHOD
-   T_PROCEDURE
-   T_OFFSET
-   T_NAME
-   T_LOOKUP
-   T_USE
-   T_OVERRIDE
-
-
-
-Grammar
-rule 1    oidl -> parent
-rule 2    oidl -> class
-rule 3    class -> classdef
-rule 4    class -> classdef description
-rule 5    classdef -> T_CLASS T_COLON T_IDENTIFIER T_SEMICOLON
-rule 6    classdef -> T_CLASS T_COLON T_IDENTIFIER attributes T_SEMICOLON
-rule 7    attributes -> T_COMMA attribute
-rule 8    attributes -> attributes T_COMMA attribute
-rule 9    attribute -> T_FILE T_STEM T_EQUAL T_IDENTIFIER
-rule 10   attribute -> T_EXTERNAL T_STEM T_EQUAL T_IDENTIFIER
-rule 11   attribute -> T_FUNCTION T_PREFIX T_EQUAL T_IDENTIFIER
-rule 12   attribute -> T_EXTERNAL T_PREFIX T_EQUAL T_IDENTIFIER
-rule 13   attribute -> T_CLASSPREFIX T_EQUAL T_IDENTIFIER
-rule 14   attribute -> T_MAJOR T_VERSION T_EQUAL T_NUMBER
-rule 15   attribute -> T_MINOR T_VERSION T_EQUAL T_NUMBER
-rule 16   attribute -> T_GLOBAL
-rule 17   attribute -> T_LOCAL
-rule 18   attribute -> T_CLASSINIT T_EQUAL T_IDENTIFIER
-rule 19   parent -> parentdef
-rule 20   parent -> parentdef description
-rule 21   parentsection -> T_PARENT T_CLASS T_COLON
-rule 22   parentsection -> T_PARENT T_COLON
-rule 23   parentdef -> parentsection T_IDENTIFIER T_SEMICOLON
-rule 24   parentdef -> parentsection T_IDENTIFIER T_COMMA parentattributes T_SEMICOLON
-rule 25   parentattributes -> T_COMMA parentattribute
-rule 26   parentattributes -> parentattributes T_COMMA parentattribute
-rule 27   parentattribute -> T_FILE T_STEM T_EQUAL T_IDENTIFIER
-rule 28   parentattribute -> T_MAJOR T_VERSION T_EQUAL T_NUMBER
-rule 29   parentattribute -> T_MINOR T_VERSION T_EQUAL T_NUMBER
-rule 30   parentattribute -> T_GLOBAL
-rule 31   parentattribute -> T_LOCAL
-rule 32   description -> T_DASHES T_COMMENT
-
-Terminals, with rules where they appear
-
-$ (-1)
-error (256)
-T_COLON (257) 5 6 21 22
-T_SEMICOLON (258) 5 6 23 24
-T_COMMA (259) 7 8 24 25 26
-T_NUMBER (260) 14 15 28 29
-T_IDENTIFIER (261) 5 6 9 10 11 12 13 18 23 24 27
-T_EQUAL (262) 9 10 11 12 13 14 15 18 27 28 29
-T_DASHES (263) 32
-T_COMMENT (264) 32
-T_CLASS (265) 5 6 21
-T_FILE (266) 9 27
-T_STEM (267) 9 10 27
-T_FUNCTION (268) 11
-T_PREFIX (269) 11 12
-T_CLASSPREFIX (270) 13
-T_MAJOR (271) 14 28
-T_MINOR (272) 15 29
-T_VERSION (273) 14 15 28 29
-T_GLOBAL (274) 16 30
-T_LOCAL (275) 17 31
-T_CLASSINIT (276) 18
-T_RELEASE (277)
-T_ORDER (278)
-T_METACLASS (279)
-T_PARENT (280) 21 22
-T_PASSTHRU (281)
-T_BEFORE (282)
-T_AFTER (283)
-T_ENDPASSTHRU (284)
-T_DATA (285)
-T_PRIVATE (286)
-T_PUBLIC (287)
-T_INTERNAL (288)
-T_METHODS (289)
-T_GROUP (290)
-T_METHOD (291)
-T_PROCEDURE (292)
-T_OFFSET (293)
-T_NAME (294)
-T_LOOKUP (295)
-T_EXTERNAL (296) 10 12
-T_USE (297)
-T_OVERRIDE (298)
-
-Nonterminals, with rules where they appear
-
-oidl (45)
-    on left: 1 2
-class (46)
-    on left: 3 4, on right: 2
-classdef (47)
-    on left: 5 6, on right: 3 4
-attributes (48)
-    on left: 7 8, on right: 6 8
-attribute (49)
-    on left: 9 10 11 12 13 14 15 16 17 18, on right: 7 8
-parent (50)
-    on left: 19 20, on right: 1
-parentsection (51)
-    on left: 21 22, on right: 23 24
-parentdef (52)
-    on left: 23 24, on right: 19 20
-parentattributes (53)
-    on left: 25 26, on right: 24 26
-parentattribute (54)
-    on left: 27 28 29 30 31, on right: 25 26
-description (55)
-    on left: 32, on right: 4 20
-
-
-state 0
-
-    T_CLASS	shift, and go to state 1
-    T_PARENT	shift, and go to state 2
-
-    oidl	go to state 78
-    class	go to state 3
-    classdef	go to state 4
-    parent	go to state 5
-    parentsection	go to state 6
-    parentdef	go to state 7
-
-
-
-state 1
-
-    classdef  ->  T_CLASS . T_COLON T_IDENTIFIER T_SEMICOLON   (rule 5)
-    classdef  ->  T_CLASS . T_COLON T_IDENTIFIER attributes T_SEMICOLON   (rule 6)
-
-    T_COLON	shift, and go to state 8
-
-
-
-state 2
-
-    parentsection  ->  T_PARENT . T_CLASS T_COLON   (rule 21)
-    parentsection  ->  T_PARENT . T_COLON   (rule 22)
-
-    T_COLON	shift, and go to state 9
-    T_CLASS	shift, and go to state 10
-
-
-
-state 3
-
-    oidl  ->  class .   (rule 2)
-
-    $default	reduce using rule 2 (oidl)
-
-
-
-state 4
-
-    class  ->  classdef .   (rule 3)
-    class  ->  classdef . description   (rule 4)
-
-    T_DASHES	shift, and go to state 11
-
-    $default	reduce using rule 3 (class)
-
-    description	go to state 12
-
-
-
-state 5
-
-    oidl  ->  parent .   (rule 1)
-
-    $default	reduce using rule 1 (oidl)
-
-
-
-state 6
-
-    parentdef  ->  parentsection . T_IDENTIFIER T_SEMICOLON   (rule 23)
-    parentdef  ->  parentsection . T_IDENTIFIER T_COMMA parentattributes T_SEMICOLON   (rule 24)
-
-    T_IDENTIFIER	shift, and go to state 13
-
-
-
-state 7
-
-    parent  ->  parentdef .   (rule 19)
-    parent  ->  parentdef . description   (rule 20)
-
-    T_DASHES	shift, and go to state 11
-
-    $default	reduce using rule 19 (parent)
-
-    description	go to state 14
-
-
-
-state 8
-
-    classdef  ->  T_CLASS T_COLON . T_IDENTIFIER T_SEMICOLON   (rule 5)
-    classdef  ->  T_CLASS T_COLON . T_IDENTIFIER attributes T_SEMICOLON   (rule 6)
-
-    T_IDENTIFIER	shift, and go to state 15
-
-
-
-state 9
-
-    parentsection  ->  T_PARENT T_COLON .   (rule 22)
-
-    $default	reduce using rule 22 (parentsection)
-
-
-
-state 10
-
-    parentsection  ->  T_PARENT T_CLASS . T_COLON   (rule 21)
-
-    T_COLON	shift, and go to state 16
-
-
-
-state 11
-
-    description  ->  T_DASHES . T_COMMENT   (rule 32)
-
-    T_COMMENT	shift, and go to state 17
-
-
-
-state 12
-
-    class  ->  classdef description .   (rule 4)
-
-    $default	reduce using rule 4 (class)
-
-
-
-state 13
-
-    parentdef  ->  parentsection T_IDENTIFIER . T_SEMICOLON   (rule 23)
-    parentdef  ->  parentsection T_IDENTIFIER . T_COMMA parentattributes T_SEMICOLON   (rule 24)
-
-    T_SEMICOLON	shift, and go to state 18
-    T_COMMA	shift, and go to state 19
-
-
-
-state 14
-
-    parent  ->  parentdef description .   (rule 20)
-
-    $default	reduce using rule 20 (parent)
-
-
-
-state 15
-
-    classdef  ->  T_CLASS T_COLON T_IDENTIFIER . T_SEMICOLON   (rule 5)
-    classdef  ->  T_CLASS T_COLON T_IDENTIFIER . attributes T_SEMICOLON   (rule 6)
-
-    T_SEMICOLON	shift, and go to state 20
-    T_COMMA	shift, and go to state 21
-
-    attributes	go to state 22
-
-
-
-state 16
-
-    parentsection  ->  T_PARENT T_CLASS T_COLON .   (rule 21)
-
-    $default	reduce using rule 21 (parentsection)
-
-
-
-state 17
-
-    description  ->  T_DASHES T_COMMENT .   (rule 32)
-
-    $default	reduce using rule 32 (description)
-
-
-
-state 18
-
-    parentdef  ->  parentsection T_IDENTIFIER T_SEMICOLON .   (rule 23)
-
-    $default	reduce using rule 23 (parentdef)
-
-
-
-state 19
-
-    parentdef  ->  parentsection T_IDENTIFIER T_COMMA . parentattributes T_SEMICOLON   (rule 24)
-
-    T_COMMA	shift, and go to state 23
-
-    parentattributes	go to state 24
-
-
-
-state 20
-
-    classdef  ->  T_CLASS T_COLON T_IDENTIFIER T_SEMICOLON .   (rule 5)
-
-    $default	reduce using rule 5 (classdef)
-
-
-
-state 21
-
-    attributes  ->  T_COMMA . attribute   (rule 7)
-
-    T_FILE	shift, and go to state 25
-    T_FUNCTION	shift, and go to state 26
-    T_CLASSPREFIX	shift, and go to state 27
-    T_MAJOR	shift, and go to state 28
-    T_MINOR	shift, and go to state 29
-    T_GLOBAL	shift, and go to state 30
-    T_LOCAL	shift, and go to state 31
-    T_CLASSINIT	shift, and go to state 32
-    T_EXTERNAL	shift, and go to state 33
-
-    attribute	go to state 34
-
-
-
-state 22
-
-    classdef  ->  T_CLASS T_COLON T_IDENTIFIER attributes . T_SEMICOLON   (rule 6)
-    attributes  ->  attributes . T_COMMA attribute   (rule 8)
-
-    T_SEMICOLON	shift, and go to state 35
-    T_COMMA	shift, and go to state 36
-
-
-
-state 23
-
-    parentattributes  ->  T_COMMA . parentattribute   (rule 25)
-
-    T_FILE	shift, and go to state 37
-    T_MAJOR	shift, and go to state 38
-    T_MINOR	shift, and go to state 39
-    T_GLOBAL	shift, and go to state 40
-    T_LOCAL	shift, and go to state 41
-
-    parentattribute	go to state 42
-
-
-
-state 24
-
-    parentdef  ->  parentsection T_IDENTIFIER T_COMMA parentattributes . T_SEMICOLON   (rule 24)
-    parentattributes  ->  parentattributes . T_COMMA parentattribute   (rule 26)
-
-    T_SEMICOLON	shift, and go to state 43
-    T_COMMA	shift, and go to state 44
-
-
-
-state 25
-
-    attribute  ->  T_FILE . T_STEM T_EQUAL T_IDENTIFIER   (rule 9)
-
-    T_STEM	shift, and go to state 45
-
-
-
-state 26
-
-    attribute  ->  T_FUNCTION . T_PREFIX T_EQUAL T_IDENTIFIER   (rule 11)
-
-    T_PREFIX	shift, and go to state 46
-
-
-
-state 27
-
-    attribute  ->  T_CLASSPREFIX . T_EQUAL T_IDENTIFIER   (rule 13)
-
-    T_EQUAL	shift, and go to state 47
-
-
-
-state 28
-
-    attribute  ->  T_MAJOR . T_VERSION T_EQUAL T_NUMBER   (rule 14)
-
-    T_VERSION	shift, and go to state 48
-
-
-
-state 29
-
-    attribute  ->  T_MINOR . T_VERSION T_EQUAL T_NUMBER   (rule 15)
-
-    T_VERSION	shift, and go to state 49
-
-
-
-state 30
-
-    attribute  ->  T_GLOBAL .   (rule 16)
-
-    $default	reduce using rule 16 (attribute)
-
-
-
-state 31
-
-    attribute  ->  T_LOCAL .   (rule 17)
-
-    $default	reduce using rule 17 (attribute)
-
-
-
-state 32
-
-    attribute  ->  T_CLASSINIT . T_EQUAL T_IDENTIFIER   (rule 18)
-
-    T_EQUAL	shift, and go to state 50
-
-
-
-state 33
-
-    attribute  ->  T_EXTERNAL . T_STEM T_EQUAL T_IDENTIFIER   (rule 10)
-    attribute  ->  T_EXTERNAL . T_PREFIX T_EQUAL T_IDENTIFIER   (rule 12)
-
-    T_STEM	shift, and go to state 51
-    T_PREFIX	shift, and go to state 52
-
-
-
-state 34
-
-    attributes  ->  T_COMMA attribute .   (rule 7)
-
-    $default	reduce using rule 7 (attributes)
-
-
-
-state 35
-
-    classdef  ->  T_CLASS T_COLON T_IDENTIFIER attributes T_SEMICOLON .   (rule 6)
-
-    $default	reduce using rule 6 (classdef)
-
-
-
-state 36
-
-    attributes  ->  attributes T_COMMA . attribute   (rule 8)
-
-    T_FILE	shift, and go to state 25
-    T_FUNCTION	shift, and go to state 26
-    T_CLASSPREFIX	shift, and go to state 27
-    T_MAJOR	shift, and go to state 28
-    T_MINOR	shift, and go to state 29
-    T_GLOBAL	shift, and go to state 30
-    T_LOCAL	shift, and go to state 31
-    T_CLASSINIT	shift, and go to state 32
-    T_EXTERNAL	shift, and go to state 33
-
-    attribute	go to state 53
-
-
-
-state 37
-
-    parentattribute  ->  T_FILE . T_STEM T_EQUAL T_IDENTIFIER   (rule 27)
-
-    T_STEM	shift, and go to state 54
-
-
-
-state 38
-
-    parentattribute  ->  T_MAJOR . T_VERSION T_EQUAL T_NUMBER   (rule 28)
-
-    T_VERSION	shift, and go to state 55
-
-
-
-state 39
-
-    parentattribute  ->  T_MINOR . T_VERSION T_EQUAL T_NUMBER   (rule 29)
-
-    T_VERSION	shift, and go to state 56
-
-
-
-state 40
-
-    parentattribute  ->  T_GLOBAL .   (rule 30)
-
-    $default	reduce using rule 30 (parentattribute)
-
-
-
-state 41
-
-    parentattribute  ->  T_LOCAL .   (rule 31)
-
-    $default	reduce using rule 31 (parentattribute)
-
-
-
-state 42
-
-    parentattributes  ->  T_COMMA parentattribute .   (rule 25)
-
-    $default	reduce using rule 25 (parentattributes)
-
-
-
-state 43
-
-    parentdef  ->  parentsection T_IDENTIFIER T_COMMA parentattributes T_SEMICOLON .   (rule 24)
-
-    $default	reduce using rule 24 (parentdef)
-
-
-
-state 44
-
-    parentattributes  ->  parentattributes T_COMMA . parentattribute   (rule 26)
-
-    T_FILE	shift, and go to state 37
-    T_MAJOR	shift, and go to state 38
-    T_MINOR	shift, and go to state 39
-    T_GLOBAL	shift, and go to state 40
-    T_LOCAL	shift, and go to state 41
-
-    parentattribute	go to state 57
-
-
-
-state 45
-
-    attribute  ->  T_FILE T_STEM . T_EQUAL T_IDENTIFIER   (rule 9)
-
-    T_EQUAL	shift, and go to state 58
-
-
-
-state 46
-
-    attribute  ->  T_FUNCTION T_PREFIX . T_EQUAL T_IDENTIFIER   (rule 11)
-
-    T_EQUAL	shift, and go to state 59
-
-
-
-state 47
-
-    attribute  ->  T_CLASSPREFIX T_EQUAL . T_IDENTIFIER   (rule 13)
-
-    T_IDENTIFIER	shift, and go to state 60
-
-
-
-state 48
-
-    attribute  ->  T_MAJOR T_VERSION . T_EQUAL T_NUMBER   (rule 14)
-
-    T_EQUAL	shift, and go to state 61
-
-
-
-state 49
-
-    attribute  ->  T_MINOR T_VERSION . T_EQUAL T_NUMBER   (rule 15)
-
-    T_EQUAL	shift, and go to state 62
-
-
-
-state 50
-
-    attribute  ->  T_CLASSINIT T_EQUAL . T_IDENTIFIER   (rule 18)
-
-    T_IDENTIFIER	shift, and go to state 63
-
-
-
-state 51
-
-    attribute  ->  T_EXTERNAL T_STEM . T_EQUAL T_IDENTIFIER   (rule 10)
-
-    T_EQUAL	shift, and go to state 64
-
-
-
-state 52
-
-    attribute  ->  T_EXTERNAL T_PREFIX . T_EQUAL T_IDENTIFIER   (rule 12)
-
-    T_EQUAL	shift, and go to state 65
-
-
-
-state 53
-
-    attributes  ->  attributes T_COMMA attribute .   (rule 8)
-
-    $default	reduce using rule 8 (attributes)
-
-
-
-state 54
-
-    parentattribute  ->  T_FILE T_STEM . T_EQUAL T_IDENTIFIER   (rule 27)
-
-    T_EQUAL	shift, and go to state 66
-
-
-
-state 55
-
-    parentattribute  ->  T_MAJOR T_VERSION . T_EQUAL T_NUMBER   (rule 28)
-
-    T_EQUAL	shift, and go to state 67
-
-
-
-state 56
-
-    parentattribute  ->  T_MINOR T_VERSION . T_EQUAL T_NUMBER   (rule 29)
-
-    T_EQUAL	shift, and go to state 68
-
-
-
-state 57
-
-    parentattributes  ->  parentattributes T_COMMA parentattribute .   (rule 26)
-
-    $default	reduce using rule 26 (parentattributes)
-
-
-
-state 58
-
-    attribute  ->  T_FILE T_STEM T_EQUAL . T_IDENTIFIER   (rule 9)
-
-    T_IDENTIFIER	shift, and go to state 69
-
-
-
-state 59
-
-    attribute  ->  T_FUNCTION T_PREFIX T_EQUAL . T_IDENTIFIER   (rule 11)
-
-    T_IDENTIFIER	shift, and go to state 70
-
-
-
-state 60
-
-    attribute  ->  T_CLASSPREFIX T_EQUAL T_IDENTIFIER .   (rule 13)
-
-    $default	reduce using rule 13 (attribute)
-
-
-
-state 61
-
-    attribute  ->  T_MAJOR T_VERSION T_EQUAL . T_NUMBER   (rule 14)
-
-    T_NUMBER	shift, and go to state 71
-
-
-
-state 62
-
-    attribute  ->  T_MINOR T_VERSION T_EQUAL . T_NUMBER   (rule 15)
-
-    T_NUMBER	shift, and go to state 72
-
-
-
-state 63
-
-    attribute  ->  T_CLASSINIT T_EQUAL T_IDENTIFIER .   (rule 18)
-
-    $default	reduce using rule 18 (attribute)
-
-
-
-state 64
-
-    attribute  ->  T_EXTERNAL T_STEM T_EQUAL . T_IDENTIFIER   (rule 10)
-
-    T_IDENTIFIER	shift, and go to state 73
-
-
-
-state 65
-
-    attribute  ->  T_EXTERNAL T_PREFIX T_EQUAL . T_IDENTIFIER   (rule 12)
-
-    T_IDENTIFIER	shift, and go to state 74
-
-
-
-state 66
-
-    parentattribute  ->  T_FILE T_STEM T_EQUAL . T_IDENTIFIER   (rule 27)
-
-    T_IDENTIFIER	shift, and go to state 75
-
-
-
-state 67
-
-    parentattribute  ->  T_MAJOR T_VERSION T_EQUAL . T_NUMBER   (rule 28)
-
-    T_NUMBER	shift, and go to state 76
-
-
-
-state 68
-
-    parentattribute  ->  T_MINOR T_VERSION T_EQUAL . T_NUMBER   (rule 29)
-
-    T_NUMBER	shift, and go to state 77
-
-
-
-state 69
-
-    attribute  ->  T_FILE T_STEM T_EQUAL T_IDENTIFIER .   (rule 9)
-
-    $default	reduce using rule 9 (attribute)
-
-
-
-state 70
-
-    attribute  ->  T_FUNCTION T_PREFIX T_EQUAL T_IDENTIFIER .   (rule 11)
-
-    $default	reduce using rule 11 (attribute)
-
-
-
-state 71
-
-    attribute  ->  T_MAJOR T_VERSION T_EQUAL T_NUMBER .   (rule 14)
-
-    $default	reduce using rule 14 (attribute)
-
-
-
-state 72
-
-    attribute  ->  T_MINOR T_VERSION T_EQUAL T_NUMBER .   (rule 15)
-
-    $default	reduce using rule 15 (attribute)
-
-
-
-state 73
-
-    attribute  ->  T_EXTERNAL T_STEM T_EQUAL T_IDENTIFIER .   (rule 10)
-
-    $default	reduce using rule 10 (attribute)
-
-
-
-state 74
-
-    attribute  ->  T_EXTERNAL T_PREFIX T_EQUAL T_IDENTIFIER .   (rule 12)
-
-    $default	reduce using rule 12 (attribute)
-
-
-
-state 75
-
-    parentattribute  ->  T_FILE T_STEM T_EQUAL T_IDENTIFIER .   (rule 27)
-
-    $default	reduce using rule 27 (parentattribute)
-
-
-
-state 76
-
-    parentattribute  ->  T_MAJOR T_VERSION T_EQUAL T_NUMBER .   (rule 28)
-
-    $default	reduce using rule 28 (parentattribute)
-
-
-
-state 77
-
-    parentattribute  ->  T_MINOR T_VERSION T_EQUAL T_NUMBER .   (rule 29)
-
-    $default	reduce using rule 29 (parentattribute)
-
-
-
-state 78
-
-    $   	go to state 79
-
-
-
-state 79
-
-    $   	go to state 80
-
-
-
-state 80
-
-    $default	accept
diff -urN somfree/somopc/src/bison.hairy newsomfree/somopc/src/bison.hairy
--- somfree/somopc/src/bison.hairy	Sat Jun 29 21:47:30 2024
+++ newsomfree/somopc/src/bison.hairy	Thu Jan 01 07:00:00 1970
@@ -1,334 +0,0 @@
-
-extern int timeclock;
-
-
-int yyerror;		/*  Yyerror and yycost are set by guards.	*/
-int yycost;		/*  If yyerror is set to a nonzero value by a	*/
-			/*  guard, the reduction with which the guard	*/
-			/*  is associated is not performed, and the	*/
-			/*  error recovery mechanism is invoked.	*/
-			/*  Yycost indicates the cost of performing	*/
-			/*  the reduction given the attributes of the	*/
-			/*  symbols.					*/
-
-
-/*  YYMAXDEPTH indicates the size of the parser's state and value	*/
-/*  stacks.								*/
-
-#ifndef	YYMAXDEPTH
-#define	YYMAXDEPTH	500
-#endif
-
-/*  YYMAXRULES must be at least as large as the number of rules that	*/
-/*  could be placed in the rule queue.  That number could be determined	*/
-/*  from the grammar and the size of the stack, but, as yet, it is not.	*/
-
-#ifndef	YYMAXRULES
-#define	YYMAXRULES	100
-#endif
-
-#ifndef	YYMAXBACKUP
-#define YYMAXBACKUP	100
-#endif
-
-
-short	yyss[YYMAXDEPTH];	/*  the state stack			*/
-YYSTYPE	yyvs[YYMAXDEPTH];	/*  the semantic value stack		*/
-YYLTYPE yyls[YYMAXDEPTH];	/*  the location stack			*/
-short	yyrq[YYMAXRULES];	/*  the rule queue			*/
-int	yychar;			/*  the lookahead symbol		*/
-
-YYSTYPE	yylval;			/*  the semantic value of the		*/
-				/*  lookahead symbol			*/
-
-YYSTYPE yytval;			/*  the semantic value for the state	*/
-				/*  at the top of the state stack.	*/
-
-YYSTYPE yyval;			/*  the variable used to return		*/
-				/*  semantic values from the action	*/
-				/*  routines				*/
-
-YYLTYPE yylloc;		/*  location data for the lookahead	*/
-				/*  symbol				*/
-
-YYLTYPE yytloc;		/*  location data for the state at the	*/
-				/*  top of the state stack		*/
-
-
-int	yynunlexed;
-short	yyunchar[YYMAXBACKUP];
-YYSTYPE	yyunval[YYMAXBACKUP];
-YYLTYPE yyunloc[YYMAXBACKUP];
-
-short *yygssp;			/*  a pointer to the top of the state	*/
-				/*  stack; only set during error	*/
-				/*  recovery.				*/
-
-YYSTYPE *yygvsp;		/*  a pointer to the top of the value	*/
-				/*  stack; only set during error	*/
-				/*  recovery.				*/
-
-YYLTYPE *yyglsp;		/*  a pointer to the top of the		*/
-				/*  location stack; only set during	*/
-				/*  error recovery.			*/
-
-
-/*  Yyget is an interface between the parser and the lexical analyzer.	*/
-/*  It is costly to provide such an interface, but it avoids requiring	*/
-/*  the lexical analyzer to be able to back up the scan.		*/
-
-yyget()
-{
-  if (yynunlexed > 0)
-    {
-      yynunlexed--;
-      yychar = yyunchar[yynunlexed];
-      yylval = yyunval[yynunlexed];
-      yylloc = yyunloc[yynunlexed];
-    }
-  else if (yychar <= 0)
-    yychar = 0;
-  else
-    {
-      yychar = yylex();
-      if (yychar < 0)
-	yychar = 0;
-      else yychar = YYTRANSLATE(yychar);
-    }
-}
-
-
-
-yyunlex(chr, val, loc)
-int chr;
-YYSTYPE val;
-YYLTYPE loc;
-{
-  yyunchar[yynunlexed] = chr;
-  yyunval[yynunlexed] = val;
-  yyunloc[yynunlexed] = loc;
-  yynunlexed++;
-}
-
-
-
-yyrestore(first, last)
-register short *first;
-register short *last;
-{
-  register short *ssp;
-  register short *rp;
-  register int symbol;
-  register int state;
-  register int tvalsaved;
-
-  ssp = yygssp;
-  yyunlex(yychar, yylval, yylloc);
-
-  tvalsaved = 0;
-  while (first != last)
-    {
-      symbol = yystos[*ssp];
-      if (symbol < YYNTBASE)
-	{
-	  yyunlex(symbol, yytval, yytloc);
-	  tvalsaved = 1;
-	  ssp--;
-	}
-
-      ssp--;
-
-      if (first == yyrq)
-	first = yyrq + YYMAXRULES;
-
-      first--;
-
-      for (rp = yyrhs + yyprhs[*first]; symbol = *rp; rp++)
-	{
-	  if (symbol < YYNTBASE)
-	    state = yytable[yypact[*ssp] + symbol];
-	  else
-	    {
-	      state = yypgoto[symbol - YYNTBASE] + *ssp;
-
-	      if (state >= 0 && state <= YYLAST && yycheck[state] == *ssp)
-		state = yytable[state];
-	      else
-		state = yydefgoto[symbol - YYNTBASE];
-	    }
-
-	  *++ssp = state;
-	}
-    }
-
-  if ( ! tvalsaved && ssp > yyss)
-    {
-      yyunlex(yystos[*ssp], yytval, yytloc);
-      ssp--;
-    }
-
-  yygssp = ssp;
-}
-
-
-
-int
-yyparse()
-{
-  register int yystate;
-  register int yyn;
-  register short *yyssp;
-  register short *yyrq0;
-  register short *yyptr;
-  register YYSTYPE *yyvsp;
-
-  int yylen;
-  YYLTYPE *yylsp;
-  short *yyrq1;
-  short *yyrq2;
-
-  yystate = 0;
-  yyssp = yyss - 1;
-  yyvsp = yyvs - 1;
-  yylsp = yyls - 1;
-  yyrq0 = yyrq;
-  yyrq1 = yyrq0;
-  yyrq2 = yyrq0;
-
-  yychar = yylex();
-  if (yychar < 0)
-    yychar = 0;
-  else yychar = YYTRANSLATE(yychar);
-
-yynewstate:
-
-  if (yyssp >= yyss + YYMAXDEPTH - 1)
-    {
-      yyabort("Parser Stack Overflow");
-      YYABORT;
-    }
-
-  *++yyssp = yystate;
-
-yyresume:
-
-  yyn = yypact[yystate];
-  if (yyn == YYFLAG)
-    goto yydefault;
-
-  yyn += yychar;
-  if (yyn < 0 || yyn > YYLAST || yycheck[yyn] != yychar)
-    goto yydefault;
-
-  yyn = yytable[yyn];
-  if (yyn < 0)
-    {
-      yyn = -yyn;
-      goto yyreduce;
-    }
-  else if (yyn == 0)
-    goto yyerrlab;
-
-  yystate = yyn;
-
-  yyptr = yyrq2;
-  while (yyptr != yyrq1)
-    {
-      yyn = *yyptr++;
-      yylen = yyr2[yyn];
-      yyvsp -= yylen;
-      yylsp -= yylen;
-
-      yyguard(yyn, yyvsp, yylsp);
-      if (yyerror)
-	goto yysemerr;
-
-      yyaction(yyn, yyvsp, yylsp);
-      *++yyvsp = yyval;
-
-      yylsp++;
-      if (yylen == 0)
-	{
-	  yylsp->timestamp = timeclock;
-	  yylsp->first_line = yytloc.first_line;
-	  yylsp->first_column = yytloc.first_column;
-	  yylsp->last_line = (yylsp-1)->last_line;
-	  yylsp->last_column = (yylsp-1)->last_column;
-	  yylsp->text = 0;
-	}
-      else
-	{
-	  yylsp->last_line = (yylsp+yylen-1)->last_line;
-	  yylsp->last_column = (yylsp+yylen-1)->last_column;
-	}
-	  
-      if (yyptr == yyrq + YYMAXRULES)
-        yyptr = yyrq;
-    }
-
-  if (yystate == YYFINAL)
-    YYACCEPT;
-
-  yyrq2 = yyptr;
-  yyrq1 = yyrq0;
-
-  *++yyvsp = yytval;
-  *++yylsp = yytloc;
-  yytval = yylval;
-  yytloc = yylloc;
-  yyget();
-
-  goto yynewstate;
-
-yydefault:
-
-  yyn = yydefact[yystate];
-  if (yyn == 0)
-    goto yyerrlab;
-
-yyreduce:
-
-  *yyrq0++ = yyn;
-
-  if (yyrq0 == yyrq + YYMAXRULES)
-    yyrq0 = yyrq;
-
-  if (yyrq0 == yyrq2)
-    {
-      yyabort("Parser Rule Queue Overflow");
-      YYABORT;
-    }
-
-  yyssp -= yyr2[yyn];
-  yyn = yyr1[yyn];
-
-  yystate = yypgoto[yyn - YYNTBASE] + *yyssp;
-  if (yystate >= 0 && yystate <= YYLAST && yycheck[yystate] == *yyssp)
-    yystate = yytable[yystate];
-  else
-    yystate = yydefgoto[yyn - YYNTBASE];
-
-  goto yynewstate;
-
-yysemerr:
-  *--yyptr = yyn;
-  yyrq2 = yyptr;
-  yyvsp += yyr2[yyn];
-
-yyerrlab:
-
-  yygssp = yyssp;
-  yygvsp = yyvsp;
-  yyglsp = yylsp;
-  yyrestore(yyrq0, yyrq2);
-  yyrecover();
-  yystate = *yygssp;
-  yyssp = yygssp;
-  yyvsp = yygvsp;
-  yyrq0 = yyrq;
-  yyrq1 = yyrq0;
-  yyrq2 = yyrq0;
-  goto yyresume;
-}
-
-$
diff -urN somfree/somopc/src/bison.simple newsomfree/somopc/src/bison.simple
--- somfree/somopc/src/bison.simple	Sat Jun 29 21:47:30 2024
+++ newsomfree/somopc/src/bison.simple	Thu Jan 01 07:00:00 1970
@@ -1,762 +0,0 @@
-/* -*-C-*-  Note some compilers choke on comments on `#line' lines.  */
-#line 3 "/emx/share/bison.simple"
-/* This file comes from bison-1.28.  */
-
-/* Skeleton output parser for bison,
-   Copyright (C) 1984, 1989, 1990 Free Software Foundation, Inc.
-
-   This program is free software; you can redistribute it and/or modify
-   it under the terms of the GNU General Public License as published by
-   the Free Software Foundation; either version 2, or (at your option)
-   any later version.
-
-   This program is distributed in the hope that it will be useful,
-   but WITHOUT ANY WARRANTY; without even the implied warranty of
-   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-   GNU General Public License for more details.
-
-   You should have received a copy of the GNU General Public License
-   along with this program; if not, write to the Free Software
-   Foundation, Inc., 59 Temple Place - Suite 330,
-   Boston, MA 02111-1307, USA.  */
-
-/* As a special exception, when this file is copied by Bison into a
-   Bison output file, you may use that output file without restriction.
-   This special exception was added by the Free Software Foundation
-   in version 1.24 of Bison.  */
-
-/* This is the parser code that is written into each bison parser
-  when the %semantic_parser declaration is not specified in the grammar.
-  It was written by Richard Stallman by simplifying the hairy parser
-  used when %semantic_parser is specified.  */
-
-#ifndef YYSTACK_USE_ALLOCA
-#ifdef alloca
-#define YYSTACK_USE_ALLOCA
-#else /* alloca not defined */
-#ifdef __GNUC__
-#define YYSTACK_USE_ALLOCA
-#define alloca __builtin_alloca
-#else /* not GNU C.  */
-#if (!defined (__STDC__) && defined (sparc)) || defined (__sparc__) || defined (__sparc) || defined (__sgi) || (defined (__sun) && defined (__i386))
-#define YYSTACK_USE_ALLOCA
-#include <alloca.h>
-#else /* not sparc */
-/* We think this test detects Watcom and Microsoft C.  */
-/* This used to test MSDOS, but that is a bad idea
-   since that symbol is in the user namespace.  */
-#if (defined (_MSDOS) || defined (_MSDOS_)) && !defined (__TURBOC__)
-#if 0 /* No need for malloc.h, which pollutes the namespace;
-	 instead, just don't use alloca.  */
-#include <malloc.h>
-#endif
-#else /* not MSDOS, or __TURBOC__ */
-#if defined(_AIX)
-/* I don't know what this was needed for, but it pollutes the namespace.
-   So I turned it off.   rms, 2 May 1997.  */
-/* #include <malloc.h>  */
- #pragma alloca
-#define YYSTACK_USE_ALLOCA
-#else /* not MSDOS, or __TURBOC__, or _AIX */
-#include <malloc.h>
-#if 0
-#ifdef __hpux /* haible@ilog.fr says this works for HPUX 9.05 and up,
-		 and on HPUX 10.  Eventually we can turn this on.  */
-#define YYSTACK_USE_ALLOCA
-#define alloca __builtin_alloca
-#endif /* __hpux */
-#endif
-#endif /* not _AIX */
-#endif /* not MSDOS, or __TURBOC__ */
-#endif /* not sparc */
-#endif /* not GNU C */
-#endif /* alloca not defined */
-#endif /* YYSTACK_USE_ALLOCA not defined */
-
-#ifdef YYSTACK_USE_ALLOCA
-#define YYSTACK_ALLOC alloca
-#else
-#define YYSTACK_ALLOC malloc
-#endif
-
-/* Note: there must be only one dollar sign in this file.
-   It is replaced by the list of actions, each action
-   as one case of the switch.  */
-
-#define yyerrok		(yyerrstatus = 0)
-#define yyclearin	(yychar = YYEMPTY)
-#define YYEMPTY		-2
-#define YYEOF		0
-#define YYACCEPT	goto yyacceptlab
-#define YYABORT 	goto yyabortlab
-#define YYERROR		goto yyerrlab1
-/* Like YYERROR except do call yyerror.
-   This remains here temporarily to ease the
-   transition to the new meaning of YYERROR, for GCC.
-   Once GCC version 2 has supplanted version 1, this can go.  */
-#define YYFAIL		goto yyerrlab
-#define YYRECOVERING()  (!!yyerrstatus)
-#define YYBACKUP(token, value) \
-do								\
-  if (yychar == YYEMPTY && yylen == 1)				\
-    { yychar = (token), yylval = (value);			\
-      yychar1 = YYTRANSLATE (yychar);				\
-      YYPOPSTACK;						\
-      goto yybackup;						\
-    }								\
-  else								\
-    { yyerror ("syntax error: cannot back up"); YYERROR; }	\
-while (0)
-
-#define YYTERROR	1
-#define YYERRCODE	256
-
-#ifndef YYPURE
-#define YYLEX		yylex()
-#endif
-
-#ifdef YYPURE
-#ifdef YYLSP_NEEDED
-#ifdef YYLEX_PARAM
-#define YYLEX		yylex(&yylval, &yylloc, YYLEX_PARAM)
-#else
-#define YYLEX		yylex(&yylval, &yylloc)
-#endif
-#else /* not YYLSP_NEEDED */
-#ifdef YYLEX_PARAM
-#define YYLEX		yylex(&yylval, YYLEX_PARAM)
-#else
-#define YYLEX		yylex(&yylval)
-#endif
-#endif /* not YYLSP_NEEDED */
-#endif
-
-/* If nonreentrant, generate the variables here */
-
-#ifndef YYPURE
-
-int	yychar;			/*  the lookahead symbol		*/
-YYSTYPE	yylval;			/*  the semantic value of the		*/
-				/*  lookahead symbol			*/
-
-#ifdef YYLSP_NEEDED
-YYLTYPE yylloc;			/*  location data for the lookahead	*/
-				/*  symbol				*/
-#endif
-
-int yynerrs;			/*  number of parse errors so far       */
-#endif  /* not YYPURE */
-
-#if YYDEBUG != 0
-int yydebug;			/*  nonzero means print parse trace	*/
-/* Since this is uninitialized, it does not stop multiple parsers
-   from coexisting.  */
-#endif
-
-/*  YYINITDEPTH indicates the initial size of the parser's stacks	*/
-
-#ifndef	YYINITDEPTH
-#define YYINITDEPTH 200
-#endif
-
-/*  YYMAXDEPTH is the maximum size the stacks can grow to
-    (effective only if the built-in stack extension method is used).  */
-
-#if YYMAXDEPTH == 0
-#undef YYMAXDEPTH
-#endif
-
-#ifndef YYMAXDEPTH
-#define YYMAXDEPTH 10000
-#endif
-
-/* Define __yy_memcpy.  Note that the size argument
-   should be passed with type unsigned int, because that is what the non-GCC
-   definitions require.  With GCC, __builtin_memcpy takes an arg
-   of type size_t, but it can handle unsigned int.  */
-
-#if __GNUC__ > 1		/* GNU C and GNU C++ define this.  */
-#define __yy_memcpy(TO,FROM,COUNT)	__builtin_memcpy(TO,FROM,COUNT)
-#else				/* not GNU C or C++ */
-#ifndef __cplusplus
-
-/* This is the most reliable way to avoid incompatibilities
-   in available built-in functions on various systems.  */
-static void
-__yy_memcpy (to, from, count)
-     char *to;
-     char *from;
-     unsigned int count;
-{
-  register char *f = from;
-  register char *t = to;
-  register int i = count;
-
-  while (i-- > 0)
-    *t++ = *f++;
-}
-
-#else /* __cplusplus */
-
-/* This is the most reliable way to avoid incompatibilities
-   in available built-in functions on various systems.  */
-static void
-__yy_memcpy (char *to, char *from, unsigned int count)
-{
-  register char *t = to;
-  register char *f = from;
-  register int i = count;
-
-  while (i-- > 0)
-    *t++ = *f++;
-}
-
-#endif
-#endif
-
-#line 217 "/emx/share/bison.simple"
-
-/* The user can define YYPARSE_PARAM as the name of an argument to be passed
-   into yyparse.  The argument should have type void *.
-   It should actually point to an object.
-   Grammar actions can access the variable by casting it
-   to the proper pointer type.  */
-
-#ifdef YYPARSE_PARAM
-#ifdef __cplusplus
-#define YYPARSE_PARAM_ARG void *YYPARSE_PARAM
-#define YYPARSE_PARAM_DECL
-#else /* not __cplusplus */
-#define YYPARSE_PARAM_ARG YYPARSE_PARAM
-#define YYPARSE_PARAM_DECL void *YYPARSE_PARAM;
-#endif /* not __cplusplus */
-#else /* not YYPARSE_PARAM */
-#define YYPARSE_PARAM_ARG
-#define YYPARSE_PARAM_DECL
-#endif /* not YYPARSE_PARAM */
-
-/* Prevent warning if -Wstrict-prototypes.  */
-#ifdef __GNUC__
-#ifdef YYPARSE_PARAM
-int yyparse (void *);
-#else
-int yyparse (void);
-#endif
-#endif
-
-int
-yyparse(YYPARSE_PARAM_ARG)
-     YYPARSE_PARAM_DECL
-{
-  register int yystate;
-  register int yyn;
-  register short *yyssp;
-  register YYSTYPE *yyvsp;
-  int yyerrstatus;	/*  number of tokens to shift before error messages enabled */
-  int yychar1 = 0;		/*  lookahead token as an internal (translated) token number */
-
-  short	yyssa[YYINITDEPTH];	/*  the state stack			*/
-  YYSTYPE yyvsa[YYINITDEPTH];	/*  the semantic value stack		*/
-
-  short *yyss = yyssa;		/*  refer to the stacks thru separate pointers */
-  YYSTYPE *yyvs = yyvsa;	/*  to allow yyoverflow to reallocate them elsewhere */
-
-#ifdef YYLSP_NEEDED
-  YYLTYPE yylsa[YYINITDEPTH];	/*  the location stack			*/
-  YYLTYPE *yyls = yylsa;
-  YYLTYPE *yylsp;
-
-#define YYPOPSTACK   (yyvsp--, yyssp--, yylsp--)
-#else
-#define YYPOPSTACK   (yyvsp--, yyssp--)
-#endif
-
-  int yystacksize = YYINITDEPTH;
-  int yyfree_stacks = 0;
-
-#ifdef YYPURE
-  int yychar;
-  YYSTYPE yylval;
-  int yynerrs;
-#ifdef YYLSP_NEEDED
-  YYLTYPE yylloc;
-#endif
-#endif
-
-  YYSTYPE yyval;		/*  the variable used to return		*/
-				/*  semantic values from the action	*/
-				/*  routines				*/
-
-  int yylen;
-
-#if YYDEBUG != 0
-  if (yydebug)
-    fprintf(stderr, "Starting parse\n");
-#endif
-
-  yystate = 0;
-  yyerrstatus = 0;
-  yynerrs = 0;
-  yychar = YYEMPTY;		/* Cause a token to be read.  */
-
-  /* Initialize stack pointers.
-     Waste one element of value and location stack
-     so that they stay on the same level as the state stack.
-     The wasted elements are never initialized.  */
-
-  yyssp = yyss - 1;
-  yyvsp = yyvs;
-#ifdef YYLSP_NEEDED
-  yylsp = yyls;
-#endif
-
-/* Push a new state, which is found in  yystate  .  */
-/* In all cases, when you get here, the value and location stacks
-   have just been pushed. so pushing a state here evens the stacks.  */
-yynewstate:
-
-  *++yyssp = yystate;
-
-  if (yyssp >= yyss + yystacksize - 1)
-    {
-      /* Give user a chance to reallocate the stack */
-      /* Use copies of these so that the &'s don't force the real ones into memory. */
-      YYSTYPE *yyvs1 = yyvs;
-      short *yyss1 = yyss;
-#ifdef YYLSP_NEEDED
-      YYLTYPE *yyls1 = yyls;
-#endif
-
-      /* Get the current used size of the three stacks, in elements.  */
-      int size = yyssp - yyss + 1;
-
-#ifdef yyoverflow
-      /* Each stack pointer address is followed by the size of
-	 the data in use in that stack, in bytes.  */
-#ifdef YYLSP_NEEDED
-      /* This used to be a conditional around just the two extra args,
-	 but that might be undefined if yyoverflow is a macro.  */
-      yyoverflow("parser stack overflow",
-		 &yyss1, size * sizeof (*yyssp),
-		 &yyvs1, size * sizeof (*yyvsp),
-		 &yyls1, size * sizeof (*yylsp),
-		 &yystacksize);
-#else
-      yyoverflow("parser stack overflow",
-		 &yyss1, size * sizeof (*yyssp),
-		 &yyvs1, size * sizeof (*yyvsp),
-		 &yystacksize);
-#endif
-
-      yyss = yyss1; yyvs = yyvs1;
-#ifdef YYLSP_NEEDED
-      yyls = yyls1;
-#endif
-#else /* no yyoverflow */
-      /* Extend the stack our own way.  */
-      if (yystacksize >= YYMAXDEPTH)
-	{
-	  yyerror("parser stack overflow");
-	  if (yyfree_stacks)
-	    {
-	      free (yyss);
-	      free (yyvs);
-#ifdef YYLSP_NEEDED
-	      free (yyls);
-#endif
-	    }
-	  return 2;
-	}
-      yystacksize *= 2;
-      if (yystacksize > YYMAXDEPTH)
-	yystacksize = YYMAXDEPTH;
-#ifndef YYSTACK_USE_ALLOCA
-      yyfree_stacks = 1;
-#endif
-      yyss = (short *) YYSTACK_ALLOC (yystacksize * sizeof (*yyssp));
-      __yy_memcpy ((char *)yyss, (char *)yyss1,
-		   size * (unsigned int) sizeof (*yyssp));
-      yyvs = (YYSTYPE *) YYSTACK_ALLOC (yystacksize * sizeof (*yyvsp));
-      __yy_memcpy ((char *)yyvs, (char *)yyvs1,
-		   size * (unsigned int) sizeof (*yyvsp));
-#ifdef YYLSP_NEEDED
-      yyls = (YYLTYPE *) YYSTACK_ALLOC (yystacksize * sizeof (*yylsp));
-      __yy_memcpy ((char *)yyls, (char *)yyls1,
-		   size * (unsigned int) sizeof (*yylsp));
-#endif
-#endif /* no yyoverflow */
-
-      yyssp = yyss + size - 1;
-      yyvsp = yyvs + size - 1;
-#ifdef YYLSP_NEEDED
-      yylsp = yyls + size - 1;
-#endif
-
-#if YYDEBUG != 0
-      if (yydebug)
-	fprintf(stderr, "Stack size increased to %d\n", yystacksize);
-#endif
-
-      if (yyssp >= yyss + yystacksize - 1)
-	YYABORT;
-    }
-
-#if YYDEBUG != 0
-  if (yydebug)
-    fprintf(stderr, "Entering state %d\n", yystate);
-#endif
-
-  goto yybackup;
- yybackup:
-
-/* Do appropriate processing given the current state.  */
-/* Read a lookahead token if we need one and don't already have one.  */
-/* yyresume: */
-
-  /* First try to decide what to do without reference to lookahead token.  */
-
-  yyn = yypact[yystate];
-  if (yyn == YYFLAG)
-    goto yydefault;
-
-  /* Not known => get a lookahead token if don't already have one.  */
-
-  /* yychar is either YYEMPTY or YYEOF
-     or a valid token in external form.  */
-
-  if (yychar == YYEMPTY)
-    {
-#if YYDEBUG != 0
-      if (yydebug)
-	fprintf(stderr, "Reading a token: ");
-#endif
-      yychar = YYLEX;
-    }
-
-  /* Convert token to internal form (in yychar1) for indexing tables with */
-
-  if (yychar <= 0)		/* This means end of input. */
-    {
-      yychar1 = 0;
-      yychar = YYEOF;		/* Don't call YYLEX any more */
-
-#if YYDEBUG != 0
-      if (yydebug)
-	fprintf(stderr, "Now at end of input.\n");
-#endif
-    }
-  else
-    {
-      yychar1 = YYTRANSLATE(yychar);
-
-#if YYDEBUG != 0
-      if (yydebug)
-	{
-	  fprintf (stderr, " Next token is %d (%s", yychar, yytname[yychar1]);
-	  /* Give the individual parser a way to print the precise meaning
-	     of a token, for further debugging info.  */
-#ifdef YYPRINT
-	  YYPRINT (stderr, yychar, yylval);
-#endif
-	  fprintf (stderr, ")\n");
-	}
-#endif
-    }
-
-  yyn += yychar1;
-  if (yyn < 0 || yyn > YYLAST || yycheck[yyn] != yychar1)
-    goto yydefault;
-
-  yyn = yytable[yyn];
-
-  /* yyn is what to do for this token type in this state.
-     Negative => reduce, -yyn is rule number.
-     Positive => shift, yyn is new state.
-       New state is final state => don't bother to shift,
-       just return success.
-     0, or most negative number => error.  */
-
-  if (yyn < 0)
-    {
-      if (yyn == YYFLAG)
-	goto yyerrlab;
-      yyn = -yyn;
-      goto yyreduce;
-    }
-  else if (yyn == 0)
-    goto yyerrlab;
-
-  if (yyn == YYFINAL)
-    YYACCEPT;
-
-  /* Shift the lookahead token.  */
-
-#if YYDEBUG != 0
-  if (yydebug)
-    fprintf(stderr, "Shifting token %d (%s), ", yychar, yytname[yychar1]);
-#endif
-
-  /* Discard the token being shifted unless it is eof.  */
-  if (yychar != YYEOF)
-    yychar = YYEMPTY;
-
-  *++yyvsp = yylval;
-#ifdef YYLSP_NEEDED
-  *++yylsp = yylloc;
-#endif
-
-  /* count tokens shifted since error; after three, turn off error status.  */
-  if (yyerrstatus) yyerrstatus--;
-
-  yystate = yyn;
-  goto yynewstate;
-
-/* Do the default action for the current state.  */
-yydefault:
-
-  yyn = yydefact[yystate];
-  if (yyn == 0)
-    goto yyerrlab;
-
-/* Do a reduction.  yyn is the number of a rule to reduce with.  */
-yyreduce:
-  yylen = yyr2[yyn];
-  if (yylen > 0)
-    yyval = yyvsp[1-yylen]; /* implement default value of the action */
-
-#if YYDEBUG != 0
-  if (yydebug)
-    {
-      int i;
-
-      fprintf (stderr, "Reducing via rule %d (line %d), ",
-	       yyn, yyrline[yyn]);
-
-      /* Print the symbols being reduced, and their result.  */
-      for (i = yyprhs[yyn]; yyrhs[i] > 0; i++)
-	fprintf (stderr, "%s ", yytname[yyrhs[i]]);
-      fprintf (stderr, " -> %s\n", yytname[yyr1[yyn]]);
-    }
-#endif
-
-$   /* the action file gets copied in in place of this dollarsign */
-#line 543 "/emx/share/bison.simple"
-
-  yyvsp -= yylen;
-  yyssp -= yylen;
-#ifdef YYLSP_NEEDED
-  yylsp -= yylen;
-#endif
-
-#if YYDEBUG != 0
-  if (yydebug)
-    {
-      short *ssp1 = yyss - 1;
-      fprintf (stderr, "state stack now");
-      while (ssp1 != yyssp)
-	fprintf (stderr, " %d", *++ssp1);
-      fprintf (stderr, "\n");
-    }
-#endif
-
-  *++yyvsp = yyval;
-
-#ifdef YYLSP_NEEDED
-  yylsp++;
-  if (yylen == 0)
-    {
-      yylsp->first_line = yylloc.first_line;
-      yylsp->first_column = yylloc.first_column;
-      yylsp->last_line = (yylsp-1)->last_line;
-      yylsp->last_column = (yylsp-1)->last_column;
-      yylsp->text = 0;
-    }
-  else
-    {
-      yylsp->last_line = (yylsp+yylen-1)->last_line;
-      yylsp->last_column = (yylsp+yylen-1)->last_column;
-    }
-#endif
-
-  /* Now "shift" the result of the reduction.
-     Determine what state that goes to,
-     based on the state we popped back to
-     and the rule number reduced by.  */
-
-  yyn = yyr1[yyn];
-
-  yystate = yypgoto[yyn - YYNTBASE] + *yyssp;
-  if (yystate >= 0 && yystate <= YYLAST && yycheck[yystate] == *yyssp)
-    yystate = yytable[yystate];
-  else
-    yystate = yydefgoto[yyn - YYNTBASE];
-
-  goto yynewstate;
-
-yyerrlab:   /* here on detecting error */
-
-  if (! yyerrstatus)
-    /* If not already recovering from an error, report this error.  */
-    {
-      ++yynerrs;
-
-#ifdef YYERROR_VERBOSE
-      yyn = yypact[yystate];
-
-      if (yyn > YYFLAG && yyn < YYLAST)
-	{
-	  int size = 0;
-	  char *msg;
-	  int x, count;
-
-	  count = 0;
-	  /* Start X at -yyn if nec to avoid negative indexes in yycheck.  */
-	  for (x = (yyn < 0 ? -yyn : 0);
-	       x < (sizeof(yytname) / sizeof(char *)); x++)
-	    if (yycheck[x + yyn] == x)
-	      size += strlen(yytname[x]) + 15, count++;
-	  msg = (char *) malloc(size + 15);
-	  if (msg != 0)
-	    {
-	      strcpy(msg, "parse error");
-
-	      if (count < 5)
-		{
-		  count = 0;
-		  for (x = (yyn < 0 ? -yyn : 0);
-		       x < (sizeof(yytname) / sizeof(char *)); x++)
-		    if (yycheck[x + yyn] == x)
-		      {
-			strcat(msg, count == 0 ? ", expecting `" : " or `");
-			strcat(msg, yytname[x]);
-			strcat(msg, "'");
-			count++;
-		      }
-		}
-	      yyerror(msg);
-	      free(msg);
-	    }
-	  else
-	    yyerror ("parse error; also virtual memory exceeded");
-	}
-      else
-#endif /* YYERROR_VERBOSE */
-	yyerror("parse error");
-    }
-
-  goto yyerrlab1;
-yyerrlab1:   /* here on error raised explicitly by an action */
-
-  if (yyerrstatus == 3)
-    {
-      /* if just tried and failed to reuse lookahead token after an error, discard it.  */
-
-      /* return failure if at end of input */
-      if (yychar == YYEOF)
-	YYABORT;
-
-#if YYDEBUG != 0
-      if (yydebug)
-	fprintf(stderr, "Discarding token %d (%s).\n", yychar, yytname[yychar1]);
-#endif
-
-      yychar = YYEMPTY;
-    }
-
-  /* Else will try to reuse lookahead token
-     after shifting the error token.  */
-
-  yyerrstatus = 3;		/* Each real token shifted decrements this */
-
-  goto yyerrhandle;
-
-yyerrdefault:  /* current state does not do anything special for the error token. */
-
-#if 0
-  /* This is wrong; only states that explicitly want error tokens
-     should shift them.  */
-  yyn = yydefact[yystate];  /* If its default is to accept any token, ok.  Otherwise pop it.*/
-  if (yyn) goto yydefault;
-#endif
-
-yyerrpop:   /* pop the current state because it cannot handle the error token */
-
-  if (yyssp == yyss) YYABORT;
-  yyvsp--;
-  yystate = *--yyssp;
-#ifdef YYLSP_NEEDED
-  yylsp--;
-#endif
-
-#if YYDEBUG != 0
-  if (yydebug)
-    {
-      short *ssp1 = yyss - 1;
-      fprintf (stderr, "Error: state stack now");
-      while (ssp1 != yyssp)
-	fprintf (stderr, " %d", *++ssp1);
-      fprintf (stderr, "\n");
-    }
-#endif
-
-yyerrhandle:
-
-  yyn = yypact[yystate];
-  if (yyn == YYFLAG)
-    goto yyerrdefault;
-
-  yyn += YYTERROR;
-  if (yyn < 0 || yyn > YYLAST || yycheck[yyn] != YYTERROR)
-    goto yyerrdefault;
-
-  yyn = yytable[yyn];
-  if (yyn < 0)
-    {
-      if (yyn == YYFLAG)
-	goto yyerrpop;
-      yyn = -yyn;
-      goto yyreduce;
-    }
-  else if (yyn == 0)
-    goto yyerrpop;
-
-  if (yyn == YYFINAL)
-    YYACCEPT;
-
-#if YYDEBUG != 0
-  if (yydebug)
-    fprintf(stderr, "Shifting error token, ");
-#endif
-
-  *++yyvsp = yylval;
-#ifdef YYLSP_NEEDED
-  *++yylsp = yylloc;
-#endif
-
-  yystate = yyn;
-  goto yynewstate;
-
- yyacceptlab:
-  /* YYACCEPT comes here.  */
-  if (yyfree_stacks)
-    {
-      free (yyss);
-      free (yyvs);
-#ifdef YYLSP_NEEDED
-      free (yyls);
-#endif
-    }
-  return 0;
-
- yyabortlab:
-  /* YYABORT comes here.  */
-  if (yyfree_stacks)
-    {
-      free (yyss);
-      free (yyvs);
-#ifdef YYLSP_NEEDED
-      free (yyls);
-#endif
-    }
-  return 1;
-}
diff -urN somfree/somopc/src/gramma.yy newsomfree/somopc/src/gramma.yy
--- somfree/somopc/src/gramma.yy	Sat Jun 29 21:47:30 2024
+++ newsomfree/somopc/src/gramma.yy	Thu Jan 01 07:00:00 1970
@@ -1,1125 +0,0 @@
-%{
-#include <stdio.h> // fopen, fprintf
-#include <string.h>
-
-#include <emitlib.h>
-
-#define YYERROR_VERBOSE
-
-extern int lineno, column;
-
-Entry e;
-
-Entry *cls;	// Current Class Entry
-Entry *pcls;	// Parent Class Entry
-Entry *mcls;	// Meta Class Entry
-
-void yyerror(const char *str)
-{
-        fprintf(stderr,"\nerror: %s\n", str);
-}
- 
-int yywrap()
-{
-        return 1;
-} 
-  
-%}
-
-
-
-%start oidl
-
-%union{
- char *stval;
- int ival;
-}
-
-
-%type <stval> overridemethod_name
-
-%type <ival> T_CONSTANT
-
-%token T_COLON T_SEMICOLON T_COMMA T_STAR T_COMMENT T_IDENTIFIER
-%token T_EQUAL T_DASHES T_CONSTANT T_PERIOD  T_STRING
-%token T_ELLIPSIS T_LEFTPARENTHESIS T_RIGHTPARENTHESIS
-%token T_LEFTSQUAREBRACKET T_RIGHTSQUAREBRACKET
-
-%token T_VERSION T_GLOBAL T_LOCAL T_CLASSINIT T_RELEASE T_ORDER T_METACLASS T_PARENT
-%token T_CLASS T_LINE
-%token T_FILE T_STEM T_FUNCTION T_PREFIX T_CLASSPREFIX T_MAJOR T_MINOR
-%token T_PASSTHRU T_BEFORE T_AFTER T_ENDPASSTHRU T_DATA T_PRIVATE T_PUBLIC T_INTERNAL
-%token T_METHODS T_GROUP T_METHOD T_PROCEDURE T_OFFSET T_NAME T_LOOKUP T_EXTERNAL
-%token T_USE T_OVERRIDE
-
-%%
-
-oidl
-	:
-		{
-			if (somtg_f.verbose) printf("Parsing of \"%s\" started.\n", somtfilePath);
-			somtg_f._ERROR=0;   /* @todo subject to move to parse() */
-			somtg_f.WARN=0;   /* @todo subject to move to parse() */
-			somtg_f.FATAL=0;   /* @todo subject to move to parse() */
-			somtg_f.INTERNAL=0;   /* @todo subject to move to parse() */
-			somtg_buf=somtsmallocSL(somtg_f.commentsize, TRUE);   /* @todo subject to move to parse() */
-		}
-	  class_list
-		{
-			somtfree(somtg_buf);   /* @todo subject to move to parse() */
-			if (somtg_f.verbose) printf("Parsing of \"%s\" finished.\n", somtfilePath);
-		}
-	| line
-        ;
-
-line	: T_LINE T_CONSTANT T_STRING
-	;
-
-class_list
-	: class_definition
-	| class_list class_definition
-	;
-
-class_definition
-	:
-		{
-			cls=(Entry *)somtsmallocSL(sizeof(Entry), TRUE);
-			cls->atts=somtaddModifierSL(cls->atts, "callstyle", "oidl");
-			cls->type=SOMTClassE;
-			somtclassIdlCall=FALSE;
-			cls->u.c.file=strdup(somtfilePath);
-		}
-	  class_section section_list
-		{
-			somtaddEntrySL(somtstab, cls->name, cls);
-			somtfree(cls);
-		}
-	;
-
-section_list
-	: section
-        | section_list section
-        ;
-
-section
-	: releaseorder_section
-        | metaclass_section
-        |
-		{
-			pcls=(Entry *)somtsmallocSL(sizeof(Entry), TRUE);
-			pcls->atts=somtaddModifierSL(pcls->atts, "callstyle", "oidl");
-			pcls->type=SOMTBaseE;
-			somtclassIdlCall=FALSE;
-//			pcls->u.c.file=strdup(somtfilePath);
-		}
-	  parent_section
-		{
-			cls->u.c.parent=somtaddEntrySL(somtstab, pcls->name, pcls);
-			somtfree(pcls);
-		}
-        | passthru_section
-        | data_section
-	| methods_section
-	;
-
-class_section
-	: classdef 
-        | classdef description
-		{
-			cls->comment=$<stval>2;
-		}
-	;
-
-classdef
-	: class_header class_name T_SEMICOLON 
-	| class_header class_name class_attributes T_SEMICOLON
-        ;
-
-class_header
-	: T_CLASS T_COLON 
-	;
-
-class_name
-	: T_IDENTIFIER 
-		{
-			somtclassName=$<stval>1;
-			cls->lineno=lineno;                 
-			cls->name=$<stval>1;
-		}
-        ;
-
-class_attributes
-	: T_COMMA class_attribute
-	| class_attributes T_COMMA class_attribute
-        ;
-
-class_attribute
-	: T_FILE T_STEM T_EQUAL T_IDENTIFIER
-		{
-			cls->atts=somtaddModifierSL(cls->atts, "filestem", $<stval>4);
-		}
-        | T_EXTERNAL T_STEM T_EQUAL T_IDENTIFIER
-		{
-			cls->atts=somtaddModifierSL(cls->atts, "externalstem", $<stval>4);
-		}
-        | T_FUNCTION T_PREFIX T_EQUAL T_IDENTIFIER
-		{
-			cls->atts=somtaddModifierSL(cls->atts, "functionprefix", $<stval>4);
-		}
-        | T_EXTERNAL T_PREFIX T_EQUAL T_IDENTIFIER
-		{
-			cls->atts=somtaddModifierSL(cls->atts, "externalprefix", $<stval>4);
-		}
-        | T_CLASSPREFIX T_EQUAL T_IDENTIFIER
-		{
-			cls->atts=somtaddModifierSL(cls->atts, "classprefix", $<stval>3);
-		}
-        | T_MAJOR T_VERSION T_EQUAL T_CONSTANT
-		{
-			char *st=itoa($4, somtsmallocSL(_MAX_ITOSTR_BASE10_COUNT, TRUE), 10);
-			cls->atts=somtaddModifierSL(cls->atts, "majorversion", st);
-			somtmajorVersion=strdup(st);
-			somtfree(st);
-		}
-        | T_MINOR T_VERSION T_EQUAL T_CONSTANT
-		{
-			char *st=itoa($4, somtsmallocSL(_MAX_ITOSTR_BASE10_COUNT, TRUE), 10);
-			cls->atts=somtaddModifierSL(cls->atts, "minorversion", st);
-			somtminorVersion=strdup(st);
-			somtfree(st);
-		}
-        | T_CLASSINIT T_EQUAL T_IDENTIFIER
-		{
-			cls->atts=somtaddModifierSL(cls->atts, "classInit", $<stval>3);
-		}
-	| visibility
-        ;
-
-visibility
-	: T_GLOBAL
-        | T_LOCAL
-	;
-
-releaseorder_section
-	: releaseorder_header release_list T_SEMICOLON
-		{
-			cls->atts=somtaddModifierSL(cls->atts, "releaseorder", $<stval>2);
-		}
-	;
-
-releaseorder_header
-	: T_RELEASE T_ORDER T_COLON
-	;
-
-release_list
-	: release
-		{ 
-			$<stval>$=strdup($<stval>1);
-		}
-	| release_list T_COMMA release
-		{
-			char *r=somtsmallocSL(strlen($<stval>1)+strlen($<stval>3)+2, TRUE);
-			strcat(strcat(strcat(r, $<stval>1), ","), $<stval>3);
-			$<stval>$=strdup(r);
-			somtfree(r);
-		}
-	;
-
-release
-	: T_IDENTIFIER
-		{
-			cls->u.c.release=somtaddModifierSL(cls->u.c.release, $<stval>1, NULL);
-			$<stval>$=$<stval>1;
-		}
-	;
-
-metaclass_section
-	: metaclassdef
-        | metaclassdef description
-		{
-			mcls->comment=$<stval>2;
-		}
-	;
-
-metaclassdef
-	: metaclass_header metaclass_name T_SEMICOLON
-        | metaclass_header metaclass_name metaclass_attributes T_SEMICOLON
-        ;
-
-metaclass_header
-	: T_METACLASS T_COLON
-        ;
-
-metaclass_name
-	: T_IDENTIFIER
-	;
-
-metaclass_attributes
-	: T_COMMA metaclass_attribute
-	| metaclass_attributes T_COMMA metaclass_attribute 
-	;
-
-metaclass_attribute
-	: T_FILE T_STEM T_EQUAL T_IDENTIFIER
-        | T_MAJOR T_VERSION T_EQUAL T_CONSTANT
-        | T_MINOR T_VERSION T_EQUAL T_CONSTANT
-        | visibility
-        ;
-
-parent_section
-	: parentdef
-        | parentdef description
-		{
-			pcls->comment=$<stval>2;
-		}
-	;
-
-
-parentdef
-	: parent_header parent_name T_SEMICOLON
-        | parent_header parent_name parent_attributes T_SEMICOLON
-        ;
-
-parent_header
-	: T_PARENT T_CLASS T_COLON
-        | T_PARENT T_COLON 
-        ;
-
-parent_name
-	: T_IDENTIFIER
-		{
-			pcls->lineno=lineno;  // @todo line of class definition?
-			pcls->name=$<stval>1;
-		}
-	;
-
-parent_attributes
-	: T_COMMA parent_attribute
-	| parent_attributes T_COMMA parent_attribute
-	;
-
-parent_attribute
-	: T_FILE T_STEM T_EQUAL T_IDENTIFIER
-        | T_MAJOR T_VERSION T_EQUAL T_CONSTANT
-        | T_MINOR T_VERSION T_EQUAL T_CONSTANT
-        | visibility
-        ;
-
-passthru_section
-	: T_PASSTHRU
-        ;
-
-data_section
-	: data_header variables
-	;
-
-data_header
-	: T_DATA T_COLON
-	;
-
-variables
-	: declaration
-        | declaration variables
-        ;
-
-declaration
-	: declarationdef T_SEMICOLON
-	| declarationdef T_SEMICOLON description
-		{
-//			cls->comment=$<stval>2;
-		}
-	;
-
-declarationdef
-	: declaration_specifiers
-	| declaration_specifiers data_attributes
-	;
-
-data_attributes
-	: T_COMMA data_attribute
-	| data_attributes T_COMMA data_attribute
-	;
-
-data_attribute
-	: T_PRIVATE
-	| T_PUBLIC
-	| T_INTERNAL
-	| T_CLASS
-	;
-
-declaration_specifiers
-	: type_specifier declarator
-	| type_specifier declarator declaration_specifiers
-	;
-
-type_specifier
-	: T_IDENTIFIER 
-		{
-			$<stval>$=$<stval>1;
-		}
-	;
-
-declarator
-	: pointer direct_declarator
-	| direct_declarator
-	;
-
-direct_declarator
-	: T_IDENTIFIER {printf("$<stval>1");}
-	| T_LEFTPARENTHESIS declarator T_RIGHTPARENTHESIS
-	| direct_declarator T_LEFTSQUAREBRACKET T_CONSTANT T_RIGHTSQUAREBRACKET
-	| direct_declarator T_LEFTSQUAREBRACKET T_RIGHTSQUAREBRACKET
-	| direct_declarator T_LEFTPARENTHESIS declaration_specifiers T_RIGHTPARENTHESIS
-	| direct_declarator T_LEFTPARENTHESIS T_RIGHTPARENTHESIS
-	;
-
-pointer
-	: T_STAR
-		{
-			$<stval>$=$<stval>1;
-		}
-	| pointer T_STAR
-		{
-			char *r=somtsmallocSL(strlen($<stval>1)+strlen($<stval>2)+1, TRUE);
-			strcat(r, $<stval>1);
-			strcat(r, $<stval>2);
-			free($<stval>1);
-			$<stval>$=strdup(r);
-			somtfree(r);
-		}
-	;
-
-
-methods_section
-	: method_header method_list
-	| method_header description method_list
-		{
-			e.comment=$<stval>2;
-		}
-	;
-
-method_header
-	: T_METHODS T_COLON
-	;
-
-method_list
-	: method 
-		{
-			cls->u.c.methodcnt++;
-			somtaddEntrySL(somtstab, e.name, &e);
-			memset(&e, 0, sizeof(Entry));
-		}
-	| method_list method 
-		{
-			cls->u.c.methodcnt++;
-			somtaddEntrySL(somtstab, e.name, &e);
-			memset(&e, 0, sizeof(Entry));
-		}
-        ;
-
-method
-	: methoddef T_SEMICOLON 
-	| methoddef T_SEMICOLON description 
-	;
-
-methoddef
-	: method_specifier
-	| method_specifier method_attributes
-	| overridemethod_specifier
-	;
-
-method_specifier
-	: method_type method_name T_LEFTPARENTHESIS parameter_list T_RIGHTPARENTHESIS 
-		{
-			e.u.m.type=strdup($<stval>1);
-		}
-	;                                             
-
-method_name
-	: T_IDENTIFIER 
-		{
-			e.type=SOMTNewMethodE;
-			e.lineno=lineno;
-			e.name=$<stval>1;
-			e.sname=&somtclassName;
-			char * desc=somtsmallocSL(MAX_DESCRIPTOR_LENGTH, TRUE);
-			strcat(desc, "::");
-			strcat(desc, $<stval>1);
-			strcat(desc, "::");
-			strcat(desc, somtclassName);
-			e.atts=somtaddModifierSL(e.atts, "descriptor", desc);
-			somtfree(desc);
-		}
-	;
-
-method_type
-	: type_specifier
-		{
-			$<stval>$=$<stval>1;
-		}
-	| type_specifier pointer
-		{
-			char *r=somtsmallocSL(strlen($<stval>1)+strlen($<stval>2)+1, TRUE);
-			strcat(r, $<stval>1);
-			strcat(r, $<stval>2);
-			free($<stval>1);
-			$<stval>$=strdup(r);
-			somtfree(r);
-		}
-	;
-
-overridemethod_specifier
-	: overridemethod_header overridemethod_name
-	| overridemethod_header overridemethod_name overridemethod_attributes
-	;                                             
-
-overridemethod_header
-	: T_OVERRIDE
-	| T_OVERRIDE T_COLON
-	;
-
-overridemethod_name
-	: T_IDENTIFIER 
-		{
-			e.type=SOMTOverrideMethodE;
-			e.lineno=lineno;
-			e.name=$<stval>1;
-			e.sname=&somtclassName;
-			char * desc=somtsmallocSL(MAX_DESCRIPTOR_LENGTH, TRUE);
-			strcat(strcat(strcat(strcat(desc ,"::"), $<stval>1), "::"), somtclassName);
-			e.atts=somtaddModifierSL(e.atts, "descriptor", desc);
-			somtfree(desc);
-		}
-	;
-
-parameter_list
-	: parameter
-	| parameter_list T_COMMA parameter
-	;
-
-parameter
-	: T_ELLIPSIS
-	| type_specifier declarator
-	;
-
-method_attributes
-	: T_COMMA method_attribute
-	| method_attributes T_COMMA method_attribute
-	;
-
-method_attribute
-	: T_PRIVATE
-	| T_PUBLIC
-	| T_METHOD
-	| T_PROCEDURE
-	| T_CLASS
-	| T_OFFSET
-	| T_NAME T_LOOKUP
-	| T_LOCAL
-	| T_EXTERNAL
-	| T_USE T_EQUAL T_IDENTIFIER
-	;
-
-/* descriptor */
-/* noset */
-/* original */
-
-overridemethod_attributes
-	: T_COMMA overridemethod_attribute
-	| overridemethod_attributes T_COMMA overridemethod_attribute
-	;
-
-overridemethod_attribute
-	: T_PRIVATE
-	| T_PUBLIC
-	| T_CLASS
-	| T_LOCAL
-	| T_EXTERNAL
-	| T_USE T_EQUAL T_IDENTIFIER
-	;
-
-description
-	: T_COMMENT 
-		{
-			$<stval>$=$<stval>1;
-		}
-        ;
-
-%%
-
-FILE *yyin;
-
-// Experimental replacement of somttype
-char * mysomttype(SOMTTypes ttype)
-{
-  char * result=NULL;
-  switch ( ttype )
-  {
-    case SOMTAnyBE:
-      result="SOMTAnyBE";
-      break;
-    case     SOMTArgumentE:
-      result="SOMTArgumentE";
-      break;
-    case     SOMTAttE:
-      result="SOMTAttE";
-      break;
-    case     SOMTBadEntryE:
-      result="SOMTBadEntryE";
-      break;
-    case     SOMTBaseE:
-      result="SOMTBaseE";
-      break;
-    case     SOMTBooleanBE:
-      result="SOMTBooleanBE";
-      break;
-    case     SOMTCaseEntryE:
-      result="SOMTCaseEntryE";
-      break;
-    case     SOMTCaseListE:
-      result="SOMTCaseListE";
-      break;
-    case     SOMTCaseSTME:
-      result="SOMTCaseSTME";
-      break;
-    case     SOMTCharBE:
-      result="SOMTCharBE";
-      break;
-    case     SOMTClassE:
-      result="SOMTClassE";
-      break;
-    case     SOMTConstE:
-      result="SOMTConstE";
-      break;
-    case     SOMTCopyrightE:
-      result="SOMTCopyrightE";
-      break;
-    case     SOMTDataE:
-      result="SOMTDataE";
-      break;
-    case     SOMTDclListE:
-      result="SOMTDclListE";
-      break;
-    case     SOMTDefaultE:
-      result="SOMTDefaultE";
-      break;
-    case     SOMTDoubleBE:
-      result="SOMTDoubleBE";
-      break;
-    case     SOMTEBaseE:
-      result="SOMTEBaseE";
-      break;
-    case     SOMTEEnumE:
-      result="SOMTEEnumE";
-      break;
-    case     SOMTEnumBE:
-      result="SOMTEnumBE";
-      break;
-    case     SOMTEnumE:
-      result="SOMTEnumE";
-      break;
-    case     SOMTEnumPE:
-      result="SOMTEnumPE";
-      break;
-    case     SOMTFloatBE:
-      result="SOMTFloatBE";
-      break;
-    case     SOMTGroupE:
-      result="SOMTGroupE";
-      break;
-    case     SOMTLongBE:
-      result="SOMTLongBE";
-      break;
-    case     SOMTMetaE:
-      result="SOMTMetaE";
-      break;
-    case     SOMTModuleE:
-      result="SOMTModuleE";
-      break;
-    case     SOMTNegativeBE:
-      result="SOMTNegativeBE";
-      break;
-    case     SOMTNewMethodE:
-      result="SOMTNewMethodE";
-      break;
-    case     SOMTOctetBE:
-      result="SOMTOctetBE";
-      break;
-    case     SOMTOverriddenMethodE:
-      result="SOMTOverriddenMethodE";
-      break;
-    case     SOMTOverrideMethodE:
-      result="SOMTOverrideMethodE";
-      break;
-    case     SOMTPassthruE:
-      result="SOMTPassthruE";
-      break;
-    case     SOMTSequenceE:
-      result="SOMTSequenceE";
-      break;
-    case     SOMTSequenceTDE:
-      result="SOMTSequenceTDE";
-      break;
-    case     SOMTShortBE:
-      result="SOMTShortBE";
-      break;
-    case     SOMTStringBE:
-      result="SOMTStringBE";
-      break;
-    case     SOMTStringE:
-      result="SOMTStringE";
-      break;
-    case     SOMTStructE:
-      result="SOMTStructE";
-      break;
-    case     SOMTStructPE:
-      result="SOMTStructPE";
-      break;
-    case     SOMTStructSE:
-      result="SOMTStructSE";
-      break;
-    case     SOMTTyDclE:
-      result="SOMTTyDclE";
-      break;
-    case     SOMTTypeCodeBE:
-      result="SOMTTypeCodeBE";
-      break;
-    case     SOMTTypedefBE:
-      result="SOMTTypedefBE";
-      break;
-    case     SOMTTypedefE:
-      result="SOMTTypedefE";
-      break;
-    case     SOMTUnionE:
-      result="SOMTUnionE";
-      break;
-    case     SOMTUnionPE:
-      result="SOMTUnionPE";
-      break;
-    case     SOMTUnionSE:
-      result="SOMTUnionSE";
-      break;
-    case     SOMTUnsignedLongBE:
-      result="SOMTUnsignedLongBE";
-      break;
-    case     SOMTUnsignedShortBE:
-      result="SOMTUnsignedShortBE";
-      break;
-    case     SOMTVoidBE:
-      result="SOMTVoidBE";
-      break;
-    case     SOMTVoidPtrBE:
-      result="SOMTVoidPtrBE";
-      break;
-// This is special case SOMTTypes used on call of emitter start and emitter end
-/*    case     SOMTEmitterBeginE:
-      result="SOMTEmitterBeginE";
-      break;
-    case     SOMTEmitterEndE:
-      result="SOMTEmitterEndE";
-      break; */
-    default:
-      printf("Unknown entry type: %d.\n", ttype);
-  }
-  return result;
-}
-
-void dumpReleaseOrder(char * name, AttList *ap)
-{
-  AttList *cur=ap;
-
-  for(; cur; cur = cur->next) 
-  {
-    printf("\t%s %s\n", name, cur->name);
-//    dumpAttrs("static", cur->staticlist);
-//    dumpAttrs("protectted", cur->protectedlist);
-//    dumpAttrs("public", cur->publiclist);
-//    dumpAttrs("private", cur->privatelist);
-  }
-}
-
-void dumpMethodOrData(Entry * ep)
-{
-  printf("\teptype = %08p\n", ep->u.m.eptype);
-  printf("\tptrs = %08p\n", ep->u.m.ptrs);
-  printf("\tarray = %08p\n", ep->u.m.array);
-  printf("\tarrays = %s\n", ep->u.m.arrays);
-  printf("\tdefn = %s\n", ep->u.m.defn);
-  printf("\ttype = %s\n", ep->u.m.type);
-  printf("\tvarargs = %s\n", ep->u.m.varargs ? "true" : "false");
-  printf("\tprivate = %s\n", ep->u.m.isprivate ? "true" : "false");
-  printf("\tinout = %d\n", ep->u.m.inoutmode);
-  printf("\tselfref = %s\n", ep->u.m.isselfref ? "true" : "false");
-  printf("\toneway = %s\n", ep->u.m.isoneway ? "true" : "false");
-  printf("\targcnt = %d\n", ep->u.m.argcnt);
-  printf("\targs = %08p\n", ep->u.m.args);
-  printf("\tomethod = %08p\n", ep->u.m.omethod);
-  printf("\toparent = %08p\n", ep->u.m.oparent);
-  printf("\tgroup = %08p\n", ep->u.m.group);
-  printf("\tnext = %08p\n", ep->u.m.next);
-  printf("\tctxsa = %08p\n", ep->u.m.ctxsa);
-  printf("\traiseslist = %08p\n", ep->u.m.raiseslist);
-}
-
-void mysomtShowEntry(Entry * ep)
-{
-  if (ep)
-  {
-    printf("      somtShowEntry: Entry at %08p, name = %s, type = %d\n", ep, ep->name, ep->type);
-    printf("\tlineno = %d\n", ep->lineno);
-    switch ( ep->type )
-    {
-      case SOMTAnyBE:
-        printf("\t SOMTAnyBE\n");
-        break;
-      case     SOMTArgumentE:
-        printf("\t SOMTArgumentE\n");
-        dumpMethodOrData(ep);
-        break;
-      case     SOMTAttE:
-        printf("\t SOMTAttE\n");
-        break;
-      case     SOMTBadEntryE:
-        printf("\t SOMTBadEntryE\n");
-        break;
-      case     SOMTBaseE:
-        printf("\t SOMTBaseE\n");
-        printf("\tparentdef = %08p\n", ep->u.p.parentdef);
-        break;
-      case     SOMTBooleanBE:
-        printf("\t SOMTBooleanBE\n");
-        break;
-      case     SOMTCaseEntryE:
-        printf("\t SOMTCaseEntryE\n");
-        break;
-      case     SOMTCaseListE:
-        printf("\t SOMTCaseListE\n");
-        break;
-      case     SOMTCaseSTME:
-        printf("\t SOMTCaseSTME\n");
-        break;
-      case     SOMTCharBE:
-        printf("\t SOMTCharBE\n");
-        break;
-      case     SOMTClassE:
-        printf("\tClass Definition Entry:\n");
-        printf("\tfile = %s\n", ep->u.c.file);
-        printf("\tmeta = %08p\n", ep->u.c.meta);
-        printf("\tparent = %08p\n", ep->u.c.parent);
-        printf("\tparents = %08p\n", ep->u.c.parents);
-        printf("\trelease = %08p\n", ep->u.c.release);
-	dumpReleaseOrder("\t", ep->u.c.release);
-        printf("\tpassthru = %08p\n", ep->u.c.passthrus);
-        printf("\tdata = %08p\n", ep->u.c.data);
-        printf("\ttc = %08p\n", ep->tc);
-        printf("\tmethodcnt = %08d\n", ep->u.c.methodcnt);
-        printf("\tmethods = %08p\n", ep->u.c.methods);
-        printf("\tinherited = %08p\n", ep->u.c.inherited);
-        printf("\tpubdefs = %08p\n", ep->u.c.pubdefs);
-        printf("\tmod = %08p\n", ep->u.c.mod);
-        printf("\tcls = %08p\n", ep->u.c.cls);
-        printf("\tforward = %s\n", ep->u.c.isforward ? "true" : "false");
-        break;
-      case     SOMTConstE:
-        printf("\t SOMTConstE\n");
-        break;
-      case     SOMTCopyrightE:
-        printf("\t SOMTCopyrightE\n");
-        break;
-      case     SOMTDataE:
-        printf("\t SOMTDataE\n");
-        dumpMethodOrData(ep);
-        break;
-      case     SOMTDclListE:
-        printf("\t SOMTDclListE\n");
-        break;
-      case     SOMTDefaultE:
-        printf("\t SOMTDefaultE\n");
-        break;
-      case     SOMTDoubleBE:
-        printf("\t SOMTDoubleBE\n");
-        break;
-      case     SOMTEBaseE:
-        printf("\t SOMTEBaseE\n");
-        break;
-      case     SOMTEEnumE:
-        printf("\t SOMTEEnumE\n");
-        break;
-      case     SOMTEnumBE:
-        printf("\t SOMTEnumBE\n");
-        break;
-      case     SOMTEnumE:
-        printf("\t SOMTEnumE\n");
-        break;
-      case     SOMTEnumPE:
-        printf("\t SOMTEnumPE\n");
-        break;
-      case     SOMTFloatBE:
-        printf("\t SOMTFloatBE\n");
-        break;
-      case     SOMTGroupE:
-        printf("\t SOMTGroupE\n");
-        break;
-      case     SOMTLongBE:
-        printf("\t SOMTLongBE\n");
-        break;
-      case     SOMTMetaE:
-        printf("\t SOMTMetaE\n");
-        break;
-      case     SOMTModuleE:
-        printf("\t SOMTModuleE\n");
-        break;
-      case     SOMTNegativeBE:
-        printf("\t SOMTNegativeBE\n");
-        break;
-      case     SOMTNewMethodE:
-        printf("\t SOMTNewMethodE\n");
-        dumpMethodOrData(ep);
-        break;
-      case     SOMTOctetBE:
-        printf("\t SOMTOctetBE\n");
-        break;
-      case     SOMTOverriddenMethodE:
-        printf("\t SOMTOverriddenMethodE\n");
-        dumpMethodOrData(ep);
-        break;
-      case     SOMTOverrideMethodE:
-        printf("\t SOMTOverrideMethodE\n");
-        dumpMethodOrData(ep);
-        break;
-      case     SOMTPassthruE:
-        printf("\t SOMTPassthruE\n");
-        break;
-      case     SOMTSequenceE:
-        printf("\t SOMTSequenceE\n");
-        break;
-      case     SOMTSequenceTDE:
-        printf("\t SOMTSequenceTDE\n");
-        break;
-      case     SOMTShortBE:
-        printf("\t SOMTShortBE\n");
-        break;
-      case     SOMTStringBE:
-        printf("\t SOMTStringBE\n");
-        break;
-      case     SOMTStringE:
-        printf("\t SOMTStringE\n");
-        break;
-      case     SOMTStructE:
-        printf("\t SOMTStructE\n");
-        break;
-      case     SOMTStructPE:
-        printf("\t SOMTStructPE\n");
-        break;
-      case     SOMTStructSE:
-        printf("\t SOMTStructSE\n");
-        printf("\tdcllist = %08p\n", ep->u.struc.dcllist);
-        printf("\tcls = %08p\n", ep->u.struc.cls);
-        printf("\texception = %s\n", ep->u.struc.isexcept ? "true" : "false");
-        printf("\tmutref = %s\n", ep->u.struc.ismutref ? "true" : "false");
-        break;
-      case     SOMTTyDclE:
-        printf("\t SOMTTyDclE\n");
-        break;
-      case     SOMTTypeCodeBE:
-        printf("\t SOMTTypeCodeBE\n");
-        break;
-      case     SOMTTypedefBE:
-        printf("\t SOMTTypedefBE\n");
-        dumpMethodOrData(ep);
-        break;
-      case     SOMTTypedefE:
-        printf("\t SOMTTypedefE\n");
-        break;
-      case     SOMTUnionE:
-        printf("\t SOMTUnionE\n");
-        break;
-      case     SOMTUnionPE:
-        printf("\t SOMTUnionPE\n");
-        break;
-      case     SOMTUnionSE:
-        printf("\t SOMTUnionSE\n");
-        break;
-      case     SOMTUnsignedLongBE:
-        printf("\t SOMTUnsignedLongBE\n");
-        break;
-      case     SOMTUnsignedShortBE:
-        printf("\t SOMTUnsignedShortBE\n");
-        break;
-      case     SOMTVoidBE:
-        printf("\t SOMTVoidBE\n");
-        break;
-      case     SOMTVoidPtrBE:
-        printf("\t SOMTVoidPtrBE\n");
-        dumpMethodOrData(ep);
-        break;
-  // This is special case SOMTTypes used on call of emitter start and emitter end
-  /*    case     SOMTEmitterBeginE:
-        result="SOMTEmitterBeginE";
-        break;
-      case     SOMTEmitterEndE:
-        result="SOMTEmitterEndE";
-        break; */
-      default:
-        printf("Error: somtShowEntry, bad entry type of %d", ep->type);
-//        SOM_Error(SOM_Fatal, __FILE__, __LINE__);
-//        SOMError(9, __FILE__, __LINE__);
-    }
-  }
-  else 
-  {
-    printf("somtShowEntry: NULL entry\n");
-  }
-}
-
-dumpAttrs(AttList *ap)
-{
-  struct AttList *cur = ap;
-
-  for(cur = ap; cur; cur = cur->next) 
-  {
-    printf("\tModifier %s=%s\n", cur->name, cur->value);
-  }
-}
-
-
-void mydumpEntry(Entry * ep)
-{
-  printf("Entry at address %p\n", ep);
-  printf("--------------------------\n");
-  printf("Entry type: %s (%d)\n", mysomttype(ep->type), ep->type);
-//  printf("Entry type: %s (%d)\n", somtEntryTypeName(ep->type), ep->type);
-  if (ep->sname) printf("Scoped name: %s\n", *ep->sname);
-  if (ep->comment) printf("Comment associated with entry: %s\n", ep->comment);
-  printf("Modifiers: %p\n", ep->atts);
-  if (ep->atts) dumpAttrs(ep->atts);
-  printf("TypeCode: %p\n", ep->tc);
-  printf("Points to the object: %p\n", ep->objref);
-  printf("Reference to real type: %s\n", ep->isref ? "true" : "false");
-  printf("Entry union: %p\n", &ep->u);
-#ifdef __PRIVATE__
-//    RHBelement *data;
-//    char *filestem;
-#endif    
-  mysomtShowEntry(ep);
-//  somtShowEntry(ep);
-};
-
-void dumpSep(Sep * sep)
-{
-    printf("Linked list item at address %p\n", sep);
-    printf("---------------------------------------\n");
-    printf("Position number: %d\n", sep->posn);
-    printf("Address of Entry: %p\n", sep->ep);
-    printf("Next linked list item address: %p\n", sep->next);
-    if (sep->ep) 
-    {
-      mydumpEntry((Entry *)sep->ep);
-      dumpSep(sep->next);
-    }
-}
-
-void dumpStab(Stab * stab)
-{
-  printf("Basic Symbol Table/Hash table (STab) structure\n");
-  printf("----------------------------------------------\n");
-  printf("Size of buscet: %d\n", stab->size);
-  printf("Size of entry structure: %d\n", stab->entrysize);
-  printf("Number of elements: %d\n", stab->nelms);
-  printf("Address of base slot: %p\n", stab->base);
-  printf("Max address of slot: %p\n", stab->limit);
-  printf("Start address of slot buffer: %p\n", stab->buf);
-  printf("Address of MemBuf: %p\n", stab->membuf);
-  printf("Ignore case flag: %s\n", stab->ignorecase ? "true" : "false");
-  for(unsigned int i=0; i<stab->size;i++)
-  {
-    printf("Linked list at slot %d at offset %08x at address %p\n", i, sizeof(Sep)*i, stab->buf+i);
-    printf("----------------------\n");
-    dumpSep(stab->buf+i);
-  }
-};
-
-
-void usage(void)
-{
-  printf("\nSC [-options] file[.CSC]\n");
-  printf("\n-C n\n\tset the size of the comment buffer (default: 16384)\n");
-  printf("\n-s n\n\tset the total amount of string space for names and passthru lines (default: 32768)\n");
-  printf("\n-V\n\tdisplay version information\n");
-  printf("\n-a name[=value]\n\tadd a global attribute. The currently supported attributes are defined below (at the end of this section)\n");
-  printf("\n-d directory\n\tspecify a directory where all files emitted during the execution of this command should be placed. If the -d option is not used, all emitted output files are placed in the same directory as the input .csc file\n");
-  printf("\n-h or ?\n\tprovide usage information for reference\n");
-  printf("\n-i filename\n\tspecify the name of the OIDL class definition file. Use this option to override the built-in assumption that the input file will have a .csc extension. Any filename you supply with the -i option is used exactly as you provide it\n");
-  printf("\n-r\n\tcheck that all release-order entries actually exist (default: FALSE)\n");
-  printf("\n-s string\n\tsubstitute string in place of the contents of the SMEMIT environment variable for the duration of the current SC command. If you supply a list of values, you\n");
-  printf("must enclose the list with double quotation marks (\" \"). You can use the -s option as a convenient way to override the SMEMIT environment variable. For example:\n\n");
-  printf("SC -s \"h;sc\" EXAMPLE\n\n");
-  printf("is equivalent to the following sequence of commands:\n\n");
-  printf("SET OLDSMEMIT = %%SMEMIT%%\n");
-  printf("SET SMEMIT = h;sc\n");
-  printf("SC EXAMPLE\n");
-  printf("SET SMEMIT = %%OLDSMEMIT%%\n");
-  printf("\n-w\n\tsuppress warning messages (default: FALSE)\n\n");
-  printf("The only global attributes currently supported by SC.EXE are:\n");
-  printf("\ncomment = comment string\n\twhere comment string can be one of the following: \"/*\", \"--\", or \"//\". This\n");
-  printf("indicates that comments marked in the indicated way are to be completely\n");
-  printf("ignored by SC.EXE and not retained for subsequent processing by one of the\n");
-  printf("emitters.\n");
-  printf("Note: Comments indicated by lines whose first non-white-space character is\n");
-  printf("a # are always ignored by SC.EXE. Also note that comments of any\n");
-  printf("form in passthru lines are passed through.\n");
-  printf("\ncstyle = comment style\n\tcontrols the form of emitted comments. Comment style must be one of s, c, or\n");
-  printf("+ to cause emitted comments to be in \"--\", \"/* */\", or \"//\" form , respectively\n");
-  printf("The default form is s\n");
-  printf("\nibmc\n\tcauses EMITC, EMITH, EMITIH, EMITPH, and EMITDEF to generate code with\n");
-  printf("pragmas specifically intended for the IBM C Set/2 Compiler. This attribute is\n");
-  printf("specified by default\n");
-  printf("\ncl386\n\tcauses EMITC, EMITH, EMITIH, EMITPH, and EMITDEF not to generate code\n");
-  printf("with pragmas specifically intended for the IBM C Set/2 Compiler\n");
-}
-
-void parse_file(char * file)
-{
-  // parser input stream
-  yyin=fopen(file,"r");
-
-  strcpy(somtfilePath, file);
-
-  // Initialize symbol table
-  somtstab=(Stab *)somtsmallocSL(sizeof(Stab), 0);
-  somtcreateStabSL(somtstab, HASH_SIZE, sizeof(Entry));
-
-  yyparse();
-
-  dumpStab(somtstab);
-}
-
-void emit_file(char * file)
-{
-   EmitFn proc;
-   FILE * fp;
-   HMODULE hmod;
-   Entry * root;
-   Stab * stab;
-
-   proc=somtloadSL("emitpsc.dll", "emitSL", &hmod);
-
-   fp=proc(file, root, stab);
-
-   if (fp) somtfcloseSL(fp);
-}
-
-void main(int argc, char *argv[])
-{
-   yydebug =1 ;
-
-//   parse_args(argc, argv);
-
-   usage();
-
-   parse_file(argv[1]);
-
-//   dump();
-
-//   emit_file(argv[1]);
-}
diff -urN somfree/somopc/src/gramma.yy.output newsomfree/somopc/src/gramma.yy.output
--- somfree/somopc/src/gramma.yy.output	Sat Jun 29 21:47:30 2024
+++ newsomfree/somopc/src/gramma.yy.output	Thu Jan 01 07:00:00 1970
@@ -1,2606 +0,0 @@
-
-
-Terminals which are not used:
-
-   T_DASHES
-   T_PERIOD
-   T_BEFORE
-   T_AFTER
-   T_ENDPASSTHRU
-   T_GROUP
-
-
-
-Grammar
-rule 1    @1 ->		/* empty */
-rule 2    oidl -> @1 class_list
-rule 3    class_list -> class_definition
-rule 4    class_list -> class_list class_definition
-rule 5    @2 ->		/* empty */
-rule 6    class_definition -> @2 class_section section_list
-rule 7    section_list -> section
-rule 8    section_list -> section_list section
-rule 9    section -> releaseorder_section
-rule 10   section -> metaclass_section
-rule 11   @3 ->		/* empty */
-rule 12   section -> @3 parent_section
-rule 13   section -> passthru_section
-rule 14   section -> data_section
-rule 15   section -> methods_section
-rule 16   class_section -> classdef
-rule 17   class_section -> classdef description
-rule 18   classdef -> class_header class_name T_SEMICOLON
-rule 19   classdef -> class_header class_name class_attributes T_SEMICOLON
-rule 20   class_header -> T_CLASS T_COLON
-rule 21   class_name -> T_IDENTIFIER
-rule 22   class_attributes -> T_COMMA class_attribute
-rule 23   class_attributes -> class_attributes T_COMMA class_attribute
-rule 24   class_attribute -> T_FILE T_STEM T_EQUAL T_IDENTIFIER
-rule 25   class_attribute -> T_EXTERNAL T_STEM T_EQUAL T_IDENTIFIER
-rule 26   class_attribute -> T_FUNCTION T_PREFIX T_EQUAL T_IDENTIFIER
-rule 27   class_attribute -> T_EXTERNAL T_PREFIX T_EQUAL T_IDENTIFIER
-rule 28   class_attribute -> T_CLASSPREFIX T_EQUAL T_IDENTIFIER
-rule 29   class_attribute -> T_MAJOR T_VERSION T_EQUAL T_CONSTANT
-rule 30   class_attribute -> T_MINOR T_VERSION T_EQUAL T_CONSTANT
-rule 31   class_attribute -> T_CLASSINIT T_EQUAL T_IDENTIFIER
-rule 32   class_attribute -> visibility
-rule 33   visibility -> T_GLOBAL
-rule 34   visibility -> T_LOCAL
-rule 35   releaseorder_section -> releaseorder_header release_list T_SEMICOLON
-rule 36   releaseorder_header -> T_RELEASE T_ORDER T_COLON
-rule 37   release_list -> release
-rule 38   release_list -> release_list T_COMMA release
-rule 39   release -> T_IDENTIFIER
-rule 40   metaclass_section -> metaclassdef
-rule 41   metaclass_section -> metaclassdef description
-rule 42   metaclassdef -> metaclass_header metaclass_name T_SEMICOLON
-rule 43   metaclassdef -> metaclass_header metaclass_name metaclass_attributes T_SEMICOLON
-rule 44   metaclass_header -> T_METACLASS T_COLON
-rule 45   metaclass_name -> T_IDENTIFIER
-rule 46   metaclass_attributes -> T_COMMA metaclass_attribute
-rule 47   metaclass_attributes -> metaclass_attributes T_COMMA metaclass_attribute
-rule 48   metaclass_attribute -> T_FILE T_STEM T_EQUAL T_IDENTIFIER
-rule 49   metaclass_attribute -> T_MAJOR T_VERSION T_EQUAL T_CONSTANT
-rule 50   metaclass_attribute -> T_MINOR T_VERSION T_EQUAL T_CONSTANT
-rule 51   metaclass_attribute -> visibility
-rule 52   parent_section -> parentdef
-rule 53   parent_section -> parentdef description
-rule 54   parentdef -> parent_header parent_name T_SEMICOLON
-rule 55   parentdef -> parent_header parent_name parent_attributes T_SEMICOLON
-rule 56   parent_header -> T_PARENT T_CLASS T_COLON
-rule 57   parent_header -> T_PARENT T_COLON
-rule 58   parent_name -> T_IDENTIFIER
-rule 59   parent_attributes -> T_COMMA parent_attribute
-rule 60   parent_attributes -> parent_attributes T_COMMA parent_attribute
-rule 61   parent_attribute -> T_FILE T_STEM T_EQUAL T_IDENTIFIER
-rule 62   parent_attribute -> T_MAJOR T_VERSION T_EQUAL T_CONSTANT
-rule 63   parent_attribute -> T_MINOR T_VERSION T_EQUAL T_CONSTANT
-rule 64   parent_attribute -> visibility
-rule 65   passthru_section -> T_PASSTHRU
-rule 66   data_section -> data_header variables
-rule 67   data_header -> T_DATA T_COLON
-rule 68   variables -> declaration
-rule 69   variables -> declaration variables
-rule 70   declaration -> declarationdef T_SEMICOLON
-rule 71   declaration -> declarationdef T_SEMICOLON description
-rule 72   declarationdef -> declaration_specifiers
-rule 73   declarationdef -> declaration_specifiers data_attributes
-rule 74   data_attributes -> T_COMMA data_attribute
-rule 75   data_attributes -> data_attributes T_COMMA data_attribute
-rule 76   data_attribute -> T_PRIVATE
-rule 77   data_attribute -> T_PUBLIC
-rule 78   data_attribute -> T_INTERNAL
-rule 79   data_attribute -> T_CLASS
-rule 80   declaration_specifiers -> type_specifier declarator
-rule 81   declaration_specifiers -> type_specifier declarator declaration_specifiers
-rule 82   type_specifier -> T_IDENTIFIER
-rule 83   declarator -> pointer direct_declarator
-rule 84   declarator -> direct_declarator
-rule 85   direct_declarator -> T_IDENTIFIER
-rule 86   direct_declarator -> T_LEFTPARENTHESIS declarator T_RIGHTPARENTHESIS
-rule 87   direct_declarator -> direct_declarator T_LEFTSQUAREBRACKET T_CONSTANT T_RIGHTSQUAREBRACKET
-rule 88   direct_declarator -> direct_declarator T_LEFTSQUAREBRACKET T_RIGHTSQUAREBRACKET
-rule 89   direct_declarator -> direct_declarator T_LEFTPARENTHESIS declaration_specifiers T_RIGHTPARENTHESIS
-rule 90   direct_declarator -> direct_declarator T_LEFTPARENTHESIS T_RIGHTPARENTHESIS
-rule 91   pointer -> T_STAR
-rule 92   pointer -> pointer T_STAR
-rule 93   methods_section -> method_header method_list
-rule 94   methods_section -> method_header description method_list
-rule 95   method_header -> T_METHODS T_COLON
-rule 96   method_list -> method
-rule 97   method_list -> method_list method
-rule 98   method -> methoddef T_SEMICOLON
-rule 99   method -> methoddef T_SEMICOLON description
-rule 100  methoddef -> method_specifier
-rule 101  methoddef -> method_specifier method_attributes
-rule 102  methoddef -> overridemethod_specifier
-rule 103  method_specifier -> method_type method_name T_LEFTPARENTHESIS parameter_list T_RIGHTPARENTHESIS
-rule 104  method_name -> T_IDENTIFIER
-rule 105  method_type -> type_specifier
-rule 106  method_type -> type_specifier pointer
-rule 107  overridemethod_specifier -> overridemethod_header overridemethod_name
-rule 108  overridemethod_specifier -> overridemethod_header overridemethod_name overridemethod_attributes
-rule 109  overridemethod_header -> T_OVERRIDE
-rule 110  overridemethod_header -> T_OVERRIDE T_COLON
-rule 111  overridemethod_name -> T_IDENTIFIER
-rule 112  parameter_list -> parameter
-rule 113  parameter_list -> parameter_list T_COMMA parameter
-rule 114  parameter -> T_ELLIPSIS
-rule 115  parameter -> type_specifier declarator
-rule 116  method_attributes -> T_COMMA method_attribute
-rule 117  method_attributes -> method_attributes T_COMMA method_attribute
-rule 118  method_attribute -> T_PRIVATE
-rule 119  method_attribute -> T_PUBLIC
-rule 120  method_attribute -> T_METHOD
-rule 121  method_attribute -> T_PROCEDURE
-rule 122  method_attribute -> T_CLASS
-rule 123  method_attribute -> T_OFFSET
-rule 124  method_attribute -> T_NAME T_LOOKUP
-rule 125  method_attribute -> T_LOCAL
-rule 126  method_attribute -> T_EXTERNAL
-rule 127  method_attribute -> T_USE T_EQUAL T_IDENTIFIER
-rule 128  overridemethod_attributes -> T_COMMA overridemethod_attribute
-rule 129  overridemethod_attributes -> overridemethod_attributes T_COMMA overridemethod_attribute
-rule 130  overridemethod_attribute -> T_PRIVATE
-rule 131  overridemethod_attribute -> T_PUBLIC
-rule 132  overridemethod_attribute -> T_CLASS
-rule 133  overridemethod_attribute -> T_LOCAL
-rule 134  overridemethod_attribute -> T_EXTERNAL
-rule 135  overridemethod_attribute -> T_USE T_EQUAL T_IDENTIFIER
-rule 136  description -> T_COMMENT
-
-Terminals, with rules where they appear
-
-$ (-1)
-error (256)
-T_CONSTANT (257) 29 30 49 50 62 63 87
-T_COLON (258) 20 36 44 56 57 67 95 110
-T_SEMICOLON (259) 18 19 35 42 43 54 55 70 71 98 99
-T_COMMA (260) 22 23 38 46 47 59 60 74 75 113 116 117 128 129
-T_STAR (261) 91 92
-T_COMMENT (262) 136
-T_IDENTIFIER (263) 21 24 25 26 27 28 31 39 45 48 58 61 82 85 104 111
-    127 135
-T_EQUAL (264) 24 25 26 27 28 29 30 31 48 49 50 61 62 63 127 135
-T_DASHES (265)
-T_PERIOD (266)
-T_ELLIPSIS (267) 114
-T_LEFTPARENTHESIS (268) 86 89 90 103
-T_RIGHTPARENTHESIS (269) 86 89 90 103
-T_LEFTSQUAREBRACKET (270) 87 88
-T_RIGHTSQUAREBRACKET (271) 87 88
-T_VERSION (272) 29 30 49 50 62 63
-T_GLOBAL (273) 33
-T_LOCAL (274) 34 125 133
-T_CLASSINIT (275) 31
-T_RELEASE (276) 36
-T_ORDER (277) 36
-T_METACLASS (278) 44
-T_PARENT (279) 56 57
-T_CLASS (280) 20 56 79 122 132
-T_FILE (281) 24 48 61
-T_STEM (282) 24 25 48 61
-T_FUNCTION (283) 26
-T_PREFIX (284) 26 27
-T_CLASSPREFIX (285) 28
-T_MAJOR (286) 29 49 62
-T_MINOR (287) 30 50 63
-T_PASSTHRU (288) 65
-T_BEFORE (289)
-T_AFTER (290)
-T_ENDPASSTHRU (291)
-T_DATA (292) 67
-T_PRIVATE (293) 76 118 130
-T_PUBLIC (294) 77 119 131
-T_INTERNAL (295) 78
-T_METHODS (296) 95
-T_GROUP (297)
-T_METHOD (298) 120
-T_PROCEDURE (299) 121
-T_OFFSET (300) 123
-T_NAME (301) 124
-T_LOOKUP (302) 124
-T_EXTERNAL (303) 25 27 126 134
-T_USE (304) 127 135
-T_OVERRIDE (305) 109 110
-
-Nonterminals, with rules where they appear
-
-oidl (52)
-    on left: 2
-@1 (53)
-    on left: 1, on right: 2
-class_list (54)
-    on left: 3 4, on right: 2 4
-class_definition (55)
-    on left: 6, on right: 3 4
-@2 (56)
-    on left: 5, on right: 6
-section_list (57)
-    on left: 7 8, on right: 6 8
-section (58)
-    on left: 9 10 12 13 14 15, on right: 7 8
-@3 (59)
-    on left: 11, on right: 12
-class_section (60)
-    on left: 16 17, on right: 6
-classdef (61)
-    on left: 18 19, on right: 16 17
-class_header (62)
-    on left: 20, on right: 18 19
-class_name (63)
-    on left: 21, on right: 18 19
-class_attributes (64)
-    on left: 22 23, on right: 19 23
-class_attribute (65)
-    on left: 24 25 26 27 28 29 30 31 32, on right: 22 23
-visibility (66)
-    on left: 33 34, on right: 32 51 64
-releaseorder_section (67)
-    on left: 35, on right: 9
-releaseorder_header (68)
-    on left: 36, on right: 35
-release_list (69)
-    on left: 37 38, on right: 35 38
-release (70)
-    on left: 39, on right: 37 38
-metaclass_section (71)
-    on left: 40 41, on right: 10
-metaclassdef (72)
-    on left: 42 43, on right: 40 41
-metaclass_header (73)
-    on left: 44, on right: 42 43
-metaclass_name (74)
-    on left: 45, on right: 42 43
-metaclass_attributes (75)
-    on left: 46 47, on right: 43 47
-metaclass_attribute (76)
-    on left: 48 49 50 51, on right: 46 47
-parent_section (77)
-    on left: 52 53, on right: 12
-parentdef (78)
-    on left: 54 55, on right: 52 53
-parent_header (79)
-    on left: 56 57, on right: 54 55
-parent_name (80)
-    on left: 58, on right: 54 55
-parent_attributes (81)
-    on left: 59 60, on right: 55 60
-parent_attribute (82)
-    on left: 61 62 63 64, on right: 59 60
-passthru_section (83)
-    on left: 65, on right: 13
-data_section (84)
-    on left: 66, on right: 14
-data_header (85)
-    on left: 67, on right: 66
-variables (86)
-    on left: 68 69, on right: 66 69
-declaration (87)
-    on left: 70 71, on right: 68 69
-declarationdef (88)
-    on left: 72 73, on right: 70 71
-data_attributes (89)
-    on left: 74 75, on right: 73 75
-data_attribute (90)
-    on left: 76 77 78 79, on right: 74 75
-declaration_specifiers (91)
-    on left: 80 81, on right: 72 73 81 89
-type_specifier (92)
-    on left: 82, on right: 80 81 105 106 115
-declarator (93)
-    on left: 83 84, on right: 80 81 86 115
-direct_declarator (94)
-    on left: 85 86 87 88 89 90, on right: 83 84 87 88 89 90
-pointer (95)
-    on left: 91 92, on right: 83 92 106
-methods_section (96)
-    on left: 93 94, on right: 15
-method_header (97)
-    on left: 95, on right: 93 94
-method_list (98)
-    on left: 96 97, on right: 93 94 97
-method (99)
-    on left: 98 99, on right: 96 97
-methoddef (100)
-    on left: 100 101 102, on right: 98 99
-method_specifier (101)
-    on left: 103, on right: 100 101
-method_name (102)
-    on left: 104, on right: 103
-method_type (103)
-    on left: 105 106, on right: 103
-overridemethod_specifier (104)
-    on left: 107 108, on right: 102
-overridemethod_header (105)
-    on left: 109 110, on right: 107 108
-overridemethod_name (106)
-    on left: 111, on right: 107 108
-parameter_list (107)
-    on left: 112 113, on right: 103 113
-parameter (108)
-    on left: 114 115, on right: 112 113
-method_attributes (109)
-    on left: 116 117, on right: 101 117
-method_attribute (110)
-    on left: 118 119 120 121 122 123 124 125 126 127,
-    on right: 116 117
-overridemethod_attributes (111)
-    on left: 128 129, on right: 108 129
-overridemethod_attribute (112)
-    on left: 130 131 132 133 134 135, on right: 128 129
-description (113)
-    on left: 136, on right: 17 41 53 71 94 99
-
-
-state 0
-
-    $default	reduce using rule 1 (@1)
-
-    oidl	go to state 234
-    @1  	go to state 1
-
-
-
-state 1
-
-    oidl  ->  @1 . class_list   (rule 2)
-
-    $default	reduce using rule 5 (@2)
-
-    class_list	go to state 2
-    class_definition	go to state 3
-    @2  	go to state 4
-
-
-
-state 2
-
-    oidl  ->  @1 class_list .   (rule 2)
-    class_list  ->  class_list . class_definition   (rule 4)
-
-    T_CLASS	reduce using rule 5 (@2)
-    $default	reduce using rule 2 (oidl)
-
-    class_definition	go to state 5
-    @2  	go to state 4
-
-
-
-state 3
-
-    class_list  ->  class_definition .   (rule 3)
-
-    $default	reduce using rule 3 (class_list)
-
-
-
-state 4
-
-    class_definition  ->  @2 . class_section section_list   (rule 6)
-
-    T_CLASS	shift, and go to state 6
-
-    class_section	go to state 7
-    classdef	go to state 8
-    class_header	go to state 9
-
-
-
-state 5
-
-    class_list  ->  class_list class_definition .   (rule 4)
-
-    $default	reduce using rule 4 (class_list)
-
-
-
-state 6
-
-    class_header  ->  T_CLASS . T_COLON   (rule 20)
-
-    T_COLON	shift, and go to state 10
-
-
-
-state 7
-
-    class_definition  ->  @2 class_section . section_list   (rule 6)
-
-    T_RELEASE	shift, and go to state 11
-    T_METACLASS	shift, and go to state 12
-    T_PASSTHRU	shift, and go to state 13
-    T_DATA	shift, and go to state 14
-    T_METHODS	shift, and go to state 15
-
-    $default	reduce using rule 11 (@3)
-
-    section_list	go to state 16
-    section	go to state 17
-    @3  	go to state 18
-    releaseorder_section	go to state 19
-    releaseorder_header	go to state 20
-    metaclass_section	go to state 21
-    metaclassdef	go to state 22
-    metaclass_header	go to state 23
-    passthru_section	go to state 24
-    data_section	go to state 25
-    data_header	go to state 26
-    methods_section	go to state 27
-    method_header	go to state 28
-
-
-
-state 8
-
-    class_section  ->  classdef .   (rule 16)
-    class_section  ->  classdef . description   (rule 17)
-
-    T_COMMENT	shift, and go to state 29
-
-    $default	reduce using rule 16 (class_section)
-
-    description	go to state 30
-
-
-
-state 9
-
-    classdef  ->  class_header . class_name T_SEMICOLON   (rule 18)
-    classdef  ->  class_header . class_name class_attributes T_SEMICOLON   (rule 19)
-
-    T_IDENTIFIER	shift, and go to state 31
-
-    class_name	go to state 32
-
-
-
-state 10
-
-    class_header  ->  T_CLASS T_COLON .   (rule 20)
-
-    $default	reduce using rule 20 (class_header)
-
-
-
-state 11
-
-    releaseorder_header  ->  T_RELEASE . T_ORDER T_COLON   (rule 36)
-
-    T_ORDER	shift, and go to state 33
-
-
-
-state 12
-
-    metaclass_header  ->  T_METACLASS . T_COLON   (rule 44)
-
-    T_COLON	shift, and go to state 34
-
-
-
-state 13
-
-    passthru_section  ->  T_PASSTHRU .   (rule 65)
-
-    $default	reduce using rule 65 (passthru_section)
-
-
-
-state 14
-
-    data_header  ->  T_DATA . T_COLON   (rule 67)
-
-    T_COLON	shift, and go to state 35
-
-
-
-state 15
-
-    method_header  ->  T_METHODS . T_COLON   (rule 95)
-
-    T_COLON	shift, and go to state 36
-
-
-
-state 16
-
-    class_definition  ->  @2 class_section section_list .   (rule 6)
-    section_list  ->  section_list . section   (rule 8)
-
-    T_RELEASE	shift, and go to state 11
-    T_METACLASS	shift, and go to state 12
-    T_PASSTHRU	shift, and go to state 13
-    T_DATA	shift, and go to state 14
-    T_METHODS	shift, and go to state 15
-
-    T_PARENT	reduce using rule 11 (@3)
-    $default	reduce using rule 6 (class_definition)
-
-    section	go to state 37
-    @3  	go to state 18
-    releaseorder_section	go to state 19
-    releaseorder_header	go to state 20
-    metaclass_section	go to state 21
-    metaclassdef	go to state 22
-    metaclass_header	go to state 23
-    passthru_section	go to state 24
-    data_section	go to state 25
-    data_header	go to state 26
-    methods_section	go to state 27
-    method_header	go to state 28
-
-
-
-state 17
-
-    section_list  ->  section .   (rule 7)
-
-    $default	reduce using rule 7 (section_list)
-
-
-
-state 18
-
-    section  ->  @3 . parent_section   (rule 12)
-
-    T_PARENT	shift, and go to state 38
-
-    parent_section	go to state 39
-    parentdef	go to state 40
-    parent_header	go to state 41
-
-
-
-state 19
-
-    section  ->  releaseorder_section .   (rule 9)
-
-    $default	reduce using rule 9 (section)
-
-
-
-state 20
-
-    releaseorder_section  ->  releaseorder_header . release_list T_SEMICOLON   (rule 35)
-
-    T_IDENTIFIER	shift, and go to state 42
-
-    release_list	go to state 43
-    release	go to state 44
-
-
-
-state 21
-
-    section  ->  metaclass_section .   (rule 10)
-
-    $default	reduce using rule 10 (section)
-
-
-
-state 22
-
-    metaclass_section  ->  metaclassdef .   (rule 40)
-    metaclass_section  ->  metaclassdef . description   (rule 41)
-
-    T_COMMENT	shift, and go to state 29
-
-    $default	reduce using rule 40 (metaclass_section)
-
-    description	go to state 45
-
-
-
-state 23
-
-    metaclassdef  ->  metaclass_header . metaclass_name T_SEMICOLON   (rule 42)
-    metaclassdef  ->  metaclass_header . metaclass_name metaclass_attributes T_SEMICOLON   (rule 43)
-
-    T_IDENTIFIER	shift, and go to state 46
-
-    metaclass_name	go to state 47
-
-
-
-state 24
-
-    section  ->  passthru_section .   (rule 13)
-
-    $default	reduce using rule 13 (section)
-
-
-
-state 25
-
-    section  ->  data_section .   (rule 14)
-
-    $default	reduce using rule 14 (section)
-
-
-
-state 26
-
-    data_section  ->  data_header . variables   (rule 66)
-
-    T_IDENTIFIER	shift, and go to state 48
-
-    variables	go to state 49
-    declaration	go to state 50
-    declarationdef	go to state 51
-    declaration_specifiers	go to state 52
-    type_specifier	go to state 53
-
-
-
-state 27
-
-    section  ->  methods_section .   (rule 15)
-
-    $default	reduce using rule 15 (section)
-
-
-
-state 28
-
-    methods_section  ->  method_header . method_list   (rule 93)
-    methods_section  ->  method_header . description method_list   (rule 94)
-
-    T_COMMENT	shift, and go to state 29
-    T_IDENTIFIER	shift, and go to state 48
-    T_OVERRIDE	shift, and go to state 54
-
-    type_specifier	go to state 55
-    method_list	go to state 56
-    method	go to state 57
-    methoddef	go to state 58
-    method_specifier	go to state 59
-    method_type	go to state 60
-    overridemethod_specifier	go to state 61
-    overridemethod_header	go to state 62
-    description	go to state 63
-
-
-
-state 29
-
-    description  ->  T_COMMENT .   (rule 136)
-
-    $default	reduce using rule 136 (description)
-
-
-
-state 30
-
-    class_section  ->  classdef description .   (rule 17)
-
-    $default	reduce using rule 17 (class_section)
-
-
-
-state 31
-
-    class_name  ->  T_IDENTIFIER .   (rule 21)
-
-    $default	reduce using rule 21 (class_name)
-
-
-
-state 32
-
-    classdef  ->  class_header class_name . T_SEMICOLON   (rule 18)
-    classdef  ->  class_header class_name . class_attributes T_SEMICOLON   (rule 19)
-
-    T_SEMICOLON	shift, and go to state 64
-    T_COMMA	shift, and go to state 65
-
-    class_attributes	go to state 66
-
-
-
-state 33
-
-    releaseorder_header  ->  T_RELEASE T_ORDER . T_COLON   (rule 36)
-
-    T_COLON	shift, and go to state 67
-
-
-
-state 34
-
-    metaclass_header  ->  T_METACLASS T_COLON .   (rule 44)
-
-    $default	reduce using rule 44 (metaclass_header)
-
-
-
-state 35
-
-    data_header  ->  T_DATA T_COLON .   (rule 67)
-
-    $default	reduce using rule 67 (data_header)
-
-
-
-state 36
-
-    method_header  ->  T_METHODS T_COLON .   (rule 95)
-
-    $default	reduce using rule 95 (method_header)
-
-
-
-state 37
-
-    section_list  ->  section_list section .   (rule 8)
-
-    $default	reduce using rule 8 (section_list)
-
-
-
-state 38
-
-    parent_header  ->  T_PARENT . T_CLASS T_COLON   (rule 56)
-    parent_header  ->  T_PARENT . T_COLON   (rule 57)
-
-    T_COLON	shift, and go to state 68
-    T_CLASS	shift, and go to state 69
-
-
-
-state 39
-
-    section  ->  @3 parent_section .   (rule 12)
-
-    $default	reduce using rule 12 (section)
-
-
-
-state 40
-
-    parent_section  ->  parentdef .   (rule 52)
-    parent_section  ->  parentdef . description   (rule 53)
-
-    T_COMMENT	shift, and go to state 29
-
-    $default	reduce using rule 52 (parent_section)
-
-    description	go to state 70
-
-
-
-state 41
-
-    parentdef  ->  parent_header . parent_name T_SEMICOLON   (rule 54)
-    parentdef  ->  parent_header . parent_name parent_attributes T_SEMICOLON   (rule 55)
-
-    T_IDENTIFIER	shift, and go to state 71
-
-    parent_name	go to state 72
-
-
-
-state 42
-
-    release  ->  T_IDENTIFIER .   (rule 39)
-
-    $default	reduce using rule 39 (release)
-
-
-
-state 43
-
-    releaseorder_section  ->  releaseorder_header release_list . T_SEMICOLON   (rule 35)
-    release_list  ->  release_list . T_COMMA release   (rule 38)
-
-    T_SEMICOLON	shift, and go to state 73
-    T_COMMA	shift, and go to state 74
-
-
-
-state 44
-
-    release_list  ->  release .   (rule 37)
-
-    $default	reduce using rule 37 (release_list)
-
-
-
-state 45
-
-    metaclass_section  ->  metaclassdef description .   (rule 41)
-
-    $default	reduce using rule 41 (metaclass_section)
-
-
-
-state 46
-
-    metaclass_name  ->  T_IDENTIFIER .   (rule 45)
-
-    $default	reduce using rule 45 (metaclass_name)
-
-
-
-state 47
-
-    metaclassdef  ->  metaclass_header metaclass_name . T_SEMICOLON   (rule 42)
-    metaclassdef  ->  metaclass_header metaclass_name . metaclass_attributes T_SEMICOLON   (rule 43)
-
-    T_SEMICOLON	shift, and go to state 75
-    T_COMMA	shift, and go to state 76
-
-    metaclass_attributes	go to state 77
-
-
-
-state 48
-
-    type_specifier  ->  T_IDENTIFIER .   (rule 82)
-
-    $default	reduce using rule 82 (type_specifier)
-
-
-
-state 49
-
-    data_section  ->  data_header variables .   (rule 66)
-
-    $default	reduce using rule 66 (data_section)
-
-
-
-state 50
-
-    variables  ->  declaration .   (rule 68)
-    variables  ->  declaration . variables   (rule 69)
-
-    T_IDENTIFIER	shift, and go to state 48
-
-    $default	reduce using rule 68 (variables)
-
-    variables	go to state 78
-    declaration	go to state 50
-    declarationdef	go to state 51
-    declaration_specifiers	go to state 52
-    type_specifier	go to state 53
-
-
-
-state 51
-
-    declaration  ->  declarationdef . T_SEMICOLON   (rule 70)
-    declaration  ->  declarationdef . T_SEMICOLON description   (rule 71)
-
-    T_SEMICOLON	shift, and go to state 79
-
-
-
-state 52
-
-    declarationdef  ->  declaration_specifiers .   (rule 72)
-    declarationdef  ->  declaration_specifiers . data_attributes   (rule 73)
-
-    T_COMMA	shift, and go to state 80
-
-    $default	reduce using rule 72 (declarationdef)
-
-    data_attributes	go to state 81
-
-
-
-state 53
-
-    declaration_specifiers  ->  type_specifier . declarator   (rule 80)
-    declaration_specifiers  ->  type_specifier . declarator declaration_specifiers   (rule 81)
-
-    T_STAR	shift, and go to state 82
-    T_IDENTIFIER	shift, and go to state 83
-    T_LEFTPARENTHESIS	shift, and go to state 84
-
-    declarator	go to state 85
-    direct_declarator	go to state 86
-    pointer	go to state 87
-
-
-
-state 54
-
-    overridemethod_header  ->  T_OVERRIDE .   (rule 109)
-    overridemethod_header  ->  T_OVERRIDE . T_COLON   (rule 110)
-
-    T_COLON	shift, and go to state 88
-
-    $default	reduce using rule 109 (overridemethod_header)
-
-
-
-state 55
-
-    method_type  ->  type_specifier .   (rule 105)
-    method_type  ->  type_specifier . pointer   (rule 106)
-
-    T_STAR	shift, and go to state 82
-
-    $default	reduce using rule 105 (method_type)
-
-    pointer	go to state 89
-
-
-
-state 56
-
-    methods_section  ->  method_header method_list .   (rule 93)
-    method_list  ->  method_list . method   (rule 97)
-
-    T_IDENTIFIER	shift, and go to state 48
-    T_OVERRIDE	shift, and go to state 54
-
-    $default	reduce using rule 93 (methods_section)
-
-    type_specifier	go to state 55
-    method	go to state 90
-    methoddef	go to state 58
-    method_specifier	go to state 59
-    method_type	go to state 60
-    overridemethod_specifier	go to state 61
-    overridemethod_header	go to state 62
-
-
-
-state 57
-
-    method_list  ->  method .   (rule 96)
-
-    $default	reduce using rule 96 (method_list)
-
-
-
-state 58
-
-    method  ->  methoddef . T_SEMICOLON   (rule 98)
-    method  ->  methoddef . T_SEMICOLON description   (rule 99)
-
-    T_SEMICOLON	shift, and go to state 91
-
-
-
-state 59
-
-    methoddef  ->  method_specifier .   (rule 100)
-    methoddef  ->  method_specifier . method_attributes   (rule 101)
-
-    T_COMMA	shift, and go to state 92
-
-    $default	reduce using rule 100 (methoddef)
-
-    method_attributes	go to state 93
-
-
-
-state 60
-
-    method_specifier  ->  method_type . method_name T_LEFTPARENTHESIS parameter_list T_RIGHTPARENTHESIS   (rule 103)
-
-    T_IDENTIFIER	shift, and go to state 94
-
-    method_name	go to state 95
-
-
-
-state 61
-
-    methoddef  ->  overridemethod_specifier .   (rule 102)
-
-    $default	reduce using rule 102 (methoddef)
-
-
-
-state 62
-
-    overridemethod_specifier  ->  overridemethod_header . overridemethod_name   (rule 107)
-    overridemethod_specifier  ->  overridemethod_header . overridemethod_name overridemethod_attributes   (rule 108)
-
-    T_IDENTIFIER	shift, and go to state 96
-
-    overridemethod_name	go to state 97
-
-
-
-state 63
-
-    methods_section  ->  method_header description . method_list   (rule 94)
-
-    T_IDENTIFIER	shift, and go to state 48
-    T_OVERRIDE	shift, and go to state 54
-
-    type_specifier	go to state 55
-    method_list	go to state 98
-    method	go to state 57
-    methoddef	go to state 58
-    method_specifier	go to state 59
-    method_type	go to state 60
-    overridemethod_specifier	go to state 61
-    overridemethod_header	go to state 62
-
-
-
-state 64
-
-    classdef  ->  class_header class_name T_SEMICOLON .   (rule 18)
-
-    $default	reduce using rule 18 (classdef)
-
-
-
-state 65
-
-    class_attributes  ->  T_COMMA . class_attribute   (rule 22)
-
-    T_GLOBAL	shift, and go to state 99
-    T_LOCAL	shift, and go to state 100
-    T_CLASSINIT	shift, and go to state 101
-    T_FILE	shift, and go to state 102
-    T_FUNCTION	shift, and go to state 103
-    T_CLASSPREFIX	shift, and go to state 104
-    T_MAJOR	shift, and go to state 105
-    T_MINOR	shift, and go to state 106
-    T_EXTERNAL	shift, and go to state 107
-
-    class_attribute	go to state 108
-    visibility	go to state 109
-
-
-
-state 66
-
-    classdef  ->  class_header class_name class_attributes . T_SEMICOLON   (rule 19)
-    class_attributes  ->  class_attributes . T_COMMA class_attribute   (rule 23)
-
-    T_SEMICOLON	shift, and go to state 110
-    T_COMMA	shift, and go to state 111
-
-
-
-state 67
-
-    releaseorder_header  ->  T_RELEASE T_ORDER T_COLON .   (rule 36)
-
-    $default	reduce using rule 36 (releaseorder_header)
-
-
-
-state 68
-
-    parent_header  ->  T_PARENT T_COLON .   (rule 57)
-
-    $default	reduce using rule 57 (parent_header)
-
-
-
-state 69
-
-    parent_header  ->  T_PARENT T_CLASS . T_COLON   (rule 56)
-
-    T_COLON	shift, and go to state 112
-
-
-
-state 70
-
-    parent_section  ->  parentdef description .   (rule 53)
-
-    $default	reduce using rule 53 (parent_section)
-
-
-
-state 71
-
-    parent_name  ->  T_IDENTIFIER .   (rule 58)
-
-    $default	reduce using rule 58 (parent_name)
-
-
-
-state 72
-
-    parentdef  ->  parent_header parent_name . T_SEMICOLON   (rule 54)
-    parentdef  ->  parent_header parent_name . parent_attributes T_SEMICOLON   (rule 55)
-
-    T_SEMICOLON	shift, and go to state 113
-    T_COMMA	shift, and go to state 114
-
-    parent_attributes	go to state 115
-
-
-
-state 73
-
-    releaseorder_section  ->  releaseorder_header release_list T_SEMICOLON .   (rule 35)
-
-    $default	reduce using rule 35 (releaseorder_section)
-
-
-
-state 74
-
-    release_list  ->  release_list T_COMMA . release   (rule 38)
-
-    T_IDENTIFIER	shift, and go to state 42
-
-    release	go to state 116
-
-
-
-state 75
-
-    metaclassdef  ->  metaclass_header metaclass_name T_SEMICOLON .   (rule 42)
-
-    $default	reduce using rule 42 (metaclassdef)
-
-
-
-state 76
-
-    metaclass_attributes  ->  T_COMMA . metaclass_attribute   (rule 46)
-
-    T_GLOBAL	shift, and go to state 99
-    T_LOCAL	shift, and go to state 100
-    T_FILE	shift, and go to state 117
-    T_MAJOR	shift, and go to state 118
-    T_MINOR	shift, and go to state 119
-
-    visibility	go to state 120
-    metaclass_attribute	go to state 121
-
-
-
-state 77
-
-    metaclassdef  ->  metaclass_header metaclass_name metaclass_attributes . T_SEMICOLON   (rule 43)
-    metaclass_attributes  ->  metaclass_attributes . T_COMMA metaclass_attribute   (rule 47)
-
-    T_SEMICOLON	shift, and go to state 122
-    T_COMMA	shift, and go to state 123
-
-
-
-state 78
-
-    variables  ->  declaration variables .   (rule 69)
-
-    $default	reduce using rule 69 (variables)
-
-
-
-state 79
-
-    declaration  ->  declarationdef T_SEMICOLON .   (rule 70)
-    declaration  ->  declarationdef T_SEMICOLON . description   (rule 71)
-
-    T_COMMENT	shift, and go to state 29
-
-    $default	reduce using rule 70 (declaration)
-
-    description	go to state 124
-
-
-
-state 80
-
-    data_attributes  ->  T_COMMA . data_attribute   (rule 74)
-
-    T_CLASS	shift, and go to state 125
-    T_PRIVATE	shift, and go to state 126
-    T_PUBLIC	shift, and go to state 127
-    T_INTERNAL	shift, and go to state 128
-
-    data_attribute	go to state 129
-
-
-
-state 81
-
-    declarationdef  ->  declaration_specifiers data_attributes .   (rule 73)
-    data_attributes  ->  data_attributes . T_COMMA data_attribute   (rule 75)
-
-    T_COMMA	shift, and go to state 130
-
-    $default	reduce using rule 73 (declarationdef)
-
-
-
-state 82
-
-    pointer  ->  T_STAR .   (rule 91)
-
-    $default	reduce using rule 91 (pointer)
-
-
-
-state 83
-
-    direct_declarator  ->  T_IDENTIFIER .   (rule 85)
-
-    $default	reduce using rule 85 (direct_declarator)
-
-
-
-state 84
-
-    direct_declarator  ->  T_LEFTPARENTHESIS . declarator T_RIGHTPARENTHESIS   (rule 86)
-
-    T_STAR	shift, and go to state 82
-    T_IDENTIFIER	shift, and go to state 83
-    T_LEFTPARENTHESIS	shift, and go to state 84
-
-    declarator	go to state 131
-    direct_declarator	go to state 86
-    pointer	go to state 87
-
-
-
-state 85
-
-    declaration_specifiers  ->  type_specifier declarator .   (rule 80)
-    declaration_specifiers  ->  type_specifier declarator . declaration_specifiers   (rule 81)
-
-    T_IDENTIFIER	shift, and go to state 48
-
-    $default	reduce using rule 80 (declaration_specifiers)
-
-    declaration_specifiers	go to state 132
-    type_specifier	go to state 53
-
-
-
-state 86
-
-    declarator  ->  direct_declarator .   (rule 84)
-    direct_declarator  ->  direct_declarator . T_LEFTSQUAREBRACKET T_CONSTANT T_RIGHTSQUAREBRACKET   (rule 87)
-    direct_declarator  ->  direct_declarator . T_LEFTSQUAREBRACKET T_RIGHTSQUAREBRACKET   (rule 88)
-    direct_declarator  ->  direct_declarator . T_LEFTPARENTHESIS declaration_specifiers T_RIGHTPARENTHESIS   (rule 89)
-    direct_declarator  ->  direct_declarator . T_LEFTPARENTHESIS T_RIGHTPARENTHESIS   (rule 90)
-
-    T_LEFTPARENTHESIS	shift, and go to state 133
-    T_LEFTSQUAREBRACKET	shift, and go to state 134
-
-    $default	reduce using rule 84 (declarator)
-
-
-
-state 87
-
-    declarator  ->  pointer . direct_declarator   (rule 83)
-    pointer  ->  pointer . T_STAR   (rule 92)
-
-    T_STAR	shift, and go to state 135
-    T_IDENTIFIER	shift, and go to state 83
-    T_LEFTPARENTHESIS	shift, and go to state 84
-
-    direct_declarator	go to state 136
-
-
-
-state 88
-
-    overridemethod_header  ->  T_OVERRIDE T_COLON .   (rule 110)
-
-    $default	reduce using rule 110 (overridemethod_header)
-
-
-
-state 89
-
-    pointer  ->  pointer . T_STAR   (rule 92)
-    method_type  ->  type_specifier pointer .   (rule 106)
-
-    T_STAR	shift, and go to state 135
-
-    $default	reduce using rule 106 (method_type)
-
-
-
-state 90
-
-    method_list  ->  method_list method .   (rule 97)
-
-    $default	reduce using rule 97 (method_list)
-
-
-
-state 91
-
-    method  ->  methoddef T_SEMICOLON .   (rule 98)
-    method  ->  methoddef T_SEMICOLON . description   (rule 99)
-
-    T_COMMENT	shift, and go to state 29
-
-    $default	reduce using rule 98 (method)
-
-    description	go to state 137
-
-
-
-state 92
-
-    method_attributes  ->  T_COMMA . method_attribute   (rule 116)
-
-    T_LOCAL	shift, and go to state 138
-    T_CLASS	shift, and go to state 139
-    T_PRIVATE	shift, and go to state 140
-    T_PUBLIC	shift, and go to state 141
-    T_METHOD	shift, and go to state 142
-    T_PROCEDURE	shift, and go to state 143
-    T_OFFSET	shift, and go to state 144
-    T_NAME	shift, and go to state 145
-    T_EXTERNAL	shift, and go to state 146
-    T_USE	shift, and go to state 147
-
-    method_attribute	go to state 148
-
-
-
-state 93
-
-    methoddef  ->  method_specifier method_attributes .   (rule 101)
-    method_attributes  ->  method_attributes . T_COMMA method_attribute   (rule 117)
-
-    T_COMMA	shift, and go to state 149
-
-    $default	reduce using rule 101 (methoddef)
-
-
-
-state 94
-
-    method_name  ->  T_IDENTIFIER .   (rule 104)
-
-    $default	reduce using rule 104 (method_name)
-
-
-
-state 95
-
-    method_specifier  ->  method_type method_name . T_LEFTPARENTHESIS parameter_list T_RIGHTPARENTHESIS   (rule 103)
-
-    T_LEFTPARENTHESIS	shift, and go to state 150
-
-
-
-state 96
-
-    overridemethod_name  ->  T_IDENTIFIER .   (rule 111)
-
-    $default	reduce using rule 111 (overridemethod_name)
-
-
-
-state 97
-
-    overridemethod_specifier  ->  overridemethod_header overridemethod_name .   (rule 107)
-    overridemethod_specifier  ->  overridemethod_header overridemethod_name . overridemethod_attributes   (rule 108)
-
-    T_COMMA	shift, and go to state 151
-
-    $default	reduce using rule 107 (overridemethod_specifier)
-
-    overridemethod_attributes	go to state 152
-
-
-
-state 98
-
-    methods_section  ->  method_header description method_list .   (rule 94)
-    method_list  ->  method_list . method   (rule 97)
-
-    T_IDENTIFIER	shift, and go to state 48
-    T_OVERRIDE	shift, and go to state 54
-
-    $default	reduce using rule 94 (methods_section)
-
-    type_specifier	go to state 55
-    method	go to state 90
-    methoddef	go to state 58
-    method_specifier	go to state 59
-    method_type	go to state 60
-    overridemethod_specifier	go to state 61
-    overridemethod_header	go to state 62
-
-
-
-state 99
-
-    visibility  ->  T_GLOBAL .   (rule 33)
-
-    $default	reduce using rule 33 (visibility)
-
-
-
-state 100
-
-    visibility  ->  T_LOCAL .   (rule 34)
-
-    $default	reduce using rule 34 (visibility)
-
-
-
-state 101
-
-    class_attribute  ->  T_CLASSINIT . T_EQUAL T_IDENTIFIER   (rule 31)
-
-    T_EQUAL	shift, and go to state 153
-
-
-
-state 102
-
-    class_attribute  ->  T_FILE . T_STEM T_EQUAL T_IDENTIFIER   (rule 24)
-
-    T_STEM	shift, and go to state 154
-
-
-
-state 103
-
-    class_attribute  ->  T_FUNCTION . T_PREFIX T_EQUAL T_IDENTIFIER   (rule 26)
-
-    T_PREFIX	shift, and go to state 155
-
-
-
-state 104
-
-    class_attribute  ->  T_CLASSPREFIX . T_EQUAL T_IDENTIFIER   (rule 28)
-
-    T_EQUAL	shift, and go to state 156
-
-
-
-state 105
-
-    class_attribute  ->  T_MAJOR . T_VERSION T_EQUAL T_CONSTANT   (rule 29)
-
-    T_VERSION	shift, and go to state 157
-
-
-
-state 106
-
-    class_attribute  ->  T_MINOR . T_VERSION T_EQUAL T_CONSTANT   (rule 30)
-
-    T_VERSION	shift, and go to state 158
-
-
-
-state 107
-
-    class_attribute  ->  T_EXTERNAL . T_STEM T_EQUAL T_IDENTIFIER   (rule 25)
-    class_attribute  ->  T_EXTERNAL . T_PREFIX T_EQUAL T_IDENTIFIER   (rule 27)
-
-    T_STEM	shift, and go to state 159
-    T_PREFIX	shift, and go to state 160
-
-
-
-state 108
-
-    class_attributes  ->  T_COMMA class_attribute .   (rule 22)
-
-    $default	reduce using rule 22 (class_attributes)
-
-
-
-state 109
-
-    class_attribute  ->  visibility .   (rule 32)
-
-    $default	reduce using rule 32 (class_attribute)
-
-
-
-state 110
-
-    classdef  ->  class_header class_name class_attributes T_SEMICOLON .   (rule 19)
-
-    $default	reduce using rule 19 (classdef)
-
-
-
-state 111
-
-    class_attributes  ->  class_attributes T_COMMA . class_attribute   (rule 23)
-
-    T_GLOBAL	shift, and go to state 99
-    T_LOCAL	shift, and go to state 100
-    T_CLASSINIT	shift, and go to state 101
-    T_FILE	shift, and go to state 102
-    T_FUNCTION	shift, and go to state 103
-    T_CLASSPREFIX	shift, and go to state 104
-    T_MAJOR	shift, and go to state 105
-    T_MINOR	shift, and go to state 106
-    T_EXTERNAL	shift, and go to state 107
-
-    class_attribute	go to state 161
-    visibility	go to state 109
-
-
-
-state 112
-
-    parent_header  ->  T_PARENT T_CLASS T_COLON .   (rule 56)
-
-    $default	reduce using rule 56 (parent_header)
-
-
-
-state 113
-
-    parentdef  ->  parent_header parent_name T_SEMICOLON .   (rule 54)
-
-    $default	reduce using rule 54 (parentdef)
-
-
-
-state 114
-
-    parent_attributes  ->  T_COMMA . parent_attribute   (rule 59)
-
-    T_GLOBAL	shift, and go to state 99
-    T_LOCAL	shift, and go to state 100
-    T_FILE	shift, and go to state 162
-    T_MAJOR	shift, and go to state 163
-    T_MINOR	shift, and go to state 164
-
-    visibility	go to state 165
-    parent_attribute	go to state 166
-
-
-
-state 115
-
-    parentdef  ->  parent_header parent_name parent_attributes . T_SEMICOLON   (rule 55)
-    parent_attributes  ->  parent_attributes . T_COMMA parent_attribute   (rule 60)
-
-    T_SEMICOLON	shift, and go to state 167
-    T_COMMA	shift, and go to state 168
-
-
-
-state 116
-
-    release_list  ->  release_list T_COMMA release .   (rule 38)
-
-    $default	reduce using rule 38 (release_list)
-
-
-
-state 117
-
-    metaclass_attribute  ->  T_FILE . T_STEM T_EQUAL T_IDENTIFIER   (rule 48)
-
-    T_STEM	shift, and go to state 169
-
-
-
-state 118
-
-    metaclass_attribute  ->  T_MAJOR . T_VERSION T_EQUAL T_CONSTANT   (rule 49)
-
-    T_VERSION	shift, and go to state 170
-
-
-
-state 119
-
-    metaclass_attribute  ->  T_MINOR . T_VERSION T_EQUAL T_CONSTANT   (rule 50)
-
-    T_VERSION	shift, and go to state 171
-
-
-
-state 120
-
-    metaclass_attribute  ->  visibility .   (rule 51)
-
-    $default	reduce using rule 51 (metaclass_attribute)
-
-
-
-state 121
-
-    metaclass_attributes  ->  T_COMMA metaclass_attribute .   (rule 46)
-
-    $default	reduce using rule 46 (metaclass_attributes)
-
-
-
-state 122
-
-    metaclassdef  ->  metaclass_header metaclass_name metaclass_attributes T_SEMICOLON .   (rule 43)
-
-    $default	reduce using rule 43 (metaclassdef)
-
-
-
-state 123
-
-    metaclass_attributes  ->  metaclass_attributes T_COMMA . metaclass_attribute   (rule 47)
-
-    T_GLOBAL	shift, and go to state 99
-    T_LOCAL	shift, and go to state 100
-    T_FILE	shift, and go to state 117
-    T_MAJOR	shift, and go to state 118
-    T_MINOR	shift, and go to state 119
-
-    visibility	go to state 120
-    metaclass_attribute	go to state 172
-
-
-
-state 124
-
-    declaration  ->  declarationdef T_SEMICOLON description .   (rule 71)
-
-    $default	reduce using rule 71 (declaration)
-
-
-
-state 125
-
-    data_attribute  ->  T_CLASS .   (rule 79)
-
-    $default	reduce using rule 79 (data_attribute)
-
-
-
-state 126
-
-    data_attribute  ->  T_PRIVATE .   (rule 76)
-
-    $default	reduce using rule 76 (data_attribute)
-
-
-
-state 127
-
-    data_attribute  ->  T_PUBLIC .   (rule 77)
-
-    $default	reduce using rule 77 (data_attribute)
-
-
-
-state 128
-
-    data_attribute  ->  T_INTERNAL .   (rule 78)
-
-    $default	reduce using rule 78 (data_attribute)
-
-
-
-state 129
-
-    data_attributes  ->  T_COMMA data_attribute .   (rule 74)
-
-    $default	reduce using rule 74 (data_attributes)
-
-
-
-state 130
-
-    data_attributes  ->  data_attributes T_COMMA . data_attribute   (rule 75)
-
-    T_CLASS	shift, and go to state 125
-    T_PRIVATE	shift, and go to state 126
-    T_PUBLIC	shift, and go to state 127
-    T_INTERNAL	shift, and go to state 128
-
-    data_attribute	go to state 173
-
-
-
-state 131
-
-    direct_declarator  ->  T_LEFTPARENTHESIS declarator . T_RIGHTPARENTHESIS   (rule 86)
-
-    T_RIGHTPARENTHESIS	shift, and go to state 174
-
-
-
-state 132
-
-    declaration_specifiers  ->  type_specifier declarator declaration_specifiers .   (rule 81)
-
-    $default	reduce using rule 81 (declaration_specifiers)
-
-
-
-state 133
-
-    direct_declarator  ->  direct_declarator T_LEFTPARENTHESIS . declaration_specifiers T_RIGHTPARENTHESIS   (rule 89)
-    direct_declarator  ->  direct_declarator T_LEFTPARENTHESIS . T_RIGHTPARENTHESIS   (rule 90)
-
-    T_IDENTIFIER	shift, and go to state 48
-    T_RIGHTPARENTHESIS	shift, and go to state 175
-
-    declaration_specifiers	go to state 176
-    type_specifier	go to state 53
-
-
-
-state 134
-
-    direct_declarator  ->  direct_declarator T_LEFTSQUAREBRACKET . T_CONSTANT T_RIGHTSQUAREBRACKET   (rule 87)
-    direct_declarator  ->  direct_declarator T_LEFTSQUAREBRACKET . T_RIGHTSQUAREBRACKET   (rule 88)
-
-    T_CONSTANT	shift, and go to state 177
-    T_RIGHTSQUAREBRACKET	shift, and go to state 178
-
-
-
-state 135
-
-    pointer  ->  pointer T_STAR .   (rule 92)
-
-    $default	reduce using rule 92 (pointer)
-
-
-
-state 136
-
-    declarator  ->  pointer direct_declarator .   (rule 83)
-    direct_declarator  ->  direct_declarator . T_LEFTSQUAREBRACKET T_CONSTANT T_RIGHTSQUAREBRACKET   (rule 87)
-    direct_declarator  ->  direct_declarator . T_LEFTSQUAREBRACKET T_RIGHTSQUAREBRACKET   (rule 88)
-    direct_declarator  ->  direct_declarator . T_LEFTPARENTHESIS declaration_specifiers T_RIGHTPARENTHESIS   (rule 89)
-    direct_declarator  ->  direct_declarator . T_LEFTPARENTHESIS T_RIGHTPARENTHESIS   (rule 90)
-
-    T_LEFTPARENTHESIS	shift, and go to state 133
-    T_LEFTSQUAREBRACKET	shift, and go to state 134
-
-    $default	reduce using rule 83 (declarator)
-
-
-
-state 137
-
-    method  ->  methoddef T_SEMICOLON description .   (rule 99)
-
-    $default	reduce using rule 99 (method)
-
-
-
-state 138
-
-    method_attribute  ->  T_LOCAL .   (rule 125)
-
-    $default	reduce using rule 125 (method_attribute)
-
-
-
-state 139
-
-    method_attribute  ->  T_CLASS .   (rule 122)
-
-    $default	reduce using rule 122 (method_attribute)
-
-
-
-state 140
-
-    method_attribute  ->  T_PRIVATE .   (rule 118)
-
-    $default	reduce using rule 118 (method_attribute)
-
-
-
-state 141
-
-    method_attribute  ->  T_PUBLIC .   (rule 119)
-
-    $default	reduce using rule 119 (method_attribute)
-
-
-
-state 142
-
-    method_attribute  ->  T_METHOD .   (rule 120)
-
-    $default	reduce using rule 120 (method_attribute)
-
-
-
-state 143
-
-    method_attribute  ->  T_PROCEDURE .   (rule 121)
-
-    $default	reduce using rule 121 (method_attribute)
-
-
-
-state 144
-
-    method_attribute  ->  T_OFFSET .   (rule 123)
-
-    $default	reduce using rule 123 (method_attribute)
-
-
-
-state 145
-
-    method_attribute  ->  T_NAME . T_LOOKUP   (rule 124)
-
-    T_LOOKUP	shift, and go to state 179
-
-
-
-state 146
-
-    method_attribute  ->  T_EXTERNAL .   (rule 126)
-
-    $default	reduce using rule 126 (method_attribute)
-
-
-
-state 147
-
-    method_attribute  ->  T_USE . T_EQUAL T_IDENTIFIER   (rule 127)
-
-    T_EQUAL	shift, and go to state 180
-
-
-
-state 148
-
-    method_attributes  ->  T_COMMA method_attribute .   (rule 116)
-
-    $default	reduce using rule 116 (method_attributes)
-
-
-
-state 149
-
-    method_attributes  ->  method_attributes T_COMMA . method_attribute   (rule 117)
-
-    T_LOCAL	shift, and go to state 138
-    T_CLASS	shift, and go to state 139
-    T_PRIVATE	shift, and go to state 140
-    T_PUBLIC	shift, and go to state 141
-    T_METHOD	shift, and go to state 142
-    T_PROCEDURE	shift, and go to state 143
-    T_OFFSET	shift, and go to state 144
-    T_NAME	shift, and go to state 145
-    T_EXTERNAL	shift, and go to state 146
-    T_USE	shift, and go to state 147
-
-    method_attribute	go to state 181
-
-
-
-state 150
-
-    method_specifier  ->  method_type method_name T_LEFTPARENTHESIS . parameter_list T_RIGHTPARENTHESIS   (rule 103)
-
-    T_IDENTIFIER	shift, and go to state 48
-    T_ELLIPSIS	shift, and go to state 182
-
-    type_specifier	go to state 183
-    parameter_list	go to state 184
-    parameter	go to state 185
-
-
-
-state 151
-
-    overridemethod_attributes  ->  T_COMMA . overridemethod_attribute   (rule 128)
-
-    T_LOCAL	shift, and go to state 186
-    T_CLASS	shift, and go to state 187
-    T_PRIVATE	shift, and go to state 188
-    T_PUBLIC	shift, and go to state 189
-    T_EXTERNAL	shift, and go to state 190
-    T_USE	shift, and go to state 191
-
-    overridemethod_attribute	go to state 192
-
-
-
-state 152
-
-    overridemethod_specifier  ->  overridemethod_header overridemethod_name overridemethod_attributes .   (rule 108)
-    overridemethod_attributes  ->  overridemethod_attributes . T_COMMA overridemethod_attribute   (rule 129)
-
-    T_COMMA	shift, and go to state 193
-
-    $default	reduce using rule 108 (overridemethod_specifier)
-
-
-
-state 153
-
-    class_attribute  ->  T_CLASSINIT T_EQUAL . T_IDENTIFIER   (rule 31)
-
-    T_IDENTIFIER	shift, and go to state 194
-
-
-
-state 154
-
-    class_attribute  ->  T_FILE T_STEM . T_EQUAL T_IDENTIFIER   (rule 24)
-
-    T_EQUAL	shift, and go to state 195
-
-
-
-state 155
-
-    class_attribute  ->  T_FUNCTION T_PREFIX . T_EQUAL T_IDENTIFIER   (rule 26)
-
-    T_EQUAL	shift, and go to state 196
-
-
-
-state 156
-
-    class_attribute  ->  T_CLASSPREFIX T_EQUAL . T_IDENTIFIER   (rule 28)
-
-    T_IDENTIFIER	shift, and go to state 197
-
-
-
-state 157
-
-    class_attribute  ->  T_MAJOR T_VERSION . T_EQUAL T_CONSTANT   (rule 29)
-
-    T_EQUAL	shift, and go to state 198
-
-
-
-state 158
-
-    class_attribute  ->  T_MINOR T_VERSION . T_EQUAL T_CONSTANT   (rule 30)
-
-    T_EQUAL	shift, and go to state 199
-
-
-
-state 159
-
-    class_attribute  ->  T_EXTERNAL T_STEM . T_EQUAL T_IDENTIFIER   (rule 25)
-
-    T_EQUAL	shift, and go to state 200
-
-
-
-state 160
-
-    class_attribute  ->  T_EXTERNAL T_PREFIX . T_EQUAL T_IDENTIFIER   (rule 27)
-
-    T_EQUAL	shift, and go to state 201
-
-
-
-state 161
-
-    class_attributes  ->  class_attributes T_COMMA class_attribute .   (rule 23)
-
-    $default	reduce using rule 23 (class_attributes)
-
-
-
-state 162
-
-    parent_attribute  ->  T_FILE . T_STEM T_EQUAL T_IDENTIFIER   (rule 61)
-
-    T_STEM	shift, and go to state 202
-
-
-
-state 163
-
-    parent_attribute  ->  T_MAJOR . T_VERSION T_EQUAL T_CONSTANT   (rule 62)
-
-    T_VERSION	shift, and go to state 203
-
-
-
-state 164
-
-    parent_attribute  ->  T_MINOR . T_VERSION T_EQUAL T_CONSTANT   (rule 63)
-
-    T_VERSION	shift, and go to state 204
-
-
-
-state 165
-
-    parent_attribute  ->  visibility .   (rule 64)
-
-    $default	reduce using rule 64 (parent_attribute)
-
-
-
-state 166
-
-    parent_attributes  ->  T_COMMA parent_attribute .   (rule 59)
-
-    $default	reduce using rule 59 (parent_attributes)
-
-
-
-state 167
-
-    parentdef  ->  parent_header parent_name parent_attributes T_SEMICOLON .   (rule 55)
-
-    $default	reduce using rule 55 (parentdef)
-
-
-
-state 168
-
-    parent_attributes  ->  parent_attributes T_COMMA . parent_attribute   (rule 60)
-
-    T_GLOBAL	shift, and go to state 99
-    T_LOCAL	shift, and go to state 100
-    T_FILE	shift, and go to state 162
-    T_MAJOR	shift, and go to state 163
-    T_MINOR	shift, and go to state 164
-
-    visibility	go to state 165
-    parent_attribute	go to state 205
-
-
-
-state 169
-
-    metaclass_attribute  ->  T_FILE T_STEM . T_EQUAL T_IDENTIFIER   (rule 48)
-
-    T_EQUAL	shift, and go to state 206
-
-
-
-state 170
-
-    metaclass_attribute  ->  T_MAJOR T_VERSION . T_EQUAL T_CONSTANT   (rule 49)
-
-    T_EQUAL	shift, and go to state 207
-
-
-
-state 171
-
-    metaclass_attribute  ->  T_MINOR T_VERSION . T_EQUAL T_CONSTANT   (rule 50)
-
-    T_EQUAL	shift, and go to state 208
-
-
-
-state 172
-
-    metaclass_attributes  ->  metaclass_attributes T_COMMA metaclass_attribute .   (rule 47)
-
-    $default	reduce using rule 47 (metaclass_attributes)
-
-
-
-state 173
-
-    data_attributes  ->  data_attributes T_COMMA data_attribute .   (rule 75)
-
-    $default	reduce using rule 75 (data_attributes)
-
-
-
-state 174
-
-    direct_declarator  ->  T_LEFTPARENTHESIS declarator T_RIGHTPARENTHESIS .   (rule 86)
-
-    $default	reduce using rule 86 (direct_declarator)
-
-
-
-state 175
-
-    direct_declarator  ->  direct_declarator T_LEFTPARENTHESIS T_RIGHTPARENTHESIS .   (rule 90)
-
-    $default	reduce using rule 90 (direct_declarator)
-
-
-
-state 176
-
-    direct_declarator  ->  direct_declarator T_LEFTPARENTHESIS declaration_specifiers . T_RIGHTPARENTHESIS   (rule 89)
-
-    T_RIGHTPARENTHESIS	shift, and go to state 209
-
-
-
-state 177
-
-    direct_declarator  ->  direct_declarator T_LEFTSQUAREBRACKET T_CONSTANT . T_RIGHTSQUAREBRACKET   (rule 87)
-
-    T_RIGHTSQUAREBRACKET	shift, and go to state 210
-
-
-
-state 178
-
-    direct_declarator  ->  direct_declarator T_LEFTSQUAREBRACKET T_RIGHTSQUAREBRACKET .   (rule 88)
-
-    $default	reduce using rule 88 (direct_declarator)
-
-
-
-state 179
-
-    method_attribute  ->  T_NAME T_LOOKUP .   (rule 124)
-
-    $default	reduce using rule 124 (method_attribute)
-
-
-
-state 180
-
-    method_attribute  ->  T_USE T_EQUAL . T_IDENTIFIER   (rule 127)
-
-    T_IDENTIFIER	shift, and go to state 211
-
-
-
-state 181
-
-    method_attributes  ->  method_attributes T_COMMA method_attribute .   (rule 117)
-
-    $default	reduce using rule 117 (method_attributes)
-
-
-
-state 182
-
-    parameter  ->  T_ELLIPSIS .   (rule 114)
-
-    $default	reduce using rule 114 (parameter)
-
-
-
-state 183
-
-    parameter  ->  type_specifier . declarator   (rule 115)
-
-    T_STAR	shift, and go to state 82
-    T_IDENTIFIER	shift, and go to state 83
-    T_LEFTPARENTHESIS	shift, and go to state 84
-
-    declarator	go to state 212
-    direct_declarator	go to state 86
-    pointer	go to state 87
-
-
-
-state 184
-
-    method_specifier  ->  method_type method_name T_LEFTPARENTHESIS parameter_list . T_RIGHTPARENTHESIS   (rule 103)
-    parameter_list  ->  parameter_list . T_COMMA parameter   (rule 113)
-
-    T_COMMA	shift, and go to state 213
-    T_RIGHTPARENTHESIS	shift, and go to state 214
-
-
-
-state 185
-
-    parameter_list  ->  parameter .   (rule 112)
-
-    $default	reduce using rule 112 (parameter_list)
-
-
-
-state 186
-
-    overridemethod_attribute  ->  T_LOCAL .   (rule 133)
-
-    $default	reduce using rule 133 (overridemethod_attribute)
-
-
-
-state 187
-
-    overridemethod_attribute  ->  T_CLASS .   (rule 132)
-
-    $default	reduce using rule 132 (overridemethod_attribute)
-
-
-
-state 188
-
-    overridemethod_attribute  ->  T_PRIVATE .   (rule 130)
-
-    $default	reduce using rule 130 (overridemethod_attribute)
-
-
-
-state 189
-
-    overridemethod_attribute  ->  T_PUBLIC .   (rule 131)
-
-    $default	reduce using rule 131 (overridemethod_attribute)
-
-
-
-state 190
-
-    overridemethod_attribute  ->  T_EXTERNAL .   (rule 134)
-
-    $default	reduce using rule 134 (overridemethod_attribute)
-
-
-
-state 191
-
-    overridemethod_attribute  ->  T_USE . T_EQUAL T_IDENTIFIER   (rule 135)
-
-    T_EQUAL	shift, and go to state 215
-
-
-
-state 192
-
-    overridemethod_attributes  ->  T_COMMA overridemethod_attribute .   (rule 128)
-
-    $default	reduce using rule 128 (overridemethod_attributes)
-
-
-
-state 193
-
-    overridemethod_attributes  ->  overridemethod_attributes T_COMMA . overridemethod_attribute   (rule 129)
-
-    T_LOCAL	shift, and go to state 186
-    T_CLASS	shift, and go to state 187
-    T_PRIVATE	shift, and go to state 188
-    T_PUBLIC	shift, and go to state 189
-    T_EXTERNAL	shift, and go to state 190
-    T_USE	shift, and go to state 191
-
-    overridemethod_attribute	go to state 216
-
-
-
-state 194
-
-    class_attribute  ->  T_CLASSINIT T_EQUAL T_IDENTIFIER .   (rule 31)
-
-    $default	reduce using rule 31 (class_attribute)
-
-
-
-state 195
-
-    class_attribute  ->  T_FILE T_STEM T_EQUAL . T_IDENTIFIER   (rule 24)
-
-    T_IDENTIFIER	shift, and go to state 217
-
-
-
-state 196
-
-    class_attribute  ->  T_FUNCTION T_PREFIX T_EQUAL . T_IDENTIFIER   (rule 26)
-
-    T_IDENTIFIER	shift, and go to state 218
-
-
-
-state 197
-
-    class_attribute  ->  T_CLASSPREFIX T_EQUAL T_IDENTIFIER .   (rule 28)
-
-    $default	reduce using rule 28 (class_attribute)
-
-
-
-state 198
-
-    class_attribute  ->  T_MAJOR T_VERSION T_EQUAL . T_CONSTANT   (rule 29)
-
-    T_CONSTANT	shift, and go to state 219
-
-
-
-state 199
-
-    class_attribute  ->  T_MINOR T_VERSION T_EQUAL . T_CONSTANT   (rule 30)
-
-    T_CONSTANT	shift, and go to state 220
-
-
-
-state 200
-
-    class_attribute  ->  T_EXTERNAL T_STEM T_EQUAL . T_IDENTIFIER   (rule 25)
-
-    T_IDENTIFIER	shift, and go to state 221
-
-
-
-state 201
-
-    class_attribute  ->  T_EXTERNAL T_PREFIX T_EQUAL . T_IDENTIFIER   (rule 27)
-
-    T_IDENTIFIER	shift, and go to state 222
-
-
-
-state 202
-
-    parent_attribute  ->  T_FILE T_STEM . T_EQUAL T_IDENTIFIER   (rule 61)
-
-    T_EQUAL	shift, and go to state 223
-
-
-
-state 203
-
-    parent_attribute  ->  T_MAJOR T_VERSION . T_EQUAL T_CONSTANT   (rule 62)
-
-    T_EQUAL	shift, and go to state 224
-
-
-
-state 204
-
-    parent_attribute  ->  T_MINOR T_VERSION . T_EQUAL T_CONSTANT   (rule 63)
-
-    T_EQUAL	shift, and go to state 225
-
-
-
-state 205
-
-    parent_attributes  ->  parent_attributes T_COMMA parent_attribute .   (rule 60)
-
-    $default	reduce using rule 60 (parent_attributes)
-
-
-
-state 206
-
-    metaclass_attribute  ->  T_FILE T_STEM T_EQUAL . T_IDENTIFIER   (rule 48)
-
-    T_IDENTIFIER	shift, and go to state 226
-
-
-
-state 207
-
-    metaclass_attribute  ->  T_MAJOR T_VERSION T_EQUAL . T_CONSTANT   (rule 49)
-
-    T_CONSTANT	shift, and go to state 227
-
-
-
-state 208
-
-    metaclass_attribute  ->  T_MINOR T_VERSION T_EQUAL . T_CONSTANT   (rule 50)
-
-    T_CONSTANT	shift, and go to state 228
-
-
-
-state 209
-
-    direct_declarator  ->  direct_declarator T_LEFTPARENTHESIS declaration_specifiers T_RIGHTPARENTHESIS .   (rule 89)
-
-    $default	reduce using rule 89 (direct_declarator)
-
-
-
-state 210
-
-    direct_declarator  ->  direct_declarator T_LEFTSQUAREBRACKET T_CONSTANT T_RIGHTSQUAREBRACKET .   (rule 87)
-
-    $default	reduce using rule 87 (direct_declarator)
-
-
-
-state 211
-
-    method_attribute  ->  T_USE T_EQUAL T_IDENTIFIER .   (rule 127)
-
-    $default	reduce using rule 127 (method_attribute)
-
-
-
-state 212
-
-    parameter  ->  type_specifier declarator .   (rule 115)
-
-    $default	reduce using rule 115 (parameter)
-
-
-
-state 213
-
-    parameter_list  ->  parameter_list T_COMMA . parameter   (rule 113)
-
-    T_IDENTIFIER	shift, and go to state 48
-    T_ELLIPSIS	shift, and go to state 182
-
-    type_specifier	go to state 183
-    parameter	go to state 229
-
-
-
-state 214
-
-    method_specifier  ->  method_type method_name T_LEFTPARENTHESIS parameter_list T_RIGHTPARENTHESIS .   (rule 103)
-
-    $default	reduce using rule 103 (method_specifier)
-
-
-
-state 215
-
-    overridemethod_attribute  ->  T_USE T_EQUAL . T_IDENTIFIER   (rule 135)
-
-    T_IDENTIFIER	shift, and go to state 230
-
-
-
-state 216
-
-    overridemethod_attributes  ->  overridemethod_attributes T_COMMA overridemethod_attribute .   (rule 129)
-
-    $default	reduce using rule 129 (overridemethod_attributes)
-
-
-
-state 217
-
-    class_attribute  ->  T_FILE T_STEM T_EQUAL T_IDENTIFIER .   (rule 24)
-
-    $default	reduce using rule 24 (class_attribute)
-
-
-
-state 218
-
-    class_attribute  ->  T_FUNCTION T_PREFIX T_EQUAL T_IDENTIFIER .   (rule 26)
-
-    $default	reduce using rule 26 (class_attribute)
-
-
-
-state 219
-
-    class_attribute  ->  T_MAJOR T_VERSION T_EQUAL T_CONSTANT .   (rule 29)
-
-    $default	reduce using rule 29 (class_attribute)
-
-
-
-state 220
-
-    class_attribute  ->  T_MINOR T_VERSION T_EQUAL T_CONSTANT .   (rule 30)
-
-    $default	reduce using rule 30 (class_attribute)
-
-
-
-state 221
-
-    class_attribute  ->  T_EXTERNAL T_STEM T_EQUAL T_IDENTIFIER .   (rule 25)
-
-    $default	reduce using rule 25 (class_attribute)
-
-
-
-state 222
-
-    class_attribute  ->  T_EXTERNAL T_PREFIX T_EQUAL T_IDENTIFIER .   (rule 27)
-
-    $default	reduce using rule 27 (class_attribute)
-
-
-
-state 223
-
-    parent_attribute  ->  T_FILE T_STEM T_EQUAL . T_IDENTIFIER   (rule 61)
-
-    T_IDENTIFIER	shift, and go to state 231
-
-
-
-state 224
-
-    parent_attribute  ->  T_MAJOR T_VERSION T_EQUAL . T_CONSTANT   (rule 62)
-
-    T_CONSTANT	shift, and go to state 232
-
-
-
-state 225
-
-    parent_attribute  ->  T_MINOR T_VERSION T_EQUAL . T_CONSTANT   (rule 63)
-
-    T_CONSTANT	shift, and go to state 233
-
-
-
-state 226
-
-    metaclass_attribute  ->  T_FILE T_STEM T_EQUAL T_IDENTIFIER .   (rule 48)
-
-    $default	reduce using rule 48 (metaclass_attribute)
-
-
-
-state 227
-
-    metaclass_attribute  ->  T_MAJOR T_VERSION T_EQUAL T_CONSTANT .   (rule 49)
-
-    $default	reduce using rule 49 (metaclass_attribute)
-
-
-
-state 228
-
-    metaclass_attribute  ->  T_MINOR T_VERSION T_EQUAL T_CONSTANT .   (rule 50)
-
-    $default	reduce using rule 50 (metaclass_attribute)
-
-
-
-state 229
-
-    parameter_list  ->  parameter_list T_COMMA parameter .   (rule 113)
-
-    $default	reduce using rule 113 (parameter_list)
-
-
-
-state 230
-
-    overridemethod_attribute  ->  T_USE T_EQUAL T_IDENTIFIER .   (rule 135)
-
-    $default	reduce using rule 135 (overridemethod_attribute)
-
-
-
-state 231
-
-    parent_attribute  ->  T_FILE T_STEM T_EQUAL T_IDENTIFIER .   (rule 61)
-
-    $default	reduce using rule 61 (parent_attribute)
-
-
-
-state 232
-
-    parent_attribute  ->  T_MAJOR T_VERSION T_EQUAL T_CONSTANT .   (rule 62)
-
-    $default	reduce using rule 62 (parent_attribute)
-
-
-
-state 233
-
-    parent_attribute  ->  T_MINOR T_VERSION T_EQUAL T_CONSTANT .   (rule 63)
-
-    $default	reduce using rule 63 (parent_attribute)
-
-
-
-state 234
-
-    $   	go to state 235
-
-
-
-state 235
-
-    $   	go to state 236
-
-
-
-state 236
-
-    $default	accept
diff -urN somfree/somopc/src/gramma.yy.tab.c newsomfree/somopc/src/gramma.yy.tab.c
--- somfree/somopc/src/gramma.yy.tab.c	Sat Jun 29 21:47:30 2024
+++ newsomfree/somopc/src/gramma.yy.tab.c	Thu Jan 01 07:00:00 1970
@@ -1,2042 +0,0 @@
-
-/*  A Bison parser, made from gramma.yy
-    by GNU Bison version 1.28  */
-
-#define YYBISON 1  /* Identify Bison output.  */
-
-#define	T_CONSTANT	257
-#define	T_COLON	258
-#define	T_SEMICOLON	259
-#define	T_COMMA	260
-#define	T_STAR	261
-#define	T_COMMENT	262
-#define	T_IDENTIFIER	263
-#define	T_EQUAL	264
-#define	T_DASHES	265
-#define	T_PERIOD	266
-#define	T_ELLIPSIS	267
-#define	T_LEFTPARENTHESIS	268
-#define	T_RIGHTPARENTHESIS	269
-#define	T_LEFTSQUAREBRACKET	270
-#define	T_RIGHTSQUAREBRACKET	271
-#define	T_VERSION	272
-#define	T_GLOBAL	273
-#define	T_LOCAL	274
-#define	T_CLASSINIT	275
-#define	T_RELEASE	276
-#define	T_ORDER	277
-#define	T_METACLASS	278
-#define	T_PARENT	279
-#define	T_CLASS	280
-#define	T_FILE	281
-#define	T_STEM	282
-#define	T_FUNCTION	283
-#define	T_PREFIX	284
-#define	T_CLASSPREFIX	285
-#define	T_MAJOR	286
-#define	T_MINOR	287
-#define	T_PASSTHRU	288
-#define	T_BEFORE	289
-#define	T_AFTER	290
-#define	T_ENDPASSTHRU	291
-#define	T_DATA	292
-#define	T_PRIVATE	293
-#define	T_PUBLIC	294
-#define	T_INTERNAL	295
-#define	T_METHODS	296
-#define	T_GROUP	297
-#define	T_METHOD	298
-#define	T_PROCEDURE	299
-#define	T_OFFSET	300
-#define	T_NAME	301
-#define	T_LOOKUP	302
-#define	T_EXTERNAL	303
-#define	T_USE	304
-#define	T_OVERRIDE	305
-
-#line 1 "gramma.yy"
-
-#include <stdio.h> // fopen, fprintf
-#include <string.h>
-
-#include <emitlib.h>
-
-#define YYERROR_VERBOSE
-
-extern int lineno, column;
-
-Entry e;
-
-Entry *cls;	// Current Class Entry
-Entry *pcls;	// Parent Class Entry
-Entry *mcls;	// Meta Class Entry
-
-void yyerror(const char *str)
-{
-        fprintf(stderr,"\nerror: %s\n", str);
-}
- 
-int yywrap()
-{
-        return 1;
-} 
-  
-
-#line 33 "gramma.yy"
-typedef union{
- char *stval;
- int ival;
-} YYSTYPE;
-#ifndef YYDEBUG
-#define YYDEBUG 1
-#endif
-
-#include <stdio.h>
-
-#ifndef __cplusplus
-#ifndef __STDC__
-#define const
-#endif
-#endif
-
-
-
-#define	YYFINAL		236
-#define	YYFLAG		-32768
-#define	YYNTBASE	52
-
-#define YYTRANSLATE(x) ((unsigned)(x) <= 305 ? yytranslate[x] : 114)
-
-static const char yytranslate[] = {     0,
-     2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
-     2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
-     2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
-     2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
-     2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
-     2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
-     2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
-     2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
-     2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
-     2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
-     2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
-     2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
-     2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
-     2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
-     2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
-     2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
-     2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
-     2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
-     2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
-     2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
-     2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
-     2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
-     2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
-     2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
-     2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
-     2,     2,     2,     2,     2,     1,     3,     4,     5,     6,
-     7,     8,     9,    10,    11,    12,    13,    14,    15,    16,
-    17,    18,    19,    20,    21,    22,    23,    24,    25,    26,
-    27,    28,    29,    30,    31,    32,    33,    34,    35,    36,
-    37,    38,    39,    40,    41,    42,    43,    44,    45,    46,
-    47,    48,    49,    50,    51
-};
-
-#if YYDEBUG != 0
-static const short yyprhs[] = {     0,
-     0,     1,     4,     6,     9,    10,    14,    16,    19,    21,
-    23,    24,    27,    29,    31,    33,    35,    38,    42,    47,
-    50,    52,    55,    59,    64,    69,    74,    79,    83,    88,
-    93,    97,    99,   101,   103,   107,   111,   113,   117,   119,
-   121,   124,   128,   133,   136,   138,   141,   145,   150,   155,
-   160,   162,   164,   167,   171,   176,   180,   183,   185,   188,
-   192,   197,   202,   207,   209,   211,   214,   217,   219,   222,
-   225,   229,   231,   234,   237,   241,   243,   245,   247,   249,
-   252,   256,   258,   261,   263,   265,   269,   274,   278,   283,
-   287,   289,   292,   295,   299,   302,   304,   307,   310,   314,
-   316,   319,   321,   327,   329,   331,   334,   337,   341,   343,
-   346,   348,   350,   354,   356,   359,   362,   366,   368,   370,
-   372,   374,   376,   378,   381,   383,   385,   389,   392,   396,
-   398,   400,   402,   404,   406,   410
-};
-
-static const short yyrhs[] = {    -1,
-    53,    54,     0,    55,     0,    54,    55,     0,     0,    56,
-    60,    57,     0,    58,     0,    57,    58,     0,    67,     0,
-    71,     0,     0,    59,    77,     0,    83,     0,    84,     0,
-    96,     0,    61,     0,    61,   113,     0,    62,    63,     5,
-     0,    62,    63,    64,     5,     0,    26,     4,     0,     9,
-     0,     6,    65,     0,    64,     6,    65,     0,    27,    28,
-    10,     9,     0,    49,    28,    10,     9,     0,    29,    30,
-    10,     9,     0,    49,    30,    10,     9,     0,    31,    10,
-     9,     0,    32,    18,    10,     3,     0,    33,    18,    10,
-     3,     0,    21,    10,     9,     0,    66,     0,    19,     0,
-    20,     0,    68,    69,     5,     0,    22,    23,     4,     0,
-    70,     0,    69,     6,    70,     0,     9,     0,    72,     0,
-    72,   113,     0,    73,    74,     5,     0,    73,    74,    75,
-     5,     0,    24,     4,     0,     9,     0,     6,    76,     0,
-    75,     6,    76,     0,    27,    28,    10,     9,     0,    32,
-    18,    10,     3,     0,    33,    18,    10,     3,     0,    66,
-     0,    78,     0,    78,   113,     0,    79,    80,     5,     0,
-    79,    80,    81,     5,     0,    25,    26,     4,     0,    25,
-     4,     0,     9,     0,     6,    82,     0,    81,     6,    82,
-     0,    27,    28,    10,     9,     0,    32,    18,    10,     3,
-     0,    33,    18,    10,     3,     0,    66,     0,    34,     0,
-    85,    86,     0,    38,     4,     0,    87,     0,    87,    86,
-     0,    88,     5,     0,    88,     5,   113,     0,    91,     0,
-    91,    89,     0,     6,    90,     0,    89,     6,    90,     0,
-    39,     0,    40,     0,    41,     0,    26,     0,    92,    93,
-     0,    92,    93,    91,     0,     9,     0,    95,    94,     0,
-    94,     0,     9,     0,    14,    93,    15,     0,    94,    16,
-     3,    17,     0,    94,    16,    17,     0,    94,    14,    91,
-    15,     0,    94,    14,    15,     0,     7,     0,    95,     7,
-     0,    97,    98,     0,    97,   113,    98,     0,    42,     4,
-     0,    99,     0,    98,    99,     0,   100,     5,     0,   100,
-     5,   113,     0,   101,     0,   101,   109,     0,   104,     0,
-   103,   102,    14,   107,    15,     0,     9,     0,    92,     0,
-    92,    95,     0,   105,   106,     0,   105,   106,   111,     0,
-    51,     0,    51,     4,     0,     9,     0,   108,     0,   107,
-     6,   108,     0,    13,     0,    92,    93,     0,     6,   110,
-     0,   109,     6,   110,     0,    39,     0,    40,     0,    44,
-     0,    45,     0,    26,     0,    46,     0,    47,    48,     0,
-    20,     0,    49,     0,    50,    10,     9,     0,     6,   112,
-     0,   111,     6,   112,     0,    39,     0,    40,     0,    26,
-     0,    20,     0,    49,     0,    50,    10,     9,     0,     8,
-     0
-};
-
-#endif
-
-#if YYDEBUG != 0
-static const short yyrline[] = { 0,
-    58,    68,    75,    76,    80,    88,    96,    97,   101,   102,
-   103,   112,   116,   117,   118,   122,   123,   130,   131,   135,
-   139,   148,   149,   153,   157,   161,   165,   169,   173,   180,
-   187,   191,   195,   196,   200,   207,   211,   215,   225,   233,
-   234,   241,   242,   246,   250,   254,   255,   259,   260,   261,
-   262,   266,   267,   275,   276,   280,   281,   285,   293,   294,
-   298,   299,   300,   301,   305,   309,   313,   317,   318,   322,
-   323,   330,   331,   335,   336,   340,   341,   342,   343,   347,
-   348,   352,   359,   360,   364,   365,   366,   367,   368,   369,
-   373,   377,   390,   391,   398,   402,   408,   417,   418,   422,
-   423,   424,   428,   435,   452,   456,   468,   469,   473,   474,
-   478,   492,   493,   497,   498,   502,   503,   507,   508,   509,
-   510,   511,   512,   513,   514,   515,   516,   524,   525,   529,
-   530,   531,   532,   533,   534,   538
-};
-#endif
-
-
-#if YYDEBUG != 0 || defined (YYERROR_VERBOSE)
-
-static const char * const yytname[] = {   "$","error","$undefined.","T_CONSTANT",
-"T_COLON","T_SEMICOLON","T_COMMA","T_STAR","T_COMMENT","T_IDENTIFIER","T_EQUAL",
-"T_DASHES","T_PERIOD","T_ELLIPSIS","T_LEFTPARENTHESIS","T_RIGHTPARENTHESIS",
-"T_LEFTSQUAREBRACKET","T_RIGHTSQUAREBRACKET","T_VERSION","T_GLOBAL","T_LOCAL",
-"T_CLASSINIT","T_RELEASE","T_ORDER","T_METACLASS","T_PARENT","T_CLASS","T_FILE",
-"T_STEM","T_FUNCTION","T_PREFIX","T_CLASSPREFIX","T_MAJOR","T_MINOR","T_PASSTHRU",
-"T_BEFORE","T_AFTER","T_ENDPASSTHRU","T_DATA","T_PRIVATE","T_PUBLIC","T_INTERNAL",
-"T_METHODS","T_GROUP","T_METHOD","T_PROCEDURE","T_OFFSET","T_NAME","T_LOOKUP",
-"T_EXTERNAL","T_USE","T_OVERRIDE","oidl","@1","class_list","class_definition",
-"@2","section_list","section","@3","class_section","classdef","class_header",
-"class_name","class_attributes","class_attribute","visibility","releaseorder_section",
-"releaseorder_header","release_list","release","metaclass_section","metaclassdef",
-"metaclass_header","metaclass_name","metaclass_attributes","metaclass_attribute",
-"parent_section","parentdef","parent_header","parent_name","parent_attributes",
-"parent_attribute","passthru_section","data_section","data_header","variables",
-"declaration","declarationdef","data_attributes","data_attribute","declaration_specifiers",
-"type_specifier","declarator","direct_declarator","pointer","methods_section",
-"method_header","method_list","method","methoddef","method_specifier","method_name",
-"method_type","overridemethod_specifier","overridemethod_header","overridemethod_name",
-"parameter_list","parameter","method_attributes","method_attribute","overridemethod_attributes",
-"overridemethod_attribute","description", NULL
-};
-#endif
-
-static const short yyr1[] = {     0,
-    53,    52,    54,    54,    56,    55,    57,    57,    58,    58,
-    59,    58,    58,    58,    58,    60,    60,    61,    61,    62,
-    63,    64,    64,    65,    65,    65,    65,    65,    65,    65,
-    65,    65,    66,    66,    67,    68,    69,    69,    70,    71,
-    71,    72,    72,    73,    74,    75,    75,    76,    76,    76,
-    76,    77,    77,    78,    78,    79,    79,    80,    81,    81,
-    82,    82,    82,    82,    83,    84,    85,    86,    86,    87,
-    87,    88,    88,    89,    89,    90,    90,    90,    90,    91,
-    91,    92,    93,    93,    94,    94,    94,    94,    94,    94,
-    95,    95,    96,    96,    97,    98,    98,    99,    99,   100,
-   100,   100,   101,   102,   103,   103,   104,   104,   105,   105,
-   106,   107,   107,   108,   108,   109,   109,   110,   110,   110,
-   110,   110,   110,   110,   110,   110,   110,   111,   111,   112,
-   112,   112,   112,   112,   112,   113
-};
-
-static const short yyr2[] = {     0,
-     0,     2,     1,     2,     0,     3,     1,     2,     1,     1,
-     0,     2,     1,     1,     1,     1,     2,     3,     4,     2,
-     1,     2,     3,     4,     4,     4,     4,     3,     4,     4,
-     3,     1,     1,     1,     3,     3,     1,     3,     1,     1,
-     2,     3,     4,     2,     1,     2,     3,     4,     4,     4,
-     1,     1,     2,     3,     4,     3,     2,     1,     2,     3,
-     4,     4,     4,     1,     1,     2,     2,     1,     2,     2,
-     3,     1,     2,     2,     3,     1,     1,     1,     1,     2,
-     3,     1,     2,     1,     1,     3,     4,     3,     4,     3,
-     1,     2,     2,     3,     2,     1,     2,     2,     3,     1,
-     2,     1,     5,     1,     1,     2,     2,     3,     1,     2,
-     1,     1,     3,     1,     2,     2,     3,     1,     1,     1,
-     1,     1,     1,     2,     1,     1,     3,     2,     3,     1,
-     1,     1,     1,     1,     3,     1
-};
-
-static const short yydefact[] = {     1,
-     5,     2,     3,     0,     4,     0,    11,    16,     0,    20,
-     0,     0,    65,     0,     0,     6,     7,     0,     9,     0,
-    10,    40,     0,    13,    14,     0,    15,     0,   136,    17,
-    21,     0,     0,    44,    67,    95,     8,     0,    12,    52,
-     0,    39,     0,    37,    41,    45,     0,    82,    66,    68,
-     0,    72,     0,   109,   105,    93,    96,     0,   100,     0,
-   102,     0,     0,    18,     0,     0,    36,    57,     0,    53,
-    58,     0,    35,     0,    42,     0,     0,    69,    70,     0,
-    73,    91,    85,     0,    80,    84,     0,   110,   106,    97,
-    98,     0,   101,   104,     0,   111,   107,    94,    33,    34,
-     0,     0,     0,     0,     0,     0,     0,    22,    32,    19,
-     0,    56,    54,     0,     0,    38,     0,     0,     0,    51,
-    46,    43,     0,    71,    79,    76,    77,    78,    74,     0,
-     0,    81,     0,     0,    92,    83,    99,   125,   122,   118,
-   119,   120,   121,   123,     0,   126,     0,   116,     0,     0,
-     0,   108,     0,     0,     0,     0,     0,     0,     0,     0,
-    23,     0,     0,     0,    64,    59,    55,     0,     0,     0,
-     0,    47,    75,    86,    90,     0,     0,    88,   124,     0,
-   117,   114,     0,     0,   112,   133,   132,   130,   131,   134,
-     0,   128,     0,    31,     0,     0,    28,     0,     0,     0,
-     0,     0,     0,     0,    60,     0,     0,     0,    89,    87,
-   127,   115,     0,   103,     0,   129,    24,    26,    29,    30,
-    25,    27,     0,     0,     0,    48,    49,    50,   113,   135,
-    61,    62,    63,     0,     0,     0
-};
-
-static const short yydefgoto[] = {   234,
-     1,     2,     3,     4,    16,    17,    18,     7,     8,     9,
-    32,    66,   108,   109,    19,    20,    43,    44,    21,    22,
-    23,    47,    77,   121,    39,    40,    41,    72,   115,   166,
-    24,    25,    26,    49,    50,    51,    81,   129,    52,    53,
-    85,    86,    87,    27,    28,    56,    57,    58,    59,    95,
-    60,    61,    62,    97,   184,   185,    93,   148,   152,   192,
-    30
-};
-
-static const short yypact[] = {-32768,
--32768,    25,-32768,    43,-32768,    54,    51,    63,    56,-32768,
-    55,    70,-32768,    76,    79,    57,-32768,    65,-32768,    83,
--32768,    63,    89,-32768,-32768,    94,-32768,    -3,-32768,-32768,
--32768,    39,    84,-32768,-32768,-32768,-32768,    12,-32768,    63,
-   114,-32768,    96,-32768,-32768,-32768,   102,-32768,-32768,    94,
-   119,   120,     5,   121,   122,    -1,-32768,   123,   124,   118,
--32768,   125,    -1,-32768,    35,   106,-32768,-32768,   127,-32768,
--32768,   109,-32768,    83,-32768,    77,   111,-32768,    63,   -16,
-   126,-32768,-32768,     5,    94,     4,     8,-32768,   128,-32768,
-    63,   -13,   130,-32768,   129,-32768,   131,    -1,-32768,-32768,
-   132,   105,   108,   134,   133,   135,    31,-32768,-32768,-32768,
-    35,-32768,-32768,    86,   115,-32768,   112,   136,   137,-32768,
--32768,-32768,    77,-32768,-32768,-32768,-32768,-32768,-32768,   -16,
-   141,-32768,    32,    26,-32768,     4,-32768,-32768,-32768,-32768,
--32768,-32768,-32768,-32768,    91,-32768,   138,-32768,   -13,    33,
-    37,   139,   140,   142,   147,   149,   150,   151,   152,   153,
--32768,   113,   146,   148,-32768,-32768,-32768,    86,   155,   157,
-   158,-32768,-32768,-32768,-32768,   144,   154,-32768,-32768,   160,
--32768,-32768,     5,    24,-32768,-32768,-32768,-32768,-32768,-32768,
-   162,-32768,    37,-32768,   161,   164,-32768,   143,   171,   166,
-   167,   168,   169,   170,-32768,   172,   174,   179,-32768,-32768,
--32768,-32768,    33,-32768,   175,-32768,-32768,-32768,-32768,-32768,
--32768,-32768,   177,   180,   184,-32768,-32768,-32768,-32768,-32768,
--32768,-32768,-32768,   188,   189,-32768
-};
-
-static const short yypgoto[] = {-32768,
--32768,-32768,   145,-32768,-32768,   176,-32768,-32768,-32768,-32768,
--32768,-32768,    80,   -74,-32768,-32768,-32768,   116,-32768,-32768,
--32768,-32768,-32768,    27,-32768,-32768,-32768,-32768,-32768,    28,
--32768,-32768,-32768,   156,-32768,-32768,-32768,    64,   -81,   -28,
-   -83,   110,   159,-32768,-32768,   163,   -45,-32768,-32768,-32768,
--32768,-32768,-32768,-32768,-32768,   -20,-32768,    46,-32768,     6,
-   -19
-};
-
-
-#define	YYLAST		226
-
-
-static const short yytable[] = {    55,
-   131,   120,    45,   132,    29,    48,   138,    48,    63,   125,
-    90,    82,   139,    83,   135,    68,    83,   133,    84,   134,
-    70,    84,   126,   127,   128,   140,   141,    55,   177,   213,
-   142,   143,   144,   145,    55,   146,   147,    69,   214,   165,
-    48,    48,   178,    64,    65,   182,   175,    54,   120,    54,
-    -5,   176,    90,    99,   100,   101,   186,    10,   159,   124,
-   160,   102,   187,   103,    31,   104,   105,   106,     6,    55,
-    29,   137,    11,    34,    12,   188,   189,    33,    11,    35,
-    12,   -11,    36,   107,    13,   190,   191,    67,    14,    38,
-    13,    42,    15,   165,    14,    99,   100,    46,    15,   212,
-    73,    74,    48,   117,    99,   100,    75,    76,   118,   119,
-   110,   111,   162,   113,   114,   122,   123,   163,   164,   167,
-   168,   183,    71,    79,    88,    80,    94,    91,    82,    92,
-   112,   130,   154,    96,   135,   149,   151,   155,   179,   169,
-   202,   153,   150,   156,   193,   219,     5,   180,   194,   172,
-   157,   195,   158,   170,   171,   174,   196,   197,   209,   198,
-   199,   200,   201,   203,   206,   204,   207,   208,   211,   217,
-   210,   215,   218,   220,   221,   222,   227,   223,   224,   225,
-   226,   228,   232,   230,   183,   231,   233,   235,   236,   116,
-   161,    37,   229,   173,   181,   205,   136,     0,   216,     0,
-     0,     0,     0,     0,     0,    78,     0,     0,     0,     0,
-     0,     0,     0,    89,     0,     0,     0,     0,     0,     0,
-     0,     0,     0,     0,     0,    98
-};
-
-static const short yycheck[] = {    28,
-    84,    76,    22,    85,     8,     9,    20,     9,    28,    26,
-    56,     7,    26,     9,     7,     4,     9,    14,    14,    16,
-    40,    14,    39,    40,    41,    39,    40,    56,     3,     6,
-    44,    45,    46,    47,    63,    49,    50,    26,    15,   114,
-     9,     9,    17,     5,     6,    13,    15,    51,   123,    51,
-    26,   133,    98,    19,    20,    21,    20,     4,    28,    79,
-    30,    27,    26,    29,     9,    31,    32,    33,    26,    98,
-     8,    91,    22,     4,    24,    39,    40,    23,    22,     4,
-    24,    25,     4,    49,    34,    49,    50,     4,    38,    25,
-    34,     9,    42,   168,    38,    19,    20,     9,    42,   183,
-     5,     6,     9,    27,    19,    20,     5,     6,    32,    33,
-     5,     6,    27,     5,     6,     5,     6,    32,    33,     5,
-     6,   150,     9,     5,     4,     6,     9,     5,     7,     6,
-     4,     6,    28,     9,     7,     6,     6,    30,    48,    28,
-    28,    10,    14,    10,     6,     3,     2,    10,     9,   123,
-    18,    10,    18,    18,    18,    15,    10,     9,    15,    10,
-    10,    10,    10,    18,    10,    18,    10,    10,     9,     9,
-    17,    10,     9,     3,     9,     9,     3,    10,    10,    10,
-     9,     3,     3,     9,   213,     9,     3,     0,     0,    74,
-   111,    16,   213,   130,   149,   168,    87,    -1,   193,    -1,
-    -1,    -1,    -1,    -1,    -1,    50,    -1,    -1,    -1,    -1,
-    -1,    -1,    -1,    55,    -1,    -1,    -1,    -1,    -1,    -1,
-    -1,    -1,    -1,    -1,    -1,    63
-};
-/* -*-C-*-  Note some compilers choke on comments on `#line' lines.  */
-#line 3 "/emx/share/bison.simple"
-/* This file comes from bison-1.28.  */
-
-/* Skeleton output parser for bison,
-   Copyright (C) 1984, 1989, 1990 Free Software Foundation, Inc.
-
-   This program is free software; you can redistribute it and/or modify
-   it under the terms of the GNU General Public License as published by
-   the Free Software Foundation; either version 2, or (at your option)
-   any later version.
-
-   This program is distributed in the hope that it will be useful,
-   but WITHOUT ANY WARRANTY; without even the implied warranty of
-   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-   GNU General Public License for more details.
-
-   You should have received a copy of the GNU General Public License
-   along with this program; if not, write to the Free Software
-   Foundation, Inc., 59 Temple Place - Suite 330,
-   Boston, MA 02111-1307, USA.  */
-
-/* As a special exception, when this file is copied by Bison into a
-   Bison output file, you may use that output file without restriction.
-   This special exception was added by the Free Software Foundation
-   in version 1.24 of Bison.  */
-
-/* This is the parser code that is written into each bison parser
-  when the %semantic_parser declaration is not specified in the grammar.
-  It was written by Richard Stallman by simplifying the hairy parser
-  used when %semantic_parser is specified.  */
-
-#ifndef YYSTACK_USE_ALLOCA
-#ifdef alloca
-#define YYSTACK_USE_ALLOCA
-#else /* alloca not defined */
-#ifdef __GNUC__
-#define YYSTACK_USE_ALLOCA
-#define alloca __builtin_alloca
-#else /* not GNU C.  */
-#if (!defined (__STDC__) && defined (sparc)) || defined (__sparc__) || defined (__sparc) || defined (__sgi) || (defined (__sun) && defined (__i386))
-#define YYSTACK_USE_ALLOCA
-#include <alloca.h>
-#else /* not sparc */
-/* We think this test detects Watcom and Microsoft C.  */
-/* This used to test MSDOS, but that is a bad idea
-   since that symbol is in the user namespace.  */
-#if (defined (_MSDOS) || defined (_MSDOS_)) && !defined (__TURBOC__)
-#if 0 /* No need for malloc.h, which pollutes the namespace;
-	 instead, just don't use alloca.  */
-#include <malloc.h>
-#endif
-#else /* not MSDOS, or __TURBOC__ */
-#if defined(_AIX)
-/* I don't know what this was needed for, but it pollutes the namespace.
-   So I turned it off.   rms, 2 May 1997.  */
-/* #include <malloc.h>  */
- #pragma alloca
-#define YYSTACK_USE_ALLOCA
-#else /* not MSDOS, or __TURBOC__, or _AIX */
-#include <malloc.h>
-#if 0
-#ifdef __hpux /* haible@ilog.fr says this works for HPUX 9.05 and up,
-		 and on HPUX 10.  Eventually we can turn this on.  */
-#define YYSTACK_USE_ALLOCA
-#define alloca __builtin_alloca
-#endif /* __hpux */
-#endif
-#endif /* not _AIX */
-#endif /* not MSDOS, or __TURBOC__ */
-#endif /* not sparc */
-#endif /* not GNU C */
-#endif /* alloca not defined */
-#endif /* YYSTACK_USE_ALLOCA not defined */
-
-#ifdef YYSTACK_USE_ALLOCA
-#define YYSTACK_ALLOC alloca
-#else
-#define YYSTACK_ALLOC malloc
-#endif
-
-/* Note: there must be only one dollar sign in this file.
-   It is replaced by the list of actions, each action
-   as one case of the switch.  */
-
-#define yyerrok		(yyerrstatus = 0)
-#define yyclearin	(yychar = YYEMPTY)
-#define YYEMPTY		-2
-#define YYEOF		0
-#define YYACCEPT	goto yyacceptlab
-#define YYABORT 	goto yyabortlab
-#define YYERROR		goto yyerrlab1
-/* Like YYERROR except do call yyerror.
-   This remains here temporarily to ease the
-   transition to the new meaning of YYERROR, for GCC.
-   Once GCC version 2 has supplanted version 1, this can go.  */
-#define YYFAIL		goto yyerrlab
-#define YYRECOVERING()  (!!yyerrstatus)
-#define YYBACKUP(token, value) \
-do								\
-  if (yychar == YYEMPTY && yylen == 1)				\
-    { yychar = (token), yylval = (value);			\
-      yychar1 = YYTRANSLATE (yychar);				\
-      YYPOPSTACK;						\
-      goto yybackup;						\
-    }								\
-  else								\
-    { yyerror ("syntax error: cannot back up"); YYERROR; }	\
-while (0)
-
-#define YYTERROR	1
-#define YYERRCODE	256
-
-#ifndef YYPURE
-#define YYLEX		yylex()
-#endif
-
-#ifdef YYPURE
-#ifdef YYLSP_NEEDED
-#ifdef YYLEX_PARAM
-#define YYLEX		yylex(&yylval, &yylloc, YYLEX_PARAM)
-#else
-#define YYLEX		yylex(&yylval, &yylloc)
-#endif
-#else /* not YYLSP_NEEDED */
-#ifdef YYLEX_PARAM
-#define YYLEX		yylex(&yylval, YYLEX_PARAM)
-#else
-#define YYLEX		yylex(&yylval)
-#endif
-#endif /* not YYLSP_NEEDED */
-#endif
-
-/* If nonreentrant, generate the variables here */
-
-#ifndef YYPURE
-
-int	yychar;			/*  the lookahead symbol		*/
-YYSTYPE	yylval;			/*  the semantic value of the		*/
-				/*  lookahead symbol			*/
-
-#ifdef YYLSP_NEEDED
-YYLTYPE yylloc;			/*  location data for the lookahead	*/
-				/*  symbol				*/
-#endif
-
-int yynerrs;			/*  number of parse errors so far       */
-#endif  /* not YYPURE */
-
-#if YYDEBUG != 0
-int yydebug;			/*  nonzero means print parse trace	*/
-/* Since this is uninitialized, it does not stop multiple parsers
-   from coexisting.  */
-#endif
-
-/*  YYINITDEPTH indicates the initial size of the parser's stacks	*/
-
-#ifndef	YYINITDEPTH
-#define YYINITDEPTH 200
-#endif
-
-/*  YYMAXDEPTH is the maximum size the stacks can grow to
-    (effective only if the built-in stack extension method is used).  */
-
-#if YYMAXDEPTH == 0
-#undef YYMAXDEPTH
-#endif
-
-#ifndef YYMAXDEPTH
-#define YYMAXDEPTH 10000
-#endif
-
-/* Define __yy_memcpy.  Note that the size argument
-   should be passed with type unsigned int, because that is what the non-GCC
-   definitions require.  With GCC, __builtin_memcpy takes an arg
-   of type size_t, but it can handle unsigned int.  */
-
-#if __GNUC__ > 1		/* GNU C and GNU C++ define this.  */
-#define __yy_memcpy(TO,FROM,COUNT)	__builtin_memcpy(TO,FROM,COUNT)
-#else				/* not GNU C or C++ */
-#ifndef __cplusplus
-
-/* This is the most reliable way to avoid incompatibilities
-   in available built-in functions on various systems.  */
-static void
-__yy_memcpy (to, from, count)
-     char *to;
-     char *from;
-     unsigned int count;
-{
-  register char *f = from;
-  register char *t = to;
-  register int i = count;
-
-  while (i-- > 0)
-    *t++ = *f++;
-}
-
-#else /* __cplusplus */
-
-/* This is the most reliable way to avoid incompatibilities
-   in available built-in functions on various systems.  */
-static void
-__yy_memcpy (char *to, char *from, unsigned int count)
-{
-  register char *t = to;
-  register char *f = from;
-  register int i = count;
-
-  while (i-- > 0)
-    *t++ = *f++;
-}
-
-#endif
-#endif
-
-#line 217 "/emx/share/bison.simple"
-
-/* The user can define YYPARSE_PARAM as the name of an argument to be passed
-   into yyparse.  The argument should have type void *.
-   It should actually point to an object.
-   Grammar actions can access the variable by casting it
-   to the proper pointer type.  */
-
-#ifdef YYPARSE_PARAM
-#ifdef __cplusplus
-#define YYPARSE_PARAM_ARG void *YYPARSE_PARAM
-#define YYPARSE_PARAM_DECL
-#else /* not __cplusplus */
-#define YYPARSE_PARAM_ARG YYPARSE_PARAM
-#define YYPARSE_PARAM_DECL void *YYPARSE_PARAM;
-#endif /* not __cplusplus */
-#else /* not YYPARSE_PARAM */
-#define YYPARSE_PARAM_ARG
-#define YYPARSE_PARAM_DECL
-#endif /* not YYPARSE_PARAM */
-
-/* Prevent warning if -Wstrict-prototypes.  */
-#ifdef __GNUC__
-#ifdef YYPARSE_PARAM
-int yyparse (void *);
-#else
-int yyparse (void);
-#endif
-#endif
-
-int
-yyparse(YYPARSE_PARAM_ARG)
-     YYPARSE_PARAM_DECL
-{
-  register int yystate;
-  register int yyn;
-  register short *yyssp;
-  register YYSTYPE *yyvsp;
-  int yyerrstatus;	/*  number of tokens to shift before error messages enabled */
-  int yychar1 = 0;		/*  lookahead token as an internal (translated) token number */
-
-  short	yyssa[YYINITDEPTH];	/*  the state stack			*/
-  YYSTYPE yyvsa[YYINITDEPTH];	/*  the semantic value stack		*/
-
-  short *yyss = yyssa;		/*  refer to the stacks thru separate pointers */
-  YYSTYPE *yyvs = yyvsa;	/*  to allow yyoverflow to reallocate them elsewhere */
-
-#ifdef YYLSP_NEEDED
-  YYLTYPE yylsa[YYINITDEPTH];	/*  the location stack			*/
-  YYLTYPE *yyls = yylsa;
-  YYLTYPE *yylsp;
-
-#define YYPOPSTACK   (yyvsp--, yyssp--, yylsp--)
-#else
-#define YYPOPSTACK   (yyvsp--, yyssp--)
-#endif
-
-  int yystacksize = YYINITDEPTH;
-  int yyfree_stacks = 0;
-
-#ifdef YYPURE
-  int yychar;
-  YYSTYPE yylval;
-  int yynerrs;
-#ifdef YYLSP_NEEDED
-  YYLTYPE yylloc;
-#endif
-#endif
-
-  YYSTYPE yyval;		/*  the variable used to return		*/
-				/*  semantic values from the action	*/
-				/*  routines				*/
-
-  int yylen;
-
-#if YYDEBUG != 0
-  if (yydebug)
-    fprintf(stderr, "Starting parse\n");
-#endif
-
-  yystate = 0;
-  yyerrstatus = 0;
-  yynerrs = 0;
-  yychar = YYEMPTY;		/* Cause a token to be read.  */
-
-  /* Initialize stack pointers.
-     Waste one element of value and location stack
-     so that they stay on the same level as the state stack.
-     The wasted elements are never initialized.  */
-
-  yyssp = yyss - 1;
-  yyvsp = yyvs;
-#ifdef YYLSP_NEEDED
-  yylsp = yyls;
-#endif
-
-/* Push a new state, which is found in  yystate  .  */
-/* In all cases, when you get here, the value and location stacks
-   have just been pushed. so pushing a state here evens the stacks.  */
-yynewstate:
-
-  *++yyssp = yystate;
-
-  if (yyssp >= yyss + yystacksize - 1)
-    {
-      /* Give user a chance to reallocate the stack */
-      /* Use copies of these so that the &'s don't force the real ones into memory. */
-      YYSTYPE *yyvs1 = yyvs;
-      short *yyss1 = yyss;
-#ifdef YYLSP_NEEDED
-      YYLTYPE *yyls1 = yyls;
-#endif
-
-      /* Get the current used size of the three stacks, in elements.  */
-      int size = yyssp - yyss + 1;
-
-#ifdef yyoverflow
-      /* Each stack pointer address is followed by the size of
-	 the data in use in that stack, in bytes.  */
-#ifdef YYLSP_NEEDED
-      /* This used to be a conditional around just the two extra args,
-	 but that might be undefined if yyoverflow is a macro.  */
-      yyoverflow("parser stack overflow",
-		 &yyss1, size * sizeof (*yyssp),
-		 &yyvs1, size * sizeof (*yyvsp),
-		 &yyls1, size * sizeof (*yylsp),
-		 &yystacksize);
-#else
-      yyoverflow("parser stack overflow",
-		 &yyss1, size * sizeof (*yyssp),
-		 &yyvs1, size * sizeof (*yyvsp),
-		 &yystacksize);
-#endif
-
-      yyss = yyss1; yyvs = yyvs1;
-#ifdef YYLSP_NEEDED
-      yyls = yyls1;
-#endif
-#else /* no yyoverflow */
-      /* Extend the stack our own way.  */
-      if (yystacksize >= YYMAXDEPTH)
-	{
-	  yyerror("parser stack overflow");
-	  if (yyfree_stacks)
-	    {
-	      free (yyss);
-	      free (yyvs);
-#ifdef YYLSP_NEEDED
-	      free (yyls);
-#endif
-	    }
-	  return 2;
-	}
-      yystacksize *= 2;
-      if (yystacksize > YYMAXDEPTH)
-	yystacksize = YYMAXDEPTH;
-#ifndef YYSTACK_USE_ALLOCA
-      yyfree_stacks = 1;
-#endif
-      yyss = (short *) YYSTACK_ALLOC (yystacksize * sizeof (*yyssp));
-      __yy_memcpy ((char *)yyss, (char *)yyss1,
-		   size * (unsigned int) sizeof (*yyssp));
-      yyvs = (YYSTYPE *) YYSTACK_ALLOC (yystacksize * sizeof (*yyvsp));
-      __yy_memcpy ((char *)yyvs, (char *)yyvs1,
-		   size * (unsigned int) sizeof (*yyvsp));
-#ifdef YYLSP_NEEDED
-      yyls = (YYLTYPE *) YYSTACK_ALLOC (yystacksize * sizeof (*yylsp));
-      __yy_memcpy ((char *)yyls, (char *)yyls1,
-		   size * (unsigned int) sizeof (*yylsp));
-#endif
-#endif /* no yyoverflow */
-
-      yyssp = yyss + size - 1;
-      yyvsp = yyvs + size - 1;
-#ifdef YYLSP_NEEDED
-      yylsp = yyls + size - 1;
-#endif
-
-#if YYDEBUG != 0
-      if (yydebug)
-	fprintf(stderr, "Stack size increased to %d\n", yystacksize);
-#endif
-
-      if (yyssp >= yyss + yystacksize - 1)
-	YYABORT;
-    }
-
-#if YYDEBUG != 0
-  if (yydebug)
-    fprintf(stderr, "Entering state %d\n", yystate);
-#endif
-
-  goto yybackup;
- yybackup:
-
-/* Do appropriate processing given the current state.  */
-/* Read a lookahead token if we need one and don't already have one.  */
-/* yyresume: */
-
-  /* First try to decide what to do without reference to lookahead token.  */
-
-  yyn = yypact[yystate];
-  if (yyn == YYFLAG)
-    goto yydefault;
-
-  /* Not known => get a lookahead token if don't already have one.  */
-
-  /* yychar is either YYEMPTY or YYEOF
-     or a valid token in external form.  */
-
-  if (yychar == YYEMPTY)
-    {
-#if YYDEBUG != 0
-      if (yydebug)
-	fprintf(stderr, "Reading a token: ");
-#endif
-      yychar = YYLEX;
-    }
-
-  /* Convert token to internal form (in yychar1) for indexing tables with */
-
-  if (yychar <= 0)		/* This means end of input. */
-    {
-      yychar1 = 0;
-      yychar = YYEOF;		/* Don't call YYLEX any more */
-
-#if YYDEBUG != 0
-      if (yydebug)
-	fprintf(stderr, "Now at end of input.\n");
-#endif
-    }
-  else
-    {
-      yychar1 = YYTRANSLATE(yychar);
-
-#if YYDEBUG != 0
-      if (yydebug)
-	{
-	  fprintf (stderr, " Next token is %d (%s", yychar, yytname[yychar1]);
-	  /* Give the individual parser a way to print the precise meaning
-	     of a token, for further debugging info.  */
-#ifdef YYPRINT
-	  YYPRINT (stderr, yychar, yylval);
-#endif
-	  fprintf (stderr, ")\n");
-	}
-#endif
-    }
-
-  yyn += yychar1;
-  if (yyn < 0 || yyn > YYLAST || yycheck[yyn] != yychar1)
-    goto yydefault;
-
-  yyn = yytable[yyn];
-
-  /* yyn is what to do for this token type in this state.
-     Negative => reduce, -yyn is rule number.
-     Positive => shift, yyn is new state.
-       New state is final state => don't bother to shift,
-       just return success.
-     0, or most negative number => error.  */
-
-  if (yyn < 0)
-    {
-      if (yyn == YYFLAG)
-	goto yyerrlab;
-      yyn = -yyn;
-      goto yyreduce;
-    }
-  else if (yyn == 0)
-    goto yyerrlab;
-
-  if (yyn == YYFINAL)
-    YYACCEPT;
-
-  /* Shift the lookahead token.  */
-
-#if YYDEBUG != 0
-  if (yydebug)
-    fprintf(stderr, "Shifting token %d (%s), ", yychar, yytname[yychar1]);
-#endif
-
-  /* Discard the token being shifted unless it is eof.  */
-  if (yychar != YYEOF)
-    yychar = YYEMPTY;
-
-  *++yyvsp = yylval;
-#ifdef YYLSP_NEEDED
-  *++yylsp = yylloc;
-#endif
-
-  /* count tokens shifted since error; after three, turn off error status.  */
-  if (yyerrstatus) yyerrstatus--;
-
-  yystate = yyn;
-  goto yynewstate;
-
-/* Do the default action for the current state.  */
-yydefault:
-
-  yyn = yydefact[yystate];
-  if (yyn == 0)
-    goto yyerrlab;
-
-/* Do a reduction.  yyn is the number of a rule to reduce with.  */
-yyreduce:
-  yylen = yyr2[yyn];
-  if (yylen > 0)
-    yyval = yyvsp[1-yylen]; /* implement default value of the action */
-
-#if YYDEBUG != 0
-  if (yydebug)
-    {
-      int i;
-
-      fprintf (stderr, "Reducing via rule %d (line %d), ",
-	       yyn, yyrline[yyn]);
-
-      /* Print the symbols being reduced, and their result.  */
-      for (i = yyprhs[yyn]; yyrhs[i] > 0; i++)
-	fprintf (stderr, "%s ", yytname[yyrhs[i]]);
-      fprintf (stderr, " -> %s\n", yytname[yyr1[yyn]]);
-    }
-#endif
-
-
-  switch (yyn) {
-
-case 1:
-#line 59 "gramma.yy"
-{
-			if (somtg_f.verbose) printf("Parsing of \"%s\" started.\n", somtfilePath);
-			somtg_f._ERROR=0;   /* @todo subject to move to parse() */
-			somtg_f.WARN=0;   /* @todo subject to move to parse() */
-			somtg_f.FATAL=0;   /* @todo subject to move to parse() */
-			somtg_f.INTERNAL=0;   /* @todo subject to move to parse() */
-			somtg_buf=somtsmallocSL(somtg_f.commentsize, TRUE);   /* @todo subject to move to parse() */
-		;
-    break;}
-case 2:
-#line 68 "gramma.yy"
-{
-			somtfree(somtg_buf);   /* @todo subject to move to parse() */
-			if (somtg_f.verbose) printf("Parsing of \"%s\" finished.\n", somtfilePath);
-		;
-    break;}
-case 5:
-#line 81 "gramma.yy"
-{
-			cls=(Entry *)somtsmallocSL(sizeof(Entry), TRUE);
-			cls->atts=somtaddModifierSL(cls->atts, "callstyle", "oidl");
-			cls->type=SOMTClassE;
-			somtclassIdlCall=FALSE;
-			cls->u.c.file=strdup(somtfilePath);
-		;
-    break;}
-case 6:
-#line 89 "gramma.yy"
-{
-			somtaddEntrySL(somtstab, cls->name, cls);
-			somtfree(cls);
-		;
-    break;}
-case 11:
-#line 104 "gramma.yy"
-{
-			pcls=(Entry *)somtsmallocSL(sizeof(Entry), TRUE);
-			pcls->atts=somtaddModifierSL(pcls->atts, "callstyle", "oidl");
-			pcls->type=SOMTBaseE;
-			somtclassIdlCall=FALSE;
-//			pcls->u.c.file=strdup(somtfilePath);
-		;
-    break;}
-case 12:
-#line 112 "gramma.yy"
-{
-			cls->u.c.parent=somtaddEntrySL(somtstab, pcls->name, pcls);
-			somtfree(pcls);
-		;
-    break;}
-case 17:
-#line 124 "gramma.yy"
-{
-			cls->comment=yyvsp[0].stval;
-		;
-    break;}
-case 21:
-#line 140 "gramma.yy"
-{
-			somtclassName=yyvsp[0].stval;
-			cls->lineno=lineno;                 
-			cls->name=yyvsp[0].stval;
-		;
-    break;}
-case 24:
-#line 154 "gramma.yy"
-{
-			cls->atts=somtaddModifierSL(cls->atts, "filestem", yyvsp[0].stval);
-		;
-    break;}
-case 25:
-#line 158 "gramma.yy"
-{
-			cls->atts=somtaddModifierSL(cls->atts, "externalstem", yyvsp[0].stval);
-		;
-    break;}
-case 26:
-#line 162 "gramma.yy"
-{
-			cls->atts=somtaddModifierSL(cls->atts, "functionprefix", yyvsp[0].stval);
-		;
-    break;}
-case 27:
-#line 166 "gramma.yy"
-{
-			cls->atts=somtaddModifierSL(cls->atts, "externalprefix", yyvsp[0].stval);
-		;
-    break;}
-case 28:
-#line 170 "gramma.yy"
-{
-			cls->atts=somtaddModifierSL(cls->atts, "classprefix", yyvsp[0].stval);
-		;
-    break;}
-case 29:
-#line 174 "gramma.yy"
-{
-			char *st=itoa(yyvsp[0].ival, somtsmallocSL(_MAX_ITOSTR_BASE10_COUNT, TRUE), 10);
-			cls->atts=somtaddModifierSL(cls->atts, "majorversion", st);
-			somtmajorVersion=strdup(st);
-			somtfree(st);
-		;
-    break;}
-case 30:
-#line 181 "gramma.yy"
-{
-			char *st=itoa(yyvsp[0].ival, somtsmallocSL(_MAX_ITOSTR_BASE10_COUNT, TRUE), 10);
-			cls->atts=somtaddModifierSL(cls->atts, "minorversion", st);
-			somtminorVersion=strdup(st);
-			somtfree(st);
-		;
-    break;}
-case 31:
-#line 188 "gramma.yy"
-{
-			cls->atts=somtaddModifierSL(cls->atts, "classInit", yyvsp[0].stval);
-		;
-    break;}
-case 35:
-#line 201 "gramma.yy"
-{
-			cls->atts=somtaddModifierSL(cls->atts, "releaseorder", yyvsp[-1].stval);
-		;
-    break;}
-case 37:
-#line 212 "gramma.yy"
-{ 
-			yyval.stval=strdup(yyvsp[0].stval);
-		;
-    break;}
-case 38:
-#line 216 "gramma.yy"
-{
-			char *r=somtsmallocSL(strlen(yyvsp[-2].stval)+strlen(yyvsp[0].stval)+2, TRUE);
-			strcat(strcat(strcat(r, yyvsp[-2].stval), ","), yyvsp[0].stval);
-			yyval.stval=strdup(r);
-			somtfree(r);
-		;
-    break;}
-case 39:
-#line 226 "gramma.yy"
-{
-			cls->u.c.release=somtaddModifierSL(cls->u.c.release, yyvsp[0].stval, NULL);
-			yyval.stval=yyvsp[0].stval;
-		;
-    break;}
-case 41:
-#line 235 "gramma.yy"
-{
-			mcls->comment=yyvsp[0].stval;
-		;
-    break;}
-case 53:
-#line 268 "gramma.yy"
-{
-			pcls->comment=yyvsp[0].stval;
-		;
-    break;}
-case 58:
-#line 286 "gramma.yy"
-{
-			pcls->lineno=lineno;  // @todo line of class definition?
-			pcls->name=yyvsp[0].stval;
-		;
-    break;}
-case 71:
-#line 324 "gramma.yy"
-{
-//			cls->comment=$<stval>2;
-		;
-    break;}
-case 82:
-#line 353 "gramma.yy"
-{
-			yyval.stval=yyvsp[0].stval;
-		;
-    break;}
-case 85:
-#line 364 "gramma.yy"
-{printf("$<stval>1");;
-    break;}
-case 91:
-#line 374 "gramma.yy"
-{
-			yyval.stval=yyvsp[0].stval;
-		;
-    break;}
-case 92:
-#line 378 "gramma.yy"
-{
-			char *r=somtsmallocSL(strlen(yyvsp[-1].stval)+strlen(yyvsp[0].stval)+1, TRUE);
-			strcat(r, yyvsp[-1].stval);
-			strcat(r, yyvsp[0].stval);
-			free(yyvsp[-1].stval);
-			yyval.stval=strdup(r);
-			somtfree(r);
-		;
-    break;}
-case 94:
-#line 392 "gramma.yy"
-{
-			e.comment=yyvsp[-1].stval;
-		;
-    break;}
-case 96:
-#line 403 "gramma.yy"
-{
-			cls->u.c.methodcnt++;
-			somtaddEntrySL(somtstab, e.name, &e);
-			memset(&e, 0, sizeof(Entry));
-		;
-    break;}
-case 97:
-#line 409 "gramma.yy"
-{
-			cls->u.c.methodcnt++;
-			somtaddEntrySL(somtstab, e.name, &e);
-			memset(&e, 0, sizeof(Entry));
-		;
-    break;}
-case 103:
-#line 429 "gramma.yy"
-{
-			e.u.m.type=strdup(yyvsp[-4].stval);
-		;
-    break;}
-case 104:
-#line 436 "gramma.yy"
-{
-			e.type=SOMTNewMethodE;
-			e.lineno=lineno;
-			e.name=yyvsp[0].stval;
-			e.sname=&somtclassName;
-			char * desc=somtsmallocSL(MAX_DESCRIPTOR_LENGTH, TRUE);
-			strcat(desc, "::");
-			strcat(desc, yyvsp[0].stval);
-			strcat(desc, "::");
-			strcat(desc, somtclassName);
-			e.atts=somtaddModifierSL(e.atts, "descriptor", desc);
-			somtfree(desc);
-		;
-    break;}
-case 105:
-#line 453 "gramma.yy"
-{
-			yyval.stval=yyvsp[0].stval;
-		;
-    break;}
-case 106:
-#line 457 "gramma.yy"
-{
-			char *r=somtsmallocSL(strlen(yyvsp[-1].stval)+strlen(yyvsp[0].stval)+1, TRUE);
-			strcat(r, yyvsp[-1].stval);
-			strcat(r, yyvsp[0].stval);
-			free(yyvsp[-1].stval);
-			yyval.stval=strdup(r);
-			somtfree(r);
-		;
-    break;}
-case 111:
-#line 479 "gramma.yy"
-{
-			e.type=SOMTOverrideMethodE;
-			e.lineno=lineno;
-			e.name=yyvsp[0].stval;
-			e.sname=&somtclassName;
-			char * desc=somtsmallocSL(MAX_DESCRIPTOR_LENGTH, TRUE);
-			strcat(strcat(strcat(strcat(desc ,"::"), yyvsp[0].stval), "::"), somtclassName);
-			e.atts=somtaddModifierSL(e.atts, "descriptor", desc);
-			somtfree(desc);
-		;
-    break;}
-case 136:
-#line 539 "gramma.yy"
-{
-			yyval.stval=yyvsp[0].stval;
-		;
-    break;}
-}
-   /* the action file gets copied in in place of this dollarsign */
-#line 543 "/emx/share/bison.simple"
-
-  yyvsp -= yylen;
-  yyssp -= yylen;
-#ifdef YYLSP_NEEDED
-  yylsp -= yylen;
-#endif
-
-#if YYDEBUG != 0
-  if (yydebug)
-    {
-      short *ssp1 = yyss - 1;
-      fprintf (stderr, "state stack now");
-      while (ssp1 != yyssp)
-	fprintf (stderr, " %d", *++ssp1);
-      fprintf (stderr, "\n");
-    }
-#endif
-
-  *++yyvsp = yyval;
-
-#ifdef YYLSP_NEEDED
-  yylsp++;
-  if (yylen == 0)
-    {
-      yylsp->first_line = yylloc.first_line;
-      yylsp->first_column = yylloc.first_column;
-      yylsp->last_line = (yylsp-1)->last_line;
-      yylsp->last_column = (yylsp-1)->last_column;
-      yylsp->text = 0;
-    }
-  else
-    {
-      yylsp->last_line = (yylsp+yylen-1)->last_line;
-      yylsp->last_column = (yylsp+yylen-1)->last_column;
-    }
-#endif
-
-  /* Now "shift" the result of the reduction.
-     Determine what state that goes to,
-     based on the state we popped back to
-     and the rule number reduced by.  */
-
-  yyn = yyr1[yyn];
-
-  yystate = yypgoto[yyn - YYNTBASE] + *yyssp;
-  if (yystate >= 0 && yystate <= YYLAST && yycheck[yystate] == *yyssp)
-    yystate = yytable[yystate];
-  else
-    yystate = yydefgoto[yyn - YYNTBASE];
-
-  goto yynewstate;
-
-yyerrlab:   /* here on detecting error */
-
-  if (! yyerrstatus)
-    /* If not already recovering from an error, report this error.  */
-    {
-      ++yynerrs;
-
-#ifdef YYERROR_VERBOSE
-      yyn = yypact[yystate];
-
-      if (yyn > YYFLAG && yyn < YYLAST)
-	{
-	  int size = 0;
-	  char *msg;
-	  int x, count;
-
-	  count = 0;
-	  /* Start X at -yyn if nec to avoid negative indexes in yycheck.  */
-	  for (x = (yyn < 0 ? -yyn : 0);
-	       x < (sizeof(yytname) / sizeof(char *)); x++)
-	    if (yycheck[x + yyn] == x)
-	      size += strlen(yytname[x]) + 15, count++;
-	  msg = (char *) malloc(size + 15);
-	  if (msg != 0)
-	    {
-	      strcpy(msg, "parse error");
-
-	      if (count < 5)
-		{
-		  count = 0;
-		  for (x = (yyn < 0 ? -yyn : 0);
-		       x < (sizeof(yytname) / sizeof(char *)); x++)
-		    if (yycheck[x + yyn] == x)
-		      {
-			strcat(msg, count == 0 ? ", expecting `" : " or `");
-			strcat(msg, yytname[x]);
-			strcat(msg, "'");
-			count++;
-		      }
-		}
-	      yyerror(msg);
-	      free(msg);
-	    }
-	  else
-	    yyerror ("parse error; also virtual memory exceeded");
-	}
-      else
-#endif /* YYERROR_VERBOSE */
-	yyerror("parse error");
-    }
-
-  goto yyerrlab1;
-yyerrlab1:   /* here on error raised explicitly by an action */
-
-  if (yyerrstatus == 3)
-    {
-      /* if just tried and failed to reuse lookahead token after an error, discard it.  */
-
-      /* return failure if at end of input */
-      if (yychar == YYEOF)
-	YYABORT;
-
-#if YYDEBUG != 0
-      if (yydebug)
-	fprintf(stderr, "Discarding token %d (%s).\n", yychar, yytname[yychar1]);
-#endif
-
-      yychar = YYEMPTY;
-    }
-
-  /* Else will try to reuse lookahead token
-     after shifting the error token.  */
-
-  yyerrstatus = 3;		/* Each real token shifted decrements this */
-
-  goto yyerrhandle;
-
-yyerrdefault:  /* current state does not do anything special for the error token. */
-
-#if 0
-  /* This is wrong; only states that explicitly want error tokens
-     should shift them.  */
-  yyn = yydefact[yystate];  /* If its default is to accept any token, ok.  Otherwise pop it.*/
-  if (yyn) goto yydefault;
-#endif
-
-yyerrpop:   /* pop the current state because it cannot handle the error token */
-
-  if (yyssp == yyss) YYABORT;
-  yyvsp--;
-  yystate = *--yyssp;
-#ifdef YYLSP_NEEDED
-  yylsp--;
-#endif
-
-#if YYDEBUG != 0
-  if (yydebug)
-    {
-      short *ssp1 = yyss - 1;
-      fprintf (stderr, "Error: state stack now");
-      while (ssp1 != yyssp)
-	fprintf (stderr, " %d", *++ssp1);
-      fprintf (stderr, "\n");
-    }
-#endif
-
-yyerrhandle:
-
-  yyn = yypact[yystate];
-  if (yyn == YYFLAG)
-    goto yyerrdefault;
-
-  yyn += YYTERROR;
-  if (yyn < 0 || yyn > YYLAST || yycheck[yyn] != YYTERROR)
-    goto yyerrdefault;
-
-  yyn = yytable[yyn];
-  if (yyn < 0)
-    {
-      if (yyn == YYFLAG)
-	goto yyerrpop;
-      yyn = -yyn;
-      goto yyreduce;
-    }
-  else if (yyn == 0)
-    goto yyerrpop;
-
-  if (yyn == YYFINAL)
-    YYACCEPT;
-
-#if YYDEBUG != 0
-  if (yydebug)
-    fprintf(stderr, "Shifting error token, ");
-#endif
-
-  *++yyvsp = yylval;
-#ifdef YYLSP_NEEDED
-  *++yylsp = yylloc;
-#endif
-
-  yystate = yyn;
-  goto yynewstate;
-
- yyacceptlab:
-  /* YYACCEPT comes here.  */
-  if (yyfree_stacks)
-    {
-      free (yyss);
-      free (yyvs);
-#ifdef YYLSP_NEEDED
-      free (yyls);
-#endif
-    }
-  return 0;
-
- yyabortlab:
-  /* YYABORT comes here.  */
-  if (yyfree_stacks)
-    {
-      free (yyss);
-      free (yyvs);
-#ifdef YYLSP_NEEDED
-      free (yyls);
-#endif
-    }
-  return 1;
-}
-#line 544 "gramma.yy"
-
-
-FILE *yyin;
-
-// Experimental replacement of somttype
-char * mysomttype(SOMTTypes ttype)
-{
-  char * result=NULL;
-  switch ( ttype )
-  {
-    case SOMTAnyBE:
-      result="SOMTAnyBE";
-      break;
-    case     SOMTArgumentE:
-      result="SOMTArgumentE";
-      break;
-    case     SOMTAttE:
-      result="SOMTAttE";
-      break;
-    case     SOMTBadEntryE:
-      result="SOMTBadEntryE";
-      break;
-    case     SOMTBaseE:
-      result="SOMTBaseE";
-      break;
-    case     SOMTBooleanBE:
-      result="SOMTBooleanBE";
-      break;
-    case     SOMTCaseEntryE:
-      result="SOMTCaseEntryE";
-      break;
-    case     SOMTCaseListE:
-      result="SOMTCaseListE";
-      break;
-    case     SOMTCaseSTME:
-      result="SOMTCaseSTME";
-      break;
-    case     SOMTCharBE:
-      result="SOMTCharBE";
-      break;
-    case     SOMTClassE:
-      result="SOMTClassE";
-      break;
-    case     SOMTConstE:
-      result="SOMTConstE";
-      break;
-    case     SOMTCopyrightE:
-      result="SOMTCopyrightE";
-      break;
-    case     SOMTDataE:
-      result="SOMTDataE";
-      break;
-    case     SOMTDclListE:
-      result="SOMTDclListE";
-      break;
-    case     SOMTDefaultE:
-      result="SOMTDefaultE";
-      break;
-    case     SOMTDoubleBE:
-      result="SOMTDoubleBE";
-      break;
-    case     SOMTEBaseE:
-      result="SOMTEBaseE";
-      break;
-    case     SOMTEEnumE:
-      result="SOMTEEnumE";
-      break;
-    case     SOMTEnumBE:
-      result="SOMTEnumBE";
-      break;
-    case     SOMTEnumE:
-      result="SOMTEnumE";
-      break;
-    case     SOMTEnumPE:
-      result="SOMTEnumPE";
-      break;
-    case     SOMTFloatBE:
-      result="SOMTFloatBE";
-      break;
-    case     SOMTGroupE:
-      result="SOMTGroupE";
-      break;
-    case     SOMTLongBE:
-      result="SOMTLongBE";
-      break;
-    case     SOMTMetaE:
-      result="SOMTMetaE";
-      break;
-    case     SOMTModuleE:
-      result="SOMTModuleE";
-      break;
-    case     SOMTNegativeBE:
-      result="SOMTNegativeBE";
-      break;
-    case     SOMTNewMethodE:
-      result="SOMTNewMethodE";
-      break;
-    case     SOMTOctetBE:
-      result="SOMTOctetBE";
-      break;
-    case     SOMTOverriddenMethodE:
-      result="SOMTOverriddenMethodE";
-      break;
-    case     SOMTOverrideMethodE:
-      result="SOMTOverrideMethodE";
-      break;
-    case     SOMTPassthruE:
-      result="SOMTPassthruE";
-      break;
-    case     SOMTSequenceE:
-      result="SOMTSequenceE";
-      break;
-    case     SOMTSequenceTDE:
-      result="SOMTSequenceTDE";
-      break;
-    case     SOMTShortBE:
-      result="SOMTShortBE";
-      break;
-    case     SOMTStringBE:
-      result="SOMTStringBE";
-      break;
-    case     SOMTStringE:
-      result="SOMTStringE";
-      break;
-    case     SOMTStructE:
-      result="SOMTStructE";
-      break;
-    case     SOMTStructPE:
-      result="SOMTStructPE";
-      break;
-    case     SOMTStructSE:
-      result="SOMTStructSE";
-      break;
-    case     SOMTTyDclE:
-      result="SOMTTyDclE";
-      break;
-    case     SOMTTypeCodeBE:
-      result="SOMTTypeCodeBE";
-      break;
-    case     SOMTTypedefBE:
-      result="SOMTTypedefBE";
-      break;
-    case     SOMTTypedefE:
-      result="SOMTTypedefE";
-      break;
-    case     SOMTUnionE:
-      result="SOMTUnionE";
-      break;
-    case     SOMTUnionPE:
-      result="SOMTUnionPE";
-      break;
-    case     SOMTUnionSE:
-      result="SOMTUnionSE";
-      break;
-    case     SOMTUnsignedLongBE:
-      result="SOMTUnsignedLongBE";
-      break;
-    case     SOMTUnsignedShortBE:
-      result="SOMTUnsignedShortBE";
-      break;
-    case     SOMTVoidBE:
-      result="SOMTVoidBE";
-      break;
-    case     SOMTVoidPtrBE:
-      result="SOMTVoidPtrBE";
-      break;
-// This is special case SOMTTypes used on call of emitter start and emitter end
-/*    case     SOMTEmitterBeginE:
-      result="SOMTEmitterBeginE";
-      break;
-    case     SOMTEmitterEndE:
-      result="SOMTEmitterEndE";
-      break; */
-    default:
-      printf("Unknown entry type: %d.\n", ttype);
-  }
-  return result;
-}
-
-void dumpReleaseOrder(char * name, AttList *ap)
-{
-  AttList *cur=ap;
-
-  for(; cur; cur = cur->next) 
-  {
-    printf("\t%s %s\n", name, cur->name);
-//    dumpAttrs("static", cur->staticlist);
-//    dumpAttrs("protectted", cur->protectedlist);
-//    dumpAttrs("public", cur->publiclist);
-//    dumpAttrs("private", cur->privatelist);
-  }
-}
-
-void dumpMethodOrData(Entry * ep)
-{
-  printf("\teptype = %08p\n", ep->u.m.eptype);
-  printf("\tptrs = %08p\n", ep->u.m.ptrs);
-  printf("\tarray = %08p\n", ep->u.m.array);
-  printf("\tarrays = %s\n", ep->u.m.arrays);
-  printf("\tdefn = %s\n", ep->u.m.defn);
-  printf("\ttype = %s\n", ep->u.m.type);
-  printf("\tvarargs = %s\n", ep->u.m.varargs ? "true" : "false");
-  printf("\tprivate = %s\n", ep->u.m.isprivate ? "true" : "false");
-  printf("\tinout = %d\n", ep->u.m.inoutmode);
-  printf("\tselfref = %s\n", ep->u.m.isselfref ? "true" : "false");
-  printf("\toneway = %s\n", ep->u.m.isoneway ? "true" : "false");
-  printf("\targcnt = %d\n", ep->u.m.argcnt);
-  printf("\targs = %08p\n", ep->u.m.args);
-  printf("\tomethod = %08p\n", ep->u.m.omethod);
-  printf("\toparent = %08p\n", ep->u.m.oparent);
-  printf("\tgroup = %08p\n", ep->u.m.group);
-  printf("\tnext = %08p\n", ep->u.m.next);
-  printf("\tctxsa = %08p\n", ep->u.m.ctxsa);
-  printf("\traiseslist = %08p\n", ep->u.m.raiseslist);
-}
-
-void mysomtShowEntry(Entry * ep)
-{
-  if (ep)
-  {
-    printf("      somtShowEntry: Entry at %08p, name = %s, type = %d\n", ep, ep->name, ep->type);
-    printf("\tlineno = %d\n", ep->lineno);
-    switch ( ep->type )
-    {
-      case SOMTAnyBE:
-        printf("\t SOMTAnyBE\n");
-        break;
-      case     SOMTArgumentE:
-        printf("\t SOMTArgumentE\n");
-        dumpMethodOrData(ep);
-        break;
-      case     SOMTAttE:
-        printf("\t SOMTAttE\n");
-        break;
-      case     SOMTBadEntryE:
-        printf("\t SOMTBadEntryE\n");
-        break;
-      case     SOMTBaseE:
-        printf("\t SOMTBaseE\n");
-        printf("\tparentdef = %08p\n", ep->u.p.parentdef);
-        break;
-      case     SOMTBooleanBE:
-        printf("\t SOMTBooleanBE\n");
-        break;
-      case     SOMTCaseEntryE:
-        printf("\t SOMTCaseEntryE\n");
-        break;
-      case     SOMTCaseListE:
-        printf("\t SOMTCaseListE\n");
-        break;
-      case     SOMTCaseSTME:
-        printf("\t SOMTCaseSTME\n");
-        break;
-      case     SOMTCharBE:
-        printf("\t SOMTCharBE\n");
-        break;
-      case     SOMTClassE:
-        printf("\tClass Definition Entry:\n");
-        printf("\tfile = %s\n", ep->u.c.file);
-        printf("\tmeta = %08p\n", ep->u.c.meta);
-        printf("\tparent = %08p\n", ep->u.c.parent);
-        printf("\tparents = %08p\n", ep->u.c.parents);
-        printf("\trelease = %08p\n", ep->u.c.release);
-	dumpReleaseOrder("\t", ep->u.c.release);
-        printf("\tpassthru = %08p\n", ep->u.c.passthrus);
-        printf("\tdata = %08p\n", ep->u.c.data);
-        printf("\ttc = %08p\n", ep->tc);
-        printf("\tmethodcnt = %08d\n", ep->u.c.methodcnt);
-        printf("\tmethods = %08p\n", ep->u.c.methods);
-        printf("\tinherited = %08p\n", ep->u.c.inherited);
-        printf("\tpubdefs = %08p\n", ep->u.c.pubdefs);
-        printf("\tmod = %08p\n", ep->u.c.mod);
-        printf("\tcls = %08p\n", ep->u.c.cls);
-        printf("\tforward = %s\n", ep->u.c.isforward ? "true" : "false");
-        break;
-      case     SOMTConstE:
-        printf("\t SOMTConstE\n");
-        break;
-      case     SOMTCopyrightE:
-        printf("\t SOMTCopyrightE\n");
-        break;
-      case     SOMTDataE:
-        printf("\t SOMTDataE\n");
-        dumpMethodOrData(ep);
-        break;
-      case     SOMTDclListE:
-        printf("\t SOMTDclListE\n");
-        break;
-      case     SOMTDefaultE:
-        printf("\t SOMTDefaultE\n");
-        break;
-      case     SOMTDoubleBE:
-        printf("\t SOMTDoubleBE\n");
-        break;
-      case     SOMTEBaseE:
-        printf("\t SOMTEBaseE\n");
-        break;
-      case     SOMTEEnumE:
-        printf("\t SOMTEEnumE\n");
-        break;
-      case     SOMTEnumBE:
-        printf("\t SOMTEnumBE\n");
-        break;
-      case     SOMTEnumE:
-        printf("\t SOMTEnumE\n");
-        break;
-      case     SOMTEnumPE:
-        printf("\t SOMTEnumPE\n");
-        break;
-      case     SOMTFloatBE:
-        printf("\t SOMTFloatBE\n");
-        break;
-      case     SOMTGroupE:
-        printf("\t SOMTGroupE\n");
-        break;
-      case     SOMTLongBE:
-        printf("\t SOMTLongBE\n");
-        break;
-      case     SOMTMetaE:
-        printf("\t SOMTMetaE\n");
-        break;
-      case     SOMTModuleE:
-        printf("\t SOMTModuleE\n");
-        break;
-      case     SOMTNegativeBE:
-        printf("\t SOMTNegativeBE\n");
-        break;
-      case     SOMTNewMethodE:
-        printf("\t SOMTNewMethodE\n");
-        dumpMethodOrData(ep);
-        break;
-      case     SOMTOctetBE:
-        printf("\t SOMTOctetBE\n");
-        break;
-      case     SOMTOverriddenMethodE:
-        printf("\t SOMTOverriddenMethodE\n");
-        dumpMethodOrData(ep);
-        break;
-      case     SOMTOverrideMethodE:
-        printf("\t SOMTOverrideMethodE\n");
-        dumpMethodOrData(ep);
-        break;
-      case     SOMTPassthruE:
-        printf("\t SOMTPassthruE\n");
-        break;
-      case     SOMTSequenceE:
-        printf("\t SOMTSequenceE\n");
-        break;
-      case     SOMTSequenceTDE:
-        printf("\t SOMTSequenceTDE\n");
-        break;
-      case     SOMTShortBE:
-        printf("\t SOMTShortBE\n");
-        break;
-      case     SOMTStringBE:
-        printf("\t SOMTStringBE\n");
-        break;
-      case     SOMTStringE:
-        printf("\t SOMTStringE\n");
-        break;
-      case     SOMTStructE:
-        printf("\t SOMTStructE\n");
-        break;
-      case     SOMTStructPE:
-        printf("\t SOMTStructPE\n");
-        break;
-      case     SOMTStructSE:
-        printf("\t SOMTStructSE\n");
-        printf("\tdcllist = %08p\n", ep->u.struc.dcllist);
-        printf("\tcls = %08p\n", ep->u.struc.cls);
-        printf("\texception = %s\n", ep->u.struc.isexcept ? "true" : "false");
-        printf("\tmutref = %s\n", ep->u.struc.ismutref ? "true" : "false");
-        break;
-      case     SOMTTyDclE:
-        printf("\t SOMTTyDclE\n");
-        break;
-      case     SOMTTypeCodeBE:
-        printf("\t SOMTTypeCodeBE\n");
-        break;
-      case     SOMTTypedefBE:
-        printf("\t SOMTTypedefBE\n");
-        dumpMethodOrData(ep);
-        break;
-      case     SOMTTypedefE:
-        printf("\t SOMTTypedefE\n");
-        break;
-      case     SOMTUnionE:
-        printf("\t SOMTUnionE\n");
-        break;
-      case     SOMTUnionPE:
-        printf("\t SOMTUnionPE\n");
-        break;
-      case     SOMTUnionSE:
-        printf("\t SOMTUnionSE\n");
-        break;
-      case     SOMTUnsignedLongBE:
-        printf("\t SOMTUnsignedLongBE\n");
-        break;
-      case     SOMTUnsignedShortBE:
-        printf("\t SOMTUnsignedShortBE\n");
-        break;
-      case     SOMTVoidBE:
-        printf("\t SOMTVoidBE\n");
-        break;
-      case     SOMTVoidPtrBE:
-        printf("\t SOMTVoidPtrBE\n");
-        dumpMethodOrData(ep);
-        break;
-  // This is special case SOMTTypes used on call of emitter start and emitter end
-  /*    case     SOMTEmitterBeginE:
-        result="SOMTEmitterBeginE";
-        break;
-      case     SOMTEmitterEndE:
-        result="SOMTEmitterEndE";
-        break; */
-      default:
-        printf("Error: somtShowEntry, bad entry type of %d", ep->type);
-//        SOM_Error(SOM_Fatal, __FILE__, __LINE__);
-//        SOMError(9, __FILE__, __LINE__);
-    }
-  }
-  else 
-  {
-    printf("somtShowEntry: NULL entry\n");
-  }
-}
-
-dumpAttrs(AttList *ap)
-{
-  struct AttList *cur = ap;
-
-  for(cur = ap; cur; cur = cur->next) 
-  {
-    printf("\tModifier %s=%s\n", cur->name, cur->value);
-  }
-}
-
-
-void mydumpEntry(Entry * ep)
-{
-  printf("Entry at address %p\n", ep);
-  printf("--------------------------\n");
-  printf("Entry type: %s (%d)\n", mysomttype(ep->type), ep->type);
-//  printf("Entry type: %s (%d)\n", somtEntryTypeName(ep->type), ep->type);
-  if (ep->sname) printf("Scoped name: %s\n", *ep->sname);
-  if (ep->comment) printf("Comment associated with entry: %s\n", ep->comment);
-  printf("Modifiers: %p\n", ep->atts);
-  if (ep->atts) dumpAttrs(ep->atts);
-  printf("TypeCode: %p\n", ep->tc);
-  printf("Points to the object: %p\n", ep->objref);
-  printf("Reference to real type: %s\n", ep->isref ? "true" : "false");
-  printf("Entry union: %p\n", &ep->u);
-#ifdef __PRIVATE__
-//    RHBelement *data;
-//    char *filestem;
-#endif    
-  mysomtShowEntry(ep);
-//  somtShowEntry(ep);
-};
-
-void dumpSep(Sep * sep)
-{
-    printf("Linked list item at address %p\n", sep);
-    printf("---------------------------------------\n");
-    printf("Position number: %d\n", sep->posn);
-    printf("Address of Entry: %p\n", sep->ep);
-    printf("Next linked list item address: %p\n", sep->next);
-    if (sep->ep) 
-    {
-      mydumpEntry((Entry *)sep->ep);
-      dumpSep(sep->next);
-    }
-}
-
-void dumpStab(Stab * stab)
-{
-  printf("Basic Symbol Table/Hash table (STab) structure\n");
-  printf("----------------------------------------------\n");
-  printf("Size of buscet: %d\n", stab->size);
-  printf("Size of entry structure: %d\n", stab->entrysize);
-  printf("Number of elements: %d\n", stab->nelms);
-  printf("Address of base slot: %p\n", stab->base);
-  printf("Max address of slot: %p\n", stab->limit);
-  printf("Start address of slot buffer: %p\n", stab->buf);
-  printf("Address of MemBuf: %p\n", stab->membuf);
-  printf("Ignore case flag: %s\n", stab->ignorecase ? "true" : "false");
-  for(unsigned int i=0; i<stab->size;i++)
-  {
-    printf("Linked list at slot %d at offset %08x at address %p\n", i, sizeof(Sep)*i, stab->buf+i);
-    printf("----------------------\n");
-    dumpSep(stab->buf+i);
-  }
-};
-
-
-void usage(void)
-{
-  printf("\nSC [-options] file[.CSC]\n");
-  printf("\n-C n\n\tset the size of the comment buffer (default: 16384)\n");
-  printf("\n-s n\n\tset the total amount of string space for names and passthru lines (default: 32768)\n");
-  printf("\n-V\n\tdisplay version information\n");
-  printf("\n-a name[=value]\n\tadd a global attribute. The currently supported attributes are defined below (at the end of this section)\n");
-  printf("\n-d directory\n\tspecify a directory where all files emitted during the execution of this command should be placed. If the -d option is not used, all emitted output files are placed in the same directory as the input .csc file\n");
-  printf("\n-h or ?\n\tprovide usage information for reference\n");
-  printf("\n-i filename\n\tspecify the name of the OIDL class definition file. Use this option to override the built-in assumption that the input file will have a .csc extension. Any filename you supply with the -i option is used exactly as you provide it\n");
-  printf("\n-r\n\tcheck that all release-order entries actually exist (default: FALSE)\n");
-  printf("\n-s string\n\tsubstitute string in place of the contents of the SMEMIT environment variable for the duration of the current SC command. If you supply a list of values, you\n");
-  printf("must enclose the list with double quotation marks (\" \"). You can use the -s option as a convenient way to override the SMEMIT environment variable. For example:\n\n");
-  printf("SC -s \"h;sc\" EXAMPLE\n\n");
-  printf("is equivalent to the following sequence of commands:\n\n");
-  printf("SET OLDSMEMIT = %%SMEMIT%%\n");
-  printf("SET SMEMIT = h;sc\n");
-  printf("SC EXAMPLE\n");
-  printf("SET SMEMIT = %%OLDSMEMIT%%\n");
-  printf("\n-w\n\tsuppress warning messages (default: FALSE)\n\n");
-  printf("The only global attributes currently supported by SC.EXE are:\n");
-  printf("\ncomment = comment string\n\twhere comment string can be one of the following: \"/*\", \"--\", or \"//\". This\n");
-  printf("indicates that comments marked in the indicated way are to be completely\n");
-  printf("ignored by SC.EXE and not retained for subsequent processing by one of the\n");
-  printf("emitters.\n");
-  printf("Note: Comments indicated by lines whose first non-white-space character is\n");
-  printf("a # are always ignored by SC.EXE. Also note that comments of any\n");
-  printf("form in passthru lines are passed through.\n");
-  printf("\ncstyle = comment style\n\tcontrols the form of emitted comments. Comment style must be one of s, c, or\n");
-  printf("+ to cause emitted comments to be in \"--\", \"/* */\", or \"//\" form , respectively\n");
-  printf("The default form is s\n");
-  printf("\nibmc\n\tcauses EMITC, EMITH, EMITIH, EMITPH, and EMITDEF to generate code with\n");
-  printf("pragmas specifically intended for the IBM C Set/2 Compiler. This attribute is\n");
-  printf("specified by default\n");
-  printf("\ncl386\n\tcauses EMITC, EMITH, EMITIH, EMITPH, and EMITDEF not to generate code\n");
-  printf("with pragmas specifically intended for the IBM C Set/2 Compiler\n");
-}
-
-void parse_file(char * file)
-{
-  // parser input stream
-  yyin=fopen(file,"r");
-
-  strcpy(somtfilePath, file);
-
-  // Initialize symbol table
-  somtstab=(Stab *)somtsmallocSL(sizeof(Stab), 0);
-  somtcreateStabSL(somtstab, HASH_SIZE, sizeof(Entry));
-
-  yyparse();
-
-  dumpStab(somtstab);
-}
-
-void emit_file(char * file)
-{
-   EmitFn proc;
-   FILE * fp;
-   HMODULE hmod;
-   Entry * root;
-   Stab * stab;
-
-   proc=somtloadSL("emitpsc.dll", "emitSL", &hmod);
-
-   fp=proc(file, root, stab);
-
-   if (fp) somtfcloseSL(fp);
-}
-
-void main(int argc, char *argv[])
-{
-   yydebug =1 ;
-
-//   parse_args(argc, argv);
-
-   usage();
-
-   parse_file(argv[1]);
-
-//   dump();
-
-//   emit_file(argv[1]);
-}
diff -urN somfree/somopc/src/gramma.yy.tab.h newsomfree/somopc/src/gramma.yy.tab.h
--- somfree/somopc/src/gramma.yy.tab.h	Sat Jun 29 21:47:30 2024
+++ newsomfree/somopc/src/gramma.yy.tab.h	Thu Jan 01 07:00:00 1970
@@ -1,56 +0,0 @@
-typedef union{
- char *stval;
- int ival;
-} YYSTYPE;
-#define	T_CONSTANT	257
-#define	T_COLON	258
-#define	T_SEMICOLON	259
-#define	T_COMMA	260
-#define	T_STAR	261
-#define	T_COMMENT	262
-#define	T_IDENTIFIER	263
-#define	T_EQUAL	264
-#define	T_DASHES	265
-#define	T_PERIOD	266
-#define	T_ELLIPSIS	267
-#define	T_LEFTPARENTHESIS	268
-#define	T_RIGHTPARENTHESIS	269
-#define	T_LEFTSQUAREBRACKET	270
-#define	T_RIGHTSQUAREBRACKET	271
-#define	T_VERSION	272
-#define	T_GLOBAL	273
-#define	T_LOCAL	274
-#define	T_CLASSINIT	275
-#define	T_RELEASE	276
-#define	T_ORDER	277
-#define	T_METACLASS	278
-#define	T_PARENT	279
-#define	T_CLASS	280
-#define	T_FILE	281
-#define	T_STEM	282
-#define	T_FUNCTION	283
-#define	T_PREFIX	284
-#define	T_CLASSPREFIX	285
-#define	T_MAJOR	286
-#define	T_MINOR	287
-#define	T_PASSTHRU	288
-#define	T_BEFORE	289
-#define	T_AFTER	290
-#define	T_ENDPASSTHRU	291
-#define	T_DATA	292
-#define	T_PRIVATE	293
-#define	T_PUBLIC	294
-#define	T_INTERNAL	295
-#define	T_METHODS	296
-#define	T_GROUP	297
-#define	T_METHOD	298
-#define	T_PROCEDURE	299
-#define	T_OFFSET	300
-#define	T_NAME	301
-#define	T_LOOKUP	302
-#define	T_EXTERNAL	303
-#define	T_USE	304
-#define	T_OVERRIDE	305
-
-
-extern YYSTYPE yylval;
diff -urN somfree/somopc/src/lex.yy.c newsomfree/somopc/src/lex.yy.c
--- somfree/somopc/src/lex.yy.c	Sat Jun 29 21:47:30 2024
+++ newsomfree/somopc/src/lex.yy.c	Thu Jan 01 07:00:00 1970
@@ -1,1923 +0,0 @@
-/* A lexical scanner generated by flex */
-
-/* Scanner skeleton version:
- * $Header: /home/daffy/u0/vern/flex/RCS/flex.skl,v 2.91 96/09/10 16:58:48 vern Exp $
- */
-
-#define FLEX_SCANNER
-#define YY_FLEX_MAJOR_VERSION 2
-#define YY_FLEX_MINOR_VERSION 5
-
-#ifdef __CRTRSXNT__
-#include <crtrsxnt.h>
-#endif
-#include <stdio.h>
-
-
-/* cfront 1.2 defines "c_plusplus" instead of "__cplusplus" */
-#ifdef c_plusplus
-#ifndef __cplusplus
-#define __cplusplus
-#endif
-#endif
-
-
-#ifdef __cplusplus
-
-#include <stdlib.h>
-#include <unistd.h>
-
-/* Use prototypes in function declarations. */
-#define YY_USE_PROTOS
-
-/* The "const" storage-class-modifier is valid. */
-#define YY_USE_CONST
-
-#else	/* ! __cplusplus */
-
-#if __STDC__
-
-#define YY_USE_PROTOS
-#define YY_USE_CONST
-
-#endif	/* __STDC__ */
-#endif	/* ! __cplusplus */
-
-#ifdef __TURBOC__
- #pragma warn -rch
- #pragma warn -use
-#include <io.h>
-#include <stdlib.h>
-#define YY_USE_CONST
-#define YY_USE_PROTOS
-#endif
-
-#ifdef YY_USE_CONST
-#define yyconst const
-#else
-#define yyconst
-#endif
-
-
-#ifdef YY_USE_PROTOS
-#define YY_PROTO(proto) proto
-#else
-#define YY_PROTO(proto) ()
-#endif
-
-/* Returned upon end-of-file. */
-#define YY_NULL 0
-
-/* Promotes a possibly negative, possibly signed char to an unsigned
- * integer for use as an array index.  If the signed char is negative,
- * we want to instead treat it as an 8-bit unsigned char, hence the
- * double cast.
- */
-#define YY_SC_TO_UI(c) ((unsigned int) (unsigned char) c)
-
-/* Enter a start condition.  This macro really ought to take a parameter,
- * but we do it the disgusting crufty way forced on us by the ()-less
- * definition of BEGIN.
- */
-#define BEGIN yy_start = 1 + 2 *
-
-/* Translate the current start state into a value that can be later handed
- * to BEGIN to return to the state.  The YYSTATE alias is for lex
- * compatibility.
- */
-#define YY_START ((yy_start - 1) / 2)
-#define YYSTATE YY_START
-
-/* Action number for EOF rule of a given start state. */
-#define YY_STATE_EOF(state) (YY_END_OF_BUFFER + state + 1)
-
-/* Special action meaning "start processing a new file". */
-#define YY_NEW_FILE yyrestart( yyin )
-
-#define YY_END_OF_BUFFER_CHAR 0
-
-/* Size of default input buffer. */
-#define YY_BUF_SIZE 16384
-
-typedef struct yy_buffer_state *YY_BUFFER_STATE;
-
-extern int yyleng;
-extern FILE *yyin, *yyout;
-
-#define EOB_ACT_CONTINUE_SCAN 0
-#define EOB_ACT_END_OF_FILE 1
-#define EOB_ACT_LAST_MATCH 2
-
-/* The funky do-while in the following #define is used to turn the definition
- * int a single C statement (which needs a semi-colon terminator).  This
- * avoids problems with code like:
- *
- * 	if ( condition_holds )
- *		yyless( 5 );
- *	else
- *		do_something_else();
- *
- * Prior to using the do-while the compiler would get upset at the
- * "else" because it interpreted the "if" statement as being all
- * done when it reached the ';' after the yyless() call.
- */
-
-/* Return all but the first 'n' matched characters back to the input stream. */
-
-#define yyless(n) \
-	do \
-		{ \
-		/* Undo effects of setting up yytext. */ \
-		*yy_cp = yy_hold_char; \
-		YY_RESTORE_YY_MORE_OFFSET \
-		yy_c_buf_p = yy_cp = yy_bp + n - YY_MORE_ADJ; \
-		YY_DO_BEFORE_ACTION; /* set up yytext again */ \
-		} \
-	while ( 0 )
-
-#define unput(c) yyunput( c, yytext_ptr )
-
-/* The following is because we cannot portably get our hands on size_t
- * (without autoconf's help, which isn't available because we want
- * flex-generated scanners to compile on their own).
- */
-typedef unsigned int yy_size_t;
-
-
-struct yy_buffer_state
-	{
-	FILE *yy_input_file;
-
-	char *yy_ch_buf;		/* input buffer */
-	char *yy_buf_pos;		/* current position in input buffer */
-
-	/* Size of input buffer in bytes, not including room for EOB
-	 * characters.
-	 */
-	yy_size_t yy_buf_size;
-
-	/* Number of characters read into yy_ch_buf, not including EOB
-	 * characters.
-	 */
-	int yy_n_chars;
-
-	/* Whether we "own" the buffer - i.e., we know we created it,
-	 * and can realloc() it to grow it, and should free() it to
-	 * delete it.
-	 */
-	int yy_is_our_buffer;
-
-	/* Whether this is an "interactive" input source; if so, and
-	 * if we're using stdio for input, then we want to use getc()
-	 * instead of fread(), to make sure we stop fetching input after
-	 * each newline.
-	 */
-	int yy_is_interactive;
-
-	/* Whether we're considered to be at the beginning of a line.
-	 * If so, '^' rules will be active on the next match, otherwise
-	 * not.
-	 */
-	int yy_at_bol;
-
-	/* Whether to try to fill the input buffer when we reach the
-	 * end of it.
-	 */
-	int yy_fill_buffer;
-
-	int yy_buffer_status;
-#define YY_BUFFER_NEW 0
-#define YY_BUFFER_NORMAL 1
-	/* When an EOF's been seen but there's still some text to process
-	 * then we mark the buffer as YY_EOF_PENDING, to indicate that we
-	 * shouldn't try reading from the input source any more.  We might
-	 * still have a bunch of tokens to match, though, because of
-	 * possible backing-up.
-	 *
-	 * When we actually see the EOF, we change the status to "new"
-	 * (via yyrestart()), so that the user can continue scanning by
-	 * just pointing yyin at a new input file.
-	 */
-#define YY_BUFFER_EOF_PENDING 2
-	};
-
-static YY_BUFFER_STATE yy_current_buffer = 0;
-
-/* We provide macros for accessing buffer states in case in the
- * future we want to put the buffer states in a more general
- * "scanner state".
- */
-#define YY_CURRENT_BUFFER yy_current_buffer
-
-
-/* yy_hold_char holds the character lost when yytext is formed. */
-static char yy_hold_char;
-
-static int yy_n_chars;		/* number of characters read into yy_ch_buf */
-
-
-int yyleng;
-
-/* Points to current character in buffer. */
-static char *yy_c_buf_p = (char *) 0;
-static int yy_init = 1;		/* whether we need to initialize */
-static int yy_start = 0;	/* start state number */
-
-/* Flag which is used to allow yywrap()'s to do buffer switches
- * instead of setting up a fresh yyin.  A bit of a hack ...
- */
-static int yy_did_buffer_switch_on_eof;
-
-void yyrestart YY_PROTO(( FILE *input_file ));
-
-void yy_switch_to_buffer YY_PROTO(( YY_BUFFER_STATE new_buffer ));
-void yy_load_buffer_state YY_PROTO(( void ));
-YY_BUFFER_STATE yy_create_buffer YY_PROTO(( FILE *file, int size ));
-void yy_delete_buffer YY_PROTO(( YY_BUFFER_STATE b ));
-void yy_init_buffer YY_PROTO(( YY_BUFFER_STATE b, FILE *file ));
-void yy_flush_buffer YY_PROTO(( YY_BUFFER_STATE b ));
-#define YY_FLUSH_BUFFER yy_flush_buffer( yy_current_buffer )
-
-YY_BUFFER_STATE yy_scan_buffer YY_PROTO(( char *base, yy_size_t size ));
-YY_BUFFER_STATE yy_scan_string YY_PROTO(( yyconst char *yy_str ));
-YY_BUFFER_STATE yy_scan_bytes YY_PROTO(( yyconst char *bytes, int len ));
-
-static void *yy_flex_alloc YY_PROTO(( yy_size_t ));
-static void *yy_flex_realloc YY_PROTO(( void *, yy_size_t ));
-static void yy_flex_free YY_PROTO(( void * ));
-
-#define yy_new_buffer yy_create_buffer
-
-#define yy_set_interactive(is_interactive) \
-	{ \
-	if ( ! yy_current_buffer ) \
-		yy_current_buffer = yy_create_buffer( yyin, YY_BUF_SIZE ); \
-	yy_current_buffer->yy_is_interactive = is_interactive; \
-	}
-
-#define yy_set_bol(at_bol) \
-	{ \
-	if ( ! yy_current_buffer ) \
-		yy_current_buffer = yy_create_buffer( yyin, YY_BUF_SIZE ); \
-	yy_current_buffer->yy_at_bol = at_bol; \
-	}
-
-#define YY_AT_BOL() (yy_current_buffer->yy_at_bol)
-
-typedef unsigned char YY_CHAR;
-FILE *yyin = (FILE *) 0, *yyout = (FILE *) 0;
-typedef int yy_state_type;
-extern char *yytext;
-#define yytext_ptr yytext
-
-static yy_state_type yy_get_previous_state YY_PROTO(( void ));
-static yy_state_type yy_try_NUL_trans YY_PROTO(( yy_state_type current_state ));
-static int yy_get_next_buffer YY_PROTO(( void ));
-static void yy_fatal_error YY_PROTO(( yyconst char msg[] ));
-
-/* Done after the current pattern has been matched and before the
- * corresponding action - sets up yytext.
- */
-#define YY_DO_BEFORE_ACTION \
-	yytext_ptr = yy_bp; \
-	yyleng = (int) (yy_cp - yy_bp); \
-	yy_hold_char = *yy_cp; \
-	*yy_cp = '\0'; \
-	yy_c_buf_p = yy_cp;
-
-#define YY_NUM_RULES 55
-#define YY_END_OF_BUFFER 56
-static yyconst short int yy_accept[213] =
-    {   0,
-        0,    0,    0,    0,    0,    0,   56,   54,   52,   53,
-       18,   19,   17,   13,   54,   54,   54,   10,   11,   12,
-       14,   51,   20,   21,   51,   51,   51,   51,   51,   51,
-       51,   51,   51,   51,   51,   51,   51,   51,    4,    6,
-        5,    8,    9,    8,   52,   15,    0,    1,   10,   51,
-       51,   51,   51,   51,   51,   51,   51,   51,   51,   51,
-       51,   51,   51,   51,   51,   51,   51,   51,   51,   51,
-       51,   51,    4,    3,    8,    8,   16,   51,   51,   51,
-       51,   51,   51,   51,   51,   51,   51,   51,   51,   51,
-       51,   51,   51,   51,   51,   51,   51,   51,   51,   51,
-
-       51,   51,   51,    8,   51,   38,   51,   23,   51,   51,
-       51,   51,   51,   51,   51,   51,   51,   51,   47,   51,
-       51,   51,   51,   51,   51,   51,   51,   51,   51,   24,
-       51,    8,   22,   51,   51,   51,   43,   51,   32,   51,
-       28,   51,   51,   29,   51,   35,   51,   51,   51,   51,
-       51,   51,   51,   51,   51,    8,   51,   51,   51,   51,
-       31,   51,   48,   51,   44,   46,   51,   37,   51,   26,
-       51,   51,   40,   51,   51,    8,   51,   51,   51,   51,
-       51,   51,   42,   51,   51,   39,   51,   34,   30,    8,
-       51,   51,   49,   25,   41,   51,   50,   51,   51,    8,
-
-       33,   51,   36,    2,   45,    8,   51,    8,   27,    8,
-        7,    0
-    } ;
-
-static yyconst int yy_ec[256] =
-    {   0,
-        1,    1,    1,    1,    1,    1,    1,    1,    2,    3,
-        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
-        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
-        1,    2,    1,    1,    1,    1,    1,    1,    1,    4,
-        5,    6,    1,    7,    8,    9,   10,   11,   11,   11,
-       11,   11,   11,   11,   11,   11,   11,   12,   13,    1,
-       14,    1,    1,    1,   15,   15,   15,   15,   15,   15,
-       15,   15,   16,   15,   15,   15,   15,   15,   15,   15,
-       15,   15,   15,   15,   15,   15,   15,   15,   15,   15,
-       17,    1,   18,    1,   19,    1,   20,   21,   22,   23,
-
-       24,   25,   26,   27,   28,   29,   30,   31,   32,   33,
-       34,   35,   15,   36,   37,   38,   39,   40,   15,   41,
-       15,   15,    1,    1,    1,    1,    1,    1,    1,    1,
-        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
-        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
-        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
-        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
-        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
-        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
-        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
-
-        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
-        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
-        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
-        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
-        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
-        1,    1,    1,    1,    1
-    } ;
-
-static yyconst int yy_meta[42] =
-    {   0,
-        1,    1,    2,    1,    1,    3,    1,    1,    1,    1,
-        4,    1,    1,    1,    4,    4,    1,    1,    4,    4,
-        4,    4,    4,    4,    4,    4,    4,    4,    4,    4,
-        4,    4,    4,    4,    4,    4,    4,    4,    4,    4,
-        4
-    } ;
-
-static yyconst short int yy_base[218] =
-    {   0,
-        0,    0,   39,   40,   41,   44,  230,  231,  227,  231,
-      231,  231,  231,  231,  220,  218,  220,  214,  231,  231,
-      231,    0,  231,  231,  193,  203,  181,   20,   18,  188,
-      186,   32,  199,   26,   33,  194,  179,  192,    0,  231,
-      205,    0,  231,  181,  211,  231,  203,  231,  200,    0,
-      190,  171,  170,  176,  173,  171,  170,  165,   33,  173,
-      163,  167,  167,  173,  174,  172,   21,   46,  174,  163,
-      169,  156,    0,  231,    0,  168,  231,  153,  169,  164,
-      163,  164,  164,  145,  159,  162,  151,  146,   44,  145,
-      154,  140,  152,  139,  150,  136,  147,  131,  148,  138,
-
-      144,  135,  129,  130,  127,    0,  127,    0,  124,  141,
-      125,  123,  127,  118,  120,  133,  120,  117,    0,  128,
-      115,  114,  116,  110,  119,  126,  121,  116,  123,    0,
-      114,  121,   47,  107,  111,  107,    0,  104,    0,  101,
-        0,  104,  111,    0,   95,    0,  104,   93,  103,   88,
-       90,  104,  104,   88,   90,   86,   89,   85,  100,   85,
-        0,   98,    0,   97,   79,    0,   92,    0,   78,    0,
-       89,   73,    0,   87,   77,   72,   80,   83,   75,   72,
-       73,   66,    0,   78,   62,    0,   64,    0,    0,   61,
-       58,   68,    0,    0,    0,   55,    0,   69,   55,   51,
-
-        0,   49,    0,  231,    0,   40,   34,   34,    0,   48,
-        0,  231,   82,   86,   46,   90,   94
-    } ;
-
-static yyconst short int yy_def[218] =
-    {   0,
-      212,    1,  213,  213,  214,  214,  212,  212,  212,  212,
-      212,  212,  212,  212,  212,  212,  212,  212,  212,  212,
-      212,  215,  212,  212,  215,  215,  215,  215,  215,  215,
-      215,  215,  215,  215,  215,  215,  215,  215,  216,  212,
-      212,  217,  212,  217,  212,  212,  212,  212,  212,  215,
-      215,  215,  215,  215,  215,  215,  215,  215,  215,  215,
-      215,  215,  215,  215,  215,  215,  215,  215,  215,  215,
-      215,  215,  216,  212,  217,  217,  212,  215,  215,  215,
-      215,  215,  215,  215,  215,  215,  215,  215,  215,  215,
-      215,  215,  215,  215,  215,  215,  215,  215,  215,  215,
-
-      215,  215,  215,  217,  215,  215,  215,  215,  215,  215,
-      215,  215,  215,  215,  215,  215,  215,  215,  215,  215,
-      215,  215,  215,  215,  215,  215,  215,  215,  215,  215,
-      215,  217,  215,  215,  215,  215,  215,  215,  215,  215,
-      215,  215,  215,  215,  215,  215,  215,  215,  215,  215,
-      215,  215,  215,  215,  215,  217,  215,  215,  215,  215,
-      215,  215,  215,  215,  215,  215,  215,  215,  215,  215,
-      215,  215,  215,  215,  215,  217,  215,  215,  215,  215,
-      215,  215,  215,  215,  215,  215,  215,  215,  215,  217,
-      215,  215,  215,  215,  215,  215,  215,  215,  215,  217,
-
-      215,  215,  215,  212,  215,  217,  215,  217,  215,  217,
-      217,    0,  212,  212,  212,  212,  212
-    } ;
-
-static yyconst short int yy_nxt[273] =
-    {   0,
-        8,    9,   10,   11,   12,   13,   14,   15,   16,   17,
-       18,   19,   20,   21,   22,   22,   23,   24,    8,   22,
-       22,   25,   26,   27,   28,   29,   22,   30,   22,   22,
-       31,   32,   33,   34,   35,   36,   37,   22,   22,   38,
-       22,   40,   40,   43,   41,   41,   43,   54,   56,   50,
-       64,   60,   67,   57,   86,   61,   95,   96,   55,   62,
-      211,   65,  157,  116,   44,   66,   87,   44,   68,   97,
-      117,   69,  210,   98,  209,  208,  207,  206,  205,   99,
-      204,  158,   39,   39,   39,   39,   42,   42,   42,   42,
-       73,  203,  202,   73,   75,  201,   75,   75,  200,  199,
-
-      198,  197,  196,  195,  194,  193,  192,  191,  190,  189,
-      188,  187,  186,  185,  184,  183,  182,  181,  180,  179,
-      178,  177,  176,  175,  174,  173,  172,  171,  170,  169,
-      168,  167,  166,  165,  164,  163,  162,  161,  160,  159,
-      156,  155,  154,  153,  152,  151,  150,  149,  148,  147,
-      146,  145,  144,  143,  142,  141,  140,  139,  138,  137,
-      136,  135,  134,  133,  132,  131,  130,  129,  128,  127,
-      126,  125,  124,  123,  122,  121,  120,  119,  118,  115,
-      114,  113,  112,  111,  110,  109,  108,  107,  106,  105,
-      104,  103,  102,  101,  100,   94,   93,   92,   91,   90,
-
-       89,   88,   85,   84,   83,   82,   81,   80,   79,   78,
-       49,   77,   45,   76,   74,   72,   71,   70,   63,   59,
-       58,   53,   52,   51,   49,   48,   47,   46,   45,  212,
-        7,  212,  212,  212,  212,  212,  212,  212,  212,  212,
-      212,  212,  212,  212,  212,  212,  212,  212,  212,  212,
-      212,  212,  212,  212,  212,  212,  212,  212,  212,  212,
-      212,  212,  212,  212,  212,  212,  212,  212,  212,  212,
-      212,  212
-    } ;
-
-static yyconst short int yy_chk[273] =
-    {   0,
-        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
-        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
-        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
-        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
-        1,    3,    4,    5,    3,    4,    6,   28,   29,  215,
-       34,   32,   35,   29,   59,   32,   67,   67,   28,   32,
-      210,   34,  133,   89,    5,   34,   59,    6,   35,   68,
-       89,   35,  208,   68,  207,  206,  202,  200,  199,   68,
-      198,  133,  213,  213,  213,  213,  214,  214,  214,  214,
-      216,  196,  192,  216,  217,  191,  217,  217,  190,  187,
-
-      185,  184,  182,  181,  180,  179,  178,  177,  176,  175,
-      174,  172,  171,  169,  167,  165,  164,  162,  160,  159,
-      158,  157,  156,  155,  154,  153,  152,  151,  150,  149,
-      148,  147,  145,  143,  142,  140,  138,  136,  135,  134,
-      132,  131,  129,  128,  127,  126,  125,  124,  123,  122,
-      121,  120,  118,  117,  116,  115,  114,  113,  112,  111,
-      110,  109,  107,  105,  104,  103,  102,  101,  100,   99,
-       98,   97,   96,   95,   94,   93,   92,   91,   90,   88,
-       87,   86,   85,   84,   83,   82,   81,   80,   79,   78,
-       76,   72,   71,   70,   69,   66,   65,   64,   63,   62,
-
-       61,   60,   58,   57,   56,   55,   54,   53,   52,   51,
-       49,   47,   45,   44,   41,   38,   37,   36,   33,   31,
-       30,   27,   26,   25,   18,   17,   16,   15,    9,    7,
-      212,  212,  212,  212,  212,  212,  212,  212,  212,  212,
-      212,  212,  212,  212,  212,  212,  212,  212,  212,  212,
-      212,  212,  212,  212,  212,  212,  212,  212,  212,  212,
-      212,  212,  212,  212,  212,  212,  212,  212,  212,  212,
-      212,  212
-    } ;
-
-static yy_state_type yy_last_accepting_state;
-static char *yy_last_accepting_cpos;
-
-/* The intent behind this definition is that it'll catch
- * any uses of REJECT which flex missed.
- */
-#define REJECT reject_used_but_not_detected
-#define yymore() yymore_used_but_not_detected
-#define YY_MORE_ADJ 0
-#define YY_RESTORE_YY_MORE_OFFSET
-char *yytext;
-#line 1 "scanner.ll"
-#define INITIAL 0
-#line 2 "scanner.ll"
-
-#include <stdio.h>  // fopen
-#include <stdlib.h> // malloc, free, realloc
-#include <string.h> // strcat
-
-#include <emitlib.h>
-
-#include "gramma.yy.tab.h"
-
-int trace=1;
-int lineno=1, column=0;
-char comment[16384]; // handle with -C
-char passthru[32768]; // handle with -S
-
-#define IN_CPP_COMMENT 1
-
-#define IN_PASSTHRU 2
-
-#line 516 "lex.yy.c"
-
-/* Macros after this point can all be overridden by user definitions in
- * section 1.
- */
-
-#ifndef YY_SKIP_YYWRAP
-#ifdef __cplusplus
-extern "C" int yywrap YY_PROTO(( void ));
-#else
-extern int yywrap YY_PROTO(( void ));
-#endif
-#endif
-
-#ifndef YY_NO_UNPUT
-static void yyunput YY_PROTO(( int c, char *buf_ptr ));
-#endif
-
-#ifndef yytext_ptr
-static void yy_flex_strncpy YY_PROTO(( char *, yyconst char *, int ));
-#endif
-
-#ifdef YY_NEED_STRLEN
-static int yy_flex_strlen YY_PROTO(( yyconst char * ));
-#endif
-
-#ifndef YY_NO_INPUT
-#ifdef __cplusplus
-static int yyinput YY_PROTO(( void ));
-#else
-static int input YY_PROTO(( void ));
-#endif
-#endif
-
-#if YY_STACK_USED
-static int yy_start_stack_ptr = 0;
-static int yy_start_stack_depth = 0;
-static int *yy_start_stack = 0;
-#ifndef YY_NO_PUSH_STATE
-static void yy_push_state YY_PROTO(( int new_state ));
-#endif
-#ifndef YY_NO_POP_STATE
-static void yy_pop_state YY_PROTO(( void ));
-#endif
-#ifndef YY_NO_TOP_STATE
-static int yy_top_state YY_PROTO(( void ));
-#endif
-
-#else
-#define YY_NO_PUSH_STATE 1
-#define YY_NO_POP_STATE 1
-#define YY_NO_TOP_STATE 1
-#endif
-
-#ifdef YY_MALLOC_DECL
-YY_MALLOC_DECL
-#else
-#if __STDC__
-#ifndef __cplusplus
-#include <stdlib.h>
-#endif
-#else
-/* Just try to get by without declaring the routines.  This will fail
- * miserably on non-ANSI systems for which sizeof(size_t) != sizeof(int)
- * or sizeof(void*) != sizeof(int).
- */
-#endif
-#endif
-
-/* Amount of stuff to slurp up with each read. */
-#ifndef YY_READ_BUF_SIZE
-#define YY_READ_BUF_SIZE 8192
-#endif
-
-/* Copy whatever the last rule matched to the standard output. */
-
-#ifndef ECHO
-/* This used to be an fputs(), but since the string might contain NUL's,
- * we now use fwrite().
- */
-#define ECHO (void) fwrite( yytext, yyleng, 1, yyout )
-#endif
-
-/* Gets input and stuffs it into "buf".  number of characters read, or YY_NULL,
- * is returned in "result".
- */
-#ifndef YY_INPUT
-#define YY_INPUT(buf,result,max_size) \
-	if ( yy_current_buffer->yy_is_interactive ) \
-		{ \
-		int c = '*', n; \
-		for ( n = 0; n < max_size && \
-			     (c = getc( yyin )) != EOF && c != '\n'; ++n ) \
-			buf[n] = (char) c; \
-		if ( c == '\n' ) \
-			buf[n++] = (char) c; \
-		if ( c == EOF && ferror( yyin ) ) \
-			YY_FATAL_ERROR( "input in flex scanner failed" ); \
-		result = n; \
-		} \
-	else if ( ((result = fread( buf, 1, max_size, yyin )) == 0) \
-		  && ferror( yyin ) ) \
-		YY_FATAL_ERROR( "input in flex scanner failed" );
-#endif
-
-/* No semi-colon after return; correct usage is to write "yyterminate();" -
- * we don't want an extra ';' after the "return" because that will cause
- * some compilers to complain about unreachable statements.
- */
-#ifndef yyterminate
-#define yyterminate() return YY_NULL
-#endif
-
-/* Number of entries by which start-condition stack grows. */
-#ifndef YY_START_STACK_INCR
-#define YY_START_STACK_INCR 25
-#endif
-
-/* Report a fatal error. */
-#ifndef YY_FATAL_ERROR
-#define YY_FATAL_ERROR(msg) yy_fatal_error( msg )
-#endif
-
-/* Default declaration of generated scanner - a define so the user can
- * easily add parameters.
- */
-#ifndef YY_DECL
-#define YY_DECL int yylex YY_PROTO(( void ))
-#endif
-
-/* Code executed at the beginning of each rule, after yytext and yyleng
- * have been set up.
- */
-#ifndef YY_USER_ACTION
-#define YY_USER_ACTION
-#endif
-
-/* Code executed at the end of each rule. */
-#ifndef YY_BREAK
-#define YY_BREAK break;
-#endif
-
-#define YY_RULE_SETUP \
-	YY_USER_ACTION
-
-YY_DECL
-	{
-	register yy_state_type yy_current_state;
-	register char *yy_cp, *yy_bp;
-	register int yy_act;
-
-#line 22 "scanner.ll"
-
-
-#line 670 "lex.yy.c"
-
-	if ( yy_init )
-		{
-		yy_init = 0;
-
-#ifdef YY_USER_INIT
-		YY_USER_INIT;
-#endif
-
-		if ( ! yy_start )
-			yy_start = 1;	/* first start state */
-
-		if ( ! yyin )
-			yyin = stdin;
-
-		if ( ! yyout )
-			yyout = stdout;
-
-		if ( ! yy_current_buffer )
-			yy_current_buffer =
-				yy_create_buffer( yyin, YY_BUF_SIZE );
-
-		yy_load_buffer_state();
-		}
-
-	while ( 1 )		/* loops until end-of-file is reached */
-		{
-		yy_cp = yy_c_buf_p;
-
-		/* Support of yytext. */
-		*yy_cp = yy_hold_char;
-
-		/* yy_bp points to the position in yy_ch_buf of the start of
-		 * the current run.
-		 */
-		yy_bp = yy_cp;
-
-		yy_current_state = yy_start;
-yy_match:
-		do
-			{
-			register YY_CHAR yy_c = yy_ec[YY_SC_TO_UI(*yy_cp)];
-			if ( yy_accept[yy_current_state] )
-				{
-				yy_last_accepting_state = yy_current_state;
-				yy_last_accepting_cpos = yy_cp;
-				}
-			while ( yy_chk[yy_base[yy_current_state] + yy_c] != yy_current_state )
-				{
-				yy_current_state = (int) yy_def[yy_current_state];
-				if ( yy_current_state >= 213 )
-					yy_c = yy_meta[(unsigned int) yy_c];
-				}
-			yy_current_state = yy_nxt[yy_base[yy_current_state] + (unsigned int) yy_c];
-			++yy_cp;
-			}
-		while ( yy_base[yy_current_state] != 231 );
-
-yy_find_action:
-		yy_act = yy_accept[yy_current_state];
-		if ( yy_act == 0 )
-			{ /* have to back up */
-			yy_cp = yy_last_accepting_cpos;
-			yy_current_state = yy_last_accepting_state;
-			yy_act = yy_accept[yy_current_state];
-			}
-
-		YY_DO_BEFORE_ACTION;
-
-
-do_action:	/* This label is used only to access EOF actions. */
-
-
-		switch ( yy_act )
-	{ /* beginning of action switch */
-			case 0: /* must back up */
-			/* undo the effects of YY_DO_BEFORE_ACTION */
-			*yy_cp = yy_hold_char;
-			yy_cp = yy_last_accepting_cpos;
-			yy_current_state = yy_last_accepting_state;
-			goto yy_find_action;
-
-
-case 1:
-YY_RULE_SETUP
-#line 25 "scanner.ll"
-{BEGIN(IN_CPP_COMMENT); comment[0]=0x0; }
-	YY_BREAK
-case 2:
-YY_RULE_SETUP
-#line 26 "scanner.ll"
-{BEGIN(IN_PASSTHRU); passthru[0]=0x0;}
-	YY_BREAK
-
-
-case 3:
-YY_RULE_SETUP
-#line 30 "scanner.ll"
-{ BEGIN(INITIAL); yylval.stval=strdup(comment); return T_COMMENT; }
-	YY_BREAK
-case 4:
-YY_RULE_SETUP
-#line 31 "scanner.ll"
-{ strcat(comment, yytext); }
-	YY_BREAK
-case 5:
-YY_RULE_SETUP
-#line 32 "scanner.ll"
-// eat the lone star
-	YY_BREAK
-case 6:
-YY_RULE_SETUP
-#line 33 "scanner.ll"
-{ strcat(comment, "\n"); lineno++; }
-	YY_BREAK
-
-
-case 7:
-YY_RULE_SETUP
-#line 37 "scanner.ll"
-{BEGIN(INITIAL);}
-	YY_BREAK
-case 8:
-YY_RULE_SETUP
-#line 38 "scanner.ll"
-{ strcat(passthru, yytext);}
-	YY_BREAK
-case 9:
-YY_RULE_SETUP
-#line 39 "scanner.ll"
-{ strcat(passthru, "\n"); lineno++; }
-	YY_BREAK
-
-case 10:
-YY_RULE_SETUP
-#line 42 "scanner.ll"
-{if (trace) ECHO; column+=yyleng; yylval.ival=atoi(yytext); return T_CONSTANT;}
-	YY_BREAK
-case 11:
-YY_RULE_SETUP
-#line 43 "scanner.ll"
-{if (trace) ECHO; column+=yyleng; return T_COLON;            }
-	YY_BREAK
-case 12:
-YY_RULE_SETUP
-#line 44 "scanner.ll"
-{if (trace) ECHO; column+=yyleng; return T_SEMICOLON;        }
-	YY_BREAK
-case 13:
-YY_RULE_SETUP
-#line 45 "scanner.ll"
-{if (trace) ECHO; column+=yyleng; return T_COMMA;            }
-	YY_BREAK
-case 14:
-YY_RULE_SETUP
-#line 46 "scanner.ll"
-{if (trace) ECHO; column+=yyleng; return T_EQUAL;            }
-	YY_BREAK
-case 15:
-YY_RULE_SETUP
-#line 47 "scanner.ll"
-{if (trace) ECHO; column+=yyleng; return T_DASHES;           }
-	YY_BREAK
-case 16:
-YY_RULE_SETUP
-#line 48 "scanner.ll"
-{if (trace) ECHO; column+=yyleng; return T_ELLIPSIS;         }
-	YY_BREAK
-case 17:
-YY_RULE_SETUP
-#line 49 "scanner.ll"
-{if (trace) ECHO; column+=yyleng; yylval.stval=strdup(yytext); return T_STAR; }
-	YY_BREAK
-case 18:
-YY_RULE_SETUP
-#line 50 "scanner.ll"
-{if (trace) ECHO; column+=yyleng; return T_LEFTPARENTHESIS;  }
-	YY_BREAK
-case 19:
-YY_RULE_SETUP
-#line 51 "scanner.ll"
-{if (trace) ECHO; column+=yyleng; return T_RIGHTPARENTHESIS; }
-	YY_BREAK
-case 20:
-YY_RULE_SETUP
-#line 52 "scanner.ll"
-{if (trace) ECHO; column+=yyleng; return T_LEFTSQUAREBRACKET;  }
-	YY_BREAK
-case 21:
-YY_RULE_SETUP
-#line 53 "scanner.ll"
-{if (trace) ECHO; column+=yyleng; return T_RIGHTSQUAREBRACKET; }
-	YY_BREAK
-case 22:
-YY_RULE_SETUP
-#line 54 "scanner.ll"
-{if (trace) ECHO; column+=yyleng; return T_CLASS;            }
-	YY_BREAK
-case 23:
-YY_RULE_SETUP
-#line 55 "scanner.ll"
-{if (trace) ECHO; column+=yyleng; return T_FILE;             }
-	YY_BREAK
-case 24:
-YY_RULE_SETUP
-#line 56 "scanner.ll"
-{if (trace) ECHO; column+=yyleng; return T_STEM;             }
-	YY_BREAK
-case 25:
-YY_RULE_SETUP
-#line 57 "scanner.ll"
-{if (trace) ECHO; column+=yyleng; return T_FUNCTION;         }
-	YY_BREAK
-case 26:
-YY_RULE_SETUP
-#line 58 "scanner.ll"
-{if (trace) ECHO; column+=yyleng; return T_PREFIX;           }
-	YY_BREAK
-case 27:
-YY_RULE_SETUP
-#line 59 "scanner.ll"
-{if (trace) ECHO; column+=yyleng; return T_CLASSPREFIX;      }
-	YY_BREAK
-case 28:
-YY_RULE_SETUP
-#line 60 "scanner.ll"
-{if (trace) ECHO; column+=yyleng; return T_MAJOR;            }
-	YY_BREAK
-case 29:
-YY_RULE_SETUP
-#line 61 "scanner.ll"
-{if (trace) ECHO; column+=yyleng; return T_MINOR;            }
-	YY_BREAK
-case 30:
-YY_RULE_SETUP
-#line 62 "scanner.ll"
-{if (trace) ECHO; column+=yyleng; return T_VERSION;          }
-	YY_BREAK
-case 31:
-YY_RULE_SETUP
-#line 63 "scanner.ll"
-{if (trace) ECHO; column+=yyleng; return T_GLOBAL;           }
-	YY_BREAK
-case 32:
-YY_RULE_SETUP
-#line 64 "scanner.ll"
-{if (trace) ECHO; column+=yyleng; return T_LOCAL;            }
-	YY_BREAK
-case 33:
-YY_RULE_SETUP
-#line 65 "scanner.ll"
-{if (trace) ECHO; column+=yyleng; return T_CLASSINIT;        }
-	YY_BREAK
-case 34:
-YY_RULE_SETUP
-#line 66 "scanner.ll"
-{if (trace) ECHO; column+=yyleng; return T_RELEASE;          }
-	YY_BREAK
-case 35:
-YY_RULE_SETUP
-#line 67 "scanner.ll"
-{if (trace) ECHO; column+=yyleng; return T_ORDER;            }
-	YY_BREAK
-case 36:
-YY_RULE_SETUP
-#line 68 "scanner.ll"
-{if (trace) ECHO; column+=yyleng; return T_METACLASS;        }
-	YY_BREAK
-case 37:
-YY_RULE_SETUP
-#line 69 "scanner.ll"
-{if (trace) ECHO; column+=yyleng; return T_PARENT;           }
-	YY_BREAK
-case 38:
-YY_RULE_SETUP
-#line 70 "scanner.ll"
-{if (trace) ECHO; column+=yyleng; return T_DATA;             }
-	YY_BREAK
-case 39:
-YY_RULE_SETUP
-#line 71 "scanner.ll"
-{if (trace) ECHO; column+=yyleng; return T_PRIVATE;          }
-	YY_BREAK
-case 40:
-YY_RULE_SETUP
-#line 72 "scanner.ll"
-{if (trace) ECHO; column+=yyleng; return T_PUBLIC;           }
-	YY_BREAK
-case 41:
-YY_RULE_SETUP
-#line 73 "scanner.ll"
-{if (trace) ECHO; column+=yyleng; return T_INTERNAL;         }
-	YY_BREAK
-case 42:
-YY_RULE_SETUP
-#line 74 "scanner.ll"
-{if (trace) ECHO; column+=yyleng; return T_METHODS;          }
-	YY_BREAK
-case 43:
-YY_RULE_SETUP
-#line 75 "scanner.ll"
-{if (trace) ECHO; column+=yyleng; return T_GROUP;            }
-	YY_BREAK
-case 44:
-YY_RULE_SETUP
-#line 76 "scanner.ll"
-{if (trace) ECHO; column+=yyleng; return T_METHOD;           }
-	YY_BREAK
-case 45:
-YY_RULE_SETUP
-#line 77 "scanner.ll"
-{if (trace) ECHO; column+=yyleng; return T_PROCEDURE;        }
-	YY_BREAK
-case 46:
-YY_RULE_SETUP
-#line 78 "scanner.ll"
-{if (trace) ECHO; column+=yyleng; return T_OFFSET;           }
-	YY_BREAK
-case 47:
-YY_RULE_SETUP
-#line 79 "scanner.ll"
-{if (trace) ECHO; column+=yyleng; return T_NAME;             }
-	YY_BREAK
-case 48:
-YY_RULE_SETUP
-#line 80 "scanner.ll"
-{if (trace) ECHO; column+=yyleng; return T_LOOKUP;           }
-	YY_BREAK
-case 49:
-YY_RULE_SETUP
-#line 81 "scanner.ll"
-{if (trace) ECHO; column+=yyleng; return T_EXTERNAL;         }
-	YY_BREAK
-case 50:
-YY_RULE_SETUP
-#line 82 "scanner.ll"
-{if (trace) ECHO; column+=yyleng; return T_OVERRIDE;         }
-	YY_BREAK
-case 51:
-YY_RULE_SETUP
-#line 83 "scanner.ll"
-{if (trace) ECHO; column+=yyleng; yylval.stval=strdup(yytext); return T_IDENTIFIER;   }
-	YY_BREAK
-case 52:
-YY_RULE_SETUP
-#line 84 "scanner.ll"
-{ column++;                                                  }
-	YY_BREAK
-case 53:
-YY_RULE_SETUP
-#line 85 "scanner.ll"
-{ lineno++;                                                  }
-	YY_BREAK
-case 54:
-YY_RULE_SETUP
-#line 86 "scanner.ll"
-{ printf("ERROR"); };
-	YY_BREAK
-case 55:
-YY_RULE_SETUP
-#line 88 "scanner.ll"
-ECHO;
-	YY_BREAK
-#line 1034 "lex.yy.c"
-case YY_STATE_EOF(INITIAL):
-case YY_STATE_EOF(IN_CPP_COMMENT):
-case YY_STATE_EOF(IN_PASSTHRU):
-	yyterminate();
-
-	case YY_END_OF_BUFFER:
-		{
-		/* Amount of text matched not including the EOB char. */
-		int yy_amount_of_matched_text = (int) (yy_cp - yytext_ptr) - 1;
-
-		/* Undo the effects of YY_DO_BEFORE_ACTION. */
-		*yy_cp = yy_hold_char;
-		YY_RESTORE_YY_MORE_OFFSET
-
-		if ( yy_current_buffer->yy_buffer_status == YY_BUFFER_NEW )
-			{
-			/* We're scanning a new file or input source.  It's
-			 * possible that this happened because the user
-			 * just pointed yyin at a new source and called
-			 * yylex().  If so, then we have to assure
-			 * consistency between yy_current_buffer and our
-			 * globals.  Here is the right place to do so, because
-			 * this is the first action (other than possibly a
-			 * back-up) that will match for the new input source.
-			 */
-			yy_n_chars = yy_current_buffer->yy_n_chars;
-			yy_current_buffer->yy_input_file = yyin;
-			yy_current_buffer->yy_buffer_status = YY_BUFFER_NORMAL;
-			}
-
-		/* Note that here we test for yy_c_buf_p "<=" to the position
-		 * of the first EOB in the buffer, since yy_c_buf_p will
-		 * already have been incremented past the NUL character
-		 * (since all states make transitions on EOB to the
-		 * end-of-buffer state).  Contrast this with the test
-		 * in input().
-		 */
-		if ( yy_c_buf_p <= &yy_current_buffer->yy_ch_buf[yy_n_chars] )
-			{ /* This was really a NUL. */
-			yy_state_type yy_next_state;
-
-			yy_c_buf_p = yytext_ptr + yy_amount_of_matched_text;
-
-			yy_current_state = yy_get_previous_state();
-
-			/* Okay, we're now positioned to make the NUL
-			 * transition.  We couldn't have
-			 * yy_get_previous_state() go ahead and do it
-			 * for us because it doesn't know how to deal
-			 * with the possibility of jamming (and we don't
-			 * want to build jamming into it because then it
-			 * will run more slowly).
-			 */
-
-			yy_next_state = yy_try_NUL_trans( yy_current_state );
-
-			yy_bp = yytext_ptr + YY_MORE_ADJ;
-
-			if ( yy_next_state )
-				{
-				/* Consume the NUL. */
-				yy_cp = ++yy_c_buf_p;
-				yy_current_state = yy_next_state;
-				goto yy_match;
-				}
-
-			else
-				{
-				yy_cp = yy_c_buf_p;
-				goto yy_find_action;
-				}
-			}
-
-		else switch ( yy_get_next_buffer() )
-			{
-			case EOB_ACT_END_OF_FILE:
-				{
-				yy_did_buffer_switch_on_eof = 0;
-
-				if ( yywrap() )
-					{
-					/* Note: because we've taken care in
-					 * yy_get_next_buffer() to have set up
-					 * yytext, we can now set up
-					 * yy_c_buf_p so that if some total
-					 * hoser (like flex itself) wants to
-					 * call the scanner after we return the
-					 * YY_NULL, it'll still work - another
-					 * YY_NULL will get returned.
-					 */
-					yy_c_buf_p = yytext_ptr + YY_MORE_ADJ;
-
-					yy_act = YY_STATE_EOF(YY_START);
-					goto do_action;
-					}
-
-				else
-					{
-					if ( ! yy_did_buffer_switch_on_eof )
-						YY_NEW_FILE;
-					}
-				break;
-				}
-
-			case EOB_ACT_CONTINUE_SCAN:
-				yy_c_buf_p =
-					yytext_ptr + yy_amount_of_matched_text;
-
-				yy_current_state = yy_get_previous_state();
-
-				yy_cp = yy_c_buf_p;
-				yy_bp = yytext_ptr + YY_MORE_ADJ;
-				goto yy_match;
-
-			case EOB_ACT_LAST_MATCH:
-				yy_c_buf_p =
-				&yy_current_buffer->yy_ch_buf[yy_n_chars];
-
-				yy_current_state = yy_get_previous_state();
-
-				yy_cp = yy_c_buf_p;
-				yy_bp = yytext_ptr + YY_MORE_ADJ;
-				goto yy_find_action;
-			}
-		break;
-		}
-
-	default:
-		YY_FATAL_ERROR(
-			"fatal flex scanner internal error--no action found" );
-	} /* end of action switch */
-		} /* end of scanning one token */
-	} /* end of yylex */
-
-
-/* yy_get_next_buffer - try to read in a new buffer
- *
- * Returns a code representing an action:
- *	EOB_ACT_LAST_MATCH -
- *	EOB_ACT_CONTINUE_SCAN - continue scanning from current position
- *	EOB_ACT_END_OF_FILE - end of file
- */
-
-static int yy_get_next_buffer()
-	{
-	register char *dest = yy_current_buffer->yy_ch_buf;
-	register char *source = yytext_ptr;
-	register int number_to_move, i;
-	int ret_val;
-
-	if ( yy_c_buf_p > &yy_current_buffer->yy_ch_buf[yy_n_chars + 1] )
-		YY_FATAL_ERROR(
-		"fatal flex scanner internal error--end of buffer missed" );
-
-	if ( yy_current_buffer->yy_fill_buffer == 0 )
-		{ /* Don't try to fill the buffer, so this is an EOF. */
-		if ( yy_c_buf_p - yytext_ptr - YY_MORE_ADJ == 1 )
-			{
-			/* We matched a single character, the EOB, so
-			 * treat this as a final EOF.
-			 */
-			return EOB_ACT_END_OF_FILE;
-			}
-
-		else
-			{
-			/* We matched some text prior to the EOB, first
-			 * process it.
-			 */
-			return EOB_ACT_LAST_MATCH;
-			}
-		}
-
-	/* Try to read more data. */
-
-	/* First move last chars to start of buffer. */
-	number_to_move = (int) (yy_c_buf_p - yytext_ptr) - 1;
-
-	for ( i = 0; i < number_to_move; ++i )
-		*(dest++) = *(source++);
-
-	if ( yy_current_buffer->yy_buffer_status == YY_BUFFER_EOF_PENDING )
-		/* don't do the read, it's not guaranteed to return an EOF,
-		 * just force an EOF
-		 */
-		yy_current_buffer->yy_n_chars = yy_n_chars = 0;
-
-	else
-		{
-		int num_to_read =
-			yy_current_buffer->yy_buf_size - number_to_move - 1;
-
-		while ( num_to_read <= 0 )
-			{ /* Not enough room in the buffer - grow it. */
-#ifdef YY_USES_REJECT
-			YY_FATAL_ERROR(
-"input buffer overflow, can't enlarge buffer because scanner uses REJECT" );
-#else
-
-			/* just a shorter name for the current buffer */
-			YY_BUFFER_STATE b = yy_current_buffer;
-
-			int yy_c_buf_p_offset =
-				(int) (yy_c_buf_p - b->yy_ch_buf);
-
-			if ( b->yy_is_our_buffer )
-				{
-				int new_size = b->yy_buf_size * 2;
-
-				if ( new_size <= 0 )
-					b->yy_buf_size += b->yy_buf_size / 8;
-				else
-					b->yy_buf_size *= 2;
-
-				b->yy_ch_buf = (char *)
-					/* Include room in for 2 EOB chars. */
-					yy_flex_realloc( (void *) b->yy_ch_buf,
-							 b->yy_buf_size + 2 );
-				}
-			else
-				/* Can't grow it, we don't own it. */
-				b->yy_ch_buf = 0;
-
-			if ( ! b->yy_ch_buf )
-				YY_FATAL_ERROR(
-				"fatal error - scanner input buffer overflow" );
-
-			yy_c_buf_p = &b->yy_ch_buf[yy_c_buf_p_offset];
-
-			num_to_read = yy_current_buffer->yy_buf_size -
-						number_to_move - 1;
-#endif
-			}
-
-		if ( num_to_read > YY_READ_BUF_SIZE )
-			num_to_read = YY_READ_BUF_SIZE;
-
-		/* Read in more data. */
-		YY_INPUT( (&yy_current_buffer->yy_ch_buf[number_to_move]),
-			yy_n_chars, num_to_read );
-
-		yy_current_buffer->yy_n_chars = yy_n_chars;
-		}
-
-	if ( yy_n_chars == 0 )
-		{
-		if ( number_to_move == YY_MORE_ADJ )
-			{
-			ret_val = EOB_ACT_END_OF_FILE;
-			yyrestart( yyin );
-			}
-
-		else
-			{
-			ret_val = EOB_ACT_LAST_MATCH;
-			yy_current_buffer->yy_buffer_status =
-				YY_BUFFER_EOF_PENDING;
-			}
-		}
-
-	else
-		ret_val = EOB_ACT_CONTINUE_SCAN;
-
-	yy_n_chars += number_to_move;
-	yy_current_buffer->yy_ch_buf[yy_n_chars] = YY_END_OF_BUFFER_CHAR;
-	yy_current_buffer->yy_ch_buf[yy_n_chars + 1] = YY_END_OF_BUFFER_CHAR;
-
-	yytext_ptr = &yy_current_buffer->yy_ch_buf[0];
-
-	return ret_val;
-	}
-
-
-/* yy_get_previous_state - get the state just before the EOB char was reached */
-
-static yy_state_type yy_get_previous_state()
-	{
-	register yy_state_type yy_current_state;
-	register char *yy_cp;
-
-	yy_current_state = yy_start;
-
-	for ( yy_cp = yytext_ptr + YY_MORE_ADJ; yy_cp < yy_c_buf_p; ++yy_cp )
-		{
-		register YY_CHAR yy_c = (*yy_cp ? yy_ec[YY_SC_TO_UI(*yy_cp)] : 1);
-		if ( yy_accept[yy_current_state] )
-			{
-			yy_last_accepting_state = yy_current_state;
-			yy_last_accepting_cpos = yy_cp;
-			}
-		while ( yy_chk[yy_base[yy_current_state] + yy_c] != yy_current_state )
-			{
-			yy_current_state = (int) yy_def[yy_current_state];
-			if ( yy_current_state >= 213 )
-				yy_c = yy_meta[(unsigned int) yy_c];
-			}
-		yy_current_state = yy_nxt[yy_base[yy_current_state] + (unsigned int) yy_c];
-		}
-
-	return yy_current_state;
-	}
-
-
-/* yy_try_NUL_trans - try to make a transition on the NUL character
- *
- * synopsis
- *	next_state = yy_try_NUL_trans( current_state );
- */
-
-#ifdef YY_USE_PROTOS
-static yy_state_type yy_try_NUL_trans( yy_state_type yy_current_state )
-#else
-static yy_state_type yy_try_NUL_trans( yy_current_state )
-yy_state_type yy_current_state;
-#endif
-	{
-	register int yy_is_jam;
-	register char *yy_cp = yy_c_buf_p;
-
-	register YY_CHAR yy_c = 1;
-	if ( yy_accept[yy_current_state] )
-		{
-		yy_last_accepting_state = yy_current_state;
-		yy_last_accepting_cpos = yy_cp;
-		}
-	while ( yy_chk[yy_base[yy_current_state] + yy_c] != yy_current_state )
-		{
-		yy_current_state = (int) yy_def[yy_current_state];
-		if ( yy_current_state >= 213 )
-			yy_c = yy_meta[(unsigned int) yy_c];
-		}
-	yy_current_state = yy_nxt[yy_base[yy_current_state] + (unsigned int) yy_c];
-	yy_is_jam = (yy_current_state == 212);
-
-	return yy_is_jam ? 0 : yy_current_state;
-	}
-
-
-#ifndef YY_NO_UNPUT
-#ifdef YY_USE_PROTOS
-static void yyunput( int c, register char *yy_bp )
-#else
-static void yyunput( c, yy_bp )
-int c;
-register char *yy_bp;
-#endif
-	{
-	register char *yy_cp = yy_c_buf_p;
-
-	/* undo effects of setting up yytext */
-	*yy_cp = yy_hold_char;
-
-	if ( yy_cp < yy_current_buffer->yy_ch_buf + 2 )
-		{ /* need to shift things up to make room */
-		/* +2 for EOB chars. */
-		register int number_to_move = yy_n_chars + 2;
-		register char *dest = &yy_current_buffer->yy_ch_buf[
-					yy_current_buffer->yy_buf_size + 2];
-		register char *source =
-				&yy_current_buffer->yy_ch_buf[number_to_move];
-
-		while ( source > yy_current_buffer->yy_ch_buf )
-			*--dest = *--source;
-
-		yy_cp += (int) (dest - source);
-		yy_bp += (int) (dest - source);
-		yy_current_buffer->yy_n_chars =
-			yy_n_chars = yy_current_buffer->yy_buf_size;
-
-		if ( yy_cp < yy_current_buffer->yy_ch_buf + 2 )
-			YY_FATAL_ERROR( "flex scanner push-back overflow" );
-		}
-
-	*--yy_cp = (char) c;
-
-
-	yytext_ptr = yy_bp;
-	yy_hold_char = *yy_cp;
-	yy_c_buf_p = yy_cp;
-	}
-#endif	/* ifndef YY_NO_UNPUT */
-
-
-#ifdef __cplusplus
-static int yyinput()
-#else
-static int input()
-#endif
-	{
-	int c;
-
-	*yy_c_buf_p = yy_hold_char;
-
-	if ( *yy_c_buf_p == YY_END_OF_BUFFER_CHAR )
-		{
-		/* yy_c_buf_p now points to the character we want to return.
-		 * If this occurs *before* the EOB characters, then it's a
-		 * valid NUL; if not, then we've hit the end of the buffer.
-		 */
-		if ( yy_c_buf_p < &yy_current_buffer->yy_ch_buf[yy_n_chars] )
-			/* This was really a NUL. */
-			*yy_c_buf_p = '\0';
-
-		else
-			{ /* need more input */
-			int offset = yy_c_buf_p - yytext_ptr;
-			++yy_c_buf_p;
-
-			switch ( yy_get_next_buffer() )
-				{
-				case EOB_ACT_LAST_MATCH:
-					/* This happens because yy_g_n_b()
-					 * sees that we've accumulated a
-					 * token and flags that we need to
-					 * try matching the token before
-					 * proceeding.  But for input(),
-					 * there's no matching to consider.
-					 * So convert the EOB_ACT_LAST_MATCH
-					 * to EOB_ACT_END_OF_FILE.
-					 */
-
-					/* Reset buffer status. */
-					yyrestart( yyin );
-
-					/* fall through */
-
-				case EOB_ACT_END_OF_FILE:
-					{
-					if ( yywrap() )
-						return EOF;
-
-					if ( ! yy_did_buffer_switch_on_eof )
-						YY_NEW_FILE;
-#ifdef __cplusplus
-					return yyinput();
-#else
-					return input();
-#endif
-					}
-
-				case EOB_ACT_CONTINUE_SCAN:
-					yy_c_buf_p = yytext_ptr + offset;
-					break;
-				}
-			}
-		}
-
-	c = *(unsigned char *) yy_c_buf_p;	/* cast for 8-bit char's */
-	*yy_c_buf_p = '\0';	/* preserve yytext */
-	yy_hold_char = *++yy_c_buf_p;
-
-
-	return c;
-	}
-
-
-#ifdef YY_USE_PROTOS
-void yyrestart( FILE *input_file )
-#else
-void yyrestart( input_file )
-FILE *input_file;
-#endif
-	{
-	if ( ! yy_current_buffer )
-		yy_current_buffer = yy_create_buffer( yyin, YY_BUF_SIZE );
-
-	yy_init_buffer( yy_current_buffer, input_file );
-	yy_load_buffer_state();
-	}
-
-
-#ifdef YY_USE_PROTOS
-void yy_switch_to_buffer( YY_BUFFER_STATE new_buffer )
-#else
-void yy_switch_to_buffer( new_buffer )
-YY_BUFFER_STATE new_buffer;
-#endif
-	{
-	if ( yy_current_buffer == new_buffer )
-		return;
-
-	if ( yy_current_buffer )
-		{
-		/* Flush out information for old buffer. */
-		*yy_c_buf_p = yy_hold_char;
-		yy_current_buffer->yy_buf_pos = yy_c_buf_p;
-		yy_current_buffer->yy_n_chars = yy_n_chars;
-		}
-
-	yy_current_buffer = new_buffer;
-	yy_load_buffer_state();
-
-	/* We don't actually know whether we did this switch during
-	 * EOF (yywrap()) processing, but the only time this flag
-	 * is looked at is after yywrap() is called, so it's safe
-	 * to go ahead and always set it.
-	 */
-	yy_did_buffer_switch_on_eof = 1;
-	}
-
-
-#ifdef YY_USE_PROTOS
-void yy_load_buffer_state( void )
-#else
-void yy_load_buffer_state()
-#endif
-	{
-	yy_n_chars = yy_current_buffer->yy_n_chars;
-	yytext_ptr = yy_c_buf_p = yy_current_buffer->yy_buf_pos;
-	yyin = yy_current_buffer->yy_input_file;
-	yy_hold_char = *yy_c_buf_p;
-	}
-
-
-#ifdef YY_USE_PROTOS
-YY_BUFFER_STATE yy_create_buffer( FILE *file, int size )
-#else
-YY_BUFFER_STATE yy_create_buffer( file, size )
-FILE *file;
-int size;
-#endif
-	{
-	YY_BUFFER_STATE b;
-
-	b = (YY_BUFFER_STATE) yy_flex_alloc( sizeof( struct yy_buffer_state ) );
-	if ( ! b )
-		YY_FATAL_ERROR( "out of dynamic memory in yy_create_buffer()" );
-
-	b->yy_buf_size = size;
-
-	/* yy_ch_buf has to be 2 characters longer than the size given because
-	 * we need to put in 2 end-of-buffer characters.
-	 */
-	b->yy_ch_buf = (char *) yy_flex_alloc( b->yy_buf_size + 2 );
-	if ( ! b->yy_ch_buf )
-		YY_FATAL_ERROR( "out of dynamic memory in yy_create_buffer()" );
-
-	b->yy_is_our_buffer = 1;
-
-	yy_init_buffer( b, file );
-
-	return b;
-	}
-
-
-#ifdef YY_USE_PROTOS
-void yy_delete_buffer( YY_BUFFER_STATE b )
-#else
-void yy_delete_buffer( b )
-YY_BUFFER_STATE b;
-#endif
-	{
-	if ( ! b )
-		return;
-
-	if ( b == yy_current_buffer )
-		yy_current_buffer = (YY_BUFFER_STATE) 0;
-
-	if ( b->yy_is_our_buffer )
-		yy_flex_free( (void *) b->yy_ch_buf );
-
-	yy_flex_free( (void *) b );
-	}
-
-
-#ifndef YY_ALWAYS_INTERACTIVE
-#ifndef YY_NEVER_INTERACTIVE
-extern int isatty YY_PROTO(( int ));
-#endif
-#endif
-
-#ifdef YY_USE_PROTOS
-void yy_init_buffer( YY_BUFFER_STATE b, FILE *file )
-#else
-void yy_init_buffer( b, file )
-YY_BUFFER_STATE b;
-FILE *file;
-#endif
-
-
-	{
-	yy_flush_buffer( b );
-
-	b->yy_input_file = file;
-	b->yy_fill_buffer = 1;
-
-#if YY_ALWAYS_INTERACTIVE
-	b->yy_is_interactive = 1;
-#else
-#if YY_NEVER_INTERACTIVE
-	b->yy_is_interactive = 0;
-#else
-	b->yy_is_interactive = file ? (isatty( fileno(file) ) > 0) : 0;
-#endif
-#endif
-	}
-
-
-#ifdef YY_USE_PROTOS
-void yy_flush_buffer( YY_BUFFER_STATE b )
-#else
-void yy_flush_buffer( b )
-YY_BUFFER_STATE b;
-#endif
-
-	{
-	if ( ! b )
-		return;
-
-	b->yy_n_chars = 0;
-
-	/* We always need two end-of-buffer characters.  The first causes
-	 * a transition to the end-of-buffer state.  The second causes
-	 * a jam in that state.
-	 */
-	b->yy_ch_buf[0] = YY_END_OF_BUFFER_CHAR;
-	b->yy_ch_buf[1] = YY_END_OF_BUFFER_CHAR;
-
-	b->yy_buf_pos = &b->yy_ch_buf[0];
-
-	b->yy_at_bol = 1;
-	b->yy_buffer_status = YY_BUFFER_NEW;
-
-	if ( b == yy_current_buffer )
-		yy_load_buffer_state();
-	}
-
-
-#ifndef YY_NO_SCAN_BUFFER
-#ifdef YY_USE_PROTOS
-YY_BUFFER_STATE yy_scan_buffer( char *base, yy_size_t size )
-#else
-YY_BUFFER_STATE yy_scan_buffer( base, size )
-char *base;
-yy_size_t size;
-#endif
-	{
-	YY_BUFFER_STATE b;
-
-	if ( size < 2 ||
-	     base[size-2] != YY_END_OF_BUFFER_CHAR ||
-	     base[size-1] != YY_END_OF_BUFFER_CHAR )
-		/* They forgot to leave room for the EOB's. */
-		return 0;
-
-	b = (YY_BUFFER_STATE) yy_flex_alloc( sizeof( struct yy_buffer_state ) );
-	if ( ! b )
-		YY_FATAL_ERROR( "out of dynamic memory in yy_scan_buffer()" );
-
-	b->yy_buf_size = size - 2;	/* "- 2" to take care of EOB's */
-	b->yy_buf_pos = b->yy_ch_buf = base;
-	b->yy_is_our_buffer = 0;
-	b->yy_input_file = 0;
-	b->yy_n_chars = b->yy_buf_size;
-	b->yy_is_interactive = 0;
-	b->yy_at_bol = 1;
-	b->yy_fill_buffer = 0;
-	b->yy_buffer_status = YY_BUFFER_NEW;
-
-	yy_switch_to_buffer( b );
-
-	return b;
-	}
-#endif
-
-
-#ifndef YY_NO_SCAN_STRING
-#ifdef YY_USE_PROTOS
-YY_BUFFER_STATE yy_scan_string( yyconst char *yy_str )
-#else
-YY_BUFFER_STATE yy_scan_string( yy_str )
-yyconst char *yy_str;
-#endif
-	{
-	int len;
-	for ( len = 0; yy_str[len]; ++len )
-		;
-
-	return yy_scan_bytes( yy_str, len );
-	}
-#endif
-
-
-#ifndef YY_NO_SCAN_BYTES
-#ifdef YY_USE_PROTOS
-YY_BUFFER_STATE yy_scan_bytes( yyconst char *bytes, int len )
-#else
-YY_BUFFER_STATE yy_scan_bytes( bytes, len )
-yyconst char *bytes;
-int len;
-#endif
-	{
-	YY_BUFFER_STATE b;
-	char *buf;
-	yy_size_t n;
-	int i;
-
-	/* Get memory for full buffer, including space for trailing EOB's. */
-	n = len + 2;
-	buf = (char *) yy_flex_alloc( n );
-	if ( ! buf )
-		YY_FATAL_ERROR( "out of dynamic memory in yy_scan_bytes()" );
-
-	for ( i = 0; i < len; ++i )
-		buf[i] = bytes[i];
-
-	buf[len] = buf[len+1] = YY_END_OF_BUFFER_CHAR;
-
-	b = yy_scan_buffer( buf, n );
-	if ( ! b )
-		YY_FATAL_ERROR( "bad buffer in yy_scan_bytes()" );
-
-	/* It's okay to grow etc. this buffer, and we should throw it
-	 * away when we're done.
-	 */
-	b->yy_is_our_buffer = 1;
-
-	return b;
-	}
-#endif
-
-
-#ifndef YY_NO_PUSH_STATE
-#ifdef YY_USE_PROTOS
-static void yy_push_state( int new_state )
-#else
-static void yy_push_state( new_state )
-int new_state;
-#endif
-	{
-	if ( yy_start_stack_ptr >= yy_start_stack_depth )
-		{
-		yy_size_t new_size;
-
-		yy_start_stack_depth += YY_START_STACK_INCR;
-		new_size = yy_start_stack_depth * sizeof( int );
-
-		if ( ! yy_start_stack )
-			yy_start_stack = (int *) yy_flex_alloc( new_size );
-
-		else
-			yy_start_stack = (int *) yy_flex_realloc(
-					(void *) yy_start_stack, new_size );
-
-		if ( ! yy_start_stack )
-			YY_FATAL_ERROR(
-			"out of memory expanding start-condition stack" );
-		}
-
-	yy_start_stack[yy_start_stack_ptr++] = YY_START;
-
-	BEGIN(new_state);
-	}
-#endif
-
-
-#ifndef YY_NO_POP_STATE
-static void yy_pop_state()
-	{
-	if ( --yy_start_stack_ptr < 0 )
-		YY_FATAL_ERROR( "start-condition stack underflow" );
-
-	BEGIN(yy_start_stack[yy_start_stack_ptr]);
-	}
-#endif
-
-
-#ifndef YY_NO_TOP_STATE
-static int yy_top_state()
-	{
-	return yy_start_stack[yy_start_stack_ptr - 1];
-	}
-#endif
-
-#ifndef YY_EXIT_FAILURE
-#define YY_EXIT_FAILURE 2
-#endif
-
-#ifdef YY_USE_PROTOS
-static void yy_fatal_error( yyconst char msg[] )
-#else
-static void yy_fatal_error( msg )
-char msg[];
-#endif
-	{
-	(void) fprintf( stderr, "%s\n", msg );
-	exit( YY_EXIT_FAILURE );
-	}
-
-
-
-/* Redefine yyless() so it works in section 3 code. */
-
-#undef yyless
-#define yyless(n) \
-	do \
-		{ \
-		/* Undo effects of setting up yytext. */ \
-		yytext[yyleng] = yy_hold_char; \
-		yy_c_buf_p = yytext + n; \
-		yy_hold_char = *yy_c_buf_p; \
-		*yy_c_buf_p = '\0'; \
-		yyleng = n; \
-		} \
-	while ( 0 )
-
-
-/* Internal utility routines. */
-
-#ifndef yytext_ptr
-#ifdef YY_USE_PROTOS
-static void yy_flex_strncpy( char *s1, yyconst char *s2, int n )
-#else
-static void yy_flex_strncpy( s1, s2, n )
-char *s1;
-yyconst char *s2;
-int n;
-#endif
-	{
-	register int i;
-	for ( i = 0; i < n; ++i )
-		s1[i] = s2[i];
-	}
-#endif
-
-#ifdef YY_NEED_STRLEN
-#ifdef YY_USE_PROTOS
-static int yy_flex_strlen( yyconst char *s )
-#else
-static int yy_flex_strlen( s )
-yyconst char *s;
-#endif
-	{
-	register int n;
-	for ( n = 0; s[n]; ++n )
-		;
-
-	return n;
-	}
-#endif
-
-
-#ifdef YY_USE_PROTOS
-static void *yy_flex_alloc( yy_size_t size )
-#else
-static void *yy_flex_alloc( size )
-yy_size_t size;
-#endif
-	{
-	return (void *) malloc( size );
-	}
-
-#ifdef YY_USE_PROTOS
-static void *yy_flex_realloc( void *ptr, yy_size_t size )
-#else
-static void *yy_flex_realloc( ptr, size )
-void *ptr;
-yy_size_t size;
-#endif
-	{
-	/* The cast to (char *) in the following accommodates both
-	 * implementations that use char* generic pointers, and those
-	 * that use void* generic pointers.  It works with the latter
-	 * because both ANSI C and C++ allow castless assignment from
-	 * any pointer type to void*, and deal with argument conversions
-	 * as though doing an assignment.
-	 */
-	return (void *) realloc( (char *) ptr, size );
-	}
-
-#ifdef YY_USE_PROTOS
-static void yy_flex_free( void *ptr )
-#else
-static void yy_flex_free( ptr )
-void *ptr;
-#endif
-	{
-	free( ptr );
-	}
-
-#if YY_MAIN
-int main()
-	{
-	yylex();
-	return 0;
-	}
-#endif
-#line 88 "scanner.ll"
-
-/* "use"             {if (trace) ECHO; column+=yyleng; return T_USE;              } */
diff -urN somfree/somopc/src/oidl.l newsomfree/somopc/src/oidl.l
--- somfree/somopc/src/oidl.l	Thu Jan 01 07:00:00 1970
+++ newsomfree/somopc/src/oidl.l	Sat Jun 29 18:37:15 2024
@@ -0,0 +1,90 @@
+%{
+
+#include <stdio.h>  // fopen
+#include <stdlib.h> // malloc, free, realloc
+#include <string.h> // strcat
+
+#include <emitlib.h>
+
+#include "oidl.h"
+
+int trace=1;
+int lineno=1, column=0;
+char comment[16384]; // handle with -C
+char passthru[32768]; // handle with -S
+
+%}
+
+
+%x IN_CPP_COMMENT
+%x IN_PASSTHRU
+
+%%
+
+<INITIAL>{
+  "/*"             {BEGIN(IN_CPP_COMMENT); comment[0]=0x0; }
+  "passthru:"       {BEGIN(IN_PASSTHRU); passthru[0]=0x0;}
+}
+
+<IN_CPP_COMMENT>{
+  "*/"      { BEGIN(INITIAL); yylval.stval=strdup(comment); return T_COMMENT; }
+  [^*\n]+   { strcat(comment, yytext); }
+  "*"       // eat the lone star
+  \n        { strcat(comment, "\n"); lineno++; }
+}
+
+<IN_PASSTHRU>{
+  "endpassthru;"  {BEGIN(INITIAL);}
+  [^\n]+    { strcat(passthru, yytext);}
+  \n        { strcat(passthru, "\n"); lineno++; }
+}
+
+[0-9]+	 	  {if (trace) ECHO; column+=yyleng; yylval.ival=atoi(yytext); return T_CONSTANT;}
+:                 {if (trace) ECHO; column+=yyleng; return T_COLON;            }
+;                 {if (trace) ECHO; column+=yyleng; return T_SEMICOLON;        }
+,                 {if (trace) ECHO; column+=yyleng; return T_COMMA;            }
+=                 {if (trace) ECHO; column+=yyleng; return T_EQUAL;            }
+--                {if (trace) ECHO; column+=yyleng; return T_DASHES;           }
+"..."             {if (trace) ECHO; column+=yyleng; return T_ELLIPSIS;         }
+"*"               {if (trace) ECHO; column+=yyleng; yylval.stval=strdup(yytext); return T_STAR; }
+"("               {if (trace) ECHO; column+=yyleng; return T_LEFTPARENTHESIS;  }
+")"               {if (trace) ECHO; column+=yyleng; return T_RIGHTPARENTHESIS; }
+"["               {if (trace) ECHO; column+=yyleng; return T_LEFTSQUAREBRACKET;  }
+"]"               {if (trace) ECHO; column+=yyleng; return T_RIGHTSQUAREBRACKET; }
+^#line            {if (trace) ECHO; column+=yyleng; return T_LINE;             }
+class             {if (trace) ECHO; column+=yyleng; return T_CLASS;            }
+file              {if (trace) ECHO; column+=yyleng; return T_FILE;             }
+stem              {if (trace) ECHO; column+=yyleng; return T_STEM;             }
+function          {if (trace) ECHO; column+=yyleng; return T_FUNCTION;         }
+prefix            {if (trace) ECHO; column+=yyleng; return T_PREFIX;           }
+classprefix       {if (trace) ECHO; column+=yyleng; return T_CLASSPREFIX;      }
+major             {if (trace) ECHO; column+=yyleng; return T_MAJOR;            }
+minor             {if (trace) ECHO; column+=yyleng; return T_MINOR;            }
+version           {if (trace) ECHO; column+=yyleng; return T_VERSION;          }
+global            {if (trace) ECHO; column+=yyleng; return T_GLOBAL;           }
+local             {if (trace) ECHO; column+=yyleng; return T_LOCAL;            }
+classInit         {if (trace) ECHO; column+=yyleng; return T_CLASSINIT;        }
+release           {if (trace) ECHO; column+=yyleng; return T_RELEASE;          }
+order             {if (trace) ECHO; column+=yyleng; return T_ORDER;            }
+metaclass         {if (trace) ECHO; column+=yyleng; return T_METACLASS;        }
+parent            {if (trace) ECHO; column+=yyleng; return T_PARENT;           }
+data              {if (trace) ECHO; column+=yyleng; return T_DATA;             }
+private           {if (trace) ECHO; column+=yyleng; return T_PRIVATE;          }
+public            {if (trace) ECHO; column+=yyleng; return T_PUBLIC;           }
+internal          {if (trace) ECHO; column+=yyleng; return T_INTERNAL;         }
+methods           {if (trace) ECHO; column+=yyleng; return T_METHODS;          }
+group             {if (trace) ECHO; column+=yyleng; return T_GROUP;            }
+method            {if (trace) ECHO; column+=yyleng; return T_METHOD;           }
+procedure         {if (trace) ECHO; column+=yyleng; return T_PROCEDURE;        }
+offset            {if (trace) ECHO; column+=yyleng; return T_OFFSET;           }
+name              {if (trace) ECHO; column+=yyleng; return T_NAME;             }
+lookup            {if (trace) ECHO; column+=yyleng; return T_LOOKUP;           }
+external          {if (trace) ECHO; column+=yyleng; return T_EXTERNAL;         }
+override          {if (trace) ECHO; column+=yyleng; return T_OVERRIDE;         }
+[A-Za-z][_0-9A-Za-z]* {if (trace) ECHO; column+=yyleng; yylval.stval=strdup(yytext); return T_IDENTIFIER;   }
+[ \t]+            { column++;                                                  }
+\n                { lineno++;                                                  }
+.                 { printf("ERROR"); };
+
+%%
+/* "use"             {if (trace) ECHO; column+=yyleng; return T_USE;              } */
diff -urN somfree/somopc/src/oidl.y newsomfree/somopc/src/oidl.y
--- somfree/somopc/src/oidl.y	Thu Jan 01 07:00:00 1970
+++ newsomfree/somopc/src/oidl.y	Sat Jun 29 21:16:35 2024
@@ -0,0 +1,1128 @@
+%{
+#include <stdio.h> // fopen, fprintf
+#include <string.h>
+
+#include <emitlib.h>
+
+#define YYERROR_VERBOSE
+
+extern int lineno, column;
+
+Entry e;
+
+Entry *cls;	// Current Class Entry
+Entry *pcls;	// Parent Class Entry
+Entry *mcls;	// Meta Class Entry
+
+void yyerror(const char *str)
+{
+        fprintf(stderr,"\nerror: %s\n", str);
+}
+ 
+int yywrap()
+{
+        return 1;
+} 
+  
+%}
+
+
+
+%start oidl
+
+%union{
+ char *stval;
+ int ival;
+}
+
+
+%type <stval> overridemethod_name
+
+%type <ival> T_CONSTANT
+
+%token T_COLON T_SEMICOLON T_COMMA T_STAR T_COMMENT T_IDENTIFIER
+%token T_EQUAL T_DASHES T_CONSTANT T_PERIOD  T_STRING
+%token T_ELLIPSIS T_LEFTPARENTHESIS T_RIGHTPARENTHESIS
+%token T_LEFTSQUAREBRACKET T_RIGHTSQUAREBRACKET
+
+%token T_VERSION T_GLOBAL T_LOCAL T_CLASSINIT T_RELEASE T_ORDER T_METACLASS T_PARENT
+%token T_CLASS T_LINE
+%token T_FILE T_STEM T_FUNCTION T_PREFIX T_CLASSPREFIX T_MAJOR T_MINOR
+%token T_PASSTHRU T_BEFORE T_AFTER T_ENDPASSTHRU T_DATA T_PRIVATE T_PUBLIC T_INTERNAL
+%token T_METHODS T_GROUP T_METHOD T_PROCEDURE T_OFFSET T_NAME T_LOOKUP T_EXTERNAL
+%token T_USE T_OVERRIDE
+
+%%
+
+oidl
+	:
+		{
+			if (somtg_f.verbose) printf("Parsing of \"%s\" started.\n", somtfilePath);
+			somtg_f._ERROR=0;   /* @todo subject to move to parse() */
+			somtg_f.WARN=0;   /* @todo subject to move to parse() */
+			somtg_f.FATAL=0;   /* @todo subject to move to parse() */
+			somtg_f.INTERNAL=0;   /* @todo subject to move to parse() */
+			somtg_buf=somtsmallocSL(somtg_f.commentsize, TRUE);   /* @todo subject to move to parse() */
+		}
+	  class_list
+		{
+			somtfree(somtg_buf);   /* @todo subject to move to parse() */
+			if (somtg_f.verbose) printf("Parsing of \"%s\" finished.\n", somtfilePath);
+		}
+	| line
+        ;
+
+line	: T_LINE T_CONSTANT T_STRING
+	;
+
+class_list
+	: class_definition
+	| class_list class_definition
+	;
+
+class_definition
+	:
+		{
+			cls=(Entry *)somtsmallocSL(sizeof(Entry), TRUE);
+			cls->atts=somtaddModifierSL(cls->atts, "callstyle", "oidl");
+			cls->type=SOMTClassE;
+			somtclassIdlCall=FALSE;
+			cls->u.c.file=strdup(somtfilePath);
+		}
+	  class_section section_list
+		{
+			somtaddEntrySL(somtstab, cls->name, cls);
+			somtfree(cls);
+		}
+	;
+
+section_list
+	: section
+        | section_list section
+        ;
+
+section
+	: releaseorder_section
+        | metaclass_section
+        |
+		{
+			pcls=(Entry *)somtsmallocSL(sizeof(Entry), TRUE);
+			pcls->atts=somtaddModifierSL(pcls->atts, "callstyle", "oidl");
+			pcls->type=SOMTBaseE;
+			somtclassIdlCall=FALSE;
+//			pcls->u.c.file=strdup(somtfilePath);
+		}
+	  parent_section
+		{
+			cls->u.c.parent=somtaddEntrySL(somtstab, pcls->name, pcls);
+			somtfree(pcls);
+		}
+        | passthru_section
+        | data_section
+	| methods_section
+	;
+
+class_section
+	: classdef 
+        | classdef description
+		{
+			cls->comment=$<stval>2;
+		}
+	;
+
+classdef
+	: class_header class_name T_SEMICOLON 
+	| class_header class_name class_attributes T_SEMICOLON
+        ;
+
+class_header
+	: T_CLASS T_COLON 
+	;
+
+class_name
+	: T_IDENTIFIER 
+		{
+			somtclassName=$<stval>1;
+			cls->lineno=lineno;                 
+			cls->name=$<stval>1;
+		}
+        ;
+
+class_attributes
+	: T_COMMA class_attribute
+	| class_attributes T_COMMA class_attribute
+        ;
+
+class_attribute
+	: T_FILE T_STEM T_EQUAL T_IDENTIFIER
+		{
+			cls->atts=somtaddModifierSL(cls->atts, "filestem", $<stval>4);
+		}
+        | T_EXTERNAL T_STEM T_EQUAL T_IDENTIFIER
+		{
+			cls->atts=somtaddModifierSL(cls->atts, "externalstem", $<stval>4);
+		}
+        | T_FUNCTION T_PREFIX T_EQUAL T_IDENTIFIER
+		{
+			cls->atts=somtaddModifierSL(cls->atts, "functionprefix", $<stval>4);
+		}
+        | T_EXTERNAL T_PREFIX T_EQUAL T_IDENTIFIER
+		{
+			cls->atts=somtaddModifierSL(cls->atts, "externalprefix", $<stval>4);
+		}
+        | T_CLASSPREFIX T_EQUAL T_IDENTIFIER
+		{
+			cls->atts=somtaddModifierSL(cls->atts, "classprefix", $<stval>3);
+		}
+        | T_MAJOR T_VERSION T_EQUAL T_CONSTANT
+		{
+			char *st=itoa($4, somtsmallocSL(sizeof(int)*8+1/*_MAX_ITOSTR_BASE10_COUNT*/, TRUE), 10);
+			cls->atts=somtaddModifierSL(cls->atts, "majorversion", st);
+			somtmajorVersion=strdup(st);
+			somtfree(st);
+		}
+        | T_MINOR T_VERSION T_EQUAL T_CONSTANT
+		{
+			char *st=itoa($4, somtsmallocSL(sizeof(int)*+1/*_MAX_ITOSTR_BASE10_COUNT*/, TRUE), 10);
+			cls->atts=somtaddModifierSL(cls->atts, "minorversion", st);
+			somtminorVersion=strdup(st);
+			somtfree(st);
+		}
+        | T_CLASSINIT T_EQUAL T_IDENTIFIER
+		{
+			cls->atts=somtaddModifierSL(cls->atts, "classInit", $<stval>3);
+		}
+	| visibility
+        ;
+
+visibility
+	: T_GLOBAL
+        | T_LOCAL
+	;
+
+releaseorder_section
+	: releaseorder_header release_list T_SEMICOLON
+		{
+			cls->atts=somtaddModifierSL(cls->atts, "releaseorder", $<stval>2);
+		}
+	;
+
+releaseorder_header
+	: T_RELEASE T_ORDER T_COLON
+	;
+
+release_list
+	: release
+		{ 
+			$<stval>$=strdup($<stval>1);
+		}
+	| release_list T_COMMA release
+		{
+			char *r=somtsmallocSL(strlen($<stval>1)+strlen($<stval>3)+2, TRUE);
+			strcat(strcat(strcat(r, $<stval>1), ","), $<stval>3);
+			$<stval>$=strdup(r);
+			somtfree(r);
+		}
+	;
+
+release
+	: T_IDENTIFIER
+		{
+			cls->u.c.release=somtaddModifierSL(cls->u.c.release, $<stval>1, NULL);
+			$<stval>$=$<stval>1;
+		}
+	;
+
+metaclass_section
+	: metaclassdef
+        | metaclassdef description
+		{
+			mcls->comment=$<stval>2;
+		}
+	;
+
+metaclassdef
+	: metaclass_header metaclass_name T_SEMICOLON
+        | metaclass_header metaclass_name metaclass_attributes T_SEMICOLON
+        ;
+
+metaclass_header
+	: T_METACLASS T_COLON
+        ;
+
+metaclass_name
+	: T_IDENTIFIER
+	;
+
+metaclass_attributes
+	: T_COMMA metaclass_attribute
+	| metaclass_attributes T_COMMA metaclass_attribute 
+	;
+
+metaclass_attribute
+	: T_FILE T_STEM T_EQUAL T_IDENTIFIER
+        | T_MAJOR T_VERSION T_EQUAL T_CONSTANT
+        | T_MINOR T_VERSION T_EQUAL T_CONSTANT
+        | visibility
+        ;
+
+parent_section
+	: parentdef
+        | parentdef description
+		{
+			pcls->comment=$<stval>2;
+		}
+	;
+
+
+parentdef
+	: parent_header parent_name T_SEMICOLON
+        | parent_header parent_name parent_attributes T_SEMICOLON
+        ;
+
+parent_header
+	: T_PARENT T_CLASS T_COLON
+        | T_PARENT T_COLON 
+        ;
+
+parent_name
+	: T_IDENTIFIER
+		{
+			pcls->lineno=lineno;  // @todo line of class definition?
+			pcls->name=$<stval>1;
+		}
+	;
+
+parent_attributes
+	: T_COMMA parent_attribute
+	| parent_attributes T_COMMA parent_attribute
+	;
+
+parent_attribute
+	: T_FILE T_STEM T_EQUAL T_IDENTIFIER
+        | T_MAJOR T_VERSION T_EQUAL T_CONSTANT
+        | T_MINOR T_VERSION T_EQUAL T_CONSTANT
+        | visibility
+        ;
+
+passthru_section
+	: T_PASSTHRU
+        ;
+
+data_section
+	: data_header variables
+	;
+
+data_header
+	: T_DATA T_COLON
+	;
+
+variables
+	: declaration
+        | declaration variables
+        ;
+
+declaration
+	: declarationdef T_SEMICOLON
+	| declarationdef T_SEMICOLON description
+		{
+//			cls->comment=$<stval>2;
+		}
+	;
+
+declarationdef
+	: declaration_specifiers
+	| declaration_specifiers data_attributes
+	;
+
+data_attributes
+	: T_COMMA data_attribute
+	| data_attributes T_COMMA data_attribute
+	;
+
+data_attribute
+	: T_PRIVATE
+	| T_PUBLIC
+	| T_INTERNAL
+	| T_CLASS
+	;
+
+declaration_specifiers
+	: type_specifier declarator
+	| type_specifier declarator declaration_specifiers
+	;
+
+type_specifier
+	: T_IDENTIFIER 
+		{
+			$<stval>$=$<stval>1;
+		}
+	;
+
+declarator
+	: pointer direct_declarator
+	| direct_declarator
+	;
+
+direct_declarator
+	: T_IDENTIFIER {printf("$<stval>1");}
+	| T_LEFTPARENTHESIS declarator T_RIGHTPARENTHESIS
+	| direct_declarator T_LEFTSQUAREBRACKET T_CONSTANT T_RIGHTSQUAREBRACKET
+	| direct_declarator T_LEFTSQUAREBRACKET T_RIGHTSQUAREBRACKET
+	| direct_declarator T_LEFTPARENTHESIS declaration_specifiers T_RIGHTPARENTHESIS
+	| direct_declarator T_LEFTPARENTHESIS T_RIGHTPARENTHESIS
+	;
+
+pointer
+	: T_STAR
+		{
+			$<stval>$=$<stval>1;
+		}
+	| pointer T_STAR
+		{
+			char *r=somtsmallocSL(strlen($<stval>1)+strlen($<stval>2)+1, TRUE);
+			strcat(r, $<stval>1);
+			strcat(r, $<stval>2);
+			free($<stval>1);
+			$<stval>$=strdup(r);
+			somtfree(r);
+		}
+	;
+
+
+methods_section
+	: method_header method_list
+	| method_header description method_list
+		{
+			e.comment=$<stval>2;
+		}
+	;
+
+method_header
+	: T_METHODS T_COLON
+	;
+
+method_list
+	: method 
+		{
+			cls->u.c.methodcnt++;
+			somtaddEntrySL(somtstab, e.name, &e);
+			memset(&e, 0, sizeof(Entry));
+		}
+	| method_list method 
+		{
+			cls->u.c.methodcnt++;
+			somtaddEntrySL(somtstab, e.name, &e);
+			memset(&e, 0, sizeof(Entry));
+		}
+        ;
+
+method
+	: methoddef T_SEMICOLON 
+	| methoddef T_SEMICOLON description 
+	;
+
+methoddef
+	: method_specifier
+	| method_specifier method_attributes
+	| overridemethod_specifier
+	;
+
+method_specifier
+	: method_type method_name T_LEFTPARENTHESIS parameter_list T_RIGHTPARENTHESIS 
+		{
+			e.u.m.type=strdup($<stval>1);
+		}
+	;                                             
+
+method_name
+	: T_IDENTIFIER 
+		{
+			char * desc=somtsmallocSL(MAX_DESCRIPTOR_LENGTH, TRUE);
+			e.type=SOMTNewMethodE;
+			e.lineno=lineno;
+			e.name=$<stval>1;
+			e.sname=&somtclassName;
+			strcat(desc, "::");
+			strcat(desc, $<stval>1);
+			strcat(desc, "::");
+			strcat(desc, somtclassName);
+			e.atts=somtaddModifierSL(e.atts, "descriptor", desc);
+			somtfree(desc);
+		}
+	;
+
+method_type
+	: type_specifier
+		{
+			$<stval>$=$<stval>1;
+		}
+	| type_specifier pointer
+		{
+			char *r=somtsmallocSL(strlen($<stval>1)+strlen($<stval>2)+1, TRUE);
+			strcat(r, $<stval>1);
+			strcat(r, $<stval>2);
+			free($<stval>1);
+			$<stval>$=strdup(r);
+			somtfree(r);
+		}
+	;
+
+overridemethod_specifier
+	: overridemethod_header overridemethod_name
+	| overridemethod_header overridemethod_name overridemethod_attributes
+	;                                             
+
+overridemethod_header
+	: T_OVERRIDE
+	| T_OVERRIDE T_COLON
+	;
+
+overridemethod_name
+	: T_IDENTIFIER 
+		{
+			char * desc=somtsmallocSL(MAX_DESCRIPTOR_LENGTH, TRUE);
+			e.type=SOMTOverrideMethodE;
+			e.lineno=lineno;
+			e.name=$<stval>1;
+			e.sname=&somtclassName;
+			strcat(strcat(strcat(strcat(desc ,"::"), $<stval>1), "::"), somtclassName);
+			e.atts=somtaddModifierSL(e.atts, "descriptor", desc);
+			somtfree(desc);
+		}
+	;
+
+parameter_list
+	: parameter
+	| parameter_list T_COMMA parameter
+	;
+
+parameter
+	: T_ELLIPSIS
+	| type_specifier declarator
+	;
+
+method_attributes
+	: T_COMMA method_attribute
+	| method_attributes T_COMMA method_attribute
+	;
+
+method_attribute
+	: T_PRIVATE
+	| T_PUBLIC
+	| T_METHOD
+	| T_PROCEDURE
+	| T_CLASS
+	| T_OFFSET
+	| T_NAME T_LOOKUP
+	| T_LOCAL
+	| T_EXTERNAL
+	| T_USE T_EQUAL T_IDENTIFIER
+	;
+
+/* descriptor */
+/* noset */
+/* original */
+
+overridemethod_attributes
+	: T_COMMA overridemethod_attribute
+	| overridemethod_attributes T_COMMA overridemethod_attribute
+	;
+
+overridemethod_attribute
+	: T_PRIVATE
+	| T_PUBLIC
+	| T_CLASS
+	| T_LOCAL
+	| T_EXTERNAL
+	| T_USE T_EQUAL T_IDENTIFIER
+	;
+
+description
+	: T_COMMENT 
+		{
+			$<stval>$=$<stval>1;
+		}
+        ;
+
+%%
+
+FILE *yyin;
+
+// Experimental replacement of somttype
+char * mysomttype(SOMTTypes ttype)
+{
+  char * result=NULL;
+  switch ( ttype )
+  {
+    case SOMTAnyBE:
+      result="SOMTAnyBE";
+      break;
+    case     SOMTArgumentE:
+      result="SOMTArgumentE";
+      break;
+    case     SOMTAttE:
+      result="SOMTAttE";
+      break;
+    case     SOMTBadEntryE:
+      result="SOMTBadEntryE";
+      break;
+    case     SOMTBaseE:
+      result="SOMTBaseE";
+      break;
+    case     SOMTBooleanBE:
+      result="SOMTBooleanBE";
+      break;
+    case     SOMTCaseEntryE:
+      result="SOMTCaseEntryE";
+      break;
+    case     SOMTCaseListE:
+      result="SOMTCaseListE";
+      break;
+    case     SOMTCaseSTME:
+      result="SOMTCaseSTME";
+      break;
+    case     SOMTCharBE:
+      result="SOMTCharBE";
+      break;
+    case     SOMTClassE:
+      result="SOMTClassE";
+      break;
+    case     SOMTConstE:
+      result="SOMTConstE";
+      break;
+    case     SOMTCopyrightE:
+      result="SOMTCopyrightE";
+      break;
+    case     SOMTDataE:
+      result="SOMTDataE";
+      break;
+    case     SOMTDclListE:
+      result="SOMTDclListE";
+      break;
+    case     SOMTDefaultE:
+      result="SOMTDefaultE";
+      break;
+    case     SOMTDoubleBE:
+      result="SOMTDoubleBE";
+      break;
+    case     SOMTEBaseE:
+      result="SOMTEBaseE";
+      break;
+    case     SOMTEEnumE:
+      result="SOMTEEnumE";
+      break;
+    case     SOMTEnumBE:
+      result="SOMTEnumBE";
+      break;
+    case     SOMTEnumE:
+      result="SOMTEnumE";
+      break;
+    case     SOMTEnumPE:
+      result="SOMTEnumPE";
+      break;
+    case     SOMTFloatBE:
+      result="SOMTFloatBE";
+      break;
+    case     SOMTGroupE:
+      result="SOMTGroupE";
+      break;
+    case     SOMTLongBE:
+      result="SOMTLongBE";
+      break;
+    case     SOMTMetaE:
+      result="SOMTMetaE";
+      break;
+    case     SOMTModuleE:
+      result="SOMTModuleE";
+      break;
+    case     SOMTNegativeBE:
+      result="SOMTNegativeBE";
+      break;
+    case     SOMTNewMethodE:
+      result="SOMTNewMethodE";
+      break;
+    case     SOMTOctetBE:
+      result="SOMTOctetBE";
+      break;
+    case     SOMTOverriddenMethodE:
+      result="SOMTOverriddenMethodE";
+      break;
+    case     SOMTOverrideMethodE:
+      result="SOMTOverrideMethodE";
+      break;
+    case     SOMTPassthruE:
+      result="SOMTPassthruE";
+      break;
+    case     SOMTSequenceE:
+      result="SOMTSequenceE";
+      break;
+    case     SOMTSequenceTDE:
+      result="SOMTSequenceTDE";
+      break;
+    case     SOMTShortBE:
+      result="SOMTShortBE";
+      break;
+    case     SOMTStringBE:
+      result="SOMTStringBE";
+      break;
+    case     SOMTStringE:
+      result="SOMTStringE";
+      break;
+    case     SOMTStructE:
+      result="SOMTStructE";
+      break;
+    case     SOMTStructPE:
+      result="SOMTStructPE";
+      break;
+    case     SOMTStructSE:
+      result="SOMTStructSE";
+      break;
+    case     SOMTTyDclE:
+      result="SOMTTyDclE";
+      break;
+    case     SOMTTypeCodeBE:
+      result="SOMTTypeCodeBE";
+      break;
+    case     SOMTTypedefBE:
+      result="SOMTTypedefBE";
+      break;
+    case     SOMTTypedefE:
+      result="SOMTTypedefE";
+      break;
+    case     SOMTUnionE:
+      result="SOMTUnionE";
+      break;
+    case     SOMTUnionPE:
+      result="SOMTUnionPE";
+      break;
+    case     SOMTUnionSE:
+      result="SOMTUnionSE";
+      break;
+    case     SOMTUnsignedLongBE:
+      result="SOMTUnsignedLongBE";
+      break;
+    case     SOMTUnsignedShortBE:
+      result="SOMTUnsignedShortBE";
+      break;
+    case     SOMTVoidBE:
+      result="SOMTVoidBE";
+      break;
+    case     SOMTVoidPtrBE:
+      result="SOMTVoidPtrBE";
+      break;
+// This is special case SOMTTypes used on call of emitter start and emitter end
+/*    case     SOMTEmitterBeginE:
+      result="SOMTEmitterBeginE";
+      break;
+    case     SOMTEmitterEndE:
+      result="SOMTEmitterEndE";
+      break; */
+    default:
+      printf("Unknown entry type: %d.\n", ttype);
+  }
+  return result;
+}
+
+void dumpReleaseOrder(char * name, AttList *ap)
+{
+  AttList *cur=ap;
+
+  for(; cur; cur = cur->next) 
+  {
+    printf("\t%s %s\n", name, cur->name);
+//    dumpAttrs("static", cur->staticlist);
+//    dumpAttrs("protectted", cur->protectedlist);
+//    dumpAttrs("public", cur->publiclist);
+//    dumpAttrs("private", cur->privatelist);
+  }
+}
+
+void dumpMethodOrData(Entry * ep)
+{
+  printf("\teptype = %08p\n", ep->u.m.eptype);
+  printf("\tptrs = %08p\n", ep->u.m.ptrs);
+  printf("\tarray = %08p\n", ep->u.m.array);
+  printf("\tarrays = %s\n", ep->u.m.arrays);
+  printf("\tdefn = %s\n", ep->u.m.defn);
+  printf("\ttype = %s\n", ep->u.m.type);
+  printf("\tvarargs = %s\n", ep->u.m.varargs ? "true" : "false");
+  printf("\tprivate = %s\n", ep->u.m.isprivate ? "true" : "false");
+  printf("\tinout = %d\n", ep->u.m.inoutmode);
+  printf("\tselfref = %s\n", ep->u.m.isselfref ? "true" : "false");
+  printf("\toneway = %s\n", ep->u.m.isoneway ? "true" : "false");
+  printf("\targcnt = %d\n", ep->u.m.argcnt);
+  printf("\targs = %08p\n", ep->u.m.args);
+  printf("\tomethod = %08p\n", ep->u.m.omethod);
+  printf("\toparent = %08p\n", ep->u.m.oparent);
+  printf("\tgroup = %08p\n", ep->u.m.group);
+  printf("\tnext = %08p\n", ep->u.m.next);
+  printf("\tctxsa = %08p\n", ep->u.m.ctxsa);
+  printf("\traiseslist = %08p\n", ep->u.m.raiseslist);
+}
+
+void mysomtShowEntry(Entry * ep)
+{
+  if (ep)
+  {
+    printf("      somtShowEntry: Entry at %08p, name = %s, type = %d\n", ep, ep->name, ep->type);
+    printf("\tlineno = %d\n", ep->lineno);
+    switch ( ep->type )
+    {
+      case SOMTAnyBE:
+        printf("\t SOMTAnyBE\n");
+        break;
+      case     SOMTArgumentE:
+        printf("\t SOMTArgumentE\n");
+        dumpMethodOrData(ep);
+        break;
+      case     SOMTAttE:
+        printf("\t SOMTAttE\n");
+        break;
+      case     SOMTBadEntryE:
+        printf("\t SOMTBadEntryE\n");
+        break;
+      case     SOMTBaseE:
+        printf("\t SOMTBaseE\n");
+        printf("\tparentdef = %08p\n", ep->u.p.parentdef);
+        break;
+      case     SOMTBooleanBE:
+        printf("\t SOMTBooleanBE\n");
+        break;
+      case     SOMTCaseEntryE:
+        printf("\t SOMTCaseEntryE\n");
+        break;
+      case     SOMTCaseListE:
+        printf("\t SOMTCaseListE\n");
+        break;
+      case     SOMTCaseSTME:
+        printf("\t SOMTCaseSTME\n");
+        break;
+      case     SOMTCharBE:
+        printf("\t SOMTCharBE\n");
+        break;
+      case     SOMTClassE:
+        printf("\tClass Definition Entry:\n");
+        printf("\tfile = %s\n", ep->u.c.file);
+        printf("\tmeta = %08p\n", ep->u.c.meta);
+        printf("\tparent = %08p\n", ep->u.c.parent);
+        printf("\tparents = %08p\n", ep->u.c.parents);
+        printf("\trelease = %08p\n", ep->u.c.release);
+	dumpReleaseOrder("\t", ep->u.c.release);
+        printf("\tpassthru = %08p\n", ep->u.c.passthrus);
+        printf("\tdata = %08p\n", ep->u.c.data);
+        printf("\ttc = %08p\n", ep->tc);
+        printf("\tmethodcnt = %08d\n", ep->u.c.methodcnt);
+        printf("\tmethods = %08p\n", ep->u.c.methods);
+        printf("\tinherited = %08p\n", ep->u.c.inherited);
+        printf("\tpubdefs = %08p\n", ep->u.c.pubdefs);
+        printf("\tmod = %08p\n", ep->u.c.mod);
+        printf("\tcls = %08p\n", ep->u.c.cls);
+        printf("\tforward = %s\n", ep->u.c.isforward ? "true" : "false");
+        break;
+      case     SOMTConstE:
+        printf("\t SOMTConstE\n");
+        break;
+      case     SOMTCopyrightE:
+        printf("\t SOMTCopyrightE\n");
+        break;
+      case     SOMTDataE:
+        printf("\t SOMTDataE\n");
+        dumpMethodOrData(ep);
+        break;
+      case     SOMTDclListE:
+        printf("\t SOMTDclListE\n");
+        break;
+      case     SOMTDefaultE:
+        printf("\t SOMTDefaultE\n");
+        break;
+      case     SOMTDoubleBE:
+        printf("\t SOMTDoubleBE\n");
+        break;
+      case     SOMTEBaseE:
+        printf("\t SOMTEBaseE\n");
+        break;
+      case     SOMTEEnumE:
+        printf("\t SOMTEEnumE\n");
+        break;
+      case     SOMTEnumBE:
+        printf("\t SOMTEnumBE\n");
+        break;
+      case     SOMTEnumE:
+        printf("\t SOMTEnumE\n");
+        break;
+      case     SOMTEnumPE:
+        printf("\t SOMTEnumPE\n");
+        break;
+      case     SOMTFloatBE:
+        printf("\t SOMTFloatBE\n");
+        break;
+      case     SOMTGroupE:
+        printf("\t SOMTGroupE\n");
+        break;
+      case     SOMTLongBE:
+        printf("\t SOMTLongBE\n");
+        break;
+      case     SOMTMetaE:
+        printf("\t SOMTMetaE\n");
+        break;
+      case     SOMTModuleE:
+        printf("\t SOMTModuleE\n");
+        break;
+      case     SOMTNegativeBE:
+        printf("\t SOMTNegativeBE\n");
+        break;
+      case     SOMTNewMethodE:
+        printf("\t SOMTNewMethodE\n");
+        dumpMethodOrData(ep);
+        break;
+      case     SOMTOctetBE:
+        printf("\t SOMTOctetBE\n");
+        break;
+      case     SOMTOverriddenMethodE:
+        printf("\t SOMTOverriddenMethodE\n");
+        dumpMethodOrData(ep);
+        break;
+      case     SOMTOverrideMethodE:
+        printf("\t SOMTOverrideMethodE\n");
+        dumpMethodOrData(ep);
+        break;
+      case     SOMTPassthruE:
+        printf("\t SOMTPassthruE\n");
+        break;
+      case     SOMTSequenceE:
+        printf("\t SOMTSequenceE\n");
+        break;
+      case     SOMTSequenceTDE:
+        printf("\t SOMTSequenceTDE\n");
+        break;
+      case     SOMTShortBE:
+        printf("\t SOMTShortBE\n");
+        break;
+      case     SOMTStringBE:
+        printf("\t SOMTStringBE\n");
+        break;
+      case     SOMTStringE:
+        printf("\t SOMTStringE\n");
+        break;
+      case     SOMTStructE:
+        printf("\t SOMTStructE\n");
+        break;
+      case     SOMTStructPE:
+        printf("\t SOMTStructPE\n");
+        break;
+      case     SOMTStructSE:
+        printf("\t SOMTStructSE\n");
+        printf("\tdcllist = %08p\n", ep->u.struc.dcllist);
+        printf("\tcls = %08p\n", ep->u.struc.cls);
+        printf("\texception = %s\n", ep->u.struc.isexcept ? "true" : "false");
+        printf("\tmutref = %s\n", ep->u.struc.ismutref ? "true" : "false");
+        break;
+      case     SOMTTyDclE:
+        printf("\t SOMTTyDclE\n");
+        break;
+      case     SOMTTypeCodeBE:
+        printf("\t SOMTTypeCodeBE\n");
+        break;
+      case     SOMTTypedefBE:
+        printf("\t SOMTTypedefBE\n");
+        dumpMethodOrData(ep);
+        break;
+      case     SOMTTypedefE:
+        printf("\t SOMTTypedefE\n");
+        break;
+      case     SOMTUnionE:
+        printf("\t SOMTUnionE\n");
+        break;
+      case     SOMTUnionPE:
+        printf("\t SOMTUnionPE\n");
+        break;
+      case     SOMTUnionSE:
+        printf("\t SOMTUnionSE\n");
+        break;
+      case     SOMTUnsignedLongBE:
+        printf("\t SOMTUnsignedLongBE\n");
+        break;
+      case     SOMTUnsignedShortBE:
+        printf("\t SOMTUnsignedShortBE\n");
+        break;
+      case     SOMTVoidBE:
+        printf("\t SOMTVoidBE\n");
+        break;
+      case     SOMTVoidPtrBE:
+        printf("\t SOMTVoidPtrBE\n");
+        dumpMethodOrData(ep);
+        break;
+  // This is special case SOMTTypes used on call of emitter start and emitter end
+  /*    case     SOMTEmitterBeginE:
+        result="SOMTEmitterBeginE";
+        break;
+      case     SOMTEmitterEndE:
+        result="SOMTEmitterEndE";
+        break; */
+      default:
+        printf("Error: somtShowEntry, bad entry type of %d", ep->type);
+//        SOM_Error(SOM_Fatal, __FILE__, __LINE__);
+//        SOMError(9, __FILE__, __LINE__);
+    }
+  }
+  else 
+  {
+    printf("somtShowEntry: NULL entry\n");
+  }
+}
+
+void dumpAttrs(AttList *ap)
+{
+  struct AttList *cur = ap;
+
+  for(cur = ap; cur; cur = cur->next) 
+  {
+    printf("\tModifier %s=%s\n", cur->name, cur->value);
+  }
+}
+
+
+void mydumpEntry(Entry * ep)
+{
+  printf("Entry at address %p\n", ep);
+  printf("--------------------------\n");
+  printf("Entry type: %s (%d)\n", mysomttype(ep->type), ep->type);
+//  printf("Entry type: %s (%d)\n", somtEntryTypeName(ep->type), ep->type);
+  if (ep->sname) printf("Scoped name: %s\n", *ep->sname);
+  if (ep->comment) printf("Comment associated with entry: %s\n", ep->comment);
+  printf("Modifiers: %p\n", ep->atts);
+  if (ep->atts) dumpAttrs(ep->atts);
+  printf("TypeCode: %p\n", ep->tc);
+  printf("Points to the object: %p\n", ep->objref);
+  printf("Reference to real type: %s\n", ep->isref ? "true" : "false");
+  printf("Entry union: %p\n", &ep->u);
+#ifdef __PRIVATE__
+//    RHBelement *data;
+//    char *filestem;
+#endif    
+  mysomtShowEntry(ep);
+//  somtShowEntry(ep);
+};
+
+void dumpSep(Sep * sep)
+{
+    printf("Linked list item at address %p\n", sep);
+    printf("---------------------------------------\n");
+    printf("Position number: %d\n", sep->posn);
+    printf("Address of Entry: %p\n", sep->ep);
+    printf("Next linked list item address: %p\n", sep->next);
+    if (sep->ep) 
+    {
+      mydumpEntry((Entry *)sep->ep);
+      dumpSep(sep->next);
+    }
+}
+
+void dumpStab(Stab * stab)
+{
+  unsigned int i;
+  printf("Basic Symbol Table/Hash table (STab) structure\n");
+  printf("----------------------------------------------\n");
+  printf("Size of buscet: %d\n", stab->size);
+  printf("Size of entry structure: %d\n", stab->entrysize);
+  printf("Number of elements: %d\n", stab->nelms);
+  printf("Address of base slot: %p\n", stab->base);
+  printf("Max address of slot: %p\n", stab->limit);
+  printf("Start address of slot buffer: %p\n", stab->buf);
+  printf("Address of MemBuf: %p\n", stab->membuf);
+  printf("Ignore case flag: %s\n", stab->ignorecase ? "true" : "false");
+  for(i=0; i<stab->size;i++)
+  {
+    printf("Linked list at slot %d at offset %08x at address %p\n", i, sizeof(Sep)*i, stab->buf+i);
+    printf("----------------------\n");
+    dumpSep(stab->buf+i);
+  }
+}
+
+
+void usage(void)
+{
+  printf("\nSC [-options] file[.CSC]\n");
+  printf("\n-C n\n\tset the size of the comment buffer (default: 16384)\n");
+  printf("\n-s n\n\tset the total amount of string space for names and passthru lines (default: 32768)\n");
+  printf("\n-V\n\tdisplay version information\n");
+  printf("\n-a name[=value]\n\tadd a global attribute. The currently supported attributes are defined below (at the end of this section)\n");
+  printf("\n-d directory\n\tspecify a directory where all files emitted during the execution of this command should be placed. If the -d option is not used, all emitted output files are placed in the same directory as the input .csc file\n");
+  printf("\n-h or ?\n\tprovide usage information for reference\n");
+  printf("\n-i filename\n\tspecify the name of the OIDL class definition file. Use this option to override the built-in assumption that the input file will have a .csc extension. Any filename you supply with the -i option is used exactly as you provide it\n");
+  printf("\n-r\n\tcheck that all release-order entries actually exist (default: FALSE)\n");
+  printf("\n-s string\n\tsubstitute string in place of the contents of the SMEMIT environment variable for the duration of the current SC command. If you supply a list of values, you\n");
+  printf("must enclose the list with double quotation marks (\" \"). You can use the -s option as a convenient way to override the SMEMIT environment variable. For example:\n\n");
+  printf("SC -s \"h;sc\" EXAMPLE\n\n");
+  printf("is equivalent to the following sequence of commands:\n\n");
+  printf("SET OLDSMEMIT = %%SMEMIT%%\n");
+  printf("SET SMEMIT = h;sc\n");
+  printf("SC EXAMPLE\n");
+  printf("SET SMEMIT = %%OLDSMEMIT%%\n");
+  printf("\n-w\n\tsuppress warning messages (default: FALSE)\n\n");
+  printf("The only global attributes currently supported by SC.EXE are:\n");
+  printf("\ncomment = comment string\n\twhere comment string can be one of the following: \"/*\", \"--\", or \"//\". This\n");
+  printf("indicates that comments marked in the indicated way are to be completely\n");
+  printf("ignored by SC.EXE and not retained for subsequent processing by one of the\n");
+  printf("emitters.\n");
+  printf("Note: Comments indicated by lines whose first non-white-space character is\n");
+  printf("a # are always ignored by SC.EXE. Also note that comments of any\n");
+  printf("form in passthru lines are passed through.\n");
+  printf("\ncstyle = comment style\n\tcontrols the form of emitted comments. Comment style must be one of s, c, or\n");
+  printf("+ to cause emitted comments to be in \"--\", \"/* */\", or \"//\" form , respectively\n");
+  printf("The default form is s\n");
+  printf("\nibmc\n\tcauses EMITC, EMITH, EMITIH, EMITPH, and EMITDEF to generate code with\n");
+  printf("pragmas specifically intended for the IBM C Set/2 Compiler. This attribute is\n");
+  printf("specified by default\n");
+  printf("\ncl386\n\tcauses EMITC, EMITH, EMITIH, EMITPH, and EMITDEF not to generate code\n");
+  printf("with pragmas specifically intended for the IBM C Set/2 Compiler\n");
+}
+
+void parse_file(char * file)
+{
+  // parser input stream
+  yyin=fopen(file,"r");
+
+  strcpy(somtfilePath, file);
+
+  // Initialize symbol table
+  somtstab=(Stab *)somtsmallocSL(sizeof(Stab), 0);
+  somtcreateStabSL(somtstab, HASH_SIZE, sizeof(Entry));
+
+  yyparse();
+
+  dumpStab(somtstab);
+}
+
+void emit_file(char * file)
+{
+   EmitFn proc;
+   FILE * fp;
+   HMODULE hmod;
+   Entry * root;
+   Stab * stab;
+
+   proc=somtloadSL("emitpsc.dll", "emitSL", (void**)&hmod);
+
+   fp=proc(file, root, stab);
+
+   if (fp) somtfcloseSL(fp);
+}
+
+void main(int argc, char *argv[])
+{
+#if YYDEBUG != 0
+   yydebug =1 ;
+#endif
+
+//   parse_args(argc, argv);
+
+   usage();
+
+   parse_file(argv[1]);
+
+//   dump();
+
+//   emit_file(argv[1]);
+}
diff -urN somfree/somopc/src/scanner.ll newsomfree/somopc/src/scanner.ll
--- somfree/somopc/src/scanner.ll	Sat Jun 29 21:47:30 2024
+++ newsomfree/somopc/src/scanner.ll	Thu Jan 01 07:00:00 1970
@@ -1,90 +0,0 @@
-%{
-
-#include <stdio.h>  // fopen
-#include <stdlib.h> // malloc, free, realloc
-#include <string.h> // strcat
-
-#include <emitlib.h>
-
-#include "gramma.yy.tab.h"
-
-int trace=1;
-int lineno=1, column=0;
-char comment[16384]; // handle with -C
-char passthru[32768]; // handle with -S
-
-%}
-
-
-%x IN_CPP_COMMENT
-%x IN_PASSTHRU
-
-%%
-
-<INITIAL>{
-  "/*"             {BEGIN(IN_CPP_COMMENT); comment[0]=0x0; }
-  "passthru:"       {BEGIN(IN_PASSTHRU); passthru[0]=0x0;}
-}
-
-<IN_CPP_COMMENT>{
-  "*/"      { BEGIN(INITIAL); yylval.stval=strdup(comment); return T_COMMENT; }
-  [^*\n]+   { strcat(comment, yytext); }
-  "*"       // eat the lone star
-  \n        { strcat(comment, "\n"); lineno++; }
-}
-
-<IN_PASSTHRU>{
-  "endpassthru;"  {BEGIN(INITIAL);}
-  [^\n]+    { strcat(passthru, yytext);}
-  \n        { strcat(passthru, "\n"); lineno++; }
-}
-
-[0-9]+	 	  {if (trace) ECHO; column+=yyleng; yylval.ival=atoi(yytext); return T_CONSTANT;}
-:                 {if (trace) ECHO; column+=yyleng; return T_COLON;            }
-;                 {if (trace) ECHO; column+=yyleng; return T_SEMICOLON;        }
-,                 {if (trace) ECHO; column+=yyleng; return T_COMMA;            }
-=                 {if (trace) ECHO; column+=yyleng; return T_EQUAL;            }
---                {if (trace) ECHO; column+=yyleng; return T_DASHES;           }
-"..."             {if (trace) ECHO; column+=yyleng; return T_ELLIPSIS;         }
-"*"               {if (trace) ECHO; column+=yyleng; yylval.stval=strdup(yytext); return T_STAR; }
-"("               {if (trace) ECHO; column+=yyleng; return T_LEFTPARENTHESIS;  }
-")"               {if (trace) ECHO; column+=yyleng; return T_RIGHTPARENTHESIS; }
-"["               {if (trace) ECHO; column+=yyleng; return T_LEFTSQUAREBRACKET;  }
-"]"               {if (trace) ECHO; column+=yyleng; return T_RIGHTSQUAREBRACKET; }
-^#line            {if (trace) ECHO; column+=yyleng; return T_LINE;             }
-class             {if (trace) ECHO; column+=yyleng; return T_CLASS;            }
-file              {if (trace) ECHO; column+=yyleng; return T_FILE;             }
-stem              {if (trace) ECHO; column+=yyleng; return T_STEM;             }
-function          {if (trace) ECHO; column+=yyleng; return T_FUNCTION;         }
-prefix            {if (trace) ECHO; column+=yyleng; return T_PREFIX;           }
-classprefix       {if (trace) ECHO; column+=yyleng; return T_CLASSPREFIX;      }
-major             {if (trace) ECHO; column+=yyleng; return T_MAJOR;            }
-minor             {if (trace) ECHO; column+=yyleng; return T_MINOR;            }
-version           {if (trace) ECHO; column+=yyleng; return T_VERSION;          }
-global            {if (trace) ECHO; column+=yyleng; return T_GLOBAL;           }
-local             {if (trace) ECHO; column+=yyleng; return T_LOCAL;            }
-classInit         {if (trace) ECHO; column+=yyleng; return T_CLASSINIT;        }
-release           {if (trace) ECHO; column+=yyleng; return T_RELEASE;          }
-order             {if (trace) ECHO; column+=yyleng; return T_ORDER;            }
-metaclass         {if (trace) ECHO; column+=yyleng; return T_METACLASS;        }
-parent            {if (trace) ECHO; column+=yyleng; return T_PARENT;           }
-data              {if (trace) ECHO; column+=yyleng; return T_DATA;             }
-private           {if (trace) ECHO; column+=yyleng; return T_PRIVATE;          }
-public            {if (trace) ECHO; column+=yyleng; return T_PUBLIC;           }
-internal          {if (trace) ECHO; column+=yyleng; return T_INTERNAL;         }
-methods           {if (trace) ECHO; column+=yyleng; return T_METHODS;          }
-group             {if (trace) ECHO; column+=yyleng; return T_GROUP;            }
-method            {if (trace) ECHO; column+=yyleng; return T_METHOD;           }
-procedure         {if (trace) ECHO; column+=yyleng; return T_PROCEDURE;        }
-offset            {if (trace) ECHO; column+=yyleng; return T_OFFSET;           }
-name              {if (trace) ECHO; column+=yyleng; return T_NAME;             }
-lookup            {if (trace) ECHO; column+=yyleng; return T_LOOKUP;           }
-external          {if (trace) ECHO; column+=yyleng; return T_EXTERNAL;         }
-override          {if (trace) ECHO; column+=yyleng; return T_OVERRIDE;         }
-[A-Za-z][_0-9A-Za-z]* {if (trace) ECHO; column+=yyleng; yylval.stval=strdup(yytext); return T_IDENTIFIER;   }
-[ \t]+            { column++;                                                  }
-\n                { lineno++;                                                  }
-.                 { printf("ERROR"); };
-
-%%
-/* "use"             {if (trace) ECHO; column+=yyleng; return T_USE;              } */
